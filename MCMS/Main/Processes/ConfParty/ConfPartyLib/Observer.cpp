
//=================================================================================================
//
//Copyright (C) 2005 POLYCOM
//This file contains confidential information proprietary to ACCORD Networks Ltd. The use or 
//disclosure of any information contained in this file without the written consent of an officer of
//ACCORD Networks Ltd. is expressly forbidden.
//
//=================================================================================================

//=================================================================================================
//
//Module Name:  Observer.CPP
//
//General Description:  
//
//    1.	Implementation of OBSERVER PATTERN
//
//Generated By: Ori P.                            Date: 2.03.05
//
//Revisions and Updates: 
//
//Date         Updated By         Description
//========   ==============   =====================================================================
// 
//=================================================================================================


#include "Observer.h"
#include "ConfApi.h"
#include "ConfPartyOpcodes.h"
#include "DefinesGeneral.h"
#include "StatusesGeneral.h"
#include "ApiStatuses.h"
#include "TraceStream.h"
/////////////////////////////////////////////////////////////////////////////
WORD operator==(const CObserverInfo& first,const CObserverInfo& second)
{
	WORD    rval = 0;     
	if (first.m_pObserver == second.m_pObserver && first.m_event == second.m_event)
		rval = 1;   

	return rval;
}
		

// ************************************************************************************
//
//	CObserverInfo
//
// ************************************************************************************



//////////////////////////////////////////////////////////////////////////////////
CObserverInfo::CObserverInfo()
{
	m_pObserver = NULL;
	m_event = 0;
	m_type = 0;
	m_observerInfo1 = 0;
}

//////////////////////////////////////////////////////////////////////////////////
CObserverInfo::CObserverInfo(void* pObserver, WORD event, WORD type, DWORD observerInfo1)
{
	m_pObserver = pObserver;
	m_event = event;
	m_type = type;
	m_observerInfo1 = observerInfo1;
}

//////////////////////////////////////////////////////////////////////////////////
CObserverInfo::~CObserverInfo()
{
}

//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
void* CObserverInfo::GetObserver()
{
	return m_pObserver;
}

//////////////////////////////////////////////////////////////////////////////////
WORD CObserverInfo::GetEvent()
{
	return m_event;
}

//////////////////////////////////////////////////////////////////////////////////
WORD CObserverInfo::GetType()
{
	return m_type;
}

//////////////////////////////////////////////////////////////////////////////////
DWORD CObserverInfo::GetObserverInfo1()
{
	return m_observerInfo1;
}


	
// ************************************************************************************
//
//	CAbstractSubject
//
// ************************************************************************************


//////////////////////////////////////////////////////////////////////////////
CAbstractSubject::CAbstractSubject()
{
}

//////////////////////////////////////////////////////////////////////////////
CAbstractSubject::~CAbstractSubject()
{

}

//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//remove observer from list
int CAbstractSubject::DetachObserver(void* pObserver)
{
	int status = STATUS_OK;
	CObserverInfo* pObserverInfo = NULL;

	if(!pObserver)
		status = STATUS_ILLEGAL_PBOJECT;

	if(STATUS_OK == status)
	{
		status = NOT_FIND;
		std::vector< CObserverInfo * >::iterator itr =  m_ObserversList.begin();
		while (itr != m_ObserversList.end())
		{
			pObserverInfo = (CObserverInfo*)(*itr);
			if(IsValidPObjectPtr(pObserverInfo))
			{
				if(pObserverInfo->GetObserver() == pObserver)
				{
					TRACESTR(eLevelInfoNormal)<<"CAbstractSubject::DetachObserver, observer="<<(DWORD)pObserver<<", event=" << EventToString(pObserverInfo->GetEvent()) ;
					m_ObserversList.erase(itr);
					POBJDELETE(pObserverInfo);
					status = STATUS_OK;
					itr = m_ObserversList.begin();
				}
				else
				{
					++itr;
					continue;
				}
			}
			else
			{
				m_ObserversList.erase(itr);
				POBJDELETE(pObserverInfo);
				itr = m_ObserversList.begin();
			}
			
		}
	}

	return status;
}

//////////////////////////////////////////////////////////////////////////////
//remove observer from list
int CAbstractSubject::DetachObserver(void* pObserver, WORD event, WORD type, DWORD observerInfo1)
{
	int status = STATUS_OK;
	CObserverInfo* pObserverInfo = NULL;

	if(!pObserver)
		status = STATUS_ILLEGAL_PBOJECT;

	if(STATUS_OK == status)
	{
		status = NOT_FIND;
		std::vector< CObserverInfo * >::iterator itr =  m_ObserversList.begin();
		while (itr != m_ObserversList.end())
		{
			pObserverInfo = (CObserverInfo*)(*itr);
			if(IsValidPObjectPtr(pObserverInfo))
			{
				if(pObserverInfo->GetObserver() == pObserver
					&& pObserverInfo->GetEvent() == event
					&& pObserverInfo->GetType() == type
					&& pObserverInfo->GetObserverInfo1() == observerInfo1)
				{
					m_ObserversList.erase(itr);
					POBJDELETE(pObserverInfo);
					status = STATUS_OK;
				}
				else
				{
					++itr;
					continue;
				}
			}
			else
			{
				m_ObserversList.erase(itr);			
				POBJDELETE(pObserverInfo);
			}
			itr = m_ObserversList.begin();
		}
	}

	return status;
}
//////////////////////////////////////////////////////////////////////////////
const char* CAbstractSubject::EventToString(const WORD event)
{
	switch(event)
	{
		case(PARTYSTATE):
			return "PARTYSTATE";
		case(CHAIROWNER):
			return "CHAIROWNER";
		case(DISCAUSE):
			return "DISCAUSE";
		case(MUTE_STATE):
			return "MUTE_STATE";
		case(CONTACT_INFO):
			return "CONTACT_INFO";
		case(CONF_LOCK):
			return "CONF_LOCK";
		case(CONF_ACTIVE):
			return "CONF_ACTIVE";
		case(AUDIOSRC):
			return "AUDIOSRC";
		case(PARTY_ADDED):
			return "PARTY_ADDED";
		case(PARTY_DELETED):
			return "PARTY_DELETED";
		case(CPCONFLAYOUT):
			return "CPCONFLAYOUT";
		case(UPDATELECTUREMODE):
			return "UPDATELECTUREMODE";
		case(UPDATEVISUALNAME):
			return "UPDATEVISUALNAME";
		case(CPPARTYLAYOUT):
			return "CPPARTYLAYOUT";
		default:
			return "UNKNOWN_EVENT";	
	}
}

// ************************************************************************************
//
//	CSubject
//
// ************************************************************************************


//////////////////////////////////////////////////////////////////////////////
CSubject::CSubject()
{
	m_pTaskApi = NULL;
}

//////////////////////////////////////////////////////////////////////////////
CSubject::CSubject(CTaskApi* pTaskApi)
{
	m_pTaskApi = pTaskApi;
}

//////////////////////////////////////////////////////////////////////////////
CSubject::~CSubject()
{
}

//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//Add observer to list
DWORD CSubject::AttachObserver(void* pObserver, WORD event, WORD type, DWORD observerInfo1)
{
	DWORD status = STATUS_OK;
	
	CSmallString str;
	str << "observer=" << (DWORD)pObserver << ", event=" << EventToString(event) << ", type=" << TypeToString(type) << ", observer=" << observerInfo1;
	PTRACE2(eLevelInfoNormal, "CSubject::AttachObserver, ", str.GetString());

/*	if(!IsValidPObjectPtr((CPObject*)pObserver))
		status = STATUS_ILLEGAL_PBOJECT;*/

	if(!pObserver || !((COsQueue*)pObserver)->IsValid())
		status = STATUS_ILLEGAL_PBOJECT;

	if(STATUS_OK == status)
	{		
		switch(event)
		{
			case(PARTYSTATE):
			case(MEDIA):
			case(CHAIROWNER):
			case(DISCAUSE):
			case(MUTE_STATE):
			case(CONTACT_INFO):
			case(CONF_LOCK):
			case(CONF_ACTIVE):
			case(AUDIOSRC):
			case(LSDSRC):
			case(PARTY_ADDED):
			case(PARTY_DELETED):
			case(CPCONFLAYOUT):
			case(UPDATELECTUREMODE):
			case(UPDATEVISUALNAME):
			case(CPPARTYLAYOUT):
			{
				status = STATUS_OK;
				break;
			}
			default:
			{
				PTRACE2INT(eLevelInfoNormal, "CSubject::AttachObserver, can not attach event - unknown event!!! ", event);
				DBGPASSERT(event);
				status = STATUS_ILLEGAL;
				break;
			}			
		}
		
		if(STATUS_OK == status)
		{
			CObserverInfo* pObserverInfo = NULL;
			std::vector< CObserverInfo * >::iterator itr =  m_ObserversList.begin();
			while (itr != m_ObserversList.end())
			{
				pObserverInfo = (CObserverInfo*)(*itr);
				if(IsValidPObjectPtr(pObserverInfo))
					if(event == pObserverInfo->GetEvent() && type == pObserverInfo->GetType())
						if(pObserver == pObserverInfo->GetObserver())
						{
							status = STATUS_ALREADY_EXISTS;
							PTRACE(eLevelInfoNormal, "CSubject::AttachObserver, STATUS_ALREADY_EXISTS.");
							break;
						}
				itr++;
			}
			
			if(STATUS_OK == status)
			{
				pObserverInfo = new CObserverInfo(pObserver, event, type, observerInfo1);
				m_ObserversList.push_back(pObserverInfo);
				PTRACE(eLevelInfoNormal, "CSubject::AttachObserver, STATUS_OK.");
			}
		}
	}
	
	return status;
}



//////////////////////////////////////////////////////////////////////////////
//remove observer from list
int CSubject::DetachObserver(void* pObserver)
{
	int status = STATUS_OK;

	CSmallString str;
	str << "observer=" << (DWORD)pObserver;
	PTRACE2(eLevelInfoNormal, "CSubject::DetachObserver, observer = ", str.GetString());

	/*if(!IsValidPObjectPtr((CPObject*)pObserver))
		status = STATUS_ILLEGAL_PBOJECT;*/

	if(!pObserver || !((COsQueue*)pObserver)->IsValid())
	{
		status = STATUS_ILLEGAL_PBOJECT;
		PTRACE(eLevelInfoNormal, "CSubject::DetachObserver, STATUS_ILLEGAL_PBOJECT.");
	}

	if(STATUS_OK == status)
	{
		status = CAbstractSubject::DetachObserver(pObserver);
		if(STATUS_OK == status)
			PTRACE(eLevelInfoNormal, "CSubject::DetachObserver, STATUS_OK.");
	}

	return status;
}

//////////////////////////////////////////////////////////////////////////////
//remove observer from list
int CSubject::DetachObserver(COsQueue* pObserver, WORD event, WORD type, DWORD observerInfo1)
{
	int status = STATUS_OK;

	CSmallString str;
	str << "observer=" << (DWORD)pObserver << ", event=" << EventToString(event) << ", type=" << TypeToString(type) << ", observer=" << observerInfo1;
	PTRACE2(eLevelInfoNormal, "CSubject::DetachObserver, ", str.GetString());

	/*if(!IsValidPObjectPtr((CPObject*)pObserver))
		status = STATUS_ILLEGAL_PBOJECT;*/

	if(!pObserver || !((COsQueue*)pObserver)->IsValid())
		status = STATUS_ILLEGAL_PBOJECT;

	if(STATUS_OK == status)
		status = CAbstractSubject::DetachObserver(pObserver, event, type, observerInfo1);

	return status;
}

//////////////////////////////////////////////////////////////////////////////
void CSubject::Notify(WORD event, DWORD val)
{
	COsQueue* pQueue = NULL;
	CObserverInfo* pObserverInfo = NULL;

	/*CSmallString  str;
	str << "event=" << EventToString(event) <<" , val=" << val;
	//PTRACE2(eLevelInfoNormal, "CSubject::Notify ", str.GetString());*/

	std::vector< CObserverInfo * >::iterator itr =  m_ObserversList.begin();
	while (itr != m_ObserversList.end())
	{
		pObserverInfo = (CObserverInfo*)(*itr);
		if(IsValidPObjectPtr(pObserverInfo))
		{
			//if observer waits for this event
			if(event == pObserverInfo->GetEvent())
			{
				pQueue = (COsQueue*)pObserverInfo->GetObserver();

				//if not under test
				if(NULL == m_pTaskApi)
				{
					/*CSmallString str;
					str << pObserverInfo->GetObserverInfo1();
					PTRACE2(eLevelInfoNormal, "CSubject::Notify, sending notify to ", str.GetString());*/

					CTaskApi* pTaskApi = new CTaskApi;
					pTaskApi->CreateOnlyApi(*pQueue);
					pTaskApi->ObserverUpdate(event, pObserverInfo->GetType(), pObserverInfo->GetObserverInfo1(), val);
					pTaskApi->DestroyOnlyApi();
					POBJDELETE(pTaskApi);
				}
				else
					m_pTaskApi->ObserverUpdate(event, pObserverInfo->GetType(), pObserverInfo->GetObserverInfo1(), val, pQueue);
			}
		}
		else
		{
			m_ObserversList.erase(itr);
			POBJDELETE(pObserverInfo);
		}
		++itr;
	}
}


//////////////////////////////////////////////////////////////////////////////
const char* CSubject::EventToString(const WORD event)
{
	switch(event)
	{
		case(PARTYSTATE):
			return "PARTYSTATE";
		case(MEDIA):
			return "MEDIA";
		case(CHAIROWNER):
			return "CHAIROWNER";
		case(DISCAUSE):
			return "DISCAUSE";
		case(MUTE_STATE):
			return "MUTE_STATE";
		case(CONTACT_INFO):
			return "CONTACT_INFO";
		case(CONF_LOCK):
			return "CONF_LOCK";
		case(CONF_ACTIVE):
			return "CONF_ACTIVE";
		case(AUDIOSRC):
			return "AUDIOSRC";
		case(PARTY_ADDED):
			return "PARTY_ADDED";
		case(PARTY_DELETED):
			return "PARTY_DELETED";
		case(LSDSRC):
			return "LSDSRC";
		case (CPCONFLAYOUT):
			return "CPCONFLAYOUT";
		case(UPDATELECTUREMODE):
			return "UPDATELECTUREMODE";
		case(UPDATEVISUALNAME):
			return "UPDATEVISUALNAME";
		case(CPPARTYLAYOUT):
			return "CPPARTYLAYOUT";
		default:
			return "UNKNOWN_EVENT";	
	}
}

//////////////////////////////////////////////////////////////////////////////
const char* CSubject::TypeToString(const WORD type)
{
	switch (type)
	{
		case(SIP_CX_PACKAGE):
			return "SIP_CX_PACKAGE";
		case(SIP_EVENT_PACKAGE):
			return "SIP_EVENT_PACKAGE";
		case(SIP_REFER):
			return "SIP_REFER";
		case(OBSERVER_TYPE_PCM):
			return "OBSERVER_TYPE_PCM";
		default:
			return "UNKNOWN_TYPE";
	}
}
