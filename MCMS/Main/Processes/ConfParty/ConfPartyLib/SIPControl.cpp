//+========================================================================+
//                            SIPControl.cpp                               |
//            Copyright 1995 POLYCOM Technologies Ltd.                     |
//                   All Rights Reserved.                                  |
//-------------------------------------------------------------------------|
// NOTE: This software contains valuable trade secrets and proprietary     |
// information of POLYCOM Technologies Ltd. and is protected by law.       |
// It may not be copied or distributed in any form or medium, disclosed    |
// to third parties, reverse engineered or used in any manner without      |
// prior written authorization from POLYCOM Technologies Ltd.              |
//-------------------------------------------------------------------------|
// FILE:       SIPControl.cpp                                              |
// SUBSYSTEM:  MCMS                                                        |
// PROGRAMMER:--														   |
//-------------------------------------------------------------------------|
// Who | Date       | Description                                          |
//-------------------------------------------------------------------------|
//     | 15/11/05   | This file contains								   |
//     |            |                                                      |
//+========================================================================+
#include <arpa/inet.h>
#include <stdlib.h>


#include "Segment.h"
#include "StateMachine.h"
#include "PartyApi.h"
#include "ProcessBase.h"
#include "ConfPartyProcess.h"

#include "SysConfigKeys.h"
#include "SysConfig.h"
#include "IpCsOpcodes.h"
#include "Conf.h"
#include "IpAddressDefinitions.h"
#include "ConfPartyDefines.h"
#include "ConfPartyOpcodes.h"
#include "ConfPartyGlobals.h"
#include "StatusesGeneral.h"
#include "SIPCommon.h"
#include "SipScm.h"
#include "SipCaps.h"
#include "NetSetup.h"
#include "IpNetSetup.h"
#include "Party.h"
#include "IPParty.h"
#include "IpMfaOpcodes.h"
#include "CsInterface.h"
#include "SIPParty.h"
#include "SIPControl.h"
#include "SipUtils.h"
#include "H264Util.h"
#include "IpRtpInd.h"
#include "IpCmInd.h"
#include "ConfPartyGlobals.h"
#include "IpServiceListManager.h"
#include "IpCommonUtilTrace.h"
#include "SystemFunctions.h"
#include "HostCommonDefinitions.h"
#include "FaultsDefines.h"
#include "HlogApi.h"
#include "IpCmReq.h"
#include "IpAddress.h"
#include "ManagerApi.h"
#include "WrappersResource.h"  //to be removed noa
#include "OpcodesMcmsCardMngrICE.h"
#include "IVRCntl.h"
#include "IpCmReq.h"
#include "OpcodesMcmsVideo.h"
#include "OpcodesMcmsAudio.h"
#include "BFCPH239Translator.h"
#include "RtvVideoMode.h"
#include "OpcodesMcmsCardMngrTIP.h"
#include "TipStructs.h"
#include "TipUtils.h"
#include "OpcodesRanges.h"
#include "BfcpStructs.h"
#include "SipProxyTaskApi.h"
#include "ScpNotificationWrapper.h"
#include "IpService.h"
#include "MrcStructs.h"
#include "ScpPipeMappingNotification.h"

#include "PrecedenceSettings.h"
#include "AudRequestStructs.h"
//CDR_MCCF:
#include "IpChannelDetails.h"
#include "PartyMonitor.h"
#include "MccfCdrPackageResponse.h"

#include "OpcodesMcmsCardMngrTB.h"

#include "ArtRequestStructs.h"
#include "SipVsrControl.h"
#include "CdrPersistHelper.h"
#include "EnumsToStrings.h"
#include "EventPackage.h"

#define LOGS_FOR_EXTRA_DEBUG 1

extern CPrecedenceSettings* GetpPrecedenceSettingsDB();

//#define MIX_MODE_SUPPORT_FOR_AVC

// extern functions
extern CConfPartyRoutingTable* GetpConfPartyRoutingTable( void );
extern CIpServiceListManager* GetIpServiceListMngr();
extern void DumpSdpAndHeadersToStream(CObjString* pMsgStr, const sipSdpAndHeadersSt& sdpAndHeaders);
extern WORD IsValidIpV4Address(const char* pIP);
extern BOOL GetVendorDetection();	// for Call Generator - Vendor detection

//CDR_MCCF:
extern std::vector< COsQueue > GetClientRspMbxForMCCFtwinTxList();


const WORD FASTUPDATETOUT	= 1;
const WORD CLOSEALLCHANTOUT	= 2;

const WORD PARTYCSKEEPALIVEFIRSTTOUT  = 20;
const WORD PARTYCSKEEPALIVESECONDTOUT = 21;
const WORD DNS_POLLING_TIMER		  = 124;


//MS project definition
const char* MOC_PRODUCT_NAME = "Microsoft "; // This product name is compatible with "Microsoft Office Communicator" and "Microsoft Lync"
const char* MICROSOFT_EP1 = "OC/2";
const char* MICROSOFT_EP2 = "LCC/1";
const char* MICROSOFT_EP3 = "OC/3";
const char* MICROSOFT_EP4 = "OC/4";
const char* MICROSOFT_EP4Alias = "OCPhone/4";     //added for VNGR-24867
const char* MICROSOFT_EP5 = "Communicator for Mac";
const char* MICROSOFT_EP6 = "Lync for Mac";
const char* MICROSOFT_EP7 = "OC/15"; //Lync2013
const char* MICROSOFT_EP8 = "iPadLync/5"; //Ipad Lync2013
const char* MICROSOFT_EP9 = "iPhoneLync/5"; //iPhone Lync2013
const char* MICROSOFT_EP10 = "RTCC/5"; // lync 2013
const char* MICROSOFT_EP11 = "Lync"; // lync client
const char* MICROSOFT_EP12 = "LyncImm/15.0";//LYNC 2013 On samsaung
const char* MICROSOFT_EP13 = "LMR/15"; // lync 2013
const char* MICROSOFT_AV_MCU_W13 = "RTCC/5.0.0.0 AV-MCU";//LYNC 2013 On samsaung
const char* MICROSOFT_EP14 = "LyncImm/16";//LYNC 2013
const char* MICROSOFT_POLYCOM_COLABORATION_EP1 = "PolycomCX"; // Polycom EP - 360 degree camera to work in Microsft environment
const char*   POLYCOM_CSS_GATEWAY  = "Polycom CSS Lync Gateway"; //Polycom CSS Lync gateway (RDP Gw)
const char*   POLYCOM_CSS_Addon  = "Polycom Real Presence Content Add-on"; //Polycom CSS Addon

// MOC R2 states
const int MocStateUnknown		= 0;
const int MocStateHold   		= 1;
const int MocStateResume 		= 2;
const int MocStateAtoV   		= 3;
const int MocStateVtoA   		= 4;
const int MocStatePauseMyVideo 	= 5;
const int MocStateResumeMyVideo = 6;

// LPR
const WORD	 LPRTOUT 		     = 24;
const WORD   LOCALLPRTOUT		 = 25;
const WORD	 RELAY_FASTUPDATETOUT 		     = 26;

// Dialog recovery
const WORD DIALOG_RECOVERY_TIMER      = 130;

// MS keep alive
const WORD MS_KEEP_ALIVE_CLIENT_TIMER      = 131;
const WORD MS_KEEP_ALIVE_SERVER_TIMER      = 132;

const char* SipInvalidDisplayChars = "#,;:/\"<>\0";

static CCloudInfo glbCloudInfo;
typedef std::vector< COsQueue > CLIENT_RSP_MBX_LIST;

//#define CONF_PARTY_MRMP_STREAM_IS_MUST_REQ                   1110017

PBEGIN_MESSAGE_MAP(CSipCntl)

// state machine for request
ONEVENT(SIP_CS_SIG_VIDEO_FAST_UPDATE_REQ,	IP_CONNECTED,			CSipCntl::SendFastUpdateReq)

ONEVENT(SIP_CS_SIG_INVITE_ACK_IND,	        IP_CONNECTING,			CSipCntl::OnSipInviteAckIndConnecting)
ONEVENT(SIP_CS_SIG_CANCEL_IND,				IP_CONNECTING,			CSipCntl::OnSipCancelIndConnecting)
ONEVENT(SIP_CS_SIG_INVITE_RESPONSE_IND,		IP_CONNECTING,			CSipCntl::OnSipInviteResponseIndConnecting)
ONEVENT(SIP_CS_SIG_BYE_IND,					IP_CONNECTING,			CSipCntl::OnSipByeIndConnecting)//CSipCntl::OnSipByeInd) //HOMOLOGATION
ONEVENT(SIP_CS_SIG_REINVITE_IND,			IP_CONNECTING,			CSipCntl::OnSipReInviteIndConnecting)
ONEVENT(PARTYCONNECTTOUT,					IP_CONNECTING,			CSipCntl::OnTimerConnectCall)
ONEVENT(SIP_CS_SIG_PROV_RESPONSE_IND, 		IP_CONNECTING,			CSipCntl::OnCsProvisunalResponseInd)
ONEVENT(ACK_IND, 							IP_CONNECTING,			CSipCntl::OnMfaAckConnecting)
ONEVENT(ACK_IND,	        IDLE,									CSipCntl::OnMfaAckConnecting)
ONEVENT(IP_CM_PARTY_MONITORING_IND,			IP_CONNECTING,			CSipCntl::OnPartyMonitoringInd)
ONEVENT(CONF_PARTY_MRMP_PARTY_MONITORING_IND,IP_CONNECTING,			CSipCntl::OnPartyMrmpPartyMonitoringInd)
ONEVENT(SIP_CS_SIG_INFO_IND,				IP_CONNECTING,			CSipCntl::OnPartyInfoUnionInd)
ONEVENT(SIP_CS_SIG_INFO_RESP_IND,			IP_CONNECTING,			CSipCntl::OnPartyInfoRespInd)
ONEVENT(IP_CM_DTLS_END_IND,					IP_CONNECTING, 			CSipCntl::OnCmDtlsEndInd)
ONEVENT(IP_CM_TIP_EARLY_PACKET_IND,			IP_CONNECTING, 			CSipCntl::OnCmTipEarlyPacketInd)

// DNS Proxi events
ONEVENT(DNS_POLLING_TIMER,					ANYCASE,          		CSipCntl::OnDnsPollingTimeout)
ONEVENT(DNS_RESOLVE_IND,			      	ANYCASE,          		CSipCntl::OnDNSResolveInd)

ONEVENT(SIP_CS_SIG_BYE_IND,					IP_CONNECTED,			CSipCntl::OnSipByeInd)
ONEVENT(SIP_CS_SIG_REINVITE_IND,			IP_CONNECTED,			CSipCntl::OnSipReInviteIndConnected)


ONEVENT(FASTUPDATETOUT,						IP_CONNECTED,			CSipCntl::OnTimerFastUpdate)
ONEVENT(RTCP_FLOW_CONTROL,					IP_CONNECTED,			CSipCntl::OnTimerSendRtcpFlowControl)

//ONEVENT(DEBUG_PROXY_CORE,					IP_CONNECTED,			CSipCntl::OnTimerSendMsgToSipProxy)    //for debug SIPProxy CORE


ONEVENT(SIP_CS_SIG_DTMF_DIGIT_IND,			IP_DISCONNECTED,		CSipCntl::OnCsDtmfIndIgnore)
ONEVENT(SIP_CS_SIG_DTMF_DIGIT_IND,			IP_DISCONNECTING,		CSipCntl::OnCsDtmfIndIgnore)
ONEVENT(SIP_CS_SIG_DTMF_DIGIT_IND,			ANYCASE,				CSipCntl::OnCsDtmfInd)
ONEVENT(IP_RTP_VIDEO_UPDATE_PIC_IND,		IP_CONNECTED,			CSipCntl::OnSipRtpVideoUpdatePicInd)
ONEVENT(SIP_CS_SIG_VIDEO_FAST_UPDATE_IND,	IP_CONNECTED,			CSipCntl::OnSipCsVideoUpdatePicInd)
ONEVENT(IP_CM_PARTY_MONITORING_IND,			IP_CONNECTED,			CSipCntl::OnPartyMonitoringInd)
ONEVENT(CONF_PARTY_MRMP_PARTY_MONITORING_IND,IP_CONNECTED,			CSipCntl::OnPartyMrmpPartyMonitoringInd)
ONEVENT(IP_CM_RTCP_MSG_IND,		            IP_CONNECTED,		    CSipCntl::OnCmRtcpMsgInd)
ONEVENT(IP_CM_RTCP_MS_SVC_PLI_IND,			IP_CONNECTED,			CSipCntl::OnCmRtcpMsSvcPliInd)
ONEVENT(IP_CM_RTCP_DSH_IND,		         	IP_CONNECTED,			CSipCntl::OnCmRtcpAvMcuDshInd)
ONEVENT(IP_CM_RTCP_DSH_IND,		         	IP_CONNECTING,			CSipCntl::OnCmRtcpAvMcuDshInd)
ONEVENT(IP_CM_RTCP_RTPFB_IND,				IP_CONNECTED,			CSipCntl::OnCmRtcpRtpFBInd) /* rtcp-fb used for TMMBR */
ONEVENT(IP_RTP_FECC_TOKEN_IND,				IP_CONNECTED,			CSipCntl::OnRtpFeccTokenInd)
ONEVENT(IP_RTP_FECC_KEY_IND,				IP_CONNECTED,			CSipCntl::OnRtpFeccKeyInd)
ONEVENT(IP_RTP_DTMF_INPUT_IND,				IP_DISCONNECTED,		CSipCntl::OnRtpDtmfIndIgnore)
ONEVENT(IP_RTP_DTMF_INPUT_IND,				IP_DISCONNECTING,		CSipCntl::OnRtpDtmfIndIgnore)
ONEVENT(IP_RTP_DTMF_INPUT_IND,				ANYCASE,				CSipCntl::OnRtpDtmfInd)
ONEVENT(ACK_IND, 							IP_CONNECTED,			CSipCntl::OnMfaAckConnected)
ONEVENT(SIP_CS_SIG_INFO_IND,				IP_CONNECTED,			CSipCntl::OnPartyInfoUnionInd)
ONEVENT(SIP_CS_SIG_INFO_RESP_IND,			IP_CONNECTED,			CSipCntl::OnPartyInfoRespInd)
ONEVENT(IP_CM_RTCP_VIDEO_PREFERENCE_IND,    IP_CONNECTED,			CSipCntl::OnCmRtcpVideoPreferenceInd)
ONEVENT(IP_CM_RTCP_RECEIVER_BANDWIDTH_IND,  IP_CONNECTED,			CSipCntl::OnCmRtcpReceiverBandwidthInd)
ONEVENT(SIP_CS_SIG_DIALOG_RECOVERY_IND,  IP_CONNECTED,     CSipCntl::OnDialogRecoveryMessageInd)
ONEVENT(IP_CM_DTLS_END_IND,					IP_CONNECTED, 			CSipCntl::OnCmDtlsEndInd)
ONEVENT(IP_CM_TIP_EARLY_PACKET_IND,			IP_CONNECTED, 			CSipCntl::OnCmTipEarlyPacketInd)
ONEVENT(IP_CM_DTLS_END_IND,					IP_CHANGEMODE, 			CSipCntl::NullActionFunction)
ONEVENT(IP_CM_TIP_EARLY_PACKET_IND,			IP_CHANGEMODE, 			CSipCntl::NullActionFunction)

ONEVENT(DIALOG_RECOVERY_REQ,              ANYCASE,              CSipCntl::OnDialogRecoveryFromProxy)
ONEVENT(DIALOG_RECOVERY_TIMER,              ANYCASE,              CSipCntl::OnDialogRecoveryTimeOut)

ONEVENT(MS_KEEP_ALIVE_CLIENT_TIMER,         ANYCASE,              CSipCntl::OnMsKeepAliveClientTimeOut)
ONEVENT(SIP_CS_SIG_CRLF_ERR_IND   ,         ANYCASE,              CSipCntl::OnMsKeepAliveErrInd)
ONEVENT(MS_KEEP_ALIVE_SERVER_TIMER,         ANYCASE,              CSipCntl::OnMsKeepAliveServerTimeOut)
ONEVENT(SIP_CS_SIG_SOCKET_ACTIVITY_IND,         ANYCASE,              CSipCntl::OnMsSocketActivityInd)

// Video quality indication
ONEVENT(IP_CM_RTCP_PACKET_LOSS_STATUS_IND,       IP_CONNECTED, 		CSipCntl::OnSipPacketLostStatusConnected)
ONEVENT(IP_CM_RTCP_PACKET_LOSS_STATUS_IND,       ANYCASE,    		CSipCntl::OnSipPacketLostStatusImproperState)



ONEVENT(SIP_CS_SIG_INVITE_ACK_IND,			IP_DISCONNECTING,		CSipCntl::OnSipInviteAckIndDisconnecting)
ONEVENT(SIP_CS_SIG_CANCEL_IND,				IP_DISCONNECTING,		CSipCntl::OnSipCancelIndDisconnecting)
ONEVENT(SIP_CS_SIG_INVITE_RESPONSE_IND,		IP_DISCONNECTING,		CSipCntl::OnSipInviteResponseIndDisconnecting)
ONEVENT(SIP_CS_SIG_BYE_IND,					IP_DISCONNECTING,		CSipCntl::OnSipByeIndDisconnecting)
ONEVENT(SIP_CS_SIG_BYE_200_OK_IND,			IP_DISCONNECTING,		CSipCntl::OnSipBye200OkInd)
/*Begin:added by Richer for BRIDGE-12062 ,2014.3.3*/
ONEVENT(SIP_CS_SIG_BYE_200_OK_IND,			ANYCASE,		CSipCntl::OnSipBye200OkInd_Avoid)
/*End:added by Richer for BRIDGE-12062 ,2014.3.3*/
ONEVENT(SIP_CS_SIG_REINVITE_IND,			IP_DISCONNECTING,		CSipCntl::OnSipReInviteIndDisconnecting)
ONEVENT(PARTYDISCONNECTTOUT,				IP_DISCONNECTING,		CSipCntl::OnTimerDisconnectCall)
ONEVENT(CLOSEALLCHANTOUT,					IP_DISCONNECTING,		CSipCntl::OnTimerCloseAllChannels)
ONEVENT(ACK_IND, 							IP_DISCONNECTING,		CSipCntl::OnMfaAckDisconnecting)
ONEVENT(MFARESPONSE_TOUT, 					IP_DISCONNECTING,		CSipCntl::OnMfaReqToutDisconnecting)
ONEVENT(MFARESPONSE_TOUT, 					IP_DISCONNECTED,		CSipCntl::NullActionFunction)
ONEVENT(IP_RTP_DIFF_PAYLOAD_TYPE_IND,		IP_DISCONNECTING,		CSipCntl::NullActionFunction)
ONEVENT(IP_RTP_FECC_MUTE_IND,				IP_DISCONNECTING,		CSipCntl::NullActionFunction)
ONEVENT(SIP_CS_SIG_INFO_IND,				IP_DISCONNECTING,		CSipCntl::NullActionFunction)
ONEVENT(SIP_CS_SIG_INFO_RESP_IND,			IP_DISCONNECTING,		CSipCntl::OnPartyInfoRespInd)
ONEVENT(ICE_CLOSE_SESSION_IND,				IP_DISCONNECTING,       CSipCntl::OnMfaICECloseSessionIndDisconnecting)
ONEVENT(SIP_CS_SIG_DIALOG_RECOVERY_IND,  IP_DISCONNECTING,     CSipCntl::OnDialogRecoveryMessageIndDisconnecting)



ONEVENT(ACK_IND, 							IP_CHANGEMODE,			CSipCntl::OnMfaAckChangeMode)
ONEVENT(SIP_CS_SIG_INFO_IND,				IP_CHANGEMODE,			CSipCntl::OnPartyInfoUnionInd)
ONEVENT(SIP_CS_SIG_INFO_RESP_IND,			IP_CHANGEMODE,			CSipCntl::OnPartyInfoRespInd)
ONEVENT(SIP_CS_SIG_REINVITE_IND,			IP_CHANGEMODE,			CSipCntl::OnSipReInviteIndChangeMode)
ONEVENT(SIP_CS_SIG_INVITE_ACK_IND,			IP_CHANGEMODE,		CSipCntl::OnSipInviteAckIndChangeMode)
ONEVENT(SIP_CS_SIG_BYE_IND,					IP_CHANGEMODE,			CSipCntl::OnSipByeInd)// AN - VNGR-21956

ONEVENT(SIP_CS_SIG_VIDEO_FAST_UPDATE_REQ,	ANYCASE,				CSipCntl::OnPartyFastUpdateReqNotConnectedState)
ONEVENT(SIP_CS_SIG_INSTANT_MESSAGE_IND,		ANYCASE,				CSipCntl::OnSipInstantMessageInd)
ONEVENT(SIP_CS_SIG_BAD_STATUS_IND,			ANYCASE,				CSipCntl::OnSipBadStatusInd)
ONEVENT(SIP_CS_SIG_TRACE_INFO_IND,			ANYCASE,				CSipCntl::OnSipTraceInfoInd)
ONEVENT(SIP_CS_SIG_TRANSPORT_ERROR_IND,		ANYCASE,				CSipCntl::OnSipTransportErrorInd)
ONEVENT(SIP_CS_SIG_SESSION_TIMER_EXPIRED_IND,ANYCASE,				CSipCntl::OnSipSessionTimerExpire)
ONEVENT(SIP_CS_SIG_SESSION_TIMER_REINVITE_IND,ANYCASE,				CSipCntl::OnSipSessionTimerReinvite)
ONEVENT(IP_RTP_STREAM_STATUS_IND,			ANYCASE,				CSipCntl::OnRtpStreamStatusInd)
ONEVENT(IP_RTP_DIFF_PAYLOAD_TYPE_IND,		ANYCASE,				CSipCntl::OnRtpDifferentPayloadTypeInd)
ONEVENT(IP_RTP_FECC_MUTE_IND,				ANYCASE,				CSipCntl::OnRtpFeccMuteInd)
ONEVENT(MFARESPONSE_TOUT, 					ANYCASE,				CSipCntl::OnMfaReqToutAnycase)
//ONEVENT(IP_RTP_BAD_SPONTAN_IND,				ANYCASE,				CSipCntl::OnMfaBadSpontaneuosInd)
	// PArty CS keep alive timers - Error handling
ONEVENT(PARTYCSKEEPALIVEFIRSTTOUT,			ANYCASE,				CSipCntl::OnPartyCsErrHandleKeepAliveFirstTout)
ONEVENT(PARTYCSKEEPALIVESECONDTOUT,			ANYCASE,				CSipCntl::OnPartyCsErrHandleKeepAliveSecondTout)
ONEVENT(SIP_CS_PARTY_KEEP_ALIVE_IND,		ANYCASE,				CSipCntl::OnPartyCsErrHandleKeepAliveInd)

//Null action function events
ONEVENT(SIP_CS_SIG_VIDEO_FAST_UPDATE_IND,	ANYCASE,				CSipCntl::NullActionFunction)
ONEVENT(IP_RTP_VIDEO_UPDATE_PIC_IND,		ANYCASE,				CSipCntl::NullActionFunction)
ONEVENT(IP_CM_PARTY_MONITORING_IND,			ANYCASE,				CSipCntl::NullActionFunction)
ONEVENT(CONF_PARTY_MRMP_PARTY_MONITORING_IND,ANYCASE,				CSipCntl::NullActionFunction)
ONEVENT(IP_CM_RTCP_MSG_IND,					ANYCASE,				CSipCntl::NullActionFunction)
ONEVENT(IP_CM_RTCP_MS_SVC_PLI_IND,			ANYCASE,				CSipCntl::LoggedNullActionFunction)
ONEVENT(IP_RTP_FECC_TOKEN_IND,				ANYCASE,				CSipCntl::NullActionFunction)
ONEVENT(IP_CM_RTCP_RTPFB_IND,				ANYCASE,				CSipCntl::NullActionFunction) /* rtcp-fb event used for TMMBR only in connected state */
ONEVENT(RTCP_FLOW_CONTROL,					ANYCASE,				CSipCntl::NullActionFunction) /* periodic rtcp-fb tmmbr flow control, should be sent only in connected state*/

//ICE
ONEVENT(ICE_SESSION_INDEX_IND,				ANYCASE,				CSipCntl::OnMfaICESessionIndexInd)
ONEVENT(ICE_MAKE_ANSWER_IND,				ANYCASE,				CSipCntl::OnMfaICEAnswerInd)
ONEVENT(ICE_MAKE_OFFER_IND,				    ANYCASE,				CSipCntl::OnMfaICEOfferInd)
ONEVENT(ICE_PROCESS_ANSWER_IND,				ANYCASE,		        CSipCntl::OnMfaICEProcessAnswerInd)
ONEVENT(ICE_CLOSE_SESSION_IND,				ANYCASE,		        CSipCntl::OnMfaICECloseSessionInd)
ONEVENT(ICE_ERR_IND,				        ANYCASE,		        CSipCntl::OnMfaICEErrInd)
ONEVENT(ICE_REINVITE_IND,					ANYCASE,				CSipCntl::OnMfaICEReinviteDataInd)
ONEVENT(ICE_CHECK_COMPLETE_IND,				ANYCASE,               CSipCntl::OnMfaICEConnectivityCheckComplete)
ONEVENT(ICE_MODIFY_SESSION_ANSWER_IND,	   ANYCASE,			    	CSipCntl::OnMfaICEModifyAnswerInd)
ONEVENT(ICE_MODIFY_SESSION_OFFER_IND,	   ANYCASE,			    	CSipCntl::OnMfaICEModifyOfferInd)
ONEVENT(ICE_BANDWIDTH_EVENT_IND,	       ANYCASE,			    	CSipCntl::OnMfaICEBandwidthEventInd)
ONEVENT(ICE_INSUFFICIENT_BANDWIDTH_IND,	       ANYCASE,			    CSipCntl::OnMfaICEInsufficientBandwidthEventInd)

//lpr
ONEVENT(IP_RTP_LPR_MODE_CHANGE_IND,				IP_CONNECTING	, 	CSipCntl::NullActionFunction)
ONEVENT(IP_RTP_LPR_MODE_CHANGE_IND,				IP_DISCONNECTING,	CSipCntl::NullActionFunction)
ONEVENT(IP_RTP_LPR_MODE_CHANGE_IND,				DISCONNECT,	CSipCntl::NullActionFunction)
ONEVENT(IP_RTP_LPR_MODE_CHANGE_IND,				ANYCASE, 	CSipCntl::OnRtpLprChangeModeInd)
ONEVENT(LPRTOUT,							    IP_DISCONNECTING,		CSipCntl::NullActionFunction)
ONEVENT(LPRTOUT,							    DISCONNECT,	CSipCntl::NullActionFunction)
ONEVENT(LPRTOUT,							    ANYCASE, 	CSipCntl::OnSIPLprTout)
ONEVENT(LOCALLPRTOUT,						    IP_DISCONNECTING,	CSipCntl::NullActionFunction)
ONEVENT(LOCALLPRTOUT,						    IP_CONNECTING,	CSipCntl::NullActionFunction)
ONEVENT(LOCALLPRTOUT,						    DISCONNECT,	CSipCntl::NullActionFunction)
ONEVENT(LOCALLPRTOUT,						    ANYCASE, 	        CSipCntl::OnRtpLprTout)
// Content
ONEVENT(SIP_CS_BFCP_MESSAGE_IND,			IP_DISCONNECTING,		CSipCntl::NullActionFunction)
//ONEVENT(SIP_CS_BFCP_MESSAGE_IND,			ANYCASE,				CSipCntl::OnSipCsBfcpMessageInd)
ONEVENT(SIP_CS_BFCP_TRANSPORT_IND,			IP_DISCONNECTING,		CSipCntl::NullActionFunction)
//ONEVENT(SIP_CS_BFCP_TRANSPORT_IND,			ANYCASE,				CSipCntl::OnSipCsBfcpTransportInd)
ONEVENT(IP_CM_BFCP_TCP_TRANSPORT_IND, 		ANYCASE, 				CSipCntl::OnCmBfcpTcpTransportInd)
ONEVENT(IP_CM_BFCP_TCP_TRANSPORT_IND, 		IP_DISCONNECTING, 		CSipCntl::NullActionFunction)

//ONEVENT(IP_RTP_ASK_ENCODER_FOR_INTRA_IND,		IP_CONNECTED,		CSipCntl::OnSipRtpSelfVideoUpdatePicReq)
ONEVENT(IP_RTP_ASK_ENCODER_FOR_INTRA_IND,		IP_DISCONNECTING,		CSipCntl::NullActionFunction)
ONEVENT(IP_RTP_ASK_ENCODER_FOR_INTRA_IND,		ANYCASE,		CSipCntl::OnSipRtpSelfVideoUpdatePicReq)

ONEVENT(IP_CM_RTCP_VIDEO_PREFERENCE_IND,    ANYCASE,			CSipCntl::OnCmRtcpVideoPreferenceIndAnycase)

ONEVENT(CM_SEND_CNAME_INFO_AS_STRING_IND,			IP_DISCONNECTING,	CSipCntl::NullActionFunction)
ONEVENT(CM_SEND_CNAME_INFO_AS_STRING_IND,			DISCONNECT,	CSipCntl::NullActionFunction)
ONEVENT(CM_SEND_CNAME_INFO_AS_STRING_IND,			ANYCASE,	CSipCntl::RetriveCNAMEInfoIfNeeded)
ONEVENT(CONF_PARTY_MRMP_SCP_STREAM_REQ_IND,			ANYCASE,    CSipCntl::OnScpStreamsRequest)
ONEVENT(CONF_PARTY_MRMP_SCP_STREAM_NOTIFICATION_IND,ANYCASE,    CSipCntl::OnScpStreamsNotificationFromEpInd)
ONEVENT(CONF_PARTY_MRMP_SCP_STREAM_NOTIFICATION_ACK_IND,	ANYCASE,	CSipCntl::OnScpStreamNotificationAckInd)

//CDR_MCCF:
ONEVENT(IP_CM_PARTY_VIDEO_CHANNELS_STATISTICS_IND,    IP_DISCONNECTING,    CSipCntl::OnPartyStatisticsIndStateDisconnecting)
ONEVENT(IP_CM_PARTY_VIDEO_CHANNELS_STATISTICS_IND,    DISCONNECT,          CSipCntl::NullActionFunction)
ONEVENT(IP_CM_PARTY_VIDEO_CHANNELS_STATISTICS_IND,    ANYCASE,             CSipCntl::OnPartyInMiddleOfTransactionStatisticsInd)
ONEVENT(IP_CM_PARTY_STATISTIC_INFO_IND_TOUT,          IP_DISCONNECTING,    CSipCntl::OnPartyStatisticsIndStateDisconnectingTout)
ONEVENT(IP_CM_PARTY_STATISTIC_INFO_IND_TOUT,          ANYCASE,             CSipCntl::OnPartyStatisticsIndAnycaseTout)


//FEC
//ONEVENT(FECINTRATOUT,							    IP_DISCONNECTING,		CSipCntl::NullActionFunction)
//ONEVENT(FECINTRATOUT,							    DISCONNECT,				CSipCntl::NullActionFunction)
//ONEVENT(FECINTRATOUT,							    ANYCASE, 				CSipCntl::SendIntraReqToEP)


// TIP
//ONEVENT(TIP_CNTL_NEGOTIATION_RESULT,		IP_CONNECTED,			CSipCntl::OnTipResultsInd)
//ONEVENT(TIP_CNTL_NEGOTIATION_RESULT,		ANYCASE,				CSipCntl::NullActionFunction)
ONEVENT(CONF_PARTY_MRMP_RTCP_FIR_IND, ANYCASE,		CSipCntl::OnMrmpRtcpFirInd)

ONEVENT(RELAY_FASTUPDATETOUT,				IP_CONNECTED,			CSipCntl::OnRelayTimerFastUpdateConnected) //intra for VSW RPD=>HDX
ONEVENT(RELAY_FASTUPDATETOUT,				ANYCASE,				CSipCntl::OnRelayTimerFastUpdateNotConnected) //intra for VSW RPD=>HDX
ONEVENT(IP_CM_MEDIA_DISCONNECTED_IND,  IP_CONNECTED,		CSipCntl::OnMediaDisconnectDetectionInd)
ONEVENT(IP_CM_MEDIA_DISCONNECTED_IND,  IP_CHANGEMODE,		CSipCntl::OnMediaDisconnectDetectionInd)
ONEVENT(IP_CM_MEDIA_DISCONNECTED_IND,  IP_CONNECTING,		CSipCntl::OnMediaDisconnectDetectionIndConnecting)
ONEVENT(IP_CM_MEDIA_DISCONNECTED_IND,  ANYCASE, 	CSipCntl::OnMediaDisconnectDetectionIndInAnycase)
ONEVENT(MEDIA_DISCONNECTION_RESUME_CELL_TIMER, ANYCASE, CSipCntl::OnMediaResume)

PEND_MESSAGE_MAP(CSipCntl,CIpCntl);


//////////////////////////////////////////////////////////////////////
CSipCntl::CSipCntl(CTaskApp *pOwnerTask)
        :CIpCntl(pOwnerTask)
{
	m_pPartyApi			= new CPartyApi;
	m_pNetSetup			= new CSipNetSetup;
	m_pQos				= new CQoS;
	m_pCall				= new CSipCall;
	m_pPartialLocalCaps = new CSipCaps;
	m_pFullLocalCaps	= new CSipCaps;
	BOOL change_audio_list_flag = GetSystemCfgFlagInt<BOOL>(CFG_KEY_SIP_CHANGE_AUDIO_CAPS_LIST_ACCORDING_TO_VENDOR);
	m_pChosenLocalCap 	= (change_audio_list_flag) ? m_pPartialLocalCaps : m_pFullLocalCaps;
	m_pMaxLocalCaps     = new CSipCaps;
	m_pLastRemoteCaps	= new CSipCaps;
	m_pPreviousRemoteCaps	= new CSipCaps;
	m_pRemoteSdp		= NULL; //alloc when know the length
	m_pLocalSdp			= NULL;
	m_outboundProxyIp	= 0;
	m_transportType		= (enTransportType)0;
	m_strConfParamInfo	= "";
	m_oldMediaBytesArr	= new DWORD[MaxChannelsPerCall+2];
	m_oldFramesArr		= new DWORD[MaxChannelsPerCall+2];
	memset(m_oldMediaBytesArr,0,(MaxChannelsPerCall+2)*sizeof(DWORD));
	memset(m_oldFramesArr,0,(MaxChannelsPerCall+2)*sizeof(DWORD));
	m_bIsReInviteTransaction	= NO;
	m_pParty 			= NULL;
	m_pDestUnitId = eSipBalancer;
	m_callIndex = 0;
	m_serviceId = 0;

	m_keepAliveTimerCouter = 0;
	m_isKeepAliveIndArrived = 0;

	memset(&m_UdpAddressesParams, 0, sizeof(UdpAddresses));

	m_isNeedToResetCallIndex = 0;

	InitSpeakerParams();

	m_remoteIdent = Regular;
	m_plcmRequireMask = 0;
	memset(m_plcmReqMaskMlineOrder, 0, sizeof(m_plcmReqMaskMlineOrder));
	m_bChangeModeWithinTransaction = NO;
	m_isLprModeOn                   = NO;
	m_LprModeTimeout                = 0;
	m_UserAgent = NULL;
	m_sdpRemoteSessionInformation = NULL;

	m_bIsHold = FALSE;	  // current hold state.
	m_bPauseMyVideo = FALSE;  // Is current state is pause my video
	m_savedAudioPort = 0;
	m_savedVideoPort = 0;
	m_savedVideoIp = 0;

	m_pCopVideoModes 		= NULL;

    m_isCameraControl = 0;
    m_bDeclareVideoFromScmOnly = FALSE;

	m_IsEnableICE = 0;
	m_pIceParams        = NULL;
	m_LocalICESdp		= NULL; //alloc when know the length
	m_Ice_Session_Index = 0;
    m_IceConnectivityCheckStatus = eIceNotConnected;
    m_bIsSentICEStackReq = FALSE;
    m_bIsIceSessionIsInClosingState = FALSE;
    m_bNeedUpdateIceToNonIce = FALSE;

    m_SavedTrans        =NULL;
    m_PendTransType     = eNoPendTrans;
    m_ChannelsWithLprPayload = NO;

    for(int i=0;i<NumOfMediaTypes-1;i++)
    	memset(&m_chosenCandidates[i],0,sizeof(chosenCandidatesSt));

	//m_lastFloorRequestID = 1;

	m_eContentInState = eNoChannel;
	m_eContentOutState = eNoChannel;

	m_fullContentRate = 0;
    m_bIsContentSpeaker	= FALSE;
    m_isNeedToReleaseUponHoldForTip = FALSE;

    // TIP
    m_tipAudioRate 		= 0;
    m_tipVideoRate 		= 0;

    m_bIsOnHold 		= FALSE;
    m_bIsResuming 		= FALSE;

    m_pTipRtcpCntl		= NULL;
	m_tipPartySlaveIdToMonitor = 0;
	m_RtcpCnameMask = 0x0001;//1 in the LSD indicates we are MCU and not EP
	m_IsNeedToExtractInfoFromRtcpCname = TRUE;
	m_AllocatedBandwidth = -1;

	m_cancelIndParams = NULL;
    m_bIsIceHasSessionIndex = FALSE;
    m_bNeedToCancelIceSession = FALSE;
    m_bRingback                 = FALSE;

    // BFCP
    m_pSipBfcpCtrl		= NULL;
    m_eMediaStreamAttrType = eMediaStreamNone;
    m_bfcpMStreamType = bfcp_m_stream_None;
	m_BFCPcapConfIDfield = 0;
	m_BFCPcapUserIDfield = 0;

    m_bDeclareOnContentFromScmOnly = FALSE;

    //================================
    // Video quality related members
    //================================
	m_cmInboundPacketLossStatus		= ePacketLossNormal;;
	m_cmOutboundPacketLossStatus	= ePacketLossNormal;;
    m_adjInboundPacketLossStatus	= ePacketLossNormal;
    m_adjOutboundPacketLossStatus	= ePacketLossNormal;
    m_inboundLprActive 				= FALSE;
    m_outboundLprActive 			= FALSE;
    //---TCP Keep Alive ----------------------------------//
    m_dwKeepAliveFrequency_Sec      = 0;
    m_MsKeepAlivePongTimeOut        = 0;
    m_dwKeppAliveBehavior           = 0;
    m_dwKeepAliveType               = 0;
    m_dwSocketActivityErrCount      = 0;
    //----------------------------------------------------//

    m_bBfcpReconnect         		= FALSE;
    m_bfcpChannelsAckCounter 		= 0;

    //m_BitRateWithFEC				= 0;
    //m_BitRateWithRED				= 0;
	m_LastRateBeforeLpr		= 0;
	//m_LastRateBeforeFEC		= 0;
	//m_LastRateBeforeRED     = 0;
	m_ChangeOfRateRED       = 0;
	m_ChangeOfRateFEC       = 0;
    m_LossPacketSeqNum              = 0;

    //LYNC2013_FEC_RED:
    m_FecFractionLossInPercent	= 0;
    m_RedFractionLossInPercent  = 0;
    m_bIsCMStartFec	  = FALSE;
    m_bIsCMStartRed	  = FALSE;
    m_bIsFecOn		  = FALSE;
    m_bIsRedOn        = FALSE;
	m_isActiveFecFlow = FALSE;
	m_isActiveRedFlow = FALSE;
	m_savedFecPacketLossStatus.isNeedToHandleNewData = FALSE;
	m_savedFecPacketLossStatus.mediaType = cmCapEmpty;
	m_savedFecPacketLossStatus.fractionLossInPercent = 0;
	m_savedFecPacketLossStatus.ssrc = 0;
	m_savedRedPacketLossStatus.isNeedToHandleNewData = FALSE;
	m_savedRedPacketLossStatus.mediaType = cmCapEmpty;
	m_savedRedPacketLossStatus.fractionLossInPercent = 0;
	m_savedRedPacketLossStatus.ssrc = 0;



    m_bIsMrcCall = FALSE;
    memset(&m_mrdVersion, 0, sizeof(MrdVersionStruct));

    //LyncCCS
    m_bIsCCSPlugin  = FALSE;
    m_ePartyAuthState = ePartyAuthStateIdle;
    m_pAuthPwd = NULL;
    m_AuthCounter = 0;

    m_pTargetModeBeforeDowngrade = new CIpComMode;

    //CDR_MCCF:
    //Video people CDR:
    m_pIpVideoCdrChannelDetails[0] = new CIpChannelDetails;
    m_pIpVideoCdrChannelDetails[0]->SetChannelType(VIDEO_OUT); //EIpChannelType
    m_pIpVideoCdrChannelMonitor[0] = CPrtMontrBaseParams::AllocNewClass(VIDEO_OUT);
    //Video content CDR:
    m_pIpVideoCdrChannelDetails[1] = new CIpChannelDetails;
    m_pIpVideoCdrChannelDetails[1]->SetChannelType(VIDEO_CONT_OUT);
    m_pIpVideoCdrChannelMonitor[1] = CPrtMontrBaseParams::AllocNewClass(VIDEO_CONT_OUT);

     //added for ANAT
    m_AnatSelectedIpVersion	 	= enIpVersionMAX;
    m_LastAnatSelectedIpVersion		= enIpVersionMAX;

    m_nCenterNacks				= 0;
    m_nLeftToRightNacks 		= 0;
    m_nRightToLeftNacks			= 0;
    m_nRtpSelfIntraReq			= 0;

    m_isUpdateAnatIpType			= FALSE;
    m_isASSIPContentEnable = FALSE;
    m_bShouldMsftVideoTxStreamOn = FALSE;
    m_isMs2013Active             = eMsft2013None;
    m_bIsVsrCtrlInitialized      = FALSE;

	for(int i = 0; i < MAX_STREAM_LYNC_2013_CONN; ++i)
		m_msftPliRequestId[i] = 1;

	m_bIsCiscoTagExist 			= FALSE;


    m_useRtcp = 1;
    m_pVsrControl = NULL;

	m_bIsOneDtlsArrived = FALSE;
    m_sLastOriginVersion = "";

    m_allowMediaBasedDisconnectionInReinvite = FALSE;

    memset(&m_LastAvMcuMux, 0, sizeof(mcMuxLync2013InfoReq));

    m_IsST852Resume = FALSE;

	VALIDATEMESSAGEMAP;
}


////////////////////////////////////////////
CSipCntl::~CSipCntl()
{
	DeleteAllTimers();
	POBJDELETE(m_pPartyApi);
	POBJDELETE(m_pNetSetup);
//	POBJDELETE(m_pRsrcDesc);
	POBJDELETE(m_pQos);
	POBJDELETE(m_pCall);
	POBJDELETE(m_pFullLocalCaps);
	POBJDELETE(m_pPartialLocalCaps);
	m_pChosenLocalCap  = NULL;
	POBJDELETE(m_pMaxLocalCaps);
	POBJDELETE(m_pLastRemoteCaps);
	POBJDELETE(m_pPreviousRemoteCaps);
	PDELETEA(m_pRemoteSdp);
	PDELETEA(m_pLocalSdp);
	PDELETEA(m_oldMediaBytesArr);
	PDELETEA(m_oldFramesArr);
	PDELETEA(m_UserAgent);
	PDELETEA(m_sdpRemoteSessionInformation);

	POBJDELETE(m_pIceParams);
	POBJDELETE(m_LocalICESdp);
	POBJDELETE(m_pCopVideoModes);
	POBJDELETE(m_SavedTrans);
	POBJDELETE(m_pTipRtcpCntl);
	POBJDELETE(m_pSipBfcpCtrl);

	POBJDELETE(m_pTargetModeBeforeDowngrade);

	if (NULL != m_pVsrControl) POBJDELETE(m_pVsrControl);

	//LyncCCS
	PDELETEA(m_pAuthPwd);

	//CDR_MCCF:
	for (int i = 0; i < NUM_OF_CHANNELS_FOR_MCCF_CDR_INFO; i++)
	{
	    POBJDELETE(m_pIpVideoCdrChannelDetails[i]);
	    POBJDELETE(m_pIpVideoCdrChannelMonitor[i]);
	}
//	POBJDELETE(m_pLoadMngrConnector);
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::LoggedNullActionFunction(CSegment*)
{
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::LoggedNullActionFunction - Null action for state: ", m_state);
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateLocalCapsSdesUnencryptedSrtcp(CSipComMode * pBestMode, cmCapDataType eMediaType, ERoleLabel eRole)
{
	if (!pBestMode)
		return;

	CSdesCap *pBestModeSdesCap = pBestMode->GetSipSdes(cmCapAudio ,cmCapTransmit, kRolePeople);
	if (!pBestModeSdesCap)
		return;

	BOOL unencryptedSrtcp = pBestModeSdesCap->GetIsSdesUnencryptedSrtcp();;

	if (m_pChosenLocalCap) {
		CSdesCap *pSdesCap = m_pChosenLocalCap->GetSdesCap(eMediaType, eRole); AUTO_DELETE(pSdesCap);
		if (pSdesCap)
			pSdesCap->SetIsSdesUnencryptedSrtcp(unencryptedSrtcp);
	}

	if (m_pFullLocalCaps) {
		CSdesCap *pSdesCap = m_pFullLocalCaps->GetSdesCap(eMediaType, eRole); AUTO_DELETE(pSdesCap);
		if (pSdesCap)
			pSdesCap->SetIsSdesUnencryptedSrtcp(unencryptedSrtcp);
	}

	if (m_pPartialLocalCaps) {
		CSdesCap *pSdesCap = m_pPartialLocalCaps->GetSdesCap(eMediaType, eRole); AUTO_DELETE(pSdesCap);
		if (pSdesCap)
			pSdesCap->SetIsSdesUnencryptedSrtcp(unencryptedSrtcp);
	}

	if (m_pMaxLocalCaps) {
		CSdesCap *pSdesCap = m_pMaxLocalCaps->GetSdesCap(eMediaType, eRole); AUTO_DELETE(pSdesCap);
		if (pSdesCap)
			pSdesCap->SetIsSdesUnencryptedSrtcp(unencryptedSrtcp);
	}
}
////////////////////////////////////////////////////////////////////////////
void  CSipCntl::HandleEvent(CSegment *pMsg, DWORD msgLen, OPCODE opCode)
{
	DispatchEvent(opCode, pMsg);
}

////////////////////////////////////////////////////////////////////////////
BOOL  CSipCntl::DispatchEvent(OPCODE event,CSegment* pParam)
{
	if (IsValidPObjectPtr(m_pTipRtcpCntl) && IsTipRtcpMessage(event))
		return m_pTipRtcpCntl->DispatchEvent(event, pParam);
	if (IsValidPObjectPtr(m_pSipBfcpCtrl) && IsSipBfcpCtrlMessage(event))
		return m_pSipBfcpCtrl->DispatchEvent(event, pParam);
	if (IsValidPObjectPtr(m_pVsrControl) && IsVsrRtcpMessage(event))
		return m_pVsrControl->DispatchEvent(event, pParam);

	return CStateMachine::DispatchEvent(event, pParam);
}

//////////////////////////////////////////////////
void CSipCntl::SetLocalSipHostAddress()
{
	TRACEINTO << "DBG";
	if (m_serviceId)
	{
		CIpServiceListManager* pIpServiceListManager = ::GetIpServiceListMngr();
		CConfIpParameters* pServiceParams = pIpServiceListManager->FindIpService(m_serviceId);
		if (pServiceParams == NULL)
		{
			PASSERTMSG((DWORD)this, "CSipCntl::SetLocalSipHostAddress - IP Service does not exist!!!");
			return;
		}

		CSmallString host = pServiceParams->GetRegistrarDomainName();
		if (host.IsEmpty())
			host = pServiceParams->GetSipProxyName();
		char*  strHost = const_cast<char*>(host.GetString());
		// In case the domain name is an IpV6 address - Add Brackets to the string.
		if (::isIpV6Str(strHost) == TRUE)
		{
			ipAddressStruct *tpmAddr = new ipAddressStruct; AUTO_DELETE(tpmAddr);
			memset(tpmAddr,0,sizeof(ipAddressStruct));
			stringToIpV6(tpmAddr,strHost);
			strHost = ipToString(*tpmAddr,strHost,1);
		}
		m_pNetSetup->SetLocalHost(const_cast<char*>(strHost));
 	}
}



////////////////////////////////////////////////////////////////
void CSipCntl::SetCardCallIndex(DWORD cardCallIndex)
{
	TRACECOND_AND_RETURN(!m_pCall , "m_pCall is NULL");
	m_pCall->SetCardIndex(cardCallIndex);
}


////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetRemoteSdp(const sipSdpAndHeadersSt & remoteSdp)
{
	PDELETEA(m_pRemoteSdp);
	int length = sizeof(sipSdpAndHeadersBaseSt) + remoteSdp.lenOfDynamicSection;
	m_pRemoteSdp = (sipSdpAndHeadersSt *)new BYTE[length];
	memset(m_pRemoteSdp, 0, length);
	memcpy(m_pRemoteSdp,&remoteSdp,length);

}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetLocalSdp(const sipSdpAndHeadersSt & localSdp)
{
	PDELETEA(m_pLocalSdp);
	int length = sizeof(sipSdpAndHeadersBaseSt) + localSdp.lenOfDynamicSection;
	m_pLocalSdp = (sipSdpAndHeadersSt *)new BYTE[length];
	memset(m_pLocalSdp, 0, length);
	memcpy(m_pLocalSdp,&localSdp,length);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::AddMrdHeader(CSipHeaderList &rHeaderList)
{
	rHeaderList.AddHeader(kProprietyHeader, strlen(MRD_HEADER_STR), MRD_HEADER_STR);
	rHeaderList.AddHeader(kSdpSession_s, strlen(MRD_SDP_HEADER_STR), MRD_SDP_HEADER_STR);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::AddInfoHeader(CSipHeaderList &rHeaderList)
{
	BYTE cascadeMode = GetCascadeMode();
	if (cascadeMode == CASCADE_MODE_MASTER)
	{
		rHeaderList.AddHeader(kSdpSession_i, strlen(INFO_HEADER_STR_MASTER), INFO_HEADER_STR_MASTER);
		TRACEINTO << "---cascade--- \"" << INFO_HEADER_STR_MASTER << "\" added";
	}

	else if (cascadeMode == CASCADE_MODE_SLAVE)
	{
		rHeaderList.AddHeader(kSdpSession_i, strlen(INFO_HEADER_STR_SLAVE), INFO_HEADER_STR_SLAVE);
		TRACEINTO << "---cascade--- \"" << INFO_HEADER_STR_SLAVE << "\" added";
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::AddQosHeader(CSipHeaderList &rHeaderList, const char* domain, BYTE rPriority) const
{
	CMedString log;
	log << "CSipCntl::AddQosHeader - RPriority[" << rPriority << "], Domain[" << domain << "]";
	PTRACE(eLevelInfoNormal, log.GetString());
	if (m_pQos -> IsDynamicRPriorityEnabled())
	{
		int headerLen = strlen(QOS_HEADER_PREFIX) + 2 /*semicolon + space*/ + strlen(domain) + 4 /*RPrio*/;
		if(headerLen < ONE_LINE_BUFFER_LEN)
		{
			//=======================
			// Preparing Qos header
			//=======================
			char QosHeader[ONE_LINE_BUFFER_LEN];
			int dRPriority = rPriority;
			headerLen = snprintf(QosHeader, sizeof(QosHeader), "%s: %s.%d", QOS_HEADER_PREFIX, domain, dRPriority);

			if (headerLen > 0)
			{
				CMedString log;
				log << "CSipCntl::AddQosHeader - Adding header[" << QosHeader << "]";
				PTRACE(eLevelInfoNormal, log.GetString());
				rHeaderList.AddHeader(kProprietyHeader, headerLen, QosHeader);

				//=====================================================
				// Preparing appropriate option for "Require:" header
				//=====================================================
				BOOL resourcePriorityInRequire = NO;
				std::string key = "RESOURCE_PRIORITY_IN_REQUIRE";
				CProcessBase::GetProcess()->GetSysConfig()->GetBOOLDataByKey(key, resourcePriorityInRequire);
				if(resourcePriorityInRequire)
				{
					CMedString log;
					PTRACE2(eLevelInfoNormal, "CSipCntl::AddQosHeader - Adding appropriate \"Require:\" header: ", QOS_REQUIRE_STR);
					rHeaderList.AddHeader(kProprietyHeader, strlen(QOS_REQUIRE_STR), QOS_REQUIRE_STR);
				}
				else
				{
					PTRACE(eLevelInfoNormal, "CSipCntl::AddQosHeader - Per configuration, not adding resource-priority in \"Require:\" header.");
				}
			}
			else
			{
				PTRACE2INT(eLevelInfoNormal,"CSipCntl::AddQosHeader - Dropping QoS header due to a failed string creation - ", headerLen);
			}
		}
		else
		{
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::AddQosHeader - Dropping QoS header due to an exceedingly large header length - ", headerLen);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::AddContactHeader(CSipHeaderList &rHeaderList)
{
	//Set contact as conf@ cs will add ip address
	if (m_pNetSetup && m_pNetSetup->GetLocalSipAddress())
	{
		char *pLocalHost = (char*)strchr(m_pNetSetup->GetLocalSipAddress(), '@');
		if (pLocalHost)
		{
			char sContact[FULL_PATH_NAME_LEN] = {};
			unsigned int size = pLocalHost - m_pNetSetup->GetLocalSipAddress() + 1;
			if (size < FULL_PATH_NAME_LEN)
			{
				strncpy(sContact, m_pNetSetup->GetLocalSipAddress(), size);
				AddParamsToContactHeader(sContact); //_dtls_
				rHeaderList.AddHeader(kContact,strlen(sContact),sContact);
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::AddIBMDestinationPublicIpHeader(CSipHeaderList &rHeaderList)
{
	//Set contact as conf@ cs will add ip address
	if (m_pNetSetup && m_pNetSetup->GetLocalSipAddress()) {
		char *pLocalHost = (char*)strchr(m_pNetSetup->GetLocalSipAddress(), '@');
		if (pLocalHost && pLocalHost[1] != '\0') {
			char sHeader[256] = "IBM-Destination-Public-IP: ";
			pLocalHost++;
			unsigned int size = strlen(pLocalHost);
			if (size < sizeof(sHeader) - strlen(sHeader)) {
				strncat(sHeader,pLocalHost, size);
				rHeaderList.AddHeader(kProprietyHeader,strlen(sHeader),sHeader);
			}
		}
	}
}
////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::GetCascadeMode() const
{
	BYTE retCascadeMode = CASCADE_MODE_NONE;
	CConfParty* pConfParty = NULL;
	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	if (pCommConf)
	{
		pConfParty = pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());
		if (pConfParty)
			retCascadeMode = pConfParty->GetCascadeMode();
	}
	TRACEINTO << "Cascade mode: " << (int)retCascadeMode;
	return retCascadeMode;
}

////////////////////////////////////////////////////////////////////////////////

/**
 * The function receives a vendor string that arrived at the userAgent/Session/Owner,Origin fields.
 * vendorStr[IN]	-	the string to parse.
 * vendor	[OUT]	-	The remote vendor identification enum.
 */
static void DetermineRemoteVendorByString(char *vendorStr, RemoteIdent *vendor)
{
	RemoteIdent remoteVendorIdent;
	remoteVendorIdent = Regular;

	//NOTE: Put the Polycom XXX before PolycomEp
	if(strstr(vendorStr, POLYCOM_CSS_GATEWAY))
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: remote ident set to RDP Gw");
		remoteVendorIdent = Polycom_Lync_CCS_Gw; //
	}
	else 	if(strstr(vendorStr, POLYCOM_CSS_Addon))
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: remote ident set to CCS Addon ");
		remoteVendorIdent = MicrosoftEP_Lync_CCS; //
	}
	else if ( strstr(vendorStr, "Polycom RMX") )
	{
		remoteVendorIdent = PolycomRMX;
	}
	else if (strstr(vendorStr, "Polycom"))
	{
		remoteVendorIdent = PolycomEp;
	}
	else if((strstr(vendorStr, MICROSOFT_EP1) || strstr(vendorStr, MICROSOFT_EP2)) && strstr(vendorStr, MOC_PRODUCT_NAME))
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: remote ident set to FlipIntraAndFastUpdateEP");
		remoteVendorIdent = MicrosoftEP_R1;// flip intra and fast update request;
	}
	else if(strstr(vendorStr, MICROSOFT_EP3) && strstr(vendorStr, MOC_PRODUCT_NAME))
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: remote ident set to FastUpdateEP");
		remoteVendorIdent = MicrosoftEP_R2;	// fast update request and ignore port 0 on audio when escalating to A+V
	}
	else if((strstr(vendorStr, MICROSOFT_EP4) || strstr(vendorStr, MICROSOFT_EP4Alias)) && strstr(vendorStr, MOC_PRODUCT_NAME)) //modified for VNGR-24867
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: Lync R1 - remote ident set to FastUpdateEP");
		remoteVendorIdent = MicrosoftEP_Lync_R1;	// fast update request and ignore port 0 on audio when escalating to A+V
	}
	else if(strstr(vendorStr, MICROSOFT_EP7) && strstr(vendorStr, MOC_PRODUCT_NAME)) //modified for VNGR-24867
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: Lync 2013 - remote ident set to FastUpdateEP");
		remoteVendorIdent = MicrosoftEP_Lync_2013;	// fast update request and ignore port 0 on audio when escalating to A+V
	}
	else if(strstr(vendorStr, MICROSOFT_EP8))
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: IPAD Lync 2013 - remote ident set to FastUpdateEP");
		remoteVendorIdent = MicrosoftEP_Lync_2013;	// fast update request and ignore port 0 on audio when escalating to A+V
	}
	else if(strstr(vendorStr, MICROSOFT_EP9))
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: IPHONE Lync 2013 - remote ident set to FastUpdateEP");
		remoteVendorIdent = MicrosoftEP_Lync_2013;	// fast update request and ignore port 0 on audio when escalating to A+V
	}
	else if(strstr(vendorStr, MICROSOFT_EP10) && strstr(vendorStr, MICROSOFT_EP11))
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: RTCC/5 Lync - remote ident set to FastUpdateEP");
		remoteVendorIdent = MicrosoftEP_Lync_2013;	// fast update request and ignore port 0 on audio when escalating to A+V
	}
	else if(strstr(vendorStr, MICROSOFT_EP12) && strstr(vendorStr, MICROSOFT_EP11))
	{
			FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: LyncImm/15.0(Lync on samsung) - remote ident set to FastUpdateEP");
			remoteVendorIdent = MicrosoftEP_Lync_2013;	// fast update request and ignore port 0 on audio when escalating to A+V
	}
	else if(  ( strstr(vendorStr, MICROSOFT_EP13) && strstr(vendorStr, MICROSOFT_EP11)  )  ||( strstr(vendorStr, MICROSOFT_EP14) ) )
	{
			FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: LMR/15 or LyncImm- remote ident set to Lync room system");
			remoteVendorIdent = MicrosoftEP_Lync_2013;	// fast update request and ignore port 0 on audio when escalating to A+V
	}
	else if(strstr(vendorStr, MICROSOFT_EP5) && strstr(vendorStr, MOC_PRODUCT_NAME))
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: MAC - remote ident set to FastUpdateEP");
		remoteVendorIdent = MicrosoftEP_MAC;	// fast update request and ignore port 0 on audio when escalating to A+V
	}
	else if(strstr(vendorStr, MICROSOFT_EP6) && strstr(vendorStr, MOC_PRODUCT_NAME))
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: MAC Lync - remote ident set to FastUpdateEP");
		remoteVendorIdent = MicrosoftEP_MAC_Lync;	// fast update request and ignore port 0 on audio when escalating to A+V
	}
	else if ( strstr(vendorStr, "AV-MCU") )
	{
		remoteVendorIdent = Microsoft_AV_MCU;
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: Microsoft AV-MCU");
		if( strstr(vendorStr, MICROSOFT_AV_MCU_W13) )
		{
			FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: Microsoft AV-MCU - 2013");
			remoteVendorIdent = Microsoft_AV_MCU2013;
		}
	}
	else if ( strstr(vendorStr, MICROSOFT_POLYCOM_COLABORATION_EP1) )
	{
		remoteVendorIdent = MicrosoftwPolycomEP_Colab_EP1;
	}
	else if ( strstr(vendorStr, "Avaya") )
	{
		remoteVendorIdent = AvayaEP;
	}
	else if ( strstr(vendorStr, "Cisco-CUCM") )
	{
		remoteVendorIdent = CiscoCucm;
	}
	else if ( strstr(vendorStr, "Sametime-Softphone-8.5.2") ) //BRIDGE-11137
	{
		FPTRACE(eLevelInfoNormal, "DetermineRemoteVendorByString: IBM Sametime 8.5.2 EP Legacy");
		remoteVendorIdent = IbmSametimeEp_Legacy;
	}
	else if ( strstr(vendorStr, "Sametime-Softphone") )
	{
		FPTRACE(eLevelInfoNormal, "DetermineRemoteVendorByString: IBM Sametime EP");
		remoteVendorIdent = IbmSametimeEp;
	}
	else if ( strstr(vendorStr, "MediationServer") )
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: remote ident set to Microsoft MediationServer ");
		remoteVendorIdent = MicrosoftMediationServer;
	}
	else if (strcasestr(vendorStr, "TANDBERG"))
	{
		FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: remote ident set to TANDBERG ");
		remoteVendorIdent = TandbergEp;
	}
	else if(strstr(vendorStr, "RV"))
	{
	    FPTRACE(eLevelInfoNormal,"DetermineRemoteVendorByString: remote ident set to Radvision ");
	    remoteVendorIdent = RvEp;
	}
	else if(strstr(vendorStr, "MFW-V"))
	{
		const char* versionStr =  strstr(vendorStr, "MFW-V");
		FPTRACE2(eLevelInfoNormal,"DetermineRemoteVendorByString: remote ident set to  MFW Client version ", versionStr);
		if (versionStr && (strcmp(versionStr, "2.8.0.52084") >= 0))
			remoteVendorIdent = IbmSametime9_Q42015_AndLater; //Client which supports video escalation after allocating audio only resources
	}

	*vendor = remoteVendorIdent;
}

//LyncCCS
static void DetermineRemoteVendorByURIString(char *URIStr, RemoteIdent *vendor)
{
	RemoteIdent remoteVendorIdent;
	remoteVendorIdent = Regular;

	char strUser[H243_NAME_LEN] = { 0 };
	char strHost[H243_NAME_LEN] = { 0 };

	SAFE_COPY(strUser, URIStr);
	char* temp = strstr(strUser, ";");
	if (temp)
		strUser[temp-strUser] = '\0';

	temp = strstr(strUser, "@");
	if (temp)
	{
		SAFE_COPY(strHost, &strUser[temp-strUser+1]);
		strUser[temp-strUser] = '\0';
		if(strstr(strUser, "_cssplugin"))
		{
			remoteVendorIdent = MicrosoftEP_Lync_CCS;
		}
	}
	*vendor= remoteVendorIdent;
	return;
}

bool CSipCntl::StoreRemoteVendorInfo()
{

	RemoteIdent userAgentIdent  = Regular,
				sdpSessionIdent = Regular,
				sdpOwnerIdent   = Regular;
				//fromHdrIdent   = Regular;

	CConfIpParameters *pService = ::GetIpServiceListMngr()->FindIpService(m_serviceId);
	BOOL change_audio_list_flag = GetSystemCfgFlagInt<BOOL>(CFG_KEY_SIP_CHANGE_AUDIO_CAPS_LIST_ACCORDING_TO_VENDOR);

	CMedString str;
	bool bIsRemotePolycom  = true;
	char cUserAgent[MaxUserAgentSize] = {0},
		 cSdpOwner[MaxUserAgentSize]  = {0},
		 cSessionName[MaxUserAgentSize] = {0};
		//cFromHdr[MaxLengthOfSingleUrl] = {0};
	int  len;

	sipMessageHeaders *pRemoteSipHeaders = GetRmtHeaders();//GetRemoteCallLegHeaders();

	if (pRemoteSipHeaders)
	{
		::SipGetHeaderValue(pRemoteSipHeaders, kUserAgent, cUserAgent, MaxUserAgentSize);
		::SipGetHeaderValue(pRemoteSipHeaders, kSdpSession_o, cSdpOwner, MaxUserAgentSize);
		::SipGetHeaderValue(pRemoteSipHeaders, kSdpSession_s, cSessionName, MaxUserAgentSize);
		//::SipGetHeaderValue(pRemoteSipHeaders, kFrom, cFromHdr, MaxLengthOfSingleUrl);  // LyncCCS client is identified by From

		if (strlen(cUserAgent) > 0)
		{
			DetermineRemoteVendorByString(cUserAgent, &userAgentIdent);
		}
		if (strlen(cSdpOwner) > 0)
		{
			DetermineRemoteVendorByString(cSdpOwner, &sdpOwnerIdent);
		}
		if (strlen(cSessionName) > 0)
		{
			DetermineRemoteVendorByString(cSessionName, &sdpSessionIdent);
		}
		// identify remote EP type by the username part in From header
		//if ((strlen(cFromHdr) > 0)&&(sdpSessionIdent == Regular))
		//{
		//	DetermineRemoteVendorByURIString(cFromHdr, &fromHdrIdent);
		//}

		str << "userAgent = " <<  cUserAgent << " sdpSession = " <<  cSessionName << " sdpOwner = " << cSdpOwner;
		PTRACE2(eLevelInfoNormal, "CSipCntl::StoreRemoteVendorInfo ", str.GetString());
	}

	/* copy the user-agent header to the m_userAgent */
	len  = strlen(cUserAgent);
	if(m_UserAgent)
	{
		PDELETEA(m_UserAgent);
	}
	m_UserAgent = new char[len+1];
	memset(m_UserAgent, 0, len);
	snprintf(m_UserAgent, len+1, "%s", cUserAgent);

	/**
	 * Determine the remoteIdent incase userAgent identity is not the same sdpSession or sdpOwner properties
	 * The priority is as follows:
	 * 1. SdpOwner
	 * 2. sdpSession
	 * 3. UserAgent
	 */
	//if(fromHdrIdent != Regular) //&&(userAgentIdent==Regular) //LyncCCS
	//From header has highest priority, we need to add condition with UserAgent
	//{
	//	m_remoteIdent = fromHdrIdent;
	//}
	//else 
	if (sdpOwnerIdent != Regular)
	{
		m_remoteIdent = sdpOwnerIdent;
	}
	else if (sdpSessionIdent != Regular)
	{
		m_remoteIdent = sdpSessionIdent;
	}
	else if (userAgentIdent != Regular)
	{
		m_remoteIdent = userAgentIdent;
	}
	else if ((pService != NULL) && ((pService->GetSipServerType() == eSipServer_CiscoCucm) || GetIsTipCall()))
	{
		str.Clear();
		str << "service id: " << m_serviceId << ", service type: " << pService->GetSipServerType() << ", is TIP: " << GetIsTipCall();
		PTRACE2(eLevelInfoNormal, "CSipCntl::StoreRemoteVendorInfo - UserAgent: Cisco-CUCM, ", str.GetString());

		m_remoteIdent = CiscoCucm;
	}
	else
	{
		m_remoteIdent = Regular;
	}

	/* update the chosen local caps according to vendor if system flag is enabled */
	if(change_audio_list_flag)
	{
		bool bIsVendorSupportFullAudioCaps = isVendorSupportFullAudioCaps(cUserAgent);
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::StoreRemoteVendorInfo IsVendorSupportFullAudioCaps=",bIsVendorSupportFullAudioCaps);

		m_pChosenLocalCap  = bIsVendorSupportFullAudioCaps ? m_pFullLocalCaps : m_pPartialLocalCaps;

        if(m_remoteIdent == MicrosoftEP_Lync_R1 || MicrosoftEP_Lync_2013 == m_remoteIdent || Microsoft_AV_MCU2013 == m_remoteIdent)
        {
			CCapSetInfo capInfoG7231 (eG7231CapCode);
			if(m_pChosenLocalCap)
				m_pChosenLocalCap->RemoveCapSet(capInfoG7231);
			if(m_pMaxLocalCaps)
				m_pMaxLocalCaps->RemoveCapSet(capInfoG7231);
			PTRACE(eLevelInfoNormal,"CSipCntl::StoreRemoteVendorInfo for LYNC remove G7231 because this audio codec doesn't work!");
        }
	}

	CCommConf* 	pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	CConfParty* pConfParty = (pCommConf? pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId()): NULL);
	if(pConfParty)
	{
		BYTE protocol = pConfParty->GetVideoProtocol();

//		if ((MicrosoftEP_Lync_2013 == m_remoteIdent || Microsoft_AV_MCU2013 == m_remoteIdent) && m_IsEnableICE &&  isMsftSvc2013Supported() &&
//				(protocol == VIDEO_PROTOCOL_MS_SVC || protocol == AUTO))
//		{
//			PTRACE(eLevelInfoNormal, "CSipCntl::StoreRemoteVendorInfo: Setting MFTS2013 ON ");
//			m_isMs2013Active = TRUE;
//		}
	}

	// for Call Generator - Vendor detection
	if (!strstr(cUserAgent, "Polycom") && !strstr(cUserAgent, "ACCORD"))
	{
		PTRACE2(eLevelInfoNormal, "CSipCntl::StoreRemoteVendorInfo: user agent is call generator? - ", cUserAgent);
		bIsRemotePolycom = false;
	}

	//add this for dial out -TBD-NOA
	/*
	if(m_remoteIdent == MicrosoftEP_Lync_2013 && isMsftSvc2013Supported()) && m_IsEnableICE)
	{
		//if( pService != NULL && pService->GetConfigurationOfSipServers() )//noa tbd readdd the ms env check
		//{
			//if(pService->GetSipServerType() == eSipServer_ms)
			//{
				PTRACE2INT(eLevelInfoNormal, "CSipCntl::StoreRemoteVendorInfo = 2013 clent set to yes for full svc support ", m_remoteIdent);
				m_isMs2013Active = TRUE;
			//}
		//}
	}
	*/

	PTRACE2(eLevelInfoNormal, "CSipCntl::StoreRemoteVendorInfo = ", RemoteIdentToString(m_remoteIdent));

	return bIsRemotePolycom;

}
////////////////////////////////////////////////////////////////////////////////
RemoteIdent CSipCntl::GetFromIdent(const sipSdpAndHeadersSt* pSdpAndHeaders)
{
	RemoteIdent fromHdrIdent   = Regular;
	char cFromHdr[MaxLengthOfSingleUrl] = {0};
	sipMessageHeaders*	tmp_pRmtHeaders = NULL;

	if (pSdpAndHeaders && pSdpAndHeaders->sipHeadersLength)
	{
		BYTE* pStart = (BYTE*) &(pSdpAndHeaders->capsAndHeaders[pSdpAndHeaders->sipHeadersOffset]);
		sipMessageHeaders* pHeaders = (sipMessageHeaders*) pStart;

		int length = pSdpAndHeaders->sipHeadersLength;
		tmp_pRmtHeaders = (sipMessageHeaders *)new BYTE[length];
		memset(tmp_pRmtHeaders, 0, length);
		memcpy(tmp_pRmtHeaders, pStart, length);
	}

	if (tmp_pRmtHeaders)
	{
		::SipGetHeaderValue(tmp_pRmtHeaders, kFrom, cFromHdr, MaxLengthOfSingleUrl);  // LyncCCS client is identified by From

		if (strlen(cFromHdr) > 0)
		{
			DetermineRemoteVendorByURIString(cFromHdr, &fromHdrIdent);
		}

		PDELETEA(tmp_pRmtHeaders);
	}

	return fromHdrIdent;
}
////////////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::SetDialInSessionTimerHeaders(CSipHeaderList& headerList)
{
	char cHeaderValue[256] = {0};
	CSipHeader* pSessionExpireHeader = NULL;
	DWORD RmtSessionTimer = 0;

	DWORD sessionTimer	= GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_SESSION_EXPIRES);
	DWORD MinSeconds 	= GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_MIN_SEC);
	CSmallString strSessionExpire;
	CSmallString strMinSec;
	strSessionExpire << sessionTimer;
	strMinSec << MinSeconds;

	sipMessageHeaders *pRmtHeaders = GetRmtHeaders();
	if(pRmtHeaders)
	{
		CSipHeaderList cRmtHeaders(*pRmtHeaders);
		pSessionExpireHeader	= (CSipHeader*) cRmtHeaders.GetNextHeader(kSessionExpires);
		if ( pSessionExpireHeader )
		{
			strncpy(cHeaderValue, pSessionExpireHeader->GetHeaderStr(), sizeof(cHeaderValue)-1);
			cHeaderValue[sizeof(cHeaderValue)-1] = '\0';
			RmtSessionTimer = atoi(cHeaderValue);
		}
	}

	BYTE bMocSessionTimer = ( (m_remoteIdent == MicrosoftEP_R2) || (m_remoteIdent == MicrosoftEP_Lync_R1) || (m_remoteIdent == MicrosoftEP_Lync_2013) || ( m_remoteIdent == Microsoft_AV_MCU2013) );

	if((sessionTimer > 0 && RmtSessionTimer > 0 && MinSeconds > 0) || bMocSessionTimer)
		{
		if((RmtSessionTimer >= MinSeconds) || bMocSessionTimer)
		{
			if(RmtSessionTimer == 0 && bMocSessionTimer)
			{
				RmtSessionTimer = sessionTimer;
			}
			//200ok and support for Session Timer
			CSmallString strRmtSessionExpire;;
			strRmtSessionExpire << RmtSessionTimer;
			PTRACE(eLevelInfoNormal, "CSipCntl::SetDialInSessionTimerHeaders - Session Timer is used or working with MOC R2");
			headerList.AddHeader(kSessionExpires,	strRmtSessionExpire.GetStringLength(),	strRmtSessionExpire.GetString());
			headerList.AddHeader(kMinSe,			strMinSec.GetStringLength(),			strMinSec.GetString());
		}
		else //if(RmtSessionTimer < MinSeconds)
		{
			//422 remote has to change (make bigger) its session timer
			PTRACE(eLevelInfoNormal, "CSipCntl::SetDialInSessionTimerHeaders - Sending 422 to the remote");
			headerList.AddHeader(kMinSe,			strMinSec.GetStringLength(),		strMinSec.GetString());
			return SipCodesIntervalTooSmall;
		}
	}
	else
	{
		//200ok and no support for Session Timer
		PTRACE(eLevelInfoNormal, "CSipCntl::SetDialInSessionTimerHeaders - No support of session timer");
	}

	return OK_VAL;
}

////////////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::SetDialOutSessionTimerHeaders(CSipHeaderList& headerList, DWORD rmtSessionTimerMinSec)
{
	DWORD sessionTimer	= GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_SESSION_EXPIRES);
	DWORD MinSeconds 	= GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_MIN_SEC);
	CMedString strSessionExpire;
	CMedString strMinSec;
	strMinSec << MinSeconds;
	if(rmtSessionTimerMinSec != 0)
	{// it means the remote has response with 422 to our invite (min seconds of remote session timer is higher than our session timer value)
		strSessionExpire << rmtSessionTimerMinSec;
	}
	else
	{
		strSessionExpire << sessionTimer;
	}

	if(sessionTimer > 0)
	{
		headerList.AddHeader(kSessionExpires,strSessionExpire.GetStringLength(),strSessionExpire.GetString());
		headerList.AddHeader(kMinSe,strMinSec.GetStringLength(),strMinSec.GetString());
	}
	else
		PTRACE(eLevelInfoNormal, "CSipCntl::SetDialOutSessionTimerHeaders - No support of session timer");
	return OK_VAL;
}

////////////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::GetRmtSessionTimerMinSec()
{
	DWORD rmtSessionTimerMinSec = 0;
	char cHeaderValue[256] = {0};
	CSipHeader* pSessionExpireHeader = NULL;

	sipMessageHeaders *pRmtHeaders = GetRmtHeaders();
	if(pRmtHeaders)
	{
		CSipHeaderList cRmtHeaders(*pRmtHeaders);
		pSessionExpireHeader	= (CSipHeader*) cRmtHeaders.GetNextHeader(kMinSe);
		if ( pSessionExpireHeader )
		{
      strncpy(cHeaderValue, pSessionExpireHeader->GetHeaderStr(), sizeof(cHeaderValue)-1);
      cHeaderValue[sizeof(cHeaderValue)-1] = '\0';
			rmtSessionTimerMinSec = atoi(cHeaderValue);
		}
	}
	return rmtSessionTimerMinSec;
}

/////////////////////////////////////////////////////////
sipSdpAndHeadersSt* CSipCntl::GetRemoteSdp(void)
{
	return m_pRemoteSdp;
}
//////////////////////////////////////////////////////////////////
sipMessageHeaders* CSipCntl::GetRemoteCallLegHeaders(void)
{
	BYTE* pStart = NULL;

	if (m_pRemoteSdp && m_pRemoteSdp->sipHeadersLength)
	{
		pStart = (BYTE *)m_pRemoteSdp->capsAndHeaders + m_pRemoteSdp->sipHeadersOffset;
	}

	return (sipMessageHeaders *)pStart;
}

////////////////////////////////////////////////////////////////////
void CSipCntl::CompleteRemoteCapDataFromLocalCap()
{
	if (m_pLastRemoteCaps && m_pChosenLocalCap  && m_pLastRemoteCaps->GetNumOfCapSets() && m_pChosenLocalCap ->GetNumOfCapSets())
	{
		//m_pLastRemoteCaps->CompleteDataFromOtherCap(*m_pChosenLocalCap );
		CompleteDataFromOtherCapUsingUserAgent(m_pLastRemoteCaps);

	}
}


////////////////////////////////////////////////////////////////////
void CSipCntl::SetCallLegAndCdrHeaders(const sipSdpAndHeadersSt & sdpAndHeaders)
{
	if (sdpAndHeaders.sipHeadersLength)
	{
		BYTE* pStart = (BYTE*) &sdpAndHeaders.capsAndHeaders + sdpAndHeaders.sipHeadersOffset;
		sipMessageHeaders* pHeaders = (sipMessageHeaders*) pStart;
		if(m_pCall)
			m_pCall->SetCallLegAndCdrHeaders(*pHeaders);
	}
	else // no headers
		DBGPASSERT(YES);
}

////////////////////////////////////////////////////////////////////
void CSipCntl::SetRemoteHeaders(const sipSdpAndHeadersSt* pSdpAndHeaders)
{
	TRACECOND_AND_RETURN(!m_pCall , "m_pCall is NULL");
	m_pCall->SetRemoteHeaders(pSdpAndHeaders);
}

////////////////////////////////////////////////////
enIpVersion CSipCntl::SetMediaIpAddress(mcXmlTransportAddress &mediaIp, unsigned int &rtcpPort, cmCapDataType mediaType, ERoleLabel eRole, cmCapDirection mediaDirection, BYTE isResultOfIpMediaMismatch)
{
	enIpVersion retIpVer = eIpVersion4;

	mediaIp.transAddr.port = (APIU16) GetPort(mediaType,mediaDirection,eRole);
	TRACEINTO << "port=" << mediaIp.transAddr.port << " mediaType=" << mediaType << " mediaDirection=" << mediaDirection << "eRole=" << eRole;

	if (CProcessBase::GetProcess()->GetProductType()==eProductTypeSoftMCUMfw) {
		if (IsSameTimeEP()) {
			rtcpPort = mediaIp.transAddr.port + 1;
			PTRACE2INT(eLevelInfoNormal,"SetIpAddressToAllMedias:  use rtcp port in sdp for Sametime-Softphone ", rtcpPort);
		}
	}

	// IpV6
	enIpVersion eIpAddrMatch = eIpVersion4;
	if (IsAnatSupported())   //added for ANAT
		eIpAddrMatch = m_AnatSelectedIpVersion;
	else if (isResultOfIpMediaMismatch)
		eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetSipLocalMediaType(),m_UdpAddressesParams.IpType);
	else
		eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);

	mediaIp.transAddr.distribution	= eDistributionUnicast;
	mediaIp.transAddr.transportType	= eTransportTypeUdp;

	retIpVer = SetLocalMediaIp(mediaIp.transAddr.addr, mediaType);
	if (GetIsEnableICE() && m_pIceParams)
	{
		mediaIp.transAddr.ipVersion = retIpVer;
		mediaIp.unionProps.unionType = retIpVer;
		mediaIp.unionProps.unionSize = sizeof(ipAddressIf);
	} else
	{
		mediaIp.transAddr.ipVersion		= eIpAddrMatch;
		//set XML params
		mediaIp.unionProps.unionType = eIpAddrMatch;
		mediaIp.unionProps.unionSize = sizeof(ipAddressIf);
	}

	return retIpVer;
}

////////////////////////////////////////////////////
enIpVersion CSipCntl::SetSessionIpAddress(mcXmlTransportAddress &mediaIp, BYTE isResultOfIpMediaMismatch)
{
	enIpVersion retIpVer = eIpVersion4;

	mediaIp.transAddr.port = 0;

	// IpV6
	enIpVersion eIpAddrMatch = eIpVersion4;
	if (IsAnatSupported())   //added for ANAT
		eIpAddrMatch = m_AnatSelectedIpVersion;
	else if (isResultOfIpMediaMismatch)
		eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetSipLocalMediaType(),m_UdpAddressesParams.IpType);
	else
		eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);

	TRACEINTO << "m_pNetSetup->GetIpVersion(): " << (DWORD)m_pNetSetup->GetIpVersion() << ", m_UdpAddressesParams.IpType : " << (DWORD)m_UdpAddressesParams.IpType
			  << ", ip Version:" << eIpAddrMatch << ", SipLocalMediaType:" << (DWORD)m_pNetSetup->GetSipLocalMediaType()
			  << ", isResultOfIpMediaMismatch:" << isResultOfIpMediaMismatch;

	mediaIp.transAddr.ipVersion		= eIpAddrMatch;
	mediaIp.transAddr.distribution	= eDistributionUnicast;
	mediaIp.transAddr.transportType	= eTransportTypeUdp;

	retIpVer = SetLocalMediaIp(mediaIp.transAddr.addr,cmCapEmpty);

	//set XML params
	mediaIp.unionProps.unionType = eIpAddrMatch;
	mediaIp.unionProps.unionSize = sizeof(ipAddressIf);

	 if (GetIsEnableICE() && m_pIceParams)
	 {
		 mediaIp.transAddr.ipVersion = retIpVer;
		 mediaIp.unionProps.unionType = retIpVer;
	 }

	return retIpVer;
}

////////////////////////////////////////////////////
void CSipCntl::SetIpAddressToAllMedias(sipSdpAndHeadersSt* pSdpAndHeaders, BYTE isResultOfIpMediaMismatch,  BYTE isReinvite)//add a param for ANAT
{
	// set the media IP addresses
//	int audioIndex = GetCardSdpArrayIndex(cmCapAudio);
//	int videoIndex = GetCardSdpArrayIndex(cmCapVideo);
//	int dataIndex  = GetCardSdpArrayIndex(cmCapData);
//	int mediaIndexArray[GetSdpArrayIndex(kSdpLastType)] = {audioIndex, videoIndex, dataIndex};
//	cmCapDataType mediaTypeArray[GetSdpArrayIndex(kSdpLastType)] = {cmCapAudio, cmCapVideo, cmCapData};
//
//	for(int k = 0; k < GetSdpArrayIndex(kSdpLastType); k++)
//		SetMediaIpAddress(ExtractMLineMediaIp(mediaIndexArray[k], pSdpAndHeaders, m_dummyMediaIp), mediaTypeArray[k], cmCapReceive, isResultOfIpMediaMismatch);

	enIpVersion ipVerAudio		= eIpVersion4,
				ipVerVideo		= eIpVersion4,
				ipVerContent	= eIpVersion4,
				ipVerFecc		= eIpVersion4,
				ipVerBfcp		= eIpVersion4;

	mcXmlTransportAddress &rIpAudio = ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());
	mcXmlTransportAddress &rIpVideo = ExtractMLineMediaIp(kMediaLineInternalTypeVideo, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());
	mcXmlTransportAddress &rIpContent = ExtractMLineMediaIp(kMediaLineInternalTypeContent, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());
	mcXmlTransportAddress &rIpFecc = ExtractMLineMediaIp(kMediaLineInternalTypeFecc, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());
	mcXmlTransportAddress &rIpBfcp = ExtractMLineMediaIp(kMediaLineInternalTypeBfcp, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());

	unsigned int &rRtcpPortAudio = ExtractMLineRtcpPort(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyRtcpPort, m_pParty->GetTargetMode()->GetIsEncrypted());
	unsigned int &rRtcpPortVideo = ExtractMLineRtcpPort(kMediaLineInternalTypeVideo, pSdpAndHeaders, m_dummyRtcpPort, m_pParty->GetTargetMode()->GetIsEncrypted());
	unsigned int &rRtcpPortContent = ExtractMLineRtcpPort(kMediaLineInternalTypeContent, pSdpAndHeaders, m_dummyRtcpPort, m_pParty->GetTargetMode()->GetIsEncrypted());
	unsigned int &rRtcpPortFecc = ExtractMLineRtcpPort(kMediaLineInternalTypeFecc, pSdpAndHeaders, m_dummyRtcpPort, m_pParty->GetTargetMode()->GetIsEncrypted());
	unsigned int &rRtcpPortBfcp = ExtractMLineRtcpPort(kMediaLineInternalTypeBfcp, pSdpAndHeaders, m_dummyRtcpPort, m_pParty->GetTargetMode()->GetIsEncrypted());

	ipVerAudio   = SetMediaIpAddress(rIpAudio, rRtcpPortAudio, cmCapAudio, kRolePeople, cmCapReceive, isResultOfIpMediaMismatch);
	ipVerVideo   = SetMediaIpAddress(rIpVideo, rRtcpPortVideo, cmCapVideo, kRolePeople, cmCapReceive, isResultOfIpMediaMismatch);
	ipVerContent = SetMediaIpAddress(rIpContent, rRtcpPortContent, cmCapVideo, kRolePresentation, cmCapReceive, isResultOfIpMediaMismatch);
	ipVerFecc    = SetMediaIpAddress(rIpFecc, rRtcpPortFecc, cmCapData, kRolePeople, cmCapReceive, isResultOfIpMediaMismatch);
	ipVerBfcp    = SetMediaIpAddress(rIpBfcp, rRtcpPortBfcp, cmCapBfcp, kRolePeople, cmCapReceive, isResultOfIpMediaMismatch);

	TRACEINTOFUNC
			<< "\nipVerAudio:   " << ( (eIpVersion6 == ipVerAudio)   ? "IPv6" : "IPv4")
			<< "\nipVerVideo:   " << ( (eIpVersion6 == ipVerVideo)   ? "IPv6" : "IPv4")
			<< "\nipVerContent: " << ( (eIpVersion6 == ipVerContent) ? "IPv6" : "IPv4")
			<< "\nipVerFecc:    " << ( (eIpVersion6 == ipVerFecc)    ? "IPv6" : "IPv4")
			<< "\nipVerBfcp:    " << ( (eIpVersion6 == ipVerBfcp)    ? "IPv6" : "IPv4");

	//added for ANAT
	if (IsAnatSupported() && (m_pCall->IsCallInitiator()|| isReinvite)) //dial out or reinvite with content for dial in
	{
		int	index = -1;
		eMediaLineInternalType mlineInternalType =kMediaLineInternalTypeNone;
		sipMediaLineSt *pMediaLine = NULL;
		enIpVersion eIpAddrMatch = ((m_AnatSelectedIpVersion == eIpVersion4) ? eIpVersion6 : eIpVersion4);

		for(int i = (int)kMediaLineInternalTypeAudio; i < (int) kMediaLineInternalTypeNotSupported; i++)
		{
			mlineInternalType = (eMediaLineInternalType)i;
			pMediaLine = GetMediaLine(*pSdpAndHeaders, mlineInternalType, 1); //get second m line based on internalType

			if (pMediaLine)
			{
				//PTRACE2INT(eLevelInfoNormal, "CSipCntl::SetIpAddressToAllMedias -Set Media IP Address to second type = ", mlineInternalType);
				cmCapDataType mediaType;
				ERoleLabel eRole;

				GetMediaDataTypeAndRole(mlineInternalType, mediaType, eRole);

				if (isReinvite)
					pMediaLine->mediaIp.transAddr.port = 0;
				else
					pMediaLine->mediaIp.transAddr.port = (APIU16) GetPort(mediaType,cmCapReceive,eRole);

				pMediaLine->mediaIp.transAddr.ipVersion		= eIpAddrMatch;
				pMediaLine->mediaIp.transAddr.distribution	= eDistributionUnicast;
				pMediaLine->mediaIp.transAddr.transportType	= eTransportTypeUdp;

				ipAddressIf* pIpAddress = &(pMediaLine->mediaIp.transAddr.addr);
				if(eIpAddrMatch == eIpVersion6)
				{
					// --- UDP: array of addresses ---
					// First we will look for the best IpV6 address match -> Meaning we will match ScopeId's
					BYTE place = FindMatchingIpV6MediaAddressByScopeId();
					memcpy(pIpAddress->v6.ip, &m_UdpAddressesParams.IpV6AddrArray[place].ip, 16);
					pIpAddress->v6.scopeId = m_UdpAddressesParams.IpV6AddrArray[place].scopeId;

				}
				else
				{
					pIpAddress->v4.ip = m_UdpAddressesParams.IpV4Addr.ip;
				}

				//set XML params
				pMediaLine->mediaIp.unionProps.unionType = eIpAddrMatch;
				pMediaLine->mediaIp.unionProps.unionSize = sizeof(ipAddressIf);
			}
		}

	}

	// added for Lync 2013 AVMCU - mute from AVMCU
	if(m_isMs2013Active == eMsft2013AvMCU && m_pParty && m_pParty->GetActiveTransactionType() == kSipTransReInviteWithSdpInd)
	{
		mcXmlTransportAddress mainMediaIp = rIpVideo;
		//memset(&mainMediaIp, 0, sizeof(mcXmlTransportAddress));

		sipMediaLineSt *pMediaLine = NULL;
		unsigned int mediaLinePos = 0;
		int curIndex = 0;
		sipMediaLinesEntrySt* pMediaLinesEntry = (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders;
		unsigned int numOfMlines = pMediaLinesEntry->numberOfMediaLines;

		DWORD videoLineNum = 0;
		BYTE firstVideoLine = TRUE;

		for (unsigned int mlineIndex = 0; mlineIndex < numOfMlines; mlineIndex++)
		{
			TRACEINTO << "mlineIndex:" << mlineIndex;
			pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
			mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;
			eMediaLineType mediaLineType = (eMediaLineType)pMediaLine->type;

			if (mediaLineType == eMediaLineTypeVideo && pMediaLine->internalType == kMediaLineInternalTypeVideo )
			{
				TRACEINTO << "mlineIndex:" << mlineIndex;
				if(!firstVideoLine)
				{
					TRACEINTO << "mlineIndex:" << mlineIndex;
					// set mediaIP
					memcpy(&(pMediaLine->mediaIp), &mainMediaIp, sizeof(mcXmlTransportAddress));
				} else
					firstVideoLine = FALSE;
			}
		}

	}
}

////////////////////////////////////////////////////
// Adds the closed medias (like in secondary video) to the sdp
void CSipCntl::AddClosedMediaCapsToSdp(sipSdpAndHeadersSt* pSdpAndHeaders,int capabilitiesSize,int &exactCapsSize)
{
    //CLargeString str;
    //m_pChosenLocalCap->DumpToString(str);
    //PTRACE2(eLevelInfoNormal,"CSipCntl::AddClosedMediaCapsToSdp m_pChosenLocalCap: ",str.GetString());

	cmCapDirection eDirection=cmCapReceive;

	TRACECOND_AND_RETURN(!m_pCall , "m_pCall is NULL");
	CSipChannel* pAudioChannel = m_pCall->GetChannel(true, cmCapAudio, eDirection);
	CSipChannel* pVideoChannel = m_pCall->GetChannel(true, cmCapVideo, eDirection);
	CSipChannel* pDataChannel = m_pCall->GetChannel(true, cmCapData, eDirection);
	CSipChannel* pContentChannel = m_pCall->GetChannel(true, cmCapVideo, eDirection, kRolePresentation);
	CSipChannel* pBfcpChannel = m_pCall->GetChannel(true, cmCapBfcp, eDirection);

	eMediaLineSubType bfcpType = GetBfcpType();

	CCommConf* pComConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());


	//Check if local caps contain Audio while audio channels closed
	if(m_pChosenLocalCap ->IsMedia(cmCapAudio) && (!pAudioChannel))
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::AddClosedMediaCapsToSdp -No Audio channel open - add audio");
		exactCapsSize = m_pChosenLocalCap ->AddCapsToCapStruct(cmCapReceiveAndTransmit, NO, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
														capabilitiesSize,bfcpType,YES,NO,NO,NO,NO);
	}

	//Check if local caps contain Video while Video channels closed
	if(m_pChosenLocalCap ->IsMedia(cmCapVideo) && (!pVideoChannel))
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::AddClosedMediaCapsToSdp -No Video channel open - add video");
		exactCapsSize = m_pChosenLocalCap ->AddCapsToCapStruct(cmCapReceiveAndTransmit, NO, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
															capabilitiesSize,bfcpType, NO,YES,NO,NO,NO);
	}

	//Check if local caps contain Data while data channels closed
	if(m_pChosenLocalCap ->IsMedia(cmCapData) && (!pDataChannel))
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::AddClosedMediaCapsToSdp -No Data channel open - add data");
		exactCapsSize = m_pChosenLocalCap ->AddCapsToCapStruct(cmCapReceiveAndTransmit, NO, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
														capabilitiesSize,bfcpType, NO,NO,YES,NO,NO);
	}


	//Check if local caps contain Content while content channels closed
	if(m_pChosenLocalCap->IsMedia(cmCapVideo,cmCapReceiveAndTransmit,kRolePresentation) && (!pContentChannel) && pBfcpChannel && (m_pLastRemoteCaps->IsBfcpSupported())) //if remote does not have content - do not add content
	{

		if(pComConf && pComConf->GetIsAsSipContent() && !m_isASSIPContentEnable)
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::AddClosedMediaCapsToSdp -No Content channel open - AS-SIP conf, content disabled - Don't add content caps");
		}
		else
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::AddClosedMediaCapsToSdp -No Content channel open - add content");
			exactCapsSize = m_pChosenLocalCap->AddCapsToCapStruct(cmCapReceiveAndTransmit, NO, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																capabilitiesSize,bfcpType, NO,NO,NO,YES,NO);
		}

	}

	//Check if local caps contain Content while content channels closed
	if(m_pChosenLocalCap->IsMedia(cmCapBfcp,cmCapReceiveAndTransmit) && (!pBfcpChannel) && (m_pLastRemoteCaps->IsBfcpSupported())) //if remote does not have content - do not add content
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::AddClosedMediaCapsToSdp -No bfcp channel open - add bfcp");
		exactCapsSize = m_pChosenLocalCap->AddCapsToCapStruct(cmCapReceiveAndTransmit, NO, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
														capabilitiesSize,bfcpType, NO,NO,NO,NO,YES);
	}
}

////////////////////////////////////////////////////
// Set port 0 to the closed medias (like in secondary video)
void CSipCntl::SetPortZeroForClosedMedias(sipSdpAndHeadersSt* pSdpAndHeaders)
{
	cmCapDirection eDirection=cmCapReceive;

	TRACECOND_AND_RETURN(!m_pCall , "m_pCall is NULL");
	CSipChannel* pAudioChannel = m_pCall->GetChannel(true, cmCapAudio, eDirection);
	CSipChannel* pVideoChannel = m_pCall->GetChannel(true, cmCapVideo, eDirection);
	CSipChannel* pDataChannel = m_pCall->GetChannel(true, cmCapData, eDirection);
	CSipChannel* pContentChannel = m_pCall->GetChannel(true, cmCapVideo, eDirection, kRolePresentation);
	CSipChannel* pBfcpChannel = m_pCall->GetChannel(true, cmCapBfcp, eDirection);

	//Check if local caps contain Audio while audio channels closed
	if(m_pChosenLocalCap ->IsMedia(cmCapAudio) && (!pAudioChannel))
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::SetPortZeroForClosedMedias -No Audio channel open - set port 0");
		ExtractMLineMediaIp(kMediaLineInternalTypeAudio, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
	}

	//Check if local caps contain Video while Video channels closed
	if(m_pChosenLocalCap ->IsMedia(cmCapVideo) && (!pVideoChannel))
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::SetPortZeroForClosedMedias -No Video channel open - set port 0");
		ExtractMLineMediaIp(kMediaLineInternalTypeVideo, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
	}

	//Check if local caps contain Data while data channels closed
	if(m_pChosenLocalCap ->IsMedia(cmCapData) && (!pDataChannel))
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::SetPortZeroForClosedMedias -No Data channel open - set port 0");
		ExtractMLineMediaIp(kMediaLineInternalTypeFecc, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
	}

	//Check if local caps contain Content while Content channels closed
	if(m_pChosenLocalCap->IsMedia(cmCapVideo,cmCapReceiveAndTransmit,kRolePresentation) && (!pContentChannel))
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::SetPortZeroForClosedMedias -No Content channel open - set port 0");
		ExtractMLineMediaIp(kMediaLineInternalTypeContent, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
	}

	//Check if local caps contain Bfcp while there is no video channel (secondary) //LyncCCS
	if(m_pChosenLocalCap->IsBfcpSupported() && (!pBfcpChannel || !pVideoChannel) && (!m_bIsCCSPlugin))
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::SetPortZeroForClosedMedias - No video. set bfcp port 0");
		ExtractMLineMediaIp(kMediaLineInternalTypeBfcp, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
	}

	//added for ANAT
	if (IsAnatSupported())
	{
		sipMediaLineSt *pMediaLine = NULL;
		eMediaLineInternalType mlineInternalType =kMediaLineInternalTypeNone;
		cmCapDataType mediaType;
		ERoleLabel eRole;

		for(int i = (int)kMediaLineInternalTypeAudio; i < (int) kMediaLineInternalTypeNotSupported; i++)
		{
			mlineInternalType = (eMediaLineInternalType)i;
			GetMediaDataTypeAndRole(mlineInternalType, mediaType, eRole);

			if(m_pChosenLocalCap ->IsMedia(mediaType) && m_pCall->GetChannel(true, mediaType, eDirection, eRole) == NULL)
			{
				pMediaLine = GetMediaLine(*pSdpAndHeaders, mlineInternalType, 1); //get second m line based on internalType

				if (pMediaLine)
				{
					//PTRACE2INT(eLevelInfoNormal, "CSipCntl::SetPortZeroForClosedMedias -Set port zero to second type = ", mlineInternalType);
					pMediaLine->mediaIp.transAddr.port = 0;
				}
			}
		}
	}
}

enIpVersion CSipCntl::SetMediaIPFromIceParams(union ipAddressIf &sIpAddress,cmCapDataType mediaType, ERoleLabel eRole)
{
	enIpVersion retIpVer = eIpVersion4;
	mcTransportAddress *ipFromIceStack = NULL;

	ICESessionsTypes sessionType = eGeneralSession;

	if(mediaType == cmCapAudio)
		sessionType = eAudioSession;
	else if((mediaType == cmCapVideo) && (eRole == kRolePeople))
		sessionType = eVideoSession;
	else if(mediaType == cmCapData)
		sessionType = eDataSession;
	else if(mediaType == cmCapEmpty)
		sessionType = eGeneralSession;

	ipFromIceStack = m_pIceParams->GetIceMediaIp(sessionType);
	if(ipFromIceStack)
	{
		if(m_pIceParams->GetIceMediaIp(sessionType)->ipVersion == eIpVersion6)
		{

			// bridge-15743 - dial out to federated clients in IPV6 disconnects after 50 seconds
			CSmallString* pStr = new CSmallString();
			::DumpMediaIp(pStr,*ipFromIceStack);
			TRACEINTO << "IPV6 from Ice params: " << pStr->GetString();
			POBJDELETE(pStr);

			memcpy(&sIpAddress.v6.ip, &(ipFromIceStack->addr.v6.ip), IPV6_ADDRESS_BYTES_LEN);
			sIpAddress.v6.scopeId = ipFromIceStack->addr.v6.scopeId;

//			old code before bridge-15743 fix
//			BYTE place = FindMatchingIpV6MediaAddressByScopeId();
//			memcpy(&sIpAddress.v6.ip, &m_UdpAddressesParams.IpV6AddrArray[place].ip, IPV6_ADDRESS_BYTES_LEN);
//			sIpAddress.v6.scopeId = m_UdpAddressesParams.IpV6AddrArray[place].scopeId;

			retIpVer = eIpVersion6;
		}
		//sIpAddress.v4.ip = 0xC0A80605; //192.168.6.5
		else
		{
			TRACEINTO << "IP VERSION m_pIceParams->GetIceMediaIp(eGeneralSession)->ipVersion : IPV4";
			sIpAddress.v4.ip = ipFromIceStack->addr.v4.ip;
			retIpVer = eIpVersion4;
		}
	}


	return retIpVer;
}
////////////////////////////////////////////////////
enIpVersion CSipCntl::SetLocalMediaIp(union ipAddressIf &sIpAddress,cmCapDataType mediaType, ERoleLabel eRole)
{
	enIpVersion retIpVer = eIpVersion4;

    if (GetIsEnableICE() && m_pIceParams)
    {
    	retIpVer = SetMediaIPFromIceParams( sIpAddress, mediaType, eRole);
    	TRACEINTO << "DBG retIpVer(0=v4, 1=v6):" << retIpVer;
    	/*
    	mcTransportAddress *ipFromIceStack = NULL;

    	if(mediaType == cmCapAudio)
    		ipFromIceStack = m_pIceParams->GetIceMediaIp(eAudioSession);
    	else if((mediaType == cmCapVideo) && (eRole == kRolePeople))
				ipFromIceStack = m_pIceParams->GetIceMediaIp(eVideoSession);
		else if(mediaType == cmCapData)
				ipFromIceStack = m_pIceParams->GetIceMediaIp(eDataSession);
		else if(mediaType == cmCapEmpty)
			    ipFromIceStack = m_pIceParams->GetIceMediaIp(eGeneralSession);

    	if(ipFromIceStack && m_pIceParams->GetIceMediaIp(eGeneralSession)->ipVersion == eIpVersion6 )
    	{
    		TRACEINTO << "IP VERSION m_pIceParams->GetIceMediaIp(eGeneralSession)->ipVersion : IPV6";
    		BYTE place = FindMatchingIpV6MediaAddressByScopeId();
			memcpy(&sIpAddress.v6.ip, &m_UdpAddressesParams.IpV6AddrArray[place].ip, IPV6_ADDRESS_BYTES_LEN);
			sIpAddress.v6.scopeId = m_UdpAddressesParams.IpV6AddrArray[place].scopeId;

			retIpVer = eIpVersion6;
    	}


        //sIpAddress.v4.ip = 0xC0A80605; //192.168.6.5
    	else if(ipFromIceStack)
    	{
    		TRACEINTO << "IP VERSION m_pIceParams->GetIceMediaIp(eGeneralSession)->ipVersion : IPV4";
    		sIpAddress.v4.ip = ipFromIceStack->addr.v4.ip;
    	}*/
    }
    else
    {
		// IpV6
		enIpVersion eIpAddrMatch = eIpVersion4;
		if (IsAnatSupported())   //added for ANAT
			eIpAddrMatch = m_AnatSelectedIpVersion;
		else
			eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);
		retIpVer = eIpAddrMatch;

		if(eIpAddrMatch == eIpVersion6)
		{
			// --- UDP: array of addresses ---
			// First we will look for the best IpV6 address match -> Meaning we will match ScopeId's
			BYTE place = FindMatchingIpV6MediaAddressByScopeId();
			memcpy(&sIpAddress.v6.ip, &m_UdpAddressesParams.IpV6AddrArray[place].ip, 16);
			sIpAddress.v6.scopeId = m_UdpAddressesParams.IpV6AddrArray[place].scopeId;
		}
		else
		{
			sIpAddress.v4.ip = m_UdpAddressesParams.IpV4Addr.ip;
		}
    }

    return retIpVer;
}

////////////////////////////////////////////////////
DWORD CSipCntl::GetLocalMediaIp() const
{
	DWORD localIp  = 0;
	// IpV6
	enIpVersion eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);

	if(eIpAddrMatch == eIpVersion6)
	{
		// --- UDP: array of addresses ---
		/*
		localIp = (DWORD)m_UdpAddressesParams.IpV6Addr.ip;
		*/
	}
	else
	{
		localIp = m_UdpAddressesParams.IpV4Addr.ip;
	}

	return	localIp;
}
///////////////////////////////////////////////////////
UdpAddresses CSipCntl::GetUdpAddress()
{
	return m_UdpAddressesParams;
}
////////////////////////////////////////////////////
void CSipCntl::GetLocalMediaIpAsTrAddr(mcTransportAddress& localIp)
{
	enIpVersion eIpAddrMatch = eIpVersion4;

	if (IsAnatSupported())   //added for ANAT
		eIpAddrMatch = m_AnatSelectedIpVersion;
	else
		eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);

	if (eIpAddrMatch == eIpVersion4)
	{
		localIp.addr.v4.ip = m_UdpAddressesParams.IpV4Addr.ip;
	}
	else
	{
		// --- UDP: array of addresses ---
		// First we will look for the best IpV6 address match -> Meaning we will match ScopeId's
		BYTE place = FindMatchingIpV6MediaAddressByScopeId();
		CLargeString *pStr = new CLargeString;

			*pStr << "GetLocalMediaIpAsTrAddr  IP v4	  			 = " << CIPV4Wrapper(m_UdpAddressesParams.IpV4Addr)  <<'\n'
			<< "IP v6 		 		 = " << CIPV6AraryWrapper(m_UdpAddressesParams.IpV6AddrArray)  <<'\n';
			PTRACE(eLevelInfoNormal, pStr->GetString());
			POBJDELETE(pStr);

		localIp.ipVersion = eIpVersion6;
		memcpy(localIp.addr.v6.ip, m_UdpAddressesParams.IpV6AddrArray[place].ip, 16);
		localIp.addr.v6.scopeId = m_UdpAddressesParams.IpV6AddrArray[place].scopeId;
	}
}

////////////////////////////////////////////////////
BOOL CSipCntl::IsRemoteMediaIpZero(cmCapDataType eMediaType, ERoleLabel eRole)   //notice: it is only suitable for IPV4, not correct for IPV6
{
	BOOL isIpZero = FALSE;

	if (m_pRemoteSdp)
	{
		eMediaLineInternalType mlineInternalType = GetMediaLineInternalType(eMediaType, eRole);
		mcXmlTransportAddress dummyMediaIp;

		//added for ANAT
		int	index = -1;
		if (IsAnatSupported())
		{
			index = GetIndexAccordingToInternalTypeAndIpVersion(mlineInternalType, m_pRemoteSdp, m_AnatSelectedIpVersion);
		}

		mcXmlTransportAddress &mediaIp = ExtractMLineMediaIp(mlineInternalType, m_pRemoteSdp, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted(), index);
		if (mediaIp.transAddr.ipVersion == eIpVersion4) //v4
		{
			if (mediaIp.transAddr.addr.v4.ip == 0)
				isIpZero = TRUE;
		}
		else
		{
			APIU8	nullIP[16] 	= {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
											  	   0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};

			if (memcmp(mediaIp.transAddr.addr.v6.ip, nullIP, IPV6_ADDRESS_BYTES_LEN) == 0)
				isIpZero = TRUE;
		}

	}
	else
		isIpZero = TRUE;

	return	isIpZero;
//	return	remoteIp;
}

////////////////////////////////////////////////////
void CSipCntl::GetRemoteMediaIpAsTrAddr(cmCapDataType eMediaType, ERoleLabel eRole, mcTransportAddress& remoteIp)
{
		if (m_pRemoteSdp)
		{
			eMediaLineInternalType mlineInternalType = GetMediaLineInternalType(eMediaType, eRole);

			//added for ANAT
			int	index = -1;

			if (IsAnatSupported())
			{
			index = GetIndexAccordingToInternalTypeAndIpVersion(mlineInternalType,
				m_pRemoteSdp, m_AnatSelectedIpVersion);
		}

		mcXmlTransportAddress &mediaIp = ExtractMLineMediaIp(mlineInternalType,
			m_pRemoteSdp, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted(), index);

			if (mediaIp.transAddr.ipVersion == eIpVersion4) //v4
				remoteIp.addr.v4.ip = mediaIp.transAddr.addr.v4.ip;
			else
			{
				remoteIp.ipVersion = eIpVersion6;
				memcpy(remoteIp.addr.v6.ip, mediaIp.transAddr.addr.v6.ip, 16);
				remoteIp.addr.v6.scopeId = mediaIp.transAddr.addr.v6.scopeId;
			}
		}
		else
			memset (&remoteIp,0,sizeof(mcTransportAddress));
}

/////////////////////////////////////////////////////////////////////////////////////////////
BOOL CSipCntl::IsRemoteSavp() const
{
	BOOL bIsRemoteSavp = FALSE;

	sipMediaLinesEntrySt *pMediaLinesEntry = NULL;
	sipMediaLineSt *pMediaLine = NULL;
	unsigned int mediaLinePos = 0;

	if (m_pRemoteSdp && m_pRemoteSdp->sipMediaLinesLength)
	{
		pMediaLinesEntry = (sipMediaLinesEntrySt *)&m_pRemoteSdp->capsAndHeaders[m_pRemoteSdp->sipMediaLinesOffset];
	}

	if(pMediaLinesEntry)
	{
		for (unsigned int i = 0; i < pMediaLinesEntry->numberOfMediaLines; i++)
		{
			pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];

			if(!pMediaLine)
				break;

			mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;

			if (kMediaLineInternalTypeAudio == pMediaLine->internalType)
				bIsRemoteSavp = (pMediaLine->subType == eMediaLineSubTypeRtpSavp)?TRUE:FALSE;
		}
	}

	return	bIsRemoteSavp;
}
DWORD CSipCntl::GetRemoteMediaPort(cmCapDataType eMediaType, ERoleLabel eRole) const
{
	DWORD remotePort = 0;
	eMediaLineInternalType mlineInternalType = GetMediaLineInternalType(eMediaType, eRole);
	mcXmlTransportAddress dummyMediaIp;

	//added for ANAT
	int	index = -1;
	if (m_AnatSelectedIpVersion != enIpVersionMAX)
	{
		index = GetIndexAccordingToInternalTypeAndIpVersion(mlineInternalType, m_pRemoteSdp, m_AnatSelectedIpVersion);
	}

	remotePort  = m_pRemoteSdp ? ExtractMLineMediaIp(mlineInternalType, m_pRemoteSdp, dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted(), index).transAddr.port : 0;
	return	remotePort;
//	if ((eMediaType > 0) && (eMediaType <= MAX_SIP_MEDIA_TYPES))
//	{
//		int index	= GetCardSdpArrayIndex(eMediaType);
//		mcXmlTransportAddress dummyMediaIp;
//		remotePort  = m_pRemoteSdp ? ExtractMLineMediaIp(index, m_pRemoteSdp, dummyMediaIp).transAddr.port : 0;
//	}
//
//	return	remotePort;
}

//////////////////////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::GetRemoteMediaRtcpPort(cmCapDataType eMediaType, ERoleLabel eRole) const
{
	DWORD remoteRtcpPort = 0;
	eMediaLineInternalType mlineInternalType = GetMediaLineInternalType(eMediaType, eRole);
	unsigned int dummyRtcpPort;

	//added for ANAT
	int	index = -1;
	if (m_AnatSelectedIpVersion != enIpVersionMAX)
	{
		index = GetIndexAccordingToInternalTypeAndIpVersion(mlineInternalType, m_pRemoteSdp, m_AnatSelectedIpVersion);
	}

	remoteRtcpPort  = m_pRemoteSdp ? ExtractMLineRtcpPort(mlineInternalType, m_pRemoteSdp, dummyRtcpPort, m_pParty->GetTargetMode()->GetIsEncrypted(), index) : 0;
	return	remoteRtcpPort;

//	DWORD remoteRtcpPort = 0;
//
//	if ((eMediaType > 0) && (eMediaType <= MAX_SIP_MEDIA_TYPES))
//	{
//		int index	= GetCardSdpArrayIndex(eMediaType);
//		unsigned int dummyRtcpPort;
//		remoteRtcpPort  = m_pRemoteSdp ? ExtractMLineRtcpPort(index, m_pRemoteSdp, dummyRtcpPort) : 0;
//	}
//
//	return	remoteRtcpPort;
}

//////////////////////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::GetPort(cmCapDataType eMediaType,cmCapDirection eDirection, ERoleLabel eRole) const
{
	DWORD port = 0;

	if (eDirection == cmCapTransmit)
	{
		CSipChannel* pChannel = (m_pCall) ? m_pCall->GetChannel(true, eMediaType, eDirection, eRole) : NULL;
		if (pChannel)
		{
			mcTransportAddress address = pChannel->GetAddress();
			port = address.port;
		}
	}
	else
	{
        if(GetIsEnableICE() && m_pIceParams)
			{
                switch (eMediaType)
                {
                    case cmCapAudio:
                        port = m_pIceParams->GetAudioRtpPort();
                        break;
                    case cmCapVideo:
				if (eRole == kRolePeople)
                        port = m_pIceParams->GetVideoRtpPort();
				else
					port  = 0;
                        break;
                    case cmCapData:
                        port = m_pIceParams->GetDataRtpPort();
                        break;
                     default:
                    	 TRACEINTOFUNC << "Set default port 0 for media="<<eMediaType;
                         port  = 0;
                }
			}
        else
        {

            switch (eMediaType)
            {
                case cmCapAudio:
				port  = m_UdpAddressesParams.AudioChannelPort;
				break;
			case cmCapVideo:
				if (eRole == kRolePeople)
					port  = m_UdpAddressesParams.VideoChannelPort;
				else
					port  = m_UdpAddressesParams.ContentChannelPort;
				break;
			case cmCapData:
				port  = m_UdpAddressesParams.FeccChannelPort;
				break;
			case cmCapBfcp:
				if(m_pSipBfcpCtrl && (m_pSipBfcpCtrl->GetBfcpConnMode()== eTcpPassive))
				{
					//=====================
					// IpV6 determination
					//=====================
					if (eIpVersion6 == GetIpAddrMatch())
					{
						port = BFCP_IPV6_TCP_PORT;
					}
					else
					{
						port = BFCP_IPV4_TCP_PORT;
					}
				}
				else
					port  = m_UdpAddressesParams.BfcpChannelPort;
				break;
			default:
				TRACEINTOFUNC << "Set default port 0 for media="<<eMediaType;
				port  = 0;
            }
		}
	}

	return port;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
APIU8 CSipCntl::GetChannelPayloadType(cmCapDataType eMediaType,cmCapDirection eDirection, ERoleLabel eRole) const
{
	APIU8 payload = _UnKnown;
	CSipChannel* pChannel = (m_pCall) ? m_pCall->GetChannel(true, eMediaType, eDirection, eRole) : NULL;

	if (pChannel)
	{
		payload = pChannel->GetPayloadType();
	}

	return payload;
}


/////////////////////////////////////////////////
BYTE CSipCntl::IsInviteInitiator() const
{
	TRACECOND_AND_RETURN_VALUE(!m_pCall , "m_pCall is NULL", NO);
	BYTE bIsCallInitiator		= m_pCall->IsCallInitiator(); //dial out
	BYTE bIsReInviteInitiator	= m_pCall->IsReInviteInitiator();
	BYTE bRes = ((m_bIsReInviteTransaction==NO && bIsCallInitiator)|| bIsReInviteInitiator);
	return bRes;
}


/////////////////////////////////////////////////////////////////////////////
// Check is P-Asserted-Identity header exist and user=phone
// bIsMcuInitiateTransactionq - For Invite request or Re-Invite request we check the 'To' header.
// bIsMcuInitiateTransactionq - For Invite_response indication or Re-Invite_Indication we check the 'From' header.
// In the future we need to take each transaction headers
BYTE CSipCntl::CheckIsMobilePhoneByHeader(BYTE bIsMcuInitiateTransactionq)
{
	if (!m_pCall)
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::CheckIsMobilePhoneByHeader - m_pCall is NULL!");
		return FALSE;
	}

	std::string strMobilePhoneIdentifier = GetSystemCfgFlagStr<std::string>(CFG_KEY_IP_MOBILE_IDENTIFIER);
	if (strMobilePhoneIdentifier.length() == 0)
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::CheckIsMobilePhoneByHeader - Identifier length is zero!");
		return FALSE;
	}

	CMedString str;

	CSipHeaderList*	   pTemp		      = m_pCall->GetCallLegHeaders();
	const CSipHeader*  pCurrentHeader	  = NULL;
	BYTE rval = FALSE;

	if (bIsMcuInitiateTransactionq)	//dial out - check To header
	{
		str << "RMX initiate transaction, check TO header\n\t, ";
		pCurrentHeader = pTemp->GetNextHeader(kTo);
	}
	else							//dial in - check From header
	{
		str << "Remote initiate transaction, check FROM header\n\t, ";
		pCurrentHeader	= pTemp->GetNextHeader(kFrom);
	}

	if (!pCurrentHeader)
	{
		str << "Header is NULL!";
	}
	else
	{
		if (strstr(pCurrentHeader->GetHeaderStr(), strMobilePhoneIdentifier.c_str()) != NULL)
		{
			str << "Mobile phone is recognized, ";
			rval = TRUE;
		}
		else
			str << "Mobile phone is not recognized, ";

		str << "strHeaderContents = " << pCurrentHeader->GetHeaderStr();
		str << ", strIdentifier = " << strMobilePhoneIdentifier.c_str();
	}

	PTRACE2(eLevelInfoNormal, "CSipCntl::CheckIsMobilePhoneByHeader - ", str.GetString());
	return rval;
}

///////////////////////////////////////////////
void CSipCntl::SetCallDisconnecting()
{
	TRACECOND_AND_RETURN(!m_pCall , "m_pCall is NULL");

	DisconnectWebRtcCntl();

	m_state = IP_DISCONNECTING;
	m_pCall->SetConnectionState(kDisconnecting);

//	if (m_pLoadMngrConnector->GetCallConnectReqId())
// 		m_pLoadMngrConnector->CallConnectExitCriticalSection();

	if (IsValidTimer(PARTYCONNECTTOUT))
		DeleteTimer(PARTYCONNECTTOUT);
}


//////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetCallDisconnectedAndRemoveFromRsrcTbl()
{
	TRACECOND_AND_RETURN(!m_pCall , "m_pCall is NULL");

	DisconnectWebRtcCntl();

	m_state = IP_DISCONNECTED;
	m_pCall->SetConnectionState(kDisconnected);
	RemoveFromRsrcTbl();
	if (IsValidTimer(PARTYCSKEEPALIVEFIRSTTOUT))
		DeleteTimer(PARTYCSKEEPALIVEFIRSTTOUT);
	if (IsValidTimer(PARTYCSKEEPALIVESECONDTOUT))
		DeleteTimer(PARTYCSKEEPALIVESECONDTOUT);
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetConnectionId(DWORD connId)
{
	POBJDELETE(m_pCsRsrcDesc);
	m_pCsRsrcDesc = new CRsrcParams(connId,	connId,
									DUMMY_CONF_ID, eLogical_ip_signaling);
	m_pCsInterface->Create(m_pCsRsrcDesc);

	CConfPartyRoutingTable* pRoutingTbl = ::GetpConfPartyRoutingTable();
	if ( pRoutingTbl== NULL )
	{
		PASSERT_AND_RETURN(101);
	}
	CPartyRsrcRoutingTblKey routingKey = CPartyRsrcRoutingTblKey(connId, connId, eLogical_ip_signaling);
	pRoutingTbl->AddPartyRsrcDesc(routingKey);

	WORD status = pRoutingTbl->AddStateMachinePointerToRoutingTbl(*m_pCsRsrcDesc, m_pPartyApi);
	if (status != STATUS_OK)
		DBGPASSERT(status);
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetRsrcParams(CRsrcParams *pCsRsrcParams)
{
	POBJDELETE(m_pCsRsrcDesc);
	m_pCsRsrcDesc = new CRsrcParams(*pCsRsrcParams);
	m_pCsInterface->Create(m_pCsRsrcDesc);


	CConfPartyRoutingTable* pRoutingTbl = ::GetpConfPartyRoutingTable();
	if ( pRoutingTbl== NULL )
	{
		PASSERT_AND_RETURN(101);
	}

	WORD status = pRoutingTbl->AddStateMachinePointerToRoutingTbl(*m_pCsRsrcDesc, m_pPartyApi);
	if (status != STATUS_OK)
		DBGPASSERT(status);

}

////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::FindSiteAndVisualNamePlusProductIdAndSendToConfLevel()
{
	CSipHeader* pRemoteNameHeader = NULL;
	char* siteName = new char[MAX_SITE_NAME_ARR_SIZE*2]; //33
	const char* privateHeaderStr = NULL;
	char* privateHeaderStrLocal = new char[MAX_SITE_NAME_ARR_SIZE]; //33
	memset(siteName,'\0',MAX_SITE_NAME_ARR_SIZE*2);
	memset(privateHeaderStrLocal,'\0',MAX_SITE_NAME_ARR_SIZE);
	eTelePresencePartyType  eLocalTelePresencePartyType = eTelePresencePartyNone;
	char*	sipUsrname = new char[MAX_SITE_NAME_ARR_SIZE];
	memset(sipUsrname,'\0',MAX_SITE_NAME_ARR_SIZE);
	BYTE bFromDisplayHeaderFound = 0;


	sipMessageHeaders *pRmtHeaders = GetRmtHeaders();


	if(pRmtHeaders && m_pCall)
	{

		BYTE remoteNameHeaderFound = 0;
		BYTE privateHeaderFound = 0;

		CSipHeaderList cRmtHeaders(*pRmtHeaders);
		if(m_pCall->IsCallInitiator() == NO) // done only in dial in
		{

			// try to get "P-Preferred-Identity"
			pRemoteNameHeader	= (CSipHeader*) cRmtHeaders.GetNextPrivateOrProprietyHeader(kPrivateHeader,strlen("P-Preferred-Identity"),"P-Preferred-Identity");
			if(pRemoteNameHeader)
			{
				privateHeaderStr = pRemoteNameHeader->GetPrivateHeaderStr("P-Preferred-Identity");
				BOOL result = FALSE;
				if((privateHeaderStr) && IsValidStringUTF8(privateHeaderStr,"NOT_EMPTY")){
				     strncpy(privateHeaderStrLocal, privateHeaderStr, MAX_SITE_NAME_ARR_SIZE);
				     result = GetDisplayNameFromIdentity(privateHeaderStrLocal);
				     if( result )
					privateHeaderFound = 1;
				}
				if(IsValidStringUTF8(pRemoteNameHeader->GetHeaderStr(),"NOT_EMPTY") && result){
					remoteNameHeaderFound = 1;
				}
			}

			// try to get "P-Asserted-Identity"
			if(!privateHeaderFound)
			{
				remoteNameHeaderFound = 0;
				pRemoteNameHeader	= (CSipHeader*) cRmtHeaders.GetNextPrivateOrProprietyHeader(kPrivateHeader,strlen("P-Asserted-Identity"),"P-Asserted-Identity");
				if(pRemoteNameHeader)
				{
					privateHeaderStr = pRemoteNameHeader->GetPrivateHeaderStr("P-Asserted-Identity");
					BOOL result = FALSE;
					if((privateHeaderStr) && IsValidStringUTF8(privateHeaderStr,"NOT_EMPTY"))
					{
				            strncpy(privateHeaderStrLocal, privateHeaderStr, MAX_SITE_NAME_ARR_SIZE);
				            result = GetDisplayNameFromIdentity((char *)privateHeaderStrLocal);
					    if( result )
						privateHeaderFound = 1;
					}
					if(IsValidStringUTF8(pRemoteNameHeader->GetHeaderStr(),"NOT_EMPTY") && result)
					{
						remoteNameHeaderFound = 1;
					}
				}
			}

			// try to get "From Display"
			if(!remoteNameHeaderFound)
			{
				pRemoteNameHeader	= (CSipHeader*) cRmtHeaders.GetNextHeader(kFromDisplay);
				if ( pRemoteNameHeader )
					if(strcmp(pRemoteNameHeader->GetHeaderStr(),"anonymous") == 0)
						pRemoteNameHeader = NULL;
				if(pRemoteNameHeader && IsValidStringUTF8(pRemoteNameHeader->GetHeaderStr(),"NOT_EMPTY"))
				{
					remoteNameHeaderFound = 1;
					bFromDisplayHeaderFound = 1;
				}
			}

			// try to get "Contact Display"
			if(!remoteNameHeaderFound)
			{
				pRemoteNameHeader	= (CSipHeader*) cRmtHeaders.GetNextHeader(kContactDisplay);
				if ( pRemoteNameHeader )
					if(strcmp(pRemoteNameHeader->GetHeaderStr(),"anonymous") == 0)
						pRemoteNameHeader = NULL;
				if(pRemoteNameHeader && IsValidStringUTF8(pRemoteNameHeader->GetHeaderStr(),"NOT_EMPTY"))
				{
					remoteNameHeaderFound = 1;
				}
			}

			// try to get "From"
			if(!remoteNameHeaderFound)
			{
				pRemoteNameHeader	= (CSipHeader*) cRmtHeaders.GetNextHeader(kFrom);
				if (pRemoteNameHeader && (IsValidStringUTF8(pRemoteNameHeader->GetHeaderStr(),"NOT_EMPTY")))
				{
					remoteNameHeaderFound = 1;
				}
			}

			// try to get "Contact"
			if(!remoteNameHeaderFound)
			{
				pRemoteNameHeader	= (CSipHeader*) cRmtHeaders.GetNextHeader(kContact);
				if(pRemoteNameHeader && (IsValidStringUTF8(pRemoteNameHeader->GetHeaderStr(),"NOT_EMPTY")))
				{
					remoteNameHeaderFound = 1;
				}
			}
		}

		if(remoteNameHeaderFound)
		{
			if(privateHeaderFound)
				strncpy(siteName, privateHeaderStrLocal, MAX_SITE_NAME_ARR_SIZE); // Not size*2
			else
				strncpy(siteName, pRemoteNameHeader->GetHeaderStr(), MAX_SITE_NAME_ARR_SIZE);
			siteName[MAX_SITE_NAME_ARR_SIZE - 1] = '\0';

			///////////////Get SIP username
			if(privateHeaderFound)
			{
				char pSipUrl[MAX_SITE_NAME_ARR_SIZE ]={0}; //to please klocwork
				strncpy(pSipUrl, privateHeaderStr, MAX_SITE_NAME_ARR_SIZE-1);

				GetSipUsernameFromUrl(sipUsrname, pSipUrl, MAX_SITE_NAME_ARR_SIZE);
			}
			else
				GetSipUsernameFromUrl(sipUsrname, siteName, MAX_SITE_NAME_ARR_SIZE);

			BuildRepresentableSiteName(siteName);
		}
	}

	BYTE bIsProductId = FALSE;
	BYTE bIsVersionId = FALSE;
	char* pVersionId = NULL;

	ALLOCBUFFER(cUserAgent, MaxUserAgentSize);
	sipMessageHeaders *pRemoteSipHeaders = GetRmtHeaders();//GetRemoteCallLegHeaders();
	//if value received from header
	if (pRemoteSipHeaders)
	{
		::SipGetHeaderValue(pRemoteSipHeaders, kUserAgent, cUserAgent, MaxUserAgentSize);

		if ( strlen(cUserAgent) > 0 )
		{
			pVersionId = new char[strlen(cUserAgent)+1];
			memset(pVersionId,'\0',strlen(cUserAgent)+1);
			bIsProductId = TRUE;

			IdentifyVersionId(cUserAgent,&pVersionId,cUserAgent,strlen(cUserAgent));

			if (pVersionId[0] != '\0')
			{
				BYTE bIsVersionId = TRUE;
				FPTRACE2(eLevelInfoNormal,"CSipCntl::FindSiteAndVisualNamePlusProductIdAndSendToConfLevel : The VersionId is ",pVersionId );
				bIsVersionId = TRUE;
				if(strstr((const char*)cUserAgent,"RPX"))
				{
				   eLocalTelePresencePartyType = eTelePresencePartyRPX;
				   PTRACE2(eLevelInfoNormal,"CSipCntl::FindSiteAndVisualNamePlusProductIdAndSendToConfLevel - Identify party as RPX: Name - ",PARTYNAME);
				}
				if(strstr((const char*)cUserAgent,"FLEX"))
				{
				   eLocalTelePresencePartyType = eTelePresencePartyFlex;
				   PTRACE2(eLevelInfoNormal,"CSipCntl::FindSiteAndVisualNamePlusProductIdAndSendToConfLevel - Identify party as FLEX: Name - ",PARTYNAME);
				}
			}

		}

	}

	//replace invalid characters in the name
	for (int i=0; SipInvalidDisplayChars[i] != '\0'; i++)
	{
		CSmallString::ReplaceChar(siteName, SipInvalidDisplayChars[i],'.');
	}

	//place the sipUsername behind the siteName, seperated by ##
	if(MicrosoftEP_Lync_CCS == GetRemoteIdent() || MicrosoftEP_Lync_R1 == GetRemoteIdent() || MicrosoftEP_Lync_2013 == GetRemoteIdent() || GetRemoteIdent() == Microsoft_AV_MCU2013 )
	{
		strcat(siteName, "#");
		strcat(siteName, sipUsrname);
	}

	BYTE bIsVisualName = TRUE;
	APIU16 isGetInfoFromCname = RetriveMaskAndNameFromEpIfPosible(m_pRemoteSdp->cCname,bIsProductId,cUserAgent,bIsVersionId,pVersionId);

	if(isGetInfoFromCname)
	{
		m_IsNeedToExtractInfoFromRtcpCname = FALSE;
		PDELETEA (siteName);
		PDELETEA (privateHeaderStrLocal);
		DEALLOCBUFFER(cUserAgent);
		PDELETEA(pVersionId);
		PDELETEA(sipUsrname);
		return;
	}
	else if(m_pCall && m_pCall->IsCallInitiator() == NO)//currently we sent the site name only in case of dial in.
	{
		// speakerIndication
		TRACEINTO << "speakerIndication - send to PartyControl - m_remoteIdent: " << m_remoteIdent <<" siteName: " << siteName ;
		m_pPartyApi->SendSiteAndVisualNamePlusProductIdToPartyControl(bIsVisualName, siteName, bIsProductId, cUserAgent,bIsVersionId,pVersionId,eLocalTelePresencePartyType, FALSE, m_remoteIdent);
	}

	PDELETEA (siteName);
	PDELETEA (privateHeaderStrLocal);
	DEALLOCBUFFER(cUserAgent);
	PDELETEA(pVersionId);
	PDELETEA(sipUsrname);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BOOL CSipCntl::GetQosParams(const char *& precedDomain, BYTE& precedRPrio) const
{
	BOOL Success = FALSE;
	CCommConf* 	pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	CConfParty* pConfParty = (pCommConf? pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId()): NULL);
	const CPrecedenceSettings* pPrecedenceSettings = GetpPrecedenceSettingsDB();

	if (pPrecedenceSettings && pPrecedenceSettings -> IsPrecedenceEnabled())
	{
		if (pConfParty && m_pQos)
		{
			//========================================
			// Retrieved QoS params, validating them
			//========================================
			precedDomain	= pConfParty -> GetPrecedenceDomain();
			int precedLevel = pConfParty -> GetPrecedenceLevel();
			int domainId	= pPrecedenceSettings -> GetDomainId(precedDomain);
			precedRPrio		= pPrecedenceSettings -> GetRPrioForPrecedenceLevel(domainId, precedLevel);
			if (precedRPrio != DEFAULT_PRECEDENCE_R_PRIORITY && precedDomain && precedDomain[0])
			{
				CMedString log;
				log << "CSipCntl::GetQosParams - got Rpriority [" << precedRPrio <<"] and Domain [" << precedDomain << "]";
				PTRACE(eLevelInfoNormal, log.GetString());
				Success = TRUE;
			}
			else
			{
				PTRACE(eLevelInfoNormal, "CSipCntl::GetQosParams - Rpriority and/or Domain are the default, leaving default media tos values");
			}
		}
		else
		{
			CSmallString log;
			log << "CSipCntl::GetQosParams - failed retrieving prereqs for precedence, " << (pCommConf? (pConfParty? "m_pQos" : "pConfParty") : "pCommConf") << " is NULL, leaving default tos values";
			PTRACE(eLevelError, log.GetString());
		}
	}
	else if (!pPrecedenceSettings)
	{
		PTRACE(eLevelError, "CSipCntl::GetQosParams - failed retrieving prereqs for precedence, pPrecedenceSettings is NULL, leaving default tos values");
	}
	else  // precedence disabled
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::GetQosParams - dynamic precedence/resource-priority mechanism disabled, leaving default tos values");
	}

	return Success;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::Create(CSipParty* pParty, CSipNetSetup* pNetSetup, /*CIpRsrcDesc* pRsrcDesc,*/ BYTE bIsInitiator, DWORD serviceId, DWORD room_Id)
{
	m_pParty = pParty;

	m_pPartyApi->CreateOnlyApi(pParty->GetRcvMbx(), this);
	m_pPartyApi->SetLocalMbx(pParty->GetLocalQueue());
	m_serviceId = serviceId;
	*m_pNetSetup = *pNetSetup;
	TRACEINTO << "IpVersion: " << (DWORD)pNetSetup->GetIpVersion();
	SetLocalSipHostAddress();

	if(m_isMs2013Active == eMsft2013AvMCU)
		m_pVsrControl = new CSipVsrCtrlAvMcu(((CTaskApp *)m_pParty),m_pPartyApi);
	else
		m_pVsrControl = new CSipVsrCtrlP2P(((CTaskApp *)m_pParty),m_pPartyApi);


	if(m_pCall)
	{
		m_pCall->SetCallInitiator(bIsInitiator);
		m_pCall->SetCallIndex(m_pNetSetup->GetCallIndex());
		eConfMediaType partyTargetModeConfMediaType = m_pParty->GetTargetMode()->GetConfMediaType();
		TRACEINTO << "mix_mode: m_confMediaType=" << ConfMediaTypeToString(partyTargetModeConfMediaType);
		m_pCall->SetConfMediaType(partyTargetModeConfMediaType);

		DWORD  timeLen = GetMediaDetectionTimer(CFG_KEY_SIP_DETECT_DISCONNECT_TIMER);
		m_pCall->SetMediaDetectionTimer(timeLen);
	}
	else
		PTRACE(eLevelError,"CSipCntl::Create - m_pCall is NULL !!!");
	m_LastRateBeforeLpr		= 0;
	//m_LastRateBeforeFEC		= 0;
	//m_LastRateBeforeRED     = 0;
	//m_BitRateWithFEC		= 0;
	//m_BitRateWithRED  		= 0;
	m_ChangeOfRateRED       = 0;
	m_ChangeOfRateFEC       = 0;

	SetTipRoomId( room_Id );

	//========================
	// Retrieving Qos Params
	//========================
	BYTE 		precedRPrio;
	const char*	precedDomain;
	if (GetQosParams(precedDomain, precedRPrio))
	{
		m_pQos -> AssembleValFromRPrio(precedDomain, precedRPrio);
	}
}


///////////////////////////////////////////////////////////////////////
void CSipCntl::MakeANewCall(CSipComMode* pTargetMode, ETipPartyTypeAndPosition tipPartyType, BYTE bIsFirstOfferer, BYTE bStartSignalingOnly)
{
	BYTE bIsInitiator =	(m_pCall) ? m_pCall->IsCallInitiator() : 0;
	BYTE bIsMrcSlave = m_bIsMrcCall && (GetCascadeMode()==CASCADE_MODE_SLAVE);
	PTRACE2(eLevelInfoNormal,"CSipCntl::MakeANewCall bIsInitiator is ", bIsInitiator ? "YES" : "NO");

	if (bStartSignalingOnly)
	{
		TRACEINTO << "start without open channels";
		m_state = IP_CONNECTING;
	}
	else if (( bIsInitiator || bIsFirstOfferer) && !bIsMrcSlave)
	{
		/* In my opinion, it is not needed, set the second param :TipNone for MSSlave */
		if ( YES == SipNewCallReq(pTargetMode, tipPartyType) )
		{
			m_state = IP_CONNECTING;
		}
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::MakeANewCall SipNewCallReq not sent");
		}
	}
	else
	{
		cmCapDirection eDirection=cmCapReceiveAndTransmit;
		BYTE bIsAnswering = TRUE;
		SipOpenChannelsReq(pTargetMode,eDirection,bIsAnswering, tipPartyType);
		m_state = IP_CONNECTING;
	}

	if( m_pCall)
		m_pCall->SetConnectionState(kConnecting);
}





///////////////////////////////////////////////////////////
void CSipCntl::CloseCall(BYTE bIsInitiator,int reason)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::CloseCall");
	BYTE bMessageSent = NO;
	SetCallDisconnecting();

	//CDR_MCCF:
	BYTE IsNeedToCollectStatisticInfo  = FALSE;
	if( m_pCall->IsMedia(cmCapVideo, cmCapTransmit,kRolePeople) || m_pCall->IsMedia(cmCapVideo, cmCapTransmit,kRolePresentation) )
	{
		IsNeedToCollectStatisticInfo = TRUE;
	}

	if ( bIsInitiator != (BYTE) NA )
	{
		m_pCall->SetCloseInitiator(bIsInitiator);
	}

	if ( reason )
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::CloseCall, reject reason = ", reason);
		m_pCall->SetRejectReason((enSipCodes)reason);
	}

	//CDR_MCCF:
	BOOL bEnableCdrMCCF = GetSystemCfgFlagInt<BOOL>(CFG_KEY_ENABLE_CDR_FOR_MCCF);
	if (bEnableCdrMCCF == TRUE)
	{
	    PTRACE(eLevelError,"CDR_MCCF: CSipCntl::CloseCall bEnableCdrMCCF == TRUE");
	    if(!IsNeedToCollectStatisticInfo)
	    {
	        PTRACE(eLevelError,"CDR_MCCF: CSipCntl::CloseCall - !IsNeedToCollectStatisticInfo");
	        if (m_pIpVideoCdrChannelMonitor[0]->GetConnectionStatus() == YES || m_pIpVideoCdrChannelMonitor[1]->GetConnectionStatus() == YES)
	    	{
	    		PTRACE(eLevelError,"CDR_MCCF: CSipCntl::CloseCall - !IsNeedToCollectStatisticInfo - if one of the details is valid and send to mccf manager");
	    		//SendStatisticsInfoOfThisEpToMCMSpolycomMixer();
	    	}
	        bMessageSent = SipCloseAllChannelsReq();
	    }
	    else
	    {
	        PTRACE(eLevelError,"CDR_MCCF: CSipCntl::CloseCall - IsNeedToCollectStatisticInfo");
	        BYTE isMonitorReqSent = FALSE;
	        isMonitorReqSent = SendRtpVideoChannelStatisticsReq();
	        if(isMonitorReqSent == FALSE)
	        {
	            PTRACE(eLevelError,"CDR_MCCF: CSipCntl::CloseCall - RTP video channel statistics wasn't sent -no DMA CDR will be created");
	            bMessageSent = SipCloseAllChannelsReq();
	        }
	    }
	}
	else
	{
	    PTRACE(eLevelError,"CDR_MCCF: CSipCntl::CloseCall bEnableCdrMCCF == FALSE");
	    bMessageSent = SipCloseAllChannelsReq();
	}

}



/////////////////////////////////////////////////////////////
void CSipCntl::ViolentCloseCall()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::ViolentCloseCall");
	m_pCall->SetViolentClose(YES);
	CloseCall(YES);
}



/////////////////////////////////////////////////////////////
void CSipCntl::RejectCall(int reason,int warning)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::RejectCall");
	if (m_pCall->GetWarning() == 0)
		m_pCall->SetWarning((enSipWarningCodes)warning);
	CloseCall(YES,reason);
}


///////////////////////////////////////////////////////////
void CSipCntl::CancelCall(ECancelType eCancelType)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::CancelCall");
	m_pCall->SetCancelType(eCancelType);
	CloseCall(YES);
}


///////////////////////////////////////////////////////////
void CSipCntl::RejectCallAndProvideAlternativeAddrToCall(int reason, const char* alternativeAddrStr)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::RejectCallAndProvideAlternativeAddrToCall");
	m_pCall->SetForwardAddr(alternativeAddrStr);
	RejectCall(reason);
}


/////////////////////////////////////////////////////////////////////////
void CSipCntl::ContinueToEndCloseChannels()
{
	BYTE bMessageSent = NO;
	BYTE bIsCloseInitiator = m_pCall->IsCloseInitiator();
	BYTE bIsViolentClose = m_pCall->IsViolentClose();
	BYTE bIsCallInitiator = m_pCall->IsCallInitiator();
	enSipCodes  rejectReason = m_pCall->GetRejectReason();

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::ContinueToEndCloseChannels, reject reason = ", (WORD)rejectReason);

	int	 warning = m_pCall->GetWarning();
	ECancelType eCancelType = m_pCall->GetCancelType();
	const char* forwardAddr = m_pCall->GetForwardAddr();

	CSipComMode* pCurrentMode = new CSipComMode;
	pCurrentMode->Create(*m_pCall);
	pCurrentMode->CopyStaticAttributes(*(m_pParty->GetTargetMode())); // copy necessary data members like ConfType from preffered mode to best mode.

	if (bIsViolentClose)
	{
		SipDelNewCallReq(0);//STATUS_TOUT
		m_pPartyApi->SipPartyCallClosed(pCurrentMode);
	}
	else if (bIsCallInitiator && eCancelType) // cancel dial out
	{
		if (eCancelType == kCancelAfterInvite)
		{
		    bMessageSent = SipCancelReq();
		}
		else // cancel before invite, we only need to tell card
		{
			SipDelNewCallReq(0);//STATUS_OK
			m_pPartyApi->SipPartyCallClosed(pCurrentMode);
		}
	}
	else if (rejectReason)// reject call
	{
		if (m_bIsReInviteTransaction && m_pCall->IsReInviteInitiator())
		{
			bMessageSent = SipInviteAckReq(NO); // Still need to send Bye.
			SipByeReq();
		}
		 // dial in
		else if (bIsCallInitiator == NO)
		{
			//  mc reject or Ep canceled
			bMessageSent = SipInviteResponseReq(rejectReason,warning,forwardAddr);
		}
		else // dial out
		{
			// Ep reject or answered to our cancel
			bMessageSent = SipInviteAckReq();
			m_pPartyApi->SipPartyCallClosed(pCurrentMode);
		}
	}
	else //regular close
	{
		if (bIsCloseInitiator)
		{
			if(m_PendTransType == etransBye)
			{//N.A. This is supposed to take care of BYE glare. This case: we started disconnecting the call and then before we sent the BYE_REQ
			 // we received BYE_IND from the EP. so we continue the regular flow of the disconnecting  and at the end take care of the glare by sending
			 //200 ok instead of BYE_REQ

				bMessageSent = SipBye200OkReq();
				m_pPartyApi->SipPartyCallClosed(pCurrentMode);
			}
			else
			{
				bMessageSent = SipByeReq();
			}
		}
		else
		{
			bMessageSent = SipBye200OkReq();
			m_pPartyApi->SipPartyCallClosed(pCurrentMode);
		}

	}
	POBJDELETE(pCurrentMode);
}
////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnAllChannelsAreClosed()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnAllChannelsAreClosed");

	if(m_MfaReqCounter!=0)
	{
		TRACEINTO<<"!@# all channels should have been closed by now: m_MfaReqCounter:"<<m_MfaReqCounter;
//		m_MfaReqCounter=0;
	}
	if(IsAtLeastOneInternalTranslatorArtConnected())
	{
		CloseTranslatorArts();
	}
	else
	{
		//For example incase of Reject dial in call due to allocation failure before we even sent request to ICE stack -
		// we don't need to close ICE session.
		if(m_IsEnableICE && m_bIsSentICEStackReq)
		{
			CloseIceSession();
		}
		else
			ContinueToEndCloseChannels();
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipNewCallReq(CSipComMode* pTargetMode, ETipPartyTypeAndPosition tipPartyType)
{
	BYTE bMessageSent = NO;

    m_pParty->GetTargetMode()->Dump("CSipCntl::SipNewCallReq Target mode", eLevelInfoNormal);
    m_pParty->GetCurrentMode()->Dump("CSipCntl::SipNewCallReq Current mode", eLevelInfoNormal);

	EIpChannelType	chanArr[CHANNEL_TYPES_COUNT] = {AUDIO_IN,VIDEO_IN,FECC_IN,VIDEO_CONT_IN,BFCP_IN};
	mcTransportAddress address;
	memset(&address, 0, sizeof(mcTransportAddress));

	/* Flora Question: only for MSSlaveIn, not for MSSlaveOut */
	//noa-agreed
	/* this function is only handling the ChannelDirection: Receive */
	/* for MSSlaveOut, call m_pPartyApi->SipPartyChannelsConnected, to SendLocalMessage(pSeg, SIP_PARTY_CHANS_CONNECTED); to MSSlaveOutParty */
	m_pCall->SetChannels(pTargetMode, cmCapReceive);
	m_pCall->SetMediaPayloadType(cmCapReceive, m_pChosenLocalCap , CHANNEL_TYPES_COUNT, chanArr);

//    if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc && !m_bIsMrcCall)
//    {
//		m_pCall->SetChannelsEx(pTargetMode,cmCapReceive,m_bIsMrcCall);
//		int arrSizeEx=1;
//		m_pCall->SetMediaPayloadTypeEx(cmCapReceive, m_pChosenLocalCap , 1/*MAX_SIP_MEDIA_TYPES*/, &chanArr[1]);
//    }
    if(m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvcVsw  && !m_bIsMrcCall)
    {
		m_pCall->SetChannelsEx(pTargetMode,cmCapReceive,m_bIsMrcCall);
		int arrSizeEx=MAX_INTERNAL_CHANNELS;
		m_pCall->SetMediaPayloadTypeEx(cmCapReceive, m_pChosenLocalCap , arrSizeEx/*MAX_SIP_MEDIA_TYPES*/, &chanArr[1]);
		m_pCall->SetMediaPayloadTypeEx(cmCapTransmit, m_pChosenLocalCap , arrSizeEx/*MAX_SIP_MEDIA_TYPES*/, &chanArr[1]);
    }

	m_pCall->SetMediaRtpAddress(address, cmCapAudio, cmCapReceive);
	m_pCall->SetMediaRtpAddress(address, cmCapVideo, cmCapReceive);
	m_pCall->SetMediaRtpAddress(address, cmCapData, cmCapReceive);
	m_pCall->SetMediaRtpAddress(address, cmCapVideo, cmCapReceive,kRolePresentation);
	m_pCall->SetMediaRtpAddress(address, cmCapBfcp, cmCapReceive);
	m_pCall->SetMediaTos(m_pQos->m_bIpAudio, m_pQos->m_bIpRtcp, cmCapAudio, cmCapReceive);
	m_pCall->SetMediaTos(m_pQos->m_bIpVideo, m_pQos->m_bIpRtcp, cmCapVideo, cmCapReceive);
	if (GetpPrecedenceSettingsDB() -> IsPrecedenceEnabled())
	{
		m_pCall->SetMediaTos(m_pQos->m_bIpVideo, m_pQos->m_bIpRtcp, cmCapData, cmCapReceive);
		m_pCall->SetMediaTos(m_pQos->m_bIpSignaling, m_pQos->m_bIpRtcp, cmCapBfcp, cmCapReceive);
		m_pCall->SetMediaTos(m_pQos->m_bIpVideo, m_pQos->m_bIpRtcp, cmCapVideo, cmCapReceive,kRolePresentation);
	}
	else
	{
		m_pCall->SetMediaTos(0, m_pQos->m_bIpRtcp, cmCapVideo, cmCapReceive,kRolePresentation);
		m_pCall->SetMediaTos(0, m_pQos->m_bIpRtcp, cmCapData, cmCapReceive);
	}

	// TIP
	TRACEINTOFUNC << "TIP mode: " << (WORD)pTargetMode->GetIsTipMode() << ", tipPartyType: " << tipPartyType;

	if (pTargetMode->GetIsTipMode())
	{
		m_pParty->SetTipPartyTypeAndPosition(tipPartyType);
		m_pCall->SetIsTipCall(TRUE);
	}

	int numOfChannels = m_pCall->SetChannelsConnectingState(kConnecting, CHANNEL_TYPES_COUNT, chanArr);

	if ( numOfChannels > 0 )
	{
		if ( OpenMediaChannels(kConnecting) > 0 )
		{
			bMessageSent = YES;
		}
		else
		{
			DBGPASSERT(YES);
			PTRACE(eLevelError,"CSipCntl::SipNewCallReq: No requests to open media");
		}
		if(!m_bIsMrcCall && m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc )
	        {

		    TRACEINTO<<"!@# before open internal channels";
		    int numOfInternalChannels;
		    numOfInternalChannels=OpenInternalChannels(pTargetMode, (CSipComMode*)m_pParty->GetCurrentMode(), kConnecting);
		    if (numOfInternalChannels > 0)
		    {
		       bMessageSent = YES;
		    }
		    else
		    {
			//DBGPASSERT(YES);
			PTRACE(eLevelError,"CSipCntl::SipNewCallReq: No requests to open internal channels.");
		    }
	       }
	}
	else
	{
		DBGPASSERT(YES);
		PTRACE(eLevelError,"CSipCntl::SipNewCallReq: No Channels");
	}

	return bMessageSent;
}


////////////////////////////////////////////////////////
BYTE CSipCntl::SipDelNewCallReq(DWORD status)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipDelNewCallReq");

	mcReqDelNewCall sDelNewCall;
	int size = sizeof(mcReqDelNewCall);
	memset(&sDelNewCall, 0, size);
	if ( m_pCall->GetCallIndex() )
		SendSIPMsgToCS(SIP_CS_SIG_DEL_NEW_CALL_REQ, &sDelNewCall, size);

	SetCallDisconnectedAndRemoveFromRsrcTbl();
	return 0;
}

extern void DumpMediaLineEntry(sipMediaLinesEntrySt *pMediaLinesEntry,std::ostream &ostr);
//======================================================
//  Reformating host of headers for scrupulous proxies
//  (Strictly for outgoing GW calls)
//======================================================
const char* CSipCntl::StripGWDecorationFromHost(const char* decorated, char* undecorated) const
{
	const char* ret = decorated;
	if(decorated && undecorated)
	{
		CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
		if (pCommConf && pCommConf->GetIsGateway() && m_pCall->IsCallInitiator())
		{
			//======================
			// Skipping GW_ prefix
			//======================
			const char* headerNdx;
			for(headerNdx = decorated; *headerNdx && *headerNdx != '@' && *headerNdx != '_'; ++headerNdx)
				;

			if (*headerNdx == '_')
			{
				//==================================
				// Skipping conf sequential number
				//==================================
				const char* confNumberStart = strchr(headerNdx, '(');
				const char* confNumberEnd	= (confNumberStart? strchr(confNumberStart, ')') : NULL);

				if (confNumberEnd)
				{
					const int realConfNameLen = confNumberStart - headerNdx - 1;
					snprintf(undecorated, realConfNameLen + 1, "%s", headerNdx + 1);
					snprintf(undecorated + realConfNameLen, IP_STRING_LEN - realConfNameLen, "%s", confNumberEnd + 1);
					CMedString log;
					log << "CSipCntl::StripGWDecorationFromHost - header for GW call has been reformatted from " << decorated << " to " << undecorated;
					PTRACE(eLevelInfoNormal,log.GetString());
					ret = undecorated;
				}
				else
				{
					PTRACE(eLevelInfoNormal,"CSipCntl::StripGWDecorationFromHost - GW call has no conf sequential number");
				}
			}
			else
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::StripGWDecorationFromHost - GW call has no prefix");
			}
		}
	}
	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::StripGWDecorationFromHost - at least one buffer is NULL, exiting");
	}

	return ret;
}

////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInviteReq(const char* alternativeAddrStr, DWORD rmtSessionTimerMinSec, BYTE isResultOfIpMediaMismatch)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteReq");
	BOOL bIsPrimaryNet = m_pNetSetup->IsItPrimaryNetwork();
	BYTE bMessageSent = NO;
	CIpServiceListManager* pIpServiceListManager = ::GetIpServiceListMngr();
	CConfIpParameters* pServiceParams = pIpServiceListManager->FindIpService(m_serviceId);
	CCommConf* 	pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	CConfParty* pConfParty = (pCommConf? pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId()): NULL);
	if (pServiceParams == NULL)
	{
		PASSERTMSG(m_pCsRsrcDesc->GetConnectionId(), "CSipCntl::SipInviteReq - IP Service does not exist!!!");
		return bMessageSent;
	}

	DWORD bOn = pServiceParams->GetSipProxyStatus();
	BYTE		bDialDirect	= 0;
	BYTE		bIsUriWithIp = 0;
	int			hostLen = 0;
	char*		strHostIp = NULL;

	//Add Ice to channels
	if(m_IsEnableICE)
	{
		m_pCall->ClearIceData();
		m_pCall->SetIceData(m_pChosenLocalCap );

	}
	else if(eMsft2013AvMCU == m_isMs2013Active)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteReq - create fake ice candidates");
		CreateFakeIceCandidates();
	}

	DWORD bIsUseOutBoundProxy = STATUS_OK;
	// IpV6
	mcTransportAddress trAddr;
	memset(&trAddr,0,sizeof(mcTransportAddress));
	const char* strDestAddr			= m_pNetSetup->GetDestPartyAddress();
	if (alternativeAddrStr && alternativeAddrStr[0])/*should we check for Amdocs string here or to get transport from the string, or to parse the string in NetSetup */
	{
		strDestAddr 	= alternativeAddrStr;
		m_pNetSetup->SetAlternativeTaDestPartyAddr(alternativeAddrStr);
		SetAlternativeTransportType(alternativeAddrStr);
	}
	char		strTransportIp[IPV6_ADDRESS_LEN];
	char		strAlternativeTransportIp[IPV6_ADDRESS_LEN];
	const mcTransportAddress* pDestTaAddr = m_pNetSetup->GetTaDestPartyAddr();

	char tempName11[IPV6_ADDRESS_LEN];
	memset (&tempName11,'\0',IPV6_ADDRESS_LEN);
	mcTransportAddress ttt11;
	memcpy(&ttt11,pDestTaAddr,sizeof(mcTransportAddress));
	ipToString(ttt11,tempName11,1);
	strncpy(strAlternativeTransportIp, m_pNetSetup->GetAlternativeTaDestPartyAddr(), IPV6_ADDRESS_LEN - 1);
	strAlternativeTransportIp[IPV6_ADDRESS_LEN - 1] = 0;

	TRACEINTOFUNC << "m_pNetSetup->GetTaDestPartyAddr()  " << tempName11
				  << "\nm_pNetSetup->GetAlternativeTaDestPartyAddr()  " << strAlternativeTransportIp
				  << "\nstrDestAddr = " << strDestAddr;

	if (::isApiTaNull(pDestTaAddr) == FALSE || strAlternativeTransportIp[0] != '\0')
	{
		bDialDirect = 1;
		bIsUriWithIp = 0;
	}
	else
	{
	//check if present @ in dial SIP URI
		char* strAt = (char*)strstr(strDestAddr,"@");
		TRACEINTO << "CSipCntl::SipInviteReq - strAt = " << strAt;
	//if found @ it's dialing via proxy (if defined)
	//otherwise if only valid IP address it's direct dial

		bDialDirect = 0;

	//if found @ check what is after the @
		strHostIp	= strAt ? (strAt+1) : NULL;
	//valid explicit IP or not
		TRACEINTO << "CSipCntl::SipInviteReq - strHostIp = " << strHostIp;
		if (strHostIp)
		{
			memset(&trAddr,0,sizeof(mcTransportAddress));
			::stringToIp(&trAddr,strHostIp);
			BYTE isIpAddrValid = ::isApiTaNull(&trAddr);
			if (isIpAddrValid != TRUE)
			{
				isIpAddrValid = ::isIpTaNonValid(&trAddr);
				if (isIpAddrValid != TRUE)
					bIsUriWithIp = 1;
			}
		}
	//	strHostIp ? ::IsValidIpV4Address(strHostIp) : NO;
		hostLen	= strHostIp ? strlen(strHostIp) : NO;
	}

	// if the service status is On and its not direct IP call (IP address valid or URI with IP address)
	// we try to get the outbound proxy.
	char* pProxyAddress = new char[MaxLengthOfSingleUrl];
	memset(pProxyAddress,0,MaxLengthOfSingleUrl);

	TRACEINTO << "SipProxyStatus(bOn) " << (int)bOn;

	if(bOn != eServerStatusOff && bDialDirect == NO) {
		GetOutboundSipProxy(pProxyAddress);

		pProxyAddress[MaxLengthOfSingleUrl - 1] = '\0';

		if (pProxyAddress[0] == '\0')
			bIsUseOutBoundProxy = STATUS_FAIL;
	}

	if(bIsUseOutBoundProxy != STATUS_OK)
	{
		DBGPASSERT(STATUS_FAIL);
		m_pPartyApi->SipPartyCallFailed(SIP_BAD_STATUS);
	}

	else if (bOn == eServerStatusOff || bDialDirect || bIsUriWithIp || pProxyAddress[0] != '\0'/*m_outboundProxyIp*/)
	{
		char strContact[IP_STRING_LEN];
		const char* strLocalAddr		= m_pNetSetup->GetLocalSipAddress();  // user@ip
		char*		strLocalUri			= new char[IP_STRING_LEN];
		char*		newstrToAddr		= new char[IP_STRING_LEN];
		m_pNetSetup->CopyLocalUriToBuffer(strLocalUri,IP_STRING_LEN); // user@domain (if we have domain)

		const char* strToDisplay		= NULL;
		const char* strToAddr			= NULL;
		const char* strFromDisplay		= ""; //m_pNetSetup->GetLocalDisplayName();-noa to do only for av-mcu
		const char* strFromAddr;
		const char* strMsConversationId = m_pNetSetup->GetMsConversationId();

		TRACEINTOFUNC << "bDialDirect: " << (int)bDialDirect << ", strLocalUri: " << strLocalUri << ", strLocalAddr: " << strLocalAddr;

		if (( bDialDirect ||  bOn == eServerStatusOff ) && (pConfParty && pConfParty->GetMsftAvmcuState() == eMsftAvmcuNone ))
            strFromAddr = strLocalAddr;
        else if(pConfParty && pConfParty->GetMsftAvmcuState() == eMsftAvmcuNone)
            strFromAddr = strLocalUri[0]? strLocalUri: strLocalAddr;
        else
        {
        	TRACEINTOFUNC << "cccp av-mcu call";
        	const char* strOriginalToFromDma = m_pNetSetup->GetOriginalToDmaSipAddress();
        	if(strOriginalToFromDma && strOriginalToFromDma[0])
			{
				strFromAddr = strOriginalToFromDma;
				if(strLocalUri && strLocalUri[0])
				{
					snprintf(strContact,IP_STRING_LEN,"%s",strLocalUri);
				}
				else
				{

					snprintf(strContact,IP_STRING_LEN,"%s",m_pNetSetup->GetSrcPartyAddress());

				}
			}
			else if(strLocalUri && strLocalUri[0])
			{
				strFromAddr = strLocalUri;
				snprintf(strContact,IP_STRING_LEN,"%s",strFromAddr);
			}
			else
			{
				strFromAddr = m_pNetSetup->GetSrcPartyAddress();
				snprintf(strContact,IP_STRING_LEN,"%s",strFromAddr);
			}
        }
		const char* strRemoteUri		= m_pNetSetup->GetRemoteSipAddress();
		const char* strContactDisplay	= "";
		const char* strConfParamInfo	= m_strConfParamInfo.GetString();

		if (alternativeAddrStr && alternativeAddrStr[0])
		{
			strToDisplay	= "";
			strToAddr		= alternativeAddrStr;
			strDestAddr 	= alternativeAddrStr;
		}
		else
		{
			strToDisplay	= m_pNetSetup->GetRemoteDisplayName();
			strToAddr		= strRemoteUri[0]? strRemoteUri: strDestAddr;


			std::string sKey;
			std::string sipURIsuffix;

			sKey = "SIP_AUTO_SUFFIX_EXTENSION";
			CProcessBase::GetProcess()->GetSysConfig()->GetDataByKey(sKey, sipURIsuffix);
		 	int sipURIsuffixLen = sipURIsuffix.size();
			if( (sipURIsuffixLen>0) && (strstr(strToAddr, sipURIsuffix.c_str()) == NULL))

			{
			   memset(newstrToAddr, 0, IP_STRING_LEN);
			   strncpy(newstrToAddr, strToAddr, IP_STRING_LEN-1);
		 	   strncat(newstrToAddr, sipURIsuffix.c_str(), IP_STRING_LEN);
		 	   strToAddr = newstrToAddr;
			}
		}

		if (m_pNetSetup->GetRemoteSipAddressType() == PARTY_SIP_TELURL_ID_TYPE)/*do we need to add this in case of Amdocs?*/
		{
		    char * sipTelURIsuffix = ";user=phone";
		    if( strstr(strToAddr, sipTelURIsuffix) == NULL )
		    {
				memset(newstrToAddr, 0, IP_STRING_LEN);
				strncpy(newstrToAddr, strToAddr, IP_STRING_LEN-1);
				strncat(newstrToAddr, sipTelURIsuffix, IP_STRING_LEN-1);
				strToAddr = newstrToAddr;
		    }
		}

		//=============================================================================
		// For REDCOM GW calls, source address related headers need to be reformatted
		//=============================================================================
		char fromAddrManipBuf	[IP_STRING_LEN];
		char contactManipBuf	[IP_STRING_LEN];
		const char* pStrContact	= strContact;
		BOOL redcomReformat 	= NO;
		std::string key 		= "SIP_FORMAT_GW_HEADERS_FOR_REDCOM";
		CProcessBase::GetProcess()->GetSysConfig()->GetBOOLDataByKey(key, redcomReformat);
		if(redcomReformat)
		{
			strFromAddr = StripGWDecorationFromHost(strFromAddr,	fromAddrManipBuf);
			pStrContact	= StripGWDecorationFromHost(strContact,		contactManipBuf);
		}
		int toDisplayLen		= strlen(strToDisplay);
		int toAddrLen			= strlen(strToAddr);
		int fromDisplayLen		= strlen(strFromDisplay);
		int fromAddrLen			= strlen(strFromAddr);
		int contactDisplayLen	= strlen(strContactDisplay);
		int localAddrLen		= strlen(strLocalAddr);
		int destAddrLen			= strlen(strDestAddr);
		int confParamLen		= m_strConfParamInfo.GetStringLength();
		int MSconversationIdLen = strlen(strMsConversationId);

		TRACEINTO << "CSipCntl::SipInviteReq - strToDisplay - " << strToDisplay << "\n strToAddr - " << strToAddr
		<< "\n strFromDisplay - " << strFromDisplay << "\n strFromAddr - " << strFromAddr << "\n strContactDisplay - " << strContactDisplay
		<< "\n strLocalAddr - " << strLocalAddr << "\n strDestAddr - " << strDestAddr <<  "\n strMsConversationId- "<<strMsConversationId << "\n";

		if(pConfParty->GetMsftAvmcuState() == eMsftAvmcuNone)
		{
			snprintf(strContact,IP_STRING_LEN,"%s",strLocalAddr);
			AddParamsToContactHeader(strContact); //_dtls_
		}

		CSipHeaderList headerList(MIN_ALLOC_HEADERS*2, 7/*8*/,
			(int)kToDisplay,		toDisplayLen,		strToDisplay,
			(int)kTo,				toAddrLen,			strToAddr,
			(int)kFromDisplay,		fromDisplayLen,		strFromDisplay,
			(int)kFrom,				fromAddrLen,		strFromAddr,
			(int)kContactDisplay,	contactDisplayLen,	strContactDisplay,
			(int)kContact,			strlen(strContact),	strContact,
			(int)kProprietyHeader,	confParamLen,		strConfParamInfo/*,
			(int)kSdpSession_i,		informationLen,		strInformation*/);

		if(MSconversationIdLen > 0)
		{
			headerList.AddHeader(kMsConversationId, MSconversationIdLen, strMsConversationId);
		}

		if (GetIsMrcCall())
		{
			AddMrdHeader(headerList);
			AddInfoHeader(headerList);
		}

		// cdr headers start
 		if (GetSystemCfgFlagInt<BOOL>(m_serviceId, CFG_KEY_SIP_IMS))
			BuildIMSHeaders(headerList, strFromDisplay, strFromAddr, strLocalAddr);

		SetDialOutSessionTimerHeaders(headerList, rmtSessionTimerMinSec);
		//========================
		// Adding Qos header
		//========================
		BYTE 		precedRPrio;
		const char*	precedDomain;
		if (GetQosParams(precedDomain, precedRPrio))
		{
			AddQosHeader(headerList, precedDomain, precedRPrio);
		}
		//========================

		AddParamsToSupportedHeader(headerList); //_dtls_

		// cdr headers end
		int headersSize  = headerList.GetTotalLen();
		int channelsSize = m_pCall->CalcCapBuffersSize(cmCapReceive, YES);
		int localCapSize = m_pChosenLocalCap ->CalcCapBuffersSize(cmCapReceiveAndTransmit, NO);
		int localSdesCapSize = m_pChosenLocalCap ->CalcSdesOnlyCapBuffersSize(cmCapReceiveAndTransmit, NO);


		int simulcastMLinesSize = 0;

		//added for MS Lync2013
		if (pServiceParams->GetSipServerType() == eSipServer_ms && isMsftSvc2013Supported() && eMsft2013AvMCU == m_isMs2013Active)
		{
			//localCapSize *= ( 1 + MaxMsftSvcSimulcastVideoMlines );

			int videoCapSize = 0;
			int videoSdesCapSize = 0;
			videoCapSize = m_pChosenLocalCap->CalcCapBuffersSize(cmCapVideo, cmCapReceiveAndTransmit, NO, TRUE, kRolePeople);
			videoCapSize *= MaxMsftSvcSimulcastVideoMlines;
			videoSdesCapSize = m_pChosenLocalCap ->CalcSdesOnlyCapBuffersSize(cmCapVideo, cmCapReceiveAndTransmit, NO, TRUE, kRolePeople);

			simulcastMLinesSize = (videoCapSize + videoSdesCapSize) *  MaxMsftSvcSimulcastVideoMlines ;
		}
		PTRACE2INT(eLevelInfoNormal,"dbg CSipCntl::SipInviteReq simulcastMLinesSize =", simulcastMLinesSize);
		// local caps and channels data contains overlapping information
		// so the following size will be larger than what we actually set in the capabilities struct
		int capabilitiesSize = sizeof(sipMediaLinesEntryBaseSt) + channelsSize + localCapSize + localSdesCapSize + simulcastMLinesSize + 20000;
		int capsAndHeadersSize	= headersSize + capabilitiesSize;
		int totalSize			= sizeof(mcReqInvite);
		totalSize				+= capsAndHeadersSize;


		//added for ANAT, calculate m line for another ip address type
		if (IsAnatSupported())
			totalSize += channelsSize + localCapSize;

		mcReqInvite* pInviteMsg = (mcReqInvite *)new BYTE[totalSize];
		memset(pInviteMsg, 0, totalSize);

		sipSdpAndHeadersSt* pSdpAndHeaders	= (sipSdpAndHeadersSt*) &pInviteMsg->sipSdpAndHeaders;

		pSdpAndHeaders->callRate = m_pNetSetup->GetMaxRate() / 100;// the values should be in 100 bit per second.

		//LYNC2013_FEC_RED:  in case of audio only + RED ON we will send audio with rate *2
		if ( m_pCall && pSdpAndHeaders && m_isMs2013Active )
		{
			DWORD audioRate = m_pCall->GetAudioRate(cmCapReceive);

			TRACEINTO << "LYNC2013_FEC_RED: isMs2013Active:" << m_isMs2013Active << ", call rate before:" << pSdpAndHeaders->callRate << ", add more:" << audioRate;

			pSdpAndHeaders->callRate += audioRate; //m_pParty->GetTargetMode()->GetMediaBitRate(cmCapAudio, cmCapReceive, kRolePeople);

			//TRACEINTO << "LYNC2013_FEC_RED: call rate after:" << pInviteResponseMsg->sipSdpAndHeaders.callRate;
		}

		if(pCommConf && pCommConf->GetTelePresenceModeConfiguration() != NO )
		{
			memset (&pSdpAndHeaders->cCname,'\0',CNAME_STRING_MAX_LEN +1);
			BuildCnameStringFromMask(m_RtcpCnameMask,pSdpAndHeaders->cCname);
		}

		if( pServiceParams->GetSipServerType() == eSipServer_ms &&  isMsftSvc2013Supported() &&  m_isMs2013Active )
		{
			if(eMsft2013AvMCU == m_isMs2013Active)
			{
				pSdpAndHeaders->msVideoRateRx = MaxMsftSvcSimulcastVideoMlines * m_pChosenLocalCap->GetMaxVideoBitRate(cmCapReceiveAndTransmit, kRolePeople) / 10;
				pSdpAndHeaders->msVideoRateTx = 3 * m_pChosenLocalCap->GetMaxVideoBitRate(cmCapReceiveAndTransmit, kRolePeople) / 10; //  - define 3
			} else
			{
				pSdpAndHeaders->msVideoRateRx = m_pChosenLocalCap->GetMaxVideoBitRate(cmCapReceiveAndTransmit, kRolePeople) / 10;
				pSdpAndHeaders->msVideoRateTx = m_pChosenLocalCap->GetMaxVideoBitRate(cmCapReceiveAndTransmit, kRolePeople) / 10;
			}
			pSdpAndHeaders->msAudioRateTx = MAX_LYNC_AUDIO;
			pSdpAndHeaders->msAudioRateRx = MAX_LYNC_AUDIO;

		}

//		pSdpAndHeaders->callRate = m_pCall->GetCallRate(cmCapReceive);// change because of bug VNGR-1097
		if (m_isNeedToResetCallIndex)
		{
			m_callIndex = 0;
			m_pCall->SetCallIndex(m_callIndex);
		}

		BOOL bOverrideSavpWithAvp  = IsForceAvpOnEncryptWhenPossible();
		APIU16 plcmRequireMask 	   = bOverrideSavpWithAvp?m_plcmRequireAvp:0;

		PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteReq before CopyToCaps");
		int exactCapsSize =
			m_pCall->CopyCapsToCapStruct((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
											capabilitiesSize, NULL,	NULL, cmCapReceive, FALSE,
											m_bIsReInviteTransaction, GetIsAllowSdesInSdp(), kUnknown, plcmRequireMask,m_pChosenLocalCap);


		PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteReq after CopyToCaps");
/*
		CSuperLargeString strCaps1;
		m_pChosenLocalCap ->DumpToString(strCaps1);
		PTRACE2(eLevelInfoNormal,"CSipCntl::SipInviteReq Dump regular caps   m_pChosenLocalCap =",strCaps1.GetString());

		CLargeString strCaps2;
		m_pChosenLocalCap ->DumpIceCapsToString(strCaps2);
		PTRACE2(eLevelInfoNormal,"CSipCntl::SipInviteReq Dump ICE caps pTempRemoteCap=",strCaps2.GetString());
*/
		eMediaLineSubType bfcpType = GetBfcpType();

		if ( GetSystemCfgFlagInt<BOOL>(CFG_KEY_SIP_REINVITE) )
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteReq before AddCaps");
			BYTE addContentCap = FALSE; // We don't add content in the initial invite-req.
			exactCapsSize = m_pChosenLocalCap ->AddCapsToCapStruct(cmCapReceiveAndTransmit,
															NO,
															(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
															capabilitiesSize,bfcpType, YES, YES, YES, addContentCap, NO, bOverrideSavpWithAvp);

			//PTRACE2(eLevelInfoNormal,"Anat SipInviteReq, m line from LocalCaps 2: \n",ostr1.str().c_str()); //debug for ANAT
		}
		else
		{
			CCapSetInfo capInfo	= eRfc2833DtmfCapCode;
			int dtmfIndex  = m_pChosenLocalCap ->GetIndexInArr(capInfo, 0);
			if (dtmfIndex != NA)
			{
				exactCapsSize = m_pChosenLocalCap ->AddSingleCapToCapStruct(cmCapAudio, dtmfIndex,
																	cmCapReceiveAndTransmit, NO,
																	(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																	capabilitiesSize, bfcpType);
			}
		}

		int audioIceSize = m_pChosenLocalCap ->CalcIceCapBufferSize(eAudioSession,cmCapReceive);
        int videoIceSize = m_pChosenLocalCap ->CalcIceCapBufferSize(eVideoSession,cmCapReceive);
        int dataIceSize = m_pChosenLocalCap ->CalcIceCapBufferSize(eDataSession,cmCapReceive);

		capabilitiesSize = exactCapsSize + audioIceSize + videoIceSize + dataIceSize;


		//added for ANAT
		if (IsAnatSupported())
		{
            int addSize = CopyMLineFromLocalForAnat(pSdpAndHeaders);
			capabilitiesSize += addSize;

			/*COstrStream ostrAnat;
			DumpMediaLineEntry((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,ostrAnat);
			PTRACE2(eLevelInfoNormal,"Anat SipInviteReq, m line After ANAT: \n",ostrAnat.str().c_str()); */ //debug for ANAT
		}

		capsAndHeadersSize = headersSize + capabilitiesSize;

		pSdpAndHeaders->sipMediaLinesOffset = 0;
		pSdpAndHeaders->sipMediaLinesLength = capabilitiesSize;
		pSdpAndHeaders->sipHeadersOffset = capabilitiesSize;
		pSdpAndHeaders->sipHeadersLength = headersSize;
		pSdpAndHeaders->lenOfDynamicSection = capsAndHeadersSize;

		// Set Session IP address
		((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->bMainMediaIpPresent = TRUE;
		SetSessionIpAddress(((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->mainMediaIp,isResultOfIpMediaMismatch);

		SetIpAddressToAllMedias(pSdpAndHeaders,isResultOfIpMediaMismatch);

		if(pServiceParams->GetSipServerType() == eSipServer_ms && isMsftSvc2013Supported() && m_isMs2013Active)
			SetLync2013SpecificMLinesAttributes(*pSdpAndHeaders);

		//added for MS Lync2013
		if (pServiceParams->GetSipServerType() == eSipServer_ms && isMsftSvc2013Supported() && eMsft2013AvMCU == m_isMs2013Active )
		{
			int addSize = AddSimulcastVideoMLinesToSDPForLync2013(pSdpAndHeaders);
			capabilitiesSize += addSize;
			PTRACE2INT(eLevelInfoNormal,"dbg CSipCntl::SipInviteReq addSize =", addSize);
			// update length and offset fields in SDP struct
			capsAndHeadersSize = headersSize + capabilitiesSize;
			pSdpAndHeaders->sipMediaLinesLength = capabilitiesSize;
			pSdpAndHeaders->sipHeadersOffset = capabilitiesSize;
			pSdpAndHeaders->lenOfDynamicSection = capsAndHeadersSize;
		}

		m_pNetSetup->SetSipLocalMediaType((enIpVersion)ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.ipVersion);

		sipMessageHeaders* pHeaders = (sipMessageHeaders*) ((char*) pSdpAndHeaders->capsAndHeaders + pSdpAndHeaders->sipHeadersOffset);
		headerList.BuildMessage(pHeaders);

		//remote port will NOT be use if the call is trough an outbound proxy
		pInviteMsg->transportAddress.transAddr.port = m_pNetSetup->GetRemoteSignallingPort();

		// invite message struct may be filled up with either an ip address
		// or a domain name. domain name, requires a dns lookup by CS.
		BYTE bUserDialWithIp = TRUE; // no dns lookup is needed
		if (bDialDirect)
		{
 	            if( strAlternativeTransportIp[0] != '\0' )
		    {
		       mcTransportAddress trAddr;
		       memset(&trAddr,0,sizeof(mcTransportAddress));
		       ::stringToIp(&trAddr,strAlternativeTransportIp);
		       BYTE isIpAddrValid = ::isApiTaNull(&trAddr);
		       if (isIpAddrValid != TRUE)
		       {
		               isIpAddrValid = ::isIpTaNonValid(&trAddr);
		               if (isIpAddrValid != TRUE)
		               {
		        	       strncpy(strTransportIp, strAlternativeTransportIp, 64);
		        	       strTransportIp[sizeof(strTransportIp) - 1] = '\0';
		               }
		       }
		       else
		       {       // dns lookup(by CS) is needed
		               memcpy(pInviteMsg->domainName, strAlternativeTransportIp, IPV6_ADDRESS_LEN);
		               bUserDialWithIp = FALSE;
		       }
		    }
		    else
		    {
		        char str[64];
		        memset(str,'\0',64);
		        ::ipToString( *pDestTaAddr,str,1);
		        DWORD destLen = strlen(str);
		        strncpy(strTransportIp, str, 64);
		        strTransportIp[sizeof(strTransportIp) - 1] = '\0';
		    }
		     TRACEINTO << "CSipCntl::SipInviteReq - strTransportIp (Dial direct) " << strTransportIp;
		}
		else if(pProxyAddress[0] != '\0')
		{
			// if uri contains the proxy ip address or contains registrar domain name
			// or contains a format of "user@domain"
			if (  (bIsUriWithIp && strcmp(strHostIp,pProxyAddress)==0) ||
				  (bIsUriWithIp && strcmp(strHostIp,m_pNetSetup->GetLocalHost())==0)  || !bIsUriWithIp )
				// User Dial With Proxy
				{
					pInviteMsg->bIsOutboundProxyInUse = YES;
					pInviteMsg->transportAddress.transAddr.port = 0; // card will take port from proxy's service
					mcTransportAddress trAddr;
					memset(&trAddr,0,sizeof(mcTransportAddress));
					::stringToIp(&trAddr,pProxyAddress);
					if (!::isApiTaNull(&trAddr) && !::isIpTaNonValid(&trAddr))
					{
							strncpy(strTransportIp, pProxyAddress, sizeof(strTransportIp) - 1);
							strTransportIp[sizeof(strTransportIp) - 1] = 0;
					}
					else
					{	// dns lookup(by CS) is needed
						memcpy(pInviteMsg->domainName,pProxyAddress,MaxLengthOfSingleUrl);
						bUserDialWithIp = FALSE;
					}
				}
			else if(bIsUriWithIp) // uri with a none proxy/registrar ip address
			{
				// direct dial
			    if (hostLen < IPV6_ADDRESS_LEN)
			    {
				        strncpy(strTransportIp, strHostIp, hostLen + 1);
			    		strTransportIp[hostLen] = 0;
			    }
			    else
			    {
                   		 PTRACE2(eLevelInfoNormal,"CSipCntl::SipInviteReq host ip is longer that 64 chars", strHostIp);
                  		  strncpy(strTransportIp, strHostIp, sizeof(strTransportIp) - 1);
                 		   strTransportIp[sizeof(strTransportIp) - 1] = 0;
			    }
			}
		}
		// no proxy is defined but ip with uri exists
		else if(bIsUriWithIp)
		{
            const int maxStringSize = min(IPV6_ADDRESS_LEN - 1, hostLen + 1);
            strncpy(strTransportIp, strHostIp, maxStringSize);
            strTransportIp[maxStringSize] = 0;
		}
		else
			strTransportIp[0] = 0;

		if(bUserDialWithIp)
		{
			mcTransportAddress trAddr;
			memset(&trAddr,0,sizeof(mcTransportAddress));
			::stringToIp(&trAddr,strTransportIp);
			if (trAddr.ipVersion == eIpVersion4)
				pInviteMsg->transportAddress.transAddr.addr.v4.ip = trAddr.addr.v4.ip;
			else
			{
				pInviteMsg->transportAddress.transAddr.ipVersion = eIpVersion6;
				memcpy(pInviteMsg->transportAddress.transAddr.addr.v6.ip, trAddr.addr.v6.ip, 16);
				pInviteMsg->transportAddress.transAddr.addr.v6.scopeId = ::getScopeId(strTransportIp);
			}
		}

		//change ICE subType (TCP/RTP/AVP etc.)
		SetIceMlineSubTypesIfNeeded(pSdpAndHeaders);


		if (pConfParty && pConfParty->GetMsftAvmcuState() != eMsftAvmcuNone )
			pInviteMsg->bIsAVMCU = TRUE;
		else
			pInviteMsg->bIsAVMCU = FALSE;

		TRACEINTO << "GetAvMcuLinkType: " << m_pParty->GetAvMcuLinkType();

/*		if(pConfParty && pConfParty->GetMsftMediaEscalationStatus() == eMsftEscalationInActive )
		{
			TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kInactive,kInactive,kInactive,kInactive,kInactive)";
			SetTheDirectionAttribute(pSdpAndHeaders,kInactive,kInactive,kInactive,kInactive,kInactive);
		}
*/
		//POBJDELETE(pLanCfg);
		pInviteMsg->transportAddress.transAddr.transportType = m_transportType;

		// IpV6
		//enIpVersion eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);

		//set XML params
		//pInviteMsg->transportAddress.unionProps.unionType = eIpAddrMatch;//assuming the signaling type is equal to the media IP address type.
		pInviteMsg->transportAddress.unionProps.unionType = pInviteMsg->transportAddress.transAddr.ipVersion;  //modified for ANAT
		pInviteMsg->transportAddress.unionProps.unionSize = sizeof(ipAddressIf);

		//add for CG_SoftMCU
		if (IsCallGeneratorConf())
		{
			pInviteMsg->callGeneratorParams.bIsCallGenerator=1;
			pInviteMsg->callGeneratorParams.eEndpointModel=endpointModelHDX9000;
		}

		SetCallLegAndCdrHeaders(pInviteMsg->sipSdpAndHeaders);
		SetSelfFlowControl(NO);
		ReduceVideoRate(NO, &pInviteMsg->sipSdpAndHeaders);
		//m_pLoadMngrConnector->RequestCallConnectEnterSection();
		SetLocalSdp(pInviteMsg->sipSdpAndHeaders);
		size_t size = sizeof(mcReqInvite) + pInviteMsg->sipSdpAndHeaders.lenOfDynamicSection;


		SendSIPMsgToCS(SIP_CS_SIG_INVITE_REQ, pInviteMsg, size);
		bMessageSent = YES;
		StartTimer(PARTYCONNECTTOUT, GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_MSG_TIMEOUT) * SECOND);
		PDELETEA(pInviteMsg);
		PDELETEA(strLocalUri);
		PDELETEA(newstrToAddr);
		PDELETEA(pProxyAddress);
	}
	else if (m_outboundProxyIp == 0)// get the proxy IP from DNS
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteReq: Zero IP. Get IP from DNS");
	}

	if(eMsft2013AvMCU == m_isMs2013Active && !m_IsEnableICE)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteReq - remove fake candidates end");
		m_pCall->ClearIceData();
	}

	return bMessageSent;
}
//////////////////////////////////////////////////////////////////////////////
enIMSSipPsiSource CSipCntl::CheckIMSPublicServiceIdentitySource()
{
	std::string strIMSSource = GetSystemCfgFlagStr<std::string>(m_serviceId,CFG_KEY_SIP_PSI_SOURCE);
	if (strIMSSource.length() > 0)
	{
		if (strstr(strIMSSource.c_str(), IMS_PSI_SOURCE_FACTORY) != NULL)
			return eIMSSourceFactory;
		if (strstr(strIMSSource.c_str(), IMS_PSI_SOURCE_EQ) != NULL)
			return eIMSSourceEntryQ;
	}
	return eIMSSourceNone;
}
//////////////////////////////////////////////////////////////////////////////
void CSipCntl::BuildIMSHeaders(CSipHeaderList& headerList, const char* strFromDisplay, const char* strFromAddr, const char* strLocalAddr)
{
	std::string strIMSPubSrvcIden = GetSystemCfgFlagStr<std::string>(m_serviceId, CFG_KEY_SIP_PSI_URI);
	if (strIMSPubSrvcIden.length() < 1 || CheckIsFactoryAtDomain(strIMSPubSrvcIden.c_str()) == NO)
	{
		enIMSSipPsiSource eTempIMSSource = CheckIMSPublicServiceIdentitySource();
		if (eTempIMSSource == eIMSSourceNone)	//in this case Route Header is not necessary
			BuildIMSAssertedHeader(headerList, strFromDisplay, strFromAddr);
		else
		{
			const char* pFirstName = NULL;
			if (eTempIMSSource == eIMSSourceFactory)
				pFirstName = ::GetpMeetingRoomDB()->GetFirstSIPFactoryName();
			else	//eTempIMSSource == eIMSSourceEntryQ
				pFirstName = ::GetpMeetingRoomDB()->GetFirstEntryQueueName();
			const char* pDomainName = GetCurrentDomainAt(strFromAddr);
			if (pFirstName != NULL && pDomainName != NULL)
			{
				//Only in case of Factory or EntryQ with valid name and domain needs Route!
				//format Route: <sip:domain_name:port;lr;orig>
				BuildIMSRouteHeader(headerList, strFromAddr);
				CSmallString stringTemp;
				stringTemp << pFirstName << pDomainName;
				BuildIMSAssertedHeader(headerList, strFromDisplay, stringTemp.GetString());
			}
			else
				BuildIMSAssertedHeader(headerList, strFromDisplay, strFromAddr);
		}
	}
	else
	{
		//If PSI is valid needs Route!
		//format Route: <sip:domain_name:port;lr;orig>
		BuildIMSRouteHeader(headerList, strFromAddr);
		BuildIMSAssertedHeader(headerList, strFromDisplay, strIMSPubSrvcIden.c_str());
	}

	// format - P-Charging-Vector: icid-value="<unique_num>-<con_id>"
	BuildIMSChargingHeader(headerList, strLocalAddr);
}
//////////////////////////////////////////////////////////////////////////////
//format P-Asserted-Identity: <sip:user@domain>
void CSipCntl::BuildIMSAssertedHeader(CSipHeaderList& headerList, const char* strFromDisplay, const char* strFromAddr)
{
	CSmallString stringAssertedIdentity = "P-Asserted-Identity:";
	stringAssertedIdentity << strFromDisplay << " <sip:" << strFromAddr << ">";
	const char* strAssertedIdentity = stringAssertedIdentity.GetString();
	int			assertedIdentityLen	= stringAssertedIdentity.GetStringLength();
	//in function AddHeader there is memcopy
	headerList.AddHeader(kPrivateHeader, assertedIdentityLen, strAssertedIdentity);
}
//////////////////////////////////////////////////////////////////////////////
// format - P-Charging-Vector: icid-value="<unique_num>-<con_id>"
void CSipCntl::BuildIMSChargingHeader(CSipHeaderList& headerList, const char* strLocalAddr)
{
	CSmallString stringChargingVector = "P-Charging-Vector:icid-value=\"";
	char uniqueNumber[16];
	::CalculateUniqueNumber(uniqueNumber, SystemIpStringToDWORD(strLocalAddr));
	DumpUniqueNumberToString(uniqueNumber,16,"","",stringChargingVector);
	stringChargingVector << "-" << m_pCall->GetConId() << "\"";
	const char* strChargingVector = stringChargingVector.GetString();
	int			chargingVectorLen = stringChargingVector.GetStringLength();
	headerList.AddHeader(kPrivateHeader, chargingVectorLen, strChargingVector);
}

//////////////////////////////////////////////////////////////////////////////
//format Route: <sip:domain_name:port;lr;orig>
void CSipCntl::BuildIMSRouteHeader(CSipHeaderList& headerList, const char* strFromAddr)
{
	//example - Route: <sip:scsf-stdn.ims-002.rel2.ims.net:5060;lr;orig>
	CIpServiceListManager* pIpServiceListManager = ::GetIpServiceListMngr();
	CConfIpParameters* pServiceParams = pIpServiceListManager->FindIpService(m_serviceId);
	if (pServiceParams == NULL)
	{
		PASSERTMSG(m_pCsRsrcDesc->GetConnectionId(), "CSipCntl::BuildIMSRouteHeader - IP Service not found!");
		return;
	}
	CONF_IP_PARAMS_S*  pServiceParamsStruct = pServiceParams->GetConfIpParamsStruct();
	if (pServiceParamsStruct == NULL)
	{
		PASSERTMSG(m_pCsRsrcDesc->GetConnectionId(), "CSipCntl::BuildIMSRouteHeader - IP Service parameters not exsist!");
		return;
	}

	BASE_SIP_SERVER_S& rProxy  = pServiceParamsStruct->sip.proxy;
	SIP_SERVER_S&      rServer = pServiceParamsStruct->sip.registrar;
	CSmallString stringRoute = "Route:<sip:";

	if (rProxy.status != eServerStatusOff)
		stringRoute << rProxy.hostName << ":" << rProxy.port;
	else if (rServer.baseSipServer.status != eServerStatusOff)
		stringRoute << rServer.baseSipServer.hostName << ":" << rServer.baseSipServer.port;
	else
	{
		const char* pDomainName = GetCurrentDomain(strFromAddr);
		if (!pDomainName)
			stringRoute << strFromAddr;
		else
			stringRoute << pDomainName;
		stringRoute << ":5060";
	}
	stringRoute << ";lr;orig>";
	const char* strRoute = stringRoute.GetString();
	int			routeLen = stringRoute.GetStringLength();
	headerList.AddHeader(kPrivateHeader, routeLen, strRoute);
}
////////////////////////////////////////////////////
// use only to set the call index (arrives after trying and ringing).
void CSipCntl::OnCsProvisunalResponseInd(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	CMedString str;

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;
	m_callIndex = callIndex;
	m_pCall->SetCallIndex(m_callIndex);

	mcIndProvResponse* pProvisunalMsg = (mcIndProvResponse *)pParam->GetPtr(1);
	str << "Name - " << PARTYNAME << " Status - " << pProvisunalMsg->status;
	if((180<= pProvisunalMsg->status) && (189 >= pProvisunalMsg->status))
	{
		SetRecevRingback(TRUE);
	}
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnCsProvisunalResponseInd, ", str.GetString());
}

//////////////////////////////////////////////////////////////////////////////
BOOL CSipCntl::IsForceSavpOnEncryptAll()
{
	BOOL bIsCucm 				 = FALSE;
	BOOL bIsForceAvpAllFlag		 = FALSE;
	BOOL bIsForceAvpCucmFlag	 = FALSE;
	BOOL bIsEncryptAll 			 = FALSE;
	BOOL bForceSavp 			 = FALSE;
	BOOL bIsTipCall 	 		 = FALSE;


	bIsEncryptAll = IsEncryptAllMode();

	IsForceAvpOnEncryptWhenPossibleFlag(bIsForceAvpAllFlag , bIsForceAvpCucmFlag);

	bIsCucm    = (m_remoteIdent == CiscoCucm);

	bIsTipCall = GetIsTipCall();

	bForceSavp = bIsEncryptAll &&
				 (bIsForceAvpAllFlag  ||  (bIsCucm && bIsForceAvpCucmFlag)  ||  (bIsTipCall && bIsForceAvpCucmFlag));

	if(bForceSavp)
	{
		CMedString str;
		str << "bIsEncryptAll " << bIsEncryptAll << " bIsEncryptAll " << bIsEncryptAll <<" bIsForceAvpAllFlag " << bIsForceAvpAllFlag << " bIsForceAvpCucmFlag " << bIsForceAvpCucmFlag << " bIsCucm " << bIsCucm << " bIsTipCall " << bIsTipCall;
		PTRACE2(eLevelInfoNormal,"CSipCntl::IsForceSavpOnEncryptAll : ", str.GetString());
	}

	return bForceSavp;
}

//////////////////////////////////////////////////////////////////////////////
BOOL CSipCntl::IsForceAvpOnEncryptWhenPossible()
{
	BOOL bIsCucm 				 = FALSE;
	BOOL bIsForceAvpAllFlag		 = FALSE;
	BOOL bIsForceAvpCucmFlag	 = FALSE;
	BOOL bIsEncryptWhenAvailable = FALSE;
	BOOL bOverrideSavpWithAvp 	 = FALSE;
	BOOL bIsTipCall 	 		 = FALSE;
	BOOL bIsRemoteSavp			 = FALSE;
	BOOL bIsRemoteSavpOnReInvite = FALSE;
	BOOL bIsMicrosoftEP			 = FALSE;
	BOOL bIsRemoteSdpAvailable	 = FALSE;


	bIsEncryptWhenAvailable = IsWhenAvailableEncryptionMode();

	IsForceAvpOnEncryptWhenPossibleFlag(bIsForceAvpAllFlag , bIsForceAvpCucmFlag);


	bIsCucm    = (m_remoteIdent == CiscoCucm);

	bIsTipCall = GetIsTipCall();

	bIsRemoteSavp = IsRemoteSavp();

	bIsRemoteSavpOnReInvite = bIsRemoteSavp && m_bIsReInviteTransaction;

	bIsMicrosoftEP = IsRemoteMicrosoft();

	bIsRemoteSdpAvailable = m_pRemoteSdp && (m_pRemoteSdp->sipMediaLinesLength > 0);

	bOverrideSavpWithAvp = bIsEncryptWhenAvailable &&
						   (bIsForceAvpAllFlag  ||  (bIsCucm && bIsForceAvpCucmFlag)  ||  (bIsTipCall && bIsForceAvpCucmFlag)) &&
						   !bIsMicrosoftEP &&
						   !bIsRemoteSdpAvailable;

	//if(bOverrideSavpWithAvp)
	//{
		CMedString str;
		str << "bOverrideSavpWithAvp " << bOverrideSavpWithAvp << " bIsEncryptWhenAvailable " << bIsEncryptWhenAvailable <<" bIsForceAvpAllFlag "
			<< bIsForceAvpAllFlag << " bIsForceAvpCucmFlag " << bIsForceAvpCucmFlag << " bIsCucm " << bIsCucm << " bIsTipCall " << bIsTipCall
			<< " bIsRemoteSavp " << bIsRemoteSavp << " bIsRemoteSavpOnReInvite " << bIsRemoteSavpOnReInvite << " bIsMicrosoftEP " << bIsMicrosoftEP << " bIsRemoteSdpAvailable " << bIsRemoteSdpAvailable;

		PTRACE2(eLevelInfoNormal,"CSipCntl::IsForceAvpOnEncryptWhenPossible : ", str.GetString());
	//}

	return bOverrideSavpWithAvp;
}

//////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipReInviteReq(DWORD reinviteReason, BYTE bIsFirstOffer)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipReInviteReq");

	//CSuperLargeString msgPM4;
	//m_pChosenLocalCap->DumpToString(msgPM4);

	BYTE bMessageSent = NO;
	int dataSize  = 0;
	const char* strLocalAddr = m_pNetSetup->GetLocalSipAddress();
	CSipHeaderList* pCallLegHeaders = m_pCall->GetCallLegHeaders();
	int exactCapsSize = 0;
	int numberOfNotSupported = 0;
	int sizeOfNotSupported = 0;
	int sizeOfClosed = 0;

	vector<eMediaLineInternalType> closedChannelsCopiedTypes;
	CLargeString print_str;
	vector<int> closedChannelsCopiedIndexes;  //added for ANAT

	//Add Ice to channels
	if(m_IsEnableICE)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SipReInviteReq - ice enabled ");
		m_pCall->ClearIceData();
		m_pCall->SetIceData(m_pChosenLocalCap );
	}
	else if(eMsft2013AvMCU == m_isMs2013Active)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SipReInviteReq - create fake ice candidates");
		CreateFakeIceCandidates();
	}

	if (pCallLegHeaders)
	{
		CSipHeaderList headerList(*pCallLegHeaders);
		if (GetIsMrcCall())
		{
			AddMrdHeader(headerList);
			AddInfoHeader(headerList);
		}

		//========================
		// Adding Qos header
		//========================
		BYTE 		precedRPrio;
		const char*	precedDomain;
		if (GetQosParams(precedDomain, precedRPrio))
		{
			AddQosHeader(headerList, precedDomain, precedRPrio);
		}
		//========================

		//=============================================================================
		// For REDCOM GW calls, source address related headers need to be reformatted
		//=============================================================================
		char contactManipBuf	[IP_STRING_LEN];
		BOOL redcomReformat 	= NO;
		std::string key 		= "SIP_FORMAT_GW_HEADERS_FOR_REDCOM";
		CProcessBase::GetProcess()->GetSysConfig()->GetBOOLDataByKey(key, redcomReformat);
		if(redcomReformat)
		{
			strLocalAddr = StripGWDecorationFromHost(strLocalAddr, contactManipBuf);
		}
		headerList.AddHeader(kContactDisplay,strlen(""),"");
		headerList.AddHeader(kContact,strlen(strLocalAddr),strLocalAddr);
		if (m_pCall->IsMedia(cmCapVideo,cmCapReceive) == NO && m_pCall->IsMedia(cmCapVideo,cmCapTransmit) == NO) // only if it is secondary
		{
			if (m_strConfParamInfo.IsEmpty() == NO)
			{
				headerList.AddHeader(kProprietyHeader,m_strConfParamInfo.GetStringLength(),m_strConfParamInfo.GetString());
			}
		}
        if (reinviteReason == SIP_CS_SIG_SESSION_TIMER_REINVITE_IND) {
        	headerList.AddHeader(kSdpSession_o_version, strlen("NO"), "NO");
        	PTRACE(eLevelInfoNormal, "CSipCntl::SipReInviteReq, kSdpSession_o_version has been set");
        }

		AddParamsToSupportedHeader(headerList); //_dtls_

		if(CProcessBase::GetProcess()->GetProductType()==eProductTypeSoftMCUMfw)
			AddIBMDestinationPublicIpHeader(headerList);

 		int headersSize  = headerList.GetTotalLen();
		int channelsSize = m_pCall->CalcCapBuffersSize(cmCapReceive, YES);
		int localCapSize = m_pChosenLocalCap ->CalcCapBuffersSize(cmCapReceiveAndTransmit, NO);
		int notSupportedMediaLinesSize = 0;

		//added for ANAT, calculate m line for another ip address type
		if (IsAnatSupported())
		{
			channelsSize = channelsSize * 2;
			localCapSize = localCapSize * 2;
		}

		int simulcastMLinesSize = 0;
		if(eMsft2013AvMCU == m_isMs2013Active)
		{
			//localCapSize *= ( 1 + MaxMsftSvcSimulcastVideoMlines );
			int videoCapSize = 0;
			int videoSdesCapSize = 0;

			videoCapSize = m_pChosenLocalCap->CalcCapBuffersSize(cmCapVideo, cmCapReceiveAndTransmit, NO, TRUE, kRolePeople);
			videoCapSize *= MaxMsftSvcSimulcastVideoMlines;
			videoSdesCapSize = m_pChosenLocalCap ->CalcSdesOnlyCapBuffersSize(cmCapVideo, cmCapReceiveAndTransmit, NO, TRUE, kRolePeople);

			simulcastMLinesSize = (videoCapSize + videoSdesCapSize) *  MaxMsftSvcSimulcastVideoMlines ;
		}

		// calc unsupported m-lines size:
		numberOfNotSupported = ::GetNumberOfMediaLinesOfIntenalType(m_pRemoteSdp, kMediaLineInternalTypeNotSupported, sizeOfNotSupported);
		if (numberOfNotSupported > 0)
		{
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::SipReInviteReq : numberOfNotSupported = ", sizeOfNotSupported);
			notSupportedMediaLinesSize = sizeOfNotSupported;
		}
		BYTE isNotCopyFullRemovedContentLineTip = FALSE;
		if(GetIsTipCall() && m_pParty->GetTargetMode()->GetIsEncrypted() != Encryp_On)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::SipReInviteReq : for reinvite in tip do not copy full content medial line  ");
			isNotCopyFullRemovedContentLineTip = TRUE;
		}

		if (!IsAnatSupported())  //added for ANAT
			sizeOfClosed = GetClosedMediaSize();
		else
			sizeOfClosed = GetClosedMediaSizeForAnat();

		// local caps and channels data contains overlapping information
		// so the following size will be larger than what we actually set in the capabilities struct
		int capabilitiesSize = sizeof(sipMediaLinesEntrySt) + channelsSize + localCapSize + notSupportedMediaLinesSize + sizeOfClosed + simulcastMLinesSize;
		int capsAndHeadersSize = headersSize + capabilitiesSize;

		mcReqReInvite* pReInviteMsg = (mcReqReInvite*)new BYTE[sizeof(mcReqReInvite) + capsAndHeadersSize + 20000];
		size_t allocatedBufferSize = sizeof(mcReqReInvite) + capsAndHeadersSize + 20000;

		print_str << "Allocated buffer size = " << sizeof(mcReqReInvite) + capsAndHeadersSize << " sizeof(mcReqReInvite) = " << sizeof(mcReqReInvite) << " capsAndHeadersSize = " << capsAndHeadersSize;

		memset(pReInviteMsg, 0, sizeof(mcReqReInvite) + capsAndHeadersSize);
		sipSdpAndHeadersSt* pSdpAndHeaders = (sipSdpAndHeadersSt*)&pReInviteMsg->sipSdpAndHeaders;
		if(!pSdpAndHeaders)
		{
			TRACEINTO << "pSdpAndHeaders  is NULL, getting out of function " ;
			return NO ;
		}
		if(m_pParty->GetTargetMode()->GetConfType() != kCop)
		{
			// AN: for IBM vngfe-4195
			if (!IsSameTimeEP())//|| m_remoteIdent != CiscoCucm)
				pSdpAndHeaders->callRate = min( m_pCall->GetCallRate(cmCapReceive), m_pNetSetup->GetMaxRate() / 100 );
			else
				pSdpAndHeaders->callRate = min( m_pCall->GetCallRate(cmCapTransmit), m_pNetSetup->GetMaxRate() / 100 );
		}
		else
			pSdpAndHeaders->callRate = GetCopMaxCallRate();

		if(GetIsTipCall())
		{
			pSdpAndHeaders->callRate = m_pNetSetup->GetMaxRate() / 100;

			m_bDeclareVideoFromScmOnly = TRUE;
		}
		else
		{
			//LyncCCS
			//if (m_bIsCCSPlugin)
			pSdpAndHeaders->callRate += m_fullContentRate;

			// bridge-13131
			if( m_UserAgent && strstr(m_UserAgent, MICROSOFT_EP4Alias) )
			{
				TRACEINTO << "bridge-13131 call rate for OCPhone/4";
				pSdpAndHeaders->callRate = m_pParty->GetCurrentMode()->GetCallRate()*10;
			}

			DWORD netSetupMaxRate = m_pNetSetup->GetMaxRate() / 100;

			if (pSdpAndHeaders->callRate > netSetupMaxRate)
			{
				TRACEINTO << "callRate: " << pSdpAndHeaders->callRate
					<< " shouldn't be larger than netsetup rate " << netSetupMaxRate;
				pSdpAndHeaders->callRate = netSetupMaxRate;
			}

			/*if( m_UserAgent && strstr(m_UserAgent, MICROSOFT_EP4Alias) )
			{
				TRACEINTO << "call rate for OCPhone/4";
				pSdpAndHeaders->callRate = 19200;
			}*/
		}

		CCommConf* 	pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
		if(pCommConf && pCommConf->GetTelePresenceModeConfiguration() != NO )
		{
			memset (&pSdpAndHeaders->cCname,'\0',CNAME_STRING_MAX_LEN +1);
			BuildCnameStringFromMask(m_RtcpCnameMask,pSdpAndHeaders->cCname);
		}

		if(m_isMs2013Active)
		{
			if(eMsft2013AvMCU == m_isMs2013Active)
			{
				pSdpAndHeaders->msVideoRateRx = MaxMsftSvcSimulcastVideoMlines * m_pChosenLocalCap->GetMaxVideoBitRate(cmCapReceiveAndTransmit, kRolePeople) / 10;
				pSdpAndHeaders->msVideoRateTx = m_pChosenLocalCap->getMsftRxVideoBwLimitation() / 10;
			} else
			{
				pSdpAndHeaders->msVideoRateRx = m_pChosenLocalCap->GetMaxVideoBitRate(cmCapReceiveAndTransmit, kRolePeople) / 10;
				pSdpAndHeaders->msVideoRateTx = m_pChosenLocalCap->GetMaxVideoBitRate(cmCapReceiveAndTransmit, kRolePeople) / 10;
			}

			pSdpAndHeaders->msAudioRateTx = MAX_LYNC_AUDIO;
			pSdpAndHeaders->msAudioRateRx = MAX_LYNC_AUDIO;
		}

		BOOL   bOverrideSavpWithAvp = IsForceAvpOnEncryptWhenPossible();
		APIU16 plcmRequireMask 		= bOverrideSavpWithAvp?m_plcmRequireAvp:0;

		// when we send reinvite we don't use the last remote caps for setting the
		//direction because this is a request and not response
		exactCapsSize =
			m_pCall->CopyCapsToCapStruct((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
										capabilitiesSize, NULL, NULL, cmCapReceive, bIsFirstOffer ? FALSE : TRUE,
										m_bIsReInviteTransaction, GetIsAllowSdesInSdp() , kUnknown, plcmRequireMask,m_pChosenLocalCap);

		eMediaLineSubType bfcpType = GetBfcpType();

		if ( GetSystemCfgFlagInt<BOOL>(CFG_KEY_SIP_REINVITE) )
		{

			CCommConf* pComConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());


			CSmallString str;
			str << "m_bDeclareVideoFromScmOnly = " << m_bDeclareVideoFromScmOnly << ", m_bDeclareOnContentFromScmOnly =" << m_bDeclareOnContentFromScmOnly;

			int bAddLocalContentCaps = YES;

			// if one side doesn't support BFCP or we send reinvite to fix content algorithm only to one
			// don't add content from local caps
			if (!m_pCall->IsMedia(cmCapBfcp, cmCapReceive)
				|| !m_pLastRemoteCaps->IsMedia(cmCapBfcp, cmCapReceive)
				|| m_bDeclareOnContentFromScmOnly == TRUE
				||m_bIsCCSPlugin //LyncCCS
				||(pComConf && pComConf->GetIsAsSipContent() && !m_isASSIPContentEnable))
				bAddLocalContentCaps = NO;


			PTRACE2INT(eLevelInfoNormal,"CSipCntl::SipReInviteReq, bAddLocalContentCaps: ", bAddLocalContentCaps);

			exactCapsSize = m_pChosenLocalCap->AddCapsToCapStruct(cmCapReceiveAndTransmit,
																NO,
																(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																capabilitiesSize,bfcpType,
																YES,
																m_bDeclareVideoFromScmOnly? NO : YES,
																YES,
																bAddLocalContentCaps,
																NO,
																bOverrideSavpWithAvp);

			if (m_bDeclareVideoFromScmOnly) // if we don't add all local video caps, we need to add LPR cap specifically
			{
				CCapSetInfo lprInfo = eLPRCapCode;
				if (m_pChosenLocalCap->GetIsLpr() && m_pChosenLocalCap->IsMedia(cmCapVideo) && m_pChosenLocalCap->IsCapSet(lprInfo))
				{
					int lprIndex  = m_pChosenLocalCap->GetIndexInArr(lprInfo,0);
					if (lprIndex != NA)
					{
						str << " adding LPR to video ";
						exactCapsSize = m_pChosenLocalCap->AddSingleCapToCapStruct(cmCapVideo, lprIndex, cmCapReceive, NO,
																				(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders, capabilitiesSize, bfcpType);
					}
					if (m_pChosenLocalCap->IsMedia(cmCapVideo, cmCapReceiveAndTransmit, kRolePresentation) &&
						(m_pCall->IsMedia(cmCapBfcp, cmCapReceive) || m_pLastRemoteCaps->IsBfcpSupported())) /* bridge-2010 */
					{
						int lprPresentationIndex = m_pChosenLocalCap->GetIndexInArr(lprInfo,0,kRolePresentation);
						if (lprPresentationIndex != NA) {
							str << " adding LPR to presentation ";
							exactCapsSize = m_pChosenLocalCap->AddSingleCapToCapStruct(cmCapVideo, lprPresentationIndex, cmCapReceive, NO,
																					(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders, capabilitiesSize, bfcpType, kRolePresentation);
						}
					}
				}
			}

			if (!m_bDeclareVideoFromScmOnly && m_bDeclareOnContentFromScmOnly) // if we don't add all local video caps, we need to add LPR cap specifically(content)
			{
				CCapSetInfo lprInfo = eLPRCapCode;
				if (m_pChosenLocalCap ->GetIsLpr() && m_pChosenLocalCap->IsMedia(cmCapVideo,cmCapReceiveAndTransmit, kRolePresentation) && m_pChosenLocalCap ->IsCapSet(lprInfo))
				{
					if (m_pChosenLocalCap->IsMedia(cmCapVideo, cmCapReceiveAndTransmit, kRolePresentation))
					{
						str << "adding LPR to content when m_bDeclareOnContentFromScmOnly is on";
						int lprPresentationIndex = m_pChosenLocalCap->GetIndexInArr(lprInfo,0,kRolePresentation);
						if (lprPresentationIndex != NA)
						{
							exactCapsSize = m_pChosenLocalCap->AddSingleCapToCapStruct(cmCapVideo, lprPresentationIndex, cmCapReceive, NO,
																					(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders, capabilitiesSize, bfcpType, kRolePresentation);
						}
					}
				}
			}
			PTRACE2(eLevelInfoNormal,"CSipCntl::SipReInviteReq ",str.GetString());
		}

		CCapSetInfo dtmfInfo = eRfc2833DtmfCapCode;

		if ( m_pChosenLocalCap ->IsCapSet(dtmfInfo))// && m_pLastRemoteCaps->IsCapSet(dtmfInfo) )
		{
			int dtmfIndex  = m_pChosenLocalCap ->GetIndexInArr(dtmfInfo,0);
			if (dtmfIndex != NA)
			{
				exactCapsSize = m_pChosenLocalCap ->AddSingleCapToCapStruct(cmCapAudio, dtmfIndex, cmCapReceiveAndTransmit,
																		NO, (sipMediaLinesEntrySt*) pSdpAndHeaders->capsAndHeaders,
																		capabilitiesSize, bfcpType);
			}
		}

		//Add caps of disabled media
		// Now we set the closed media caps in the sdp. We will set later the ports to 0.
		AddClosedMediaCapsToSdp(pSdpAndHeaders, capabilitiesSize, exactCapsSize);

		//added for ANAT
		if (IsAnatSupported())
		{
            		 int addSize = CopyMLineFromLocalForAnat(pSdpAndHeaders, TRUE);
			exactCapsSize += addSize;

			/*COstrStream ostrAnat;
			DumpMediaLineEntry((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,ostrAnat);
			PTRACE2(eLevelInfoNormal,"Anat SipReInviteReq, m line After ANAT: \n",ostrAnat.str().c_str()); */ //debug for ANAT
		}


		// Add unsupported media lines:
		if (numberOfNotSupported > 0)
		{
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::SipReInviteReq : numberOfNotSupported=", numberOfNotSupported);
			exactCapsSize += sizeOfNotSupported;
			AddNotSupportedMediaLines(numberOfNotSupported, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders);
		}

		if (sizeOfClosed > 0)
		{
			if (!IsAnatSupported())  //added for ANAT
				exactCapsSize += AddClosedMediaLinesFromRemoteSDP(&pReInviteMsg->sipSdpAndHeaders, &closedChannelsCopiedTypes);
			else
				exactCapsSize += AddClosedMediaLinesFromRemoteSDPReinvteForAnat(&pReInviteMsg->sipSdpAndHeaders, &closedChannelsCopiedIndexes);
		}

	/*	if ( m_pLastRemoteCaps->IsMedia(cmCapVideo) &&
				 m_pCall->IsMedia(cmCapVideo,cmCapReceive) == NO &&
				 m_pCall->IsMedia(cmCapVideo,cmCapTransmit) == NO)
		{
			exactCapsSize = m_pLastRemoteCaps->AddMediaToCapStruct(cmCapVideo, cmCapReceiveAndTransmit,
																	YES, (ctCapabilitiesStruct*) pSdpAndHeaders->capsAndHeaders,
																	capabilitiesSize);
		}*/

		capabilitiesSize 	= exactCapsSize;
		capsAndHeadersSize 	= headersSize + capabilitiesSize;

		pSdpAndHeaders->sipMediaLinesOffset = 0;
		pSdpAndHeaders->sipMediaLinesLength = capabilitiesSize;
		pSdpAndHeaders->sipHeadersOffset 	= capabilitiesSize;
		pSdpAndHeaders->sipHeadersLength 	= headersSize;
		pSdpAndHeaders->lenOfDynamicSection = capsAndHeadersSize;

		// Set Session IP address
		((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->bMainMediaIpPresent = TRUE;

		SetSessionIpAddress(((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->mainMediaIp);

		SetIpAddressToAllMedias(pSdpAndHeaders, 0, 1);  //add param for ANAT
		//::SetFirFlag(*pSdpAndHeaders, kMediaLineInternalTypeVideo);
		SetPortZeroForClosedMedias(pSdpAndHeaders);

		SetSelfFlowControl(NO);

		ReduceVideoRate(NO, pSdpAndHeaders);

		if (!IsAnatSupported()) //added for ANAT
		SetLabelsAndContentAttributesInLocalSdp(*pSdpAndHeaders);
		else
			SetLabelsAndContentAttributesInLocalSdpForAnat(*pSdpAndHeaders);

		if (GetIsTipCall())
		{
			SetRateForLocalSdp(*pSdpAndHeaders, kMediaLineInternalTypeAudio, m_tipAudioRate, (int) eAAC_LDCapCode);
			SetRateForLocalSdp(*pSdpAndHeaders, kMediaLineInternalTypeVideo, m_tipVideoRate, (int) eH264CapCode);
		}
		else if ((GetRemoteIdent() == PolycomRMX) || (GetRemoteIdent() == PolycomEp) || GetSystemCfgFlagInt<BOOL>("DISABLE_SIP_PPC_VIDEO_RATE_REDUCTION"))
		{
			SetRateForLocalSdp(*pSdpAndHeaders,kMediaLineInternalTypeContent,m_fullContentRate);
			SetRateForLocalSdp(*pSdpAndHeaders,kMediaLineInternalTypeVideo,min(m_pChosenLocalCap->GetMaxVideoBitRate(), pSdpAndHeaders->callRate ));
		}
		else //need to change rate in MediaLineInternalTypeVideo and MediaLineInternalTypeContent according to flowControlRateConstraint (for people) and FlowControlRateConstraintForPresentation
			//In case that this is PolycomRMX or PolycomEp we don't need it because we send it in info message
			//if ( !(GetRemoteIdent() == PolycomRMX ) && !(GetRemoteIdent() == PolycomEp ) )
		{

			if (m_pParty->GetTargetMode()->GetFlowControlRateConstraint())
				SetRateForLocalSdp(*pSdpAndHeaders,kMediaLineInternalTypeVideo, m_pParty->GetTargetMode()->GetFlowControlRateConstraint());

			SetRateForLocalSdp(*pSdpAndHeaders,kMediaLineInternalTypeContent,m_fullContentRate);
		}

		TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,"
				  << (int)( m_pLastRemoteCaps->GetDirection(cmCapAudio, kRolePeople, TRUE) )
				  << "," << (int)( m_pLastRemoteCaps->GetDirection(cmCapVideo, kRolePeople, TRUE) )
				  << "," << (int)( m_pLastRemoteCaps->GetDirection(cmCapData, kRolePeople, TRUE) )
				  << "," << (int)( m_pLastRemoteCaps->GetDirection(cmCapVideo, kRolePresentation, TRUE) )
				  << "," << (int)( m_pLastRemoteCaps->GetDirection(cmCapBfcp, kRolePeople, TRUE) )
				  << "\n[0=kInactive, 1=kRecvOnly, 2=kSendOnly, 3=kSendRecv]";

        ::SetTheDirectionAttribute(pSdpAndHeaders, m_pLastRemoteCaps->GetDirection(cmCapAudio, kRolePeople, TRUE),
                                                   m_pLastRemoteCaps->GetDirection(cmCapVideo, kRolePeople, TRUE),
                                                   m_pLastRemoteCaps->GetDirection(cmCapData, kRolePeople, TRUE),
                                                   m_pLastRemoteCaps->GetDirection(cmCapVideo, kRolePresentation, TRUE),
                                                   m_pLastRemoteCaps->GetDirection(cmCapBfcp, kRolePeople, TRUE));
		//change ICE subType (TCP/RTP/AVP etc.)
		SetIceMlineSubTypesIfNeeded(pSdpAndHeaders);

		if (!IsAnatSupported()) //added for ANAT
		UpdatePortInClosedMedias(&pReInviteMsg->sipSdpAndHeaders, closedChannelsCopiedTypes);
		else
			UpdatePortInClosedMediasForAnat(&pReInviteMsg->sipSdpAndHeaders, closedChannelsCopiedIndexes);

		// set Lync2013 specific attributes:
		if( m_isMs2013Active )
		{
			SetLync2013SpecificMLinesAttributes(*pSdpAndHeaders);

			//LYNC2013_FEC_RED: in case of audio only + RED ON we will send audio with rate *2
			if ( m_pCall)
			{
				DWORD audioRate = m_pCall->GetAudioRate(cmCapReceive);

				TRACEINTO << "LYNC2013_FEC_RED: isMs2013Active:" << m_isMs2013Active << ", call rate before:" << pSdpAndHeaders->callRate << ", add more:" << audioRate;

				pSdpAndHeaders->callRate += audioRate; //m_pParty->GetTargetMode()->GetMediaBitRate(cmCapAudio, cmCapReceive, kRolePeople);

				//TRACEINTO << "LYNC2013_FEC_RED: call rate after:" << pInviteResponseMsg->sipSdpAndHeaders.callRate;
			}
		}

		if( eMsft2013AvMCU == m_isMs2013Active )
		{

			int addSize = AddSimulcastVideoMLinesToSDPForLync2013(pSdpAndHeaders);
			capabilitiesSize += addSize;

			capsAndHeadersSize = headersSize + capabilitiesSize;
			pSdpAndHeaders->sipMediaLinesLength = capabilitiesSize;
			pSdpAndHeaders->sipHeadersOffset = capabilitiesSize;
			pSdpAndHeaders->lenOfDynamicSection = capsAndHeadersSize;
		}


		if (!IsAnatSupported()) //added for ANAT
		{
			if(eMsft2013AvMCU == m_isMs2013Active)
			{
				OrderMediaLinesForMsft2013AVMCU(*pSdpAndHeaders);
			} else
				OrderMediaLines(*pSdpAndHeaders);
		}
		else
			OrderMediaLinesForAnat(*pSdpAndHeaders);

		//CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
		CConfParty* pConfParty = NULL;

		if (pCommConf)
		{
		    pConfParty = pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());

		}

	/*	if(pConfParty && pConfParty->GetMsftMediaEscalationStatus() == eMsftEscalationInActive )
		{
			TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kInactive,kInactive,kInactive,kInactive,kInactive)";
			SetTheDirectionAttribute(pSdpAndHeaders,kInactive,kInactive,kInactive,kInactive,kInactive);
		}
*/


		sipMessageHeaders* pHeaders = (sipMessageHeaders*)((char*)pSdpAndHeaders->capsAndHeaders + pSdpAndHeaders->sipHeadersOffset);
		headerList.BuildMessage(pHeaders);

		SetLocalSdp(*pSdpAndHeaders);
		size_t size = sizeof(mcReqReInvite) + pReInviteMsg->sipSdpAndHeaders.lenOfDynamicSection;

		if (allocatedBufferSize < size)
		{
			print_str << " Buffer size sent to system" << size << " sizeof(mcReqReInvite) = " << sizeof(mcReqReInvite) << " pReInviteMsg->sipSdpAndHeaders.lenOfDynamicSection = " << pReInviteMsg->sipSdpAndHeaders.lenOfDynamicSection;
			print_str << " Buffer size mismatch";
		}

		PTRACE2(eLevelInfoNormal, "CSipCntl::SipReInviteReq :", print_str.GetString());

		//BRIDGE-1105
		if (allocatedBufferSize < size)
		{
			PASSERTMSG(m_pCsRsrcDesc->GetConnectionId(), "CSipCntl::SipReInviteReq - Allocated Buffer size  smaller than size needed!!");
		}
		else if (pCommConf && !pCommConf->GetVideoRecoveryStatus())
		{
			SendSIPMsgToCS(SIP_CS_SIG_REINVITE_REQ, pReInviteMsg, size);

			bMessageSent = YES;
			StartTimer(PARTYCONNECTTOUT, GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_MSG_TIMEOUT) * SECOND);
			m_bIsReInviteTransaction = YES;
			m_pCall->SetReInviteInitiator(YES);
			m_state = IP_CONNECTING;
		}

		PDELETEA(pReInviteMsg);
	}
	if(eMsft2013AvMCU == m_isMs2013Active && !m_IsEnableICE)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SipReInviteReq - remove fake candidates end");
		m_pCall->ClearIceData();

	}
	return bMessageSent;
}



/////////////////////////////////////////////////////////////////////
APIU32 CSipCntl::CalcRateForIBM()
{
	CIpComMode  *pBestMode = m_pParty->GetTargetMode();
	DWORD 		actualAudioRate;
	DWORD 		actualVideoRate;
	DWORD 		totalRateTxOfRemote;
	APIU32 		rate = 0,
				vidRateTx = 0,
				actConfRate = 0;
	CMedString 	str;

	if (pBestMode) {

		actualAudioRate = pBestMode->GetMediaBitRate(cmCapAudio, cmCapReceive, kRolePeople);
		actualVideoRate = pBestMode->GetMediaBitRate(cmCapVideo, cmCapReceive, kRolePeople);

		vidRateTx = m_pLastRemoteCaps->GetMaxVideoBitRate(cmCapTransmit, kRolePeople);

		totalRateTxOfRemote = vidRateTx + (actualAudioRate*10);
		actConfRate = min(totalRateTxOfRemote, actualVideoRate+ actualAudioRate*10);
		rate = min(actConfRate, pBestMode->GetCallRate()*10 );

		str << "actualAudioRate=" << actualAudioRate << " actualVideoRate=" << actualVideoRate << " vidRateTx=" << vidRateTx << " actConfRate=" << actConfRate << " finalRate=" << rate ;
		PTRACE2(eLevelInfoNormal,"CSipCntl::CalcRateForIBM, ", str.GetString());
	}
	return rate;
}

///////////////////////////////////////////////////////////////////////////
//for debug SIPProxy CORE
/*void CSipCntl::OnTimerSendMsgToSipProxy()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnTimerSendMsgToSipProxy ");
	CSegment*  pSendSeg = new CSegment;
	*pSendSeg << (DWORD)m_pParty->GetMonitorConfId();
	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	*pSendSeg << pCommConf->GetName();
	*pSendSeg << (DWORD)m_pCsRsrcDesc->GetPartyRsrcId();
	*pSendSeg << (DWORD)m_pCsRsrcDesc->GetConnectionId();

	PTRACE(eLevelInfoNormal,"CSipCntl::OnMsSocketActivityInd.  Re-REGISTER ordered");
	SendReqToSipProxy(pSendSeg, DIALOG_RECOVERY_IND);
	PTRACE(eLevelInfoNormal,"CSipCntl::OnMsSocketActivityInd.  2*CRLF continue ");
}*/
/////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInviteAckReq(BYTE bCloseSession)
{
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::SipInviteAckReq: state ", m_state);
	BYTE bMessageSent = NO;

	mcReqInviteAck* pInviteAckMsg = new mcReqInviteAck;
	size_t size = sizeof(mcReqInviteAck);
	memset(pInviteAckMsg, 0, size);
	SendSIPMsgToCS(SIP_CS_SIG_INVITE_ACK_REQ, pInviteAckMsg, size);

	//BandwidthAllocationStatus(m_pLastRemoteCaps->GetVideoRate()/10, m_pChosenLocalCap->GetVideoRate()/10 ); only for debuging EMA

	bMessageSent				= YES;
	m_bIsReInviteTransaction	= NO; // close transaction

	if (m_state == IP_CONNECTING)
	{
		// answer for 200 ok
		m_state = IP_CONNECTED;
		m_bChangeModeWithinTransaction= NO;
		/* IBM-811 - send RTCP TMMBR flow control when the call is connected */
		if (IsSameTimeEP()) {
			DWORD 	rtcpTmmbrInterval = 0;
			APIU32 	rate = 0;

			rate = CalcRateForIBM();
			if (rate)
			{
				CProcessBase::GetProcess()->GetSysConfig()->GetDWORDDataByKey("RTCP_FLOW_CONTROL_TMMBR_INTERVAL", rtcpTmmbrInterval);
				SendFlowControlReq(mainType, cmCapReceive, rate);
				rtcpTmmbrInterval = rtcpTmmbrInterval ? rtcpTmmbrInterval : 120;
				StartTimer(RTCP_FLOW_CONTROL, rtcpTmmbrInterval * SECOND);
			}
		}

		StartFastUpdateTimer();
		if (bCloseSession) // value will be NO if we want to send re-invite right away (in dial out), for instance.
		{
			m_pCall->SetConnectionState(kConnected);
		}
	}
	else if (m_state == IP_DISCONNECTING)
	{
		// answer for 4xx reject
		if (m_pCall->GetRejectReason())
		{
			if (bCloseSession)
			{
				SetCallDisconnectedAndRemoveFromRsrcTbl();
			}
			// else - other disconnecting process (like bye ind) has started - let it finish the session
		}
	}
	else
	{
		DBGPASSERT(YES);
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::SipInviteAckReq: state ", m_state);
	}

	PDELETE(pInviteAckMsg);

	return bMessageSent;
}


/////////////////////////////////////////////////////////////
BYTE CSipCntl::SipCancelReq()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipCancelReq");
	BYTE bMessageSent = NO;
	mcReqCancel* pCancelMsg = new mcReqCancel;
	size_t size = sizeof(mcReqCancel);
	memset(pCancelMsg, 0, size);
	SendSIPMsgToCS(SIP_CS_SIG_CANCEL_REQ, pCancelMsg, size);
	PDELETE(pCancelMsg);
	bMessageSent = YES;

	if (IsValidTimer(PARTYCONNECTTOUT)) // stop waiting for an ok.
		DeleteTimer(PARTYCONNECTTOUT);

	StartTimer(PARTYDISCONNECTTOUT, GetSIPMsgTimeout() * SECOND);
	return bMessageSent;
}

//////////////////////////////////////////////////////////////////////////
void CSipCntl::AddParamsToContactHeader(char* strContact)
{
	AddXCiscoToContactHeader(strContact);
}
//////////////////////////////////////////////////////////////////////////
void CSipCntl::AddXCiscoToContactHeader(char* strContact)
{
	char strContactPrev[IP_STRING_LEN];

	if(strContact && GetIsTipCall())
	{
		snprintf(strContactPrev,IP_STRING_LEN,"%s",strContact);
		snprintf(strContact,IP_STRING_LEN,"%s;x-cisco-tip;x-cisco-multiple-screen=3;+u.sip!model.ccm.cisco.com=\"583\"",strContactPrev);
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::AddXCiscoToSupportedHeader(CSipHeaderList& headerList)
{
	//cisco TIP support
	if (GetIsTipCall() || m_remoteIdent == CiscoCucm)
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::AddXCiscoToSupportedHeader, Add XCisco to Supported header for X-cisco-callinfo, X-cisco-srtp-fallback, X-cisco-sis-5.1.0");
		headerList.AddHeader(kSupported, strlen("X-cisco-callinfo, X-cisco-srtp-fallback, X-cisco-sis-5.1.0"), "X-cisco-callinfo, X-cisco-srtp-fallback, X-cisco-sis-5.1.0");
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::AddPlcmIvrToSupportedHeader(CSipHeaderList& headerList)
{
	//Add suppported for plcm-ivr
	CCommConf* pComConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	if (pComConf && pComConf->isIvrProviderEQ())
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::AddPlcmIvrToSupportedHeader, Add Supported for plcm-ivr-service-provider");
		headerList.AddHeader(kSupported, strlen("plcm-ivr-service-provider"), "plcm-ivr-service-provider");
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::AddParamsToSupportedHeader(CSipHeaderList& headerList)
{
	AddPlcmIvrToSupportedHeader(headerList);
	AddXCiscoToSupportedHeader(headerList);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CSipCntl::GetIsAllowSdesInSdp()
{
	BOOL bIsAllowed = FALSE;
	//Will always allow for now..
	//bIsAllowed = (GetTransportProtocol() == eTransportTypeTls || GetIsTipCall())?TRUE:FALSE;
	bIsAllowed = TRUE;

	TRACEINTO << "is allow : " << (int)bIsAllowed;
	return bIsAllowed;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInviteResponseReqBuildHeadersList(CSipHeaderList& headerList, DWORD& status, int warning, const char* alternativeAddrStr)
{
	BYTE bSetHeaders = FALSE;
	CSipHeaderList* pCallLegHeaders = NULL;

	// validity check
	if(m_pCall)
		pCallLegHeaders = m_pCall->GetCallLegHeaders();
	else
	{
		DBGPASSERT(200);
		return bSetHeaders;
	}

	if (pCallLegHeaders)
	{
		headerList = *pCallLegHeaders;

		if (GetIsMrcCall())
		{
			AddMrdHeader(headerList);
			AddInfoHeader(headerList);
		}

		AddInviteResponseReqHeader(headerList);

		if (warning)
		{
			const char* calLWarningString = m_pCall->GetWarningString();

			if (calLWarningString)
			{
				CSmallString warningString;
				CConfIpParameters *pService = ::GetIpServiceListMngr()->FindIpService(m_serviceId);
				char ip[16];

				if (pService)
				{
					SystemDWORDToIpString(pService->GetIpV4Address().v4.ip, ip);
				}
				else
				{
					SystemDWORDToIpString(0, ip);
				}

				warningString << warning << " " << ip << " \"" << calLWarningString << "\"";
				const char* strWarning = warningString.GetString();

				if (strWarning)
				{
					headerList.AddHeader(kWarning,strlen(strWarning),strWarning);
				}
			}
			else
			{
				CSmallString warningString;
				//NOTE!!! RFC-3261 "20.43 Warning": <warning code><host name><warning text>.
				//The host name CANNOT include space in Warning header.
				warningString << warning << " POLYCOM-RMX \"" << ::GetWarningCodeStr((enSipWarningCodes)warning) << "\"";
				const char* strWarning = warningString.GetString();

				if (strWarning)
				{
					headerList.AddHeader(kWarning,strlen(strWarning),strWarning);
				}
			}

			//NOTE!!! RFC-3261 "20.43 Warning": <warning code><host name><warning text>.
			//The host name CANNOT include space in Warning header.
		}

		if (alternativeAddrStr)
		{
			char strContact[IP_STRING_LEN];
			const char* strOtherCard = "";
			headerList.AddHeader(kContactDisplay,strlen(strOtherCard),strOtherCard);
			snprintf(strContact,IP_STRING_LEN,"%s",alternativeAddrStr);
			AddParamsToContactHeader(strContact);
			headerList.AddHeader(kContact,strlen(strContact),strContact);
		}
		else
			AddContactHeader(headerList);

		if(CProcessBase::GetProcess()->GetProductType()==eProductTypeSoftMCUMfw)
			AddIBMDestinationPublicIpHeader(headerList);

		if (m_strConfParamInfo.IsEmpty() == NO)
		{
			headerList.AddHeader(kProprietyHeader,m_strConfParamInfo.GetStringLength(),m_strConfParamInfo.GetString());
		}


		if (status == OK_VAL)
		{
			const CSipHeader* pCalledPartyId = m_pCall->GetCdrSpecificHeader(strlen("P-Called-Party-ID"),"P-Called-Party-ID");
			if (pCalledPartyId)
			{
				headerList.AddHeader(*pCalledPartyId);
			}

			if(m_bIsReInviteTransaction == NO)// Session Timer set parameters in the first transaction only
				status = SetDialInSessionTimerHeaders(headerList);
			if(status != OK_VAL)
				PTRACE(eLevelInfoNormal, "CSipCntl::SipInviteResponseReqBuildHeadersList, Status has change to 422 due to session timers values");
		}
		//-------TCP-KEEP-ALIVE ---------------------------------------------------------------------//
		//DWORD isKASupported = GetRmtMsKeepAliveTimeOut();
		//if( isKASupported )
		{
			//m_MsKeepAlivePongTimeOut = GetSystemCfgFlagInt<DWORD>("SOCKET_ACTIVITY_TIMEOUT");
			if(0 != m_dwKeepAliveType)
			{
				char strValue[64];
				int strLen = sprintf(strValue, "%d|%d|%d|%d", m_dwKeepAliveFrequency_Sec
															, m_MsKeepAlivePongTimeOut
															, m_dwKeppAliveBehavior
															, m_dwKeepAliveType);

				headerList.AddHeader(kMsKeepAliveTimeout, strLen, strValue);

				DeleteTimer(MS_KEEP_ALIVE_CLIENT_TIMER);
				DeleteTimer(MS_KEEP_ALIVE_SERVER_TIMER);

				if(m_MsKeepAlivePongTimeOut > 0)
				{
					StartTimer(MS_KEEP_ALIVE_SERVER_TIMER, (m_MsKeepAlivePongTimeOut+3) * SECOND);
				}
				else
				if(m_dwKeepAliveFrequency_Sec > 0)
				{//IT is for SIP_TCP_KEEPALIVE_PLCM
					StartTimer(MS_KEEP_ALIVE_CLIENT_TIMER, (m_dwKeepAliveFrequency_Sec/2) * SECOND);
				}
			}
		}
		//---------------------------------------------------------------------------------------------//

		AddParamsToSupportedHeader(headerList);

		if(CProcessBase::GetProcess()->GetProductType()==eProductTypeSoftMCUMfw)
			AddIBMDestinationPublicIpHeader(headerList);

		bSetHeaders = TRUE;
	}

	return bSetHeaders;

}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInviteResponseReqSendMsg(mcReqInviteResponse* pInviteResponseMsg)
{
	PASSERT_AND_RETURN_VALUE(!pInviteResponseMsg, FALSE);

	size_t size = sizeof(mcReqInviteResponse) + pInviteResponseMsg->sipSdpAndHeaders.lenOfDynamicSection;

	//LYNC2013_FEC_RED:   in case of audio only + RED ON we will send audio with rate *2
	if ( pInviteResponseMsg && m_pCall && m_isMs2013Active )
	{
		DWORD audioRate = m_pCall->GetAudioRate(cmCapReceive);

		TRACEINTO << "LYNC2013_FEC_RED: isMs2013Active:" << m_isMs2013Active << ", call rate before:" << pInviteResponseMsg->sipSdpAndHeaders.callRate << ", add more:" << audioRate;

		pInviteResponseMsg->sipSdpAndHeaders.callRate += audioRate; //m_pParty->GetTargetMode()->GetMediaBitRate(cmCapAudio, cmCapReceive, kRolePeople);

		//TRACEINTO << "LYNC2013_FEC_RED: call rate after:" << pInviteResponseMsg->sipSdpAndHeaders.callRate;
	}

	SendSIPMsgToCS(SIP_CS_SIG_INVITE_RESPONSE_REQ, pInviteResponseMsg, size);

	if (m_state == IP_CONNECTING)  //	invite 200 OK, re-invite 200 ok or re-invite reject
		StartTimer(PARTYCONNECTTOUT, GetSIPMsgTimeout() * SECOND);
	else // IP_DISCONNECTING.			invite reject
		StartTimer(PARTYDISCONNECTTOUT, GetSIPMsgTimeout() * SECOND);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SipInviteResponseReqSetSdpHeaderStuctFields(sipSdpAndHeadersSt* pSdpAndHeaders, int mediaLinesOffset, int mediaLinesLength, int iceOffset,
													int iceLength, int headersOffset, int headerLength, int lenOfDynamicSection)
{
	pSdpAndHeaders->sipMediaLinesOffset = mediaLinesOffset;
	pSdpAndHeaders->sipMediaLinesLength = mediaLinesLength;
	pSdpAndHeaders->sipIceOffset		= iceOffset;
	pSdpAndHeaders->sipIceLength		= iceLength;

	// Add Headers to Buffer
	pSdpAndHeaders->sipHeadersOffset = headersOffset;
	pSdpAndHeaders->sipHeadersLength = headerLength;
	pSdpAndHeaders->lenOfDynamicSection = lenOfDynamicSection;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// zeros pInviteResponseMsg, sets invite response generic fields
// returns the size of the set data.
DWORD CSipCntl::SipInviteResponseReqSetResponseMsg(mcReqInviteResponse* pInviteResponseMsg, int msgLen, DWORD status)
{
	DWORD sizeAdded = 0;

	memset(pInviteResponseMsg, 0 , msgLen);

	pInviteResponseMsg->status		= status;
	sizeAdded += sizeof(pInviteResponseMsg->status);

	//TRACEINTO << "sizeAdded:" << (DWORD)sizeAdded << ", msgLen:" << (DWORD)msgLen << ", IsMrcHeader:"<< (DWORD)::IsMrcHeader(GetRemoteSdp());

	pInviteResponseMsg->bIsFocus	= YES;
	if (::IsMrcHeader(GetRemoteSdp()))
	{
		CCommConf* pComConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());

		//TRACEINTO << "in1 - pComConf->GetConfMediaType:" << (DWORD)pComConf->GetConfMediaType();

		if (pComConf && pComConf->GetConfMediaType() == eAvcOnly)
		{
			pInviteResponseMsg->bIsFocus = NO;

			//TRACEINTO << "in2 - isFocus=NO";
		}
	}
	sizeAdded += sizeof(pInviteResponseMsg->bIsFocus);

	//TRACEINTO << "sizeAdded:" << (DWORD)sizeAdded;

	return sizeAdded;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SipInviteResponseReqSetSDPGenericFields(mcReqInviteResponse* pInviteResponseMsg, BYTE isBwmForIBM)
{
	sipSdpAndHeadersSt* pSdpAndHeaders = &pInviteResponseMsg->sipSdpAndHeaders;

	// set cCname
	CCommConf* 	pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	if(pCommConf && pCommConf->GetTelePresenceModeConfiguration() != NO )
	{
		memset(&pSdpAndHeaders->cCname,'\0',CNAME_STRING_MAX_LEN +1);
		BuildCnameStringFromMask(m_RtcpCnameMask,pSdpAndHeaders->cCname);
	}

	// set callRate
	if(m_pParty->GetTargetMode()->GetConfType() != kCop)
	{
		if (isBwmForIBM)
		{
			pSdpAndHeaders->callRate = CalcRateForIBM();
		}
		else {
			// AN: for IBM vngfe-4195
			if (!IsSameTimeEP())// || m_remoteIdent != CiscoCucm)
			{
				pSdpAndHeaders->callRate = min(m_pCall->GetCallRate(cmCapReceive), m_pNetSetup->GetMaxRate() / 100 );
			}
			else
			{
				pSdpAndHeaders->callRate = min(m_pCall->GetCallRate(cmCapTransmit), m_pNetSetup->GetMaxRate() / 100 );
			}
		}
	}
	else
		pSdpAndHeaders->callRate = GetCopMaxCallRate();

	if(m_pParty->GetTargetMode()->GetIsTipMode() )
	{
		if(m_pNetSetup)
			pSdpAndHeaders->callRate = m_pNetSetup->GetMaxRate() / 100;
		else
			PASSERTMSG(1, "m_pNetSetup is NULL");
	}

	// set rate for RTV channel
	CSipChannel* pVideoChannel = NULL;
	pVideoChannel = m_pCall->GetChannel(true, cmCapVideo, cmCapTransmit);
	if(pVideoChannel)
	{
		if(pVideoChannel->GetAlgorithm() == eRtvCapCode)
		{
			DWORD rate = m_pLastRemoteCaps->GetTotalRate();
			TRACEINTOFUNC << "This is RTV channel rate = " << rate;
			pSdpAndHeaders->callRate = rate;
		}
	}

	//LyncCCS: Since there's no video channel, the b=AS filed should be Audio+Content
	if(m_bIsCCSPlugin)
	{
		pSdpAndHeaders->callRate +=m_fullContentRate;
	}




	if( m_isMs2013Active )
	{
		pSdpAndHeaders->msVideoRateTx = m_pChosenLocalCap->GetMaxVideoBitRate(cmCapReceiveAndTransmit, kRolePeople) / 10; // in kb
		pSdpAndHeaders->msVideoRateRx = m_pChosenLocalCap->GetMaxVideoBitRate(cmCapReceiveAndTransmit, kRolePeople) / 10; // in kb
		pSdpAndHeaders->msAudioRateTx = MAX_LYNC_AUDIO;
		pSdpAndHeaders->msAudioRateRx = MAX_LYNC_AUDIO;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SipInviteResponseReqSetMediaRatesInSDP(sipSdpAndHeadersSt* pSdpAndHeaders)
{
	if (GetIsTipCall() && m_bIsReInviteTransaction)
	{
		SetRateForLocalSdp(*pSdpAndHeaders, kMediaLineInternalTypeAudio, m_tipAudioRate, (int) eAAC_LDCapCode);
		SetRateForLocalSdp(*pSdpAndHeaders, kMediaLineInternalTypeVideo, m_tipVideoRate, (int) eH264CapCode);
	}
	else if ( (GetRemoteIdent() == PolycomRMX) || (GetRemoteIdent() == PolycomEp) )
	{
		SetRateForLocalSdp(*pSdpAndHeaders,kMediaLineInternalTypeContent,m_fullContentRate);
		SetRateForLocalSdp(*pSdpAndHeaders,kMediaLineInternalTypeVideo,m_pChosenLocalCap->GetMaxVideoBitRate());
	}
	else //need to change rate in MediaLineInternalTypeVideo and MediaLineInternalTypeContent according to flowControlRateConstraint (for people) and FlowControlRateConstraintForPresentation
		//In case that this is PolycomRMX or PolycomEp we don't need it because we send it in info message
	if ( !(GetRemoteIdent() == PolycomRMX ) && !(GetRemoteIdent() == PolycomEp ) )
	{
		if (m_pParty->GetTargetMode()->GetFlowControlRateConstraint())
			SetRateForLocalSdp(*pSdpAndHeaders,kMediaLineInternalTypeVideo, m_pParty->GetTargetMode()->GetFlowControlRateConstraint());

		SetRateForLocalSdp(*pSdpAndHeaders,kMediaLineInternalTypeContent,m_fullContentRate);
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::LeaveMedia(cmCapDataType eMediaType, int& leaveMediaCaps, eMediaLineInternalType intType, CSipCaps* pTempRemoteCap)
{
	// if the media is 'muted' or audio only call in Party setting (EMA) we must response with media algorithm when the port is zero,
	// calc the buffer needed for that
	// Identify this case by: no media channels but media algorithm in the remote SDP.
//	 ERoleLabel eRole = kRolePeople;
//	 kRolePresentation
	if((m_pCall->IsMedia(eMediaType,cmCapReceive) ==  NO) && (m_pCall->IsMedia(eMediaType,cmCapTransmit) == NO)
						&& ::IsMediaContainedInSdp(m_pRemoteSdp, intType))
	{
		TRACEINTOFUNC << "m_pCall is off for media - " << ::CapDataTypeToString(eMediaType);
		// 1. case of defined audio only and video port = 0 - take video size from remote temp caps.
		// 2. case of defined audio only and video port != 0 - take video size from remote temp caps.
		// 3. case of video call and video port 0 and - take video size from local caps.
		leaveMediaCaps = m_pChosenLocalCap->IsMedia(eMediaType, cmCapReceive);// 3

		#ifdef LOGS_FOR_EXTRA_DEBUG
			PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::LeaveMedia : leaveMediaCaps = ", leaveMediaCaps);
		#endif
		
		if(leaveMediaCaps == NO && eMediaType != cmCapAudio)
		{
			TRACEINTOFUNC << "m_pChosenLocalCap is off for media - " << ::CapDataTypeToString(eMediaType);
			leaveMediaCaps = pTempRemoteCap->IsMedia(eMediaType, cmCapReceive);//1+2, is that line good for audio media as well??? (UriA)
		}
}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SipInviteResponseReqLeaveMediaAnswerer(CSipCaps* pTempRemoteCap, int& leaveAudioCaps, int& leaveVideoCaps, int& leaveDataCaps,
												int& leaveContentCaps, int& leaveBfcpCaps)
{

	// if the audio is 'muted' we must response with audio algorithm when the port is zero, calc the buffer needed for that
	// Identify this case by: no audio channels but audio algorithm in the remote SDP
	// 'muted' means the port is zero and the channel must be close.
	// the case of audio port = 0, get audio caps from local caps
	LeaveMedia(cmCapAudio, leaveAudioCaps, kMediaLineInternalTypeAudio, pTempRemoteCap);

	// if the video is 'muted' or audio only call in Party setting (EMA) we must response with video algorithm when the port is zero,
	// calc the buffer needed for that
	// Identify this case by: no video channels but video algorithm in the remote SDP.
	LeaveMedia(cmCapVideo, leaveVideoCaps, kMediaLineInternalTypeVideo, pTempRemoteCap);

	LeaveMedia(cmCapData, leaveDataCaps, kMediaLineInternalTypeFecc, pTempRemoteCap);

	if((m_pCall->IsMedia(cmCapVideo,cmCapReceive,kRolePresentation) ==  NO) && (m_pCall->IsMedia(cmCapVideo,cmCapTransmit,kRolePresentation) == NO)
			&& ::IsMediaContainedInSdp(m_pRemoteSdp, kMediaLineInternalTypeContent))
	{
		// 1. case of defined audio only and content port = 0 - take content size from remote temp caps.
		// 2. case of defined audio only and content port != 0 - take content size from remote temp caps.
		// 3. case of video call and content port 0 and - take content size from local caps.
		leaveContentCaps = m_pChosenLocalCap->IsMedia(cmCapVideo,cmCapReceive, kRolePresentation) && m_pChosenLocalCap->IsMedia(cmCapBfcp,cmCapReceive);//3
		if(leaveContentCaps == NO)
			leaveContentCaps = pTempRemoteCap->IsMedia(cmCapVideo,cmCapReceive, kRolePresentation);
	}

	LeaveMedia(cmCapBfcp, leaveBfcpCaps, kMediaLineInternalTypeBfcp, pTempRemoteCap);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SipInviteResponseReqLeaveMedia(BYTE bIsAnswerer, CSipCaps* pTempRemoteCap, int& leaveAudioCaps, int& leaveVideoCaps, int& leaveDataCaps,
												int& leaveContentCaps, int& leaveBfcpCaps)
{

	#ifdef LOGS_FOR_EXTRA_DEBUG
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqLeaveMedia : Entering Function ", 0);
	#endif
	

	// all the leave media should have been gathered into a structure and set to BYTE or BOOL
	if(bIsAnswerer)
	{
		#ifdef LOGS_FOR_EXTRA_DEBUG
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqLeaveMedia : bIsAnswerer = true ", 0);
		#endif
	
		SipInviteResponseReqLeaveMediaAnswerer(pTempRemoteCap, leaveAudioCaps, leaveVideoCaps, leaveDataCaps, leaveContentCaps, leaveBfcpCaps);
	}
	else
	{
		#ifdef LOGS_FOR_EXTRA_DEBUG
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqLeaveMedia : bIsAnswerer = false ", 0);
		#endif
		
		// instead of calling => SipInviteResponseReqLeaveMediaOferer(leaveAudioCaps, leaveVideoCaps, leaveDataCaps, leaveContentCaps, leaveBfcpCaps);
		if( GetSystemCfgFlagInt<BOOL>(CFG_KEY_SIP_REINVITE))
		{

			#ifdef LOGS_FOR_EXTRA_DEBUG
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqLeaveMedia : GetSystemCfgFlagInt<BOOL>(CFG_KEY_SIP_REINVITE) = true ", 0);
			#endif
		
			// invite with no SDP and re-invite we remove other codec except the SCM ones.
			leaveAudioCaps	= YES;
			leaveVideoCaps	= YES;
			leaveDataCaps	= YES;
			leaveBfcpCaps	= NO;

			if (m_bIsReInviteTransaction && m_pChosenLocalCap->IsMedia(cmCapBfcp,cmCapReceiveAndTransmit)
					&& m_pLastRemoteCaps->IsMedia(cmCapBfcp,cmCapReceiveAndTransmit)) // we don't add content in first invite (relevant for invite no sdp)
				{				
					#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqLeaveMedia : leaveContentCaps = YES ", 0);
					#endif
					leaveContentCaps = YES;
				}

			if (m_pChosenLocalCap->IsMedia(cmCapBfcp,cmCapReceiveAndTransmit))
				{
					#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqLeaveMedia : leaveBfcpCaps	 = YES ", 0);
					#endif
					leaveBfcpCaps	 = YES;
				}				

			TRACEINTOFUNC << "Leave Caps: leaveContentCaps - " << leaveContentCaps << ", leaveBfcpCaps - " << leaveBfcpCaps;;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
int CSipCntl::SipInviteResponseReqAnswererAddMediaCap(sipSdpAndHeadersSt* pSdpAndHeaders, CSipCaps* pTempRemoteCap, int capsBufferLens, cmCapDataType eMediaType,
														int leaveMediaCap, eMediaLineSubType bfcpType, ERoleLabel eRole)
{
	int leaveAudioCaps, leaveVideoCaps, leaveDataCaps, leaveContentCaps, leaveBfcpCaps;
	leaveAudioCaps = leaveVideoCaps = leaveDataCaps = leaveContentCaps = leaveBfcpCaps= NO;
	BYTE bIgnoreContent		= YES;

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SipInviteResponseReqAnswererAddMediaCap  eMediaType = ", eMediaType);

	BYTE ms2013AddVideoCaps = NO;
	CSipChannel* pVideoChannelIn = m_pCall->GetChannel(true, cmCapVideo, cmCapReceive);
	CSipChannel* pVideoChannelOut = m_pCall->GetChannel(true, cmCapVideo, cmCapTransmit);
	if(pVideoChannelIn || pVideoChannelOut)
	{
		if(m_isMs2013Active)
			ms2013AddVideoCaps = YES;
	}

	BYTE ms2013AddAudioCaps = NO;
	CSipChannel* pAudioChannelIn = m_pCall->GetChannel(true, cmCapAudio, cmCapReceive);
	CSipChannel* pAudioChannelOut = m_pCall->GetChannel(true, cmCapAudio, cmCapTransmit);
	if(pAudioChannelIn || pAudioChannelOut)
	{
		if(m_isMs2013Active)
			{
				#ifdef LOGS_FOR_EXTRA_DEBUG
					PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCap : m_isMs2013Active = true", 0);
				#endif
				
				ms2013AddAudioCaps = YES;
			}			
	}

		#ifdef LOGS_FOR_EXTRA_DEBUG
			PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCap : eMediaType = ", eMediaType);
		#endif

	switch(eMediaType)
	{
	case cmCapAudio:
			{
			if(ms2013AddAudioCaps)
				{
					#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCap : cmCapAudio  ms2013AddAudioCaps= true", 0);
					#endif
					leaveAudioCaps = YES;
				}
			else
				{

					#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCap : cmCapAudio  ms2013AddAudioCaps= false", 0);
					#endif
					
					leaveAudioCaps = leaveMediaCap;
				}
			break;
		}
	case cmCapVideo:
	{
		if(eRole == kRolePresentation)
		{
			#ifdef LOGS_FOR_EXTRA_DEBUG
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCap : cmCapVideo  eRole == kRolePresentation", 0);
			#endif
					
			leaveContentCaps = leaveMediaCap;
			bIgnoreContent	 = NO;
		}
		else
		{
			#ifdef LOGS_FOR_EXTRA_DEBUG
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCap : cmCapVideo  eRole != kRolePresentation", 0);
			#endif
		
            if(ms2013AddVideoCaps)
            	{
            		#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCap : cmCapVideo  eRole != kRolePresentation ms2013AddVideoCaps = true", 0);
					#endif
				   leaveVideoCaps = YES;
            	}
			else
				{

					#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCap : cmCapVideo  eRole != kRolePresentation ms2013AddVideoCaps = false", 0);
					#endif
					
					leaveVideoCaps = leaveMediaCap;
				}
		}
		break;
	}
	case cmCapData:
		leaveDataCaps = leaveMediaCap;
		break;
	case cmCapBfcp:
		leaveBfcpCaps = leaveMediaCap;
		break;
	default:
		break;
	}

	int exactCapsSize = 0;
	BOOL   bOverrideSavpWithAvp = IsForceAvpOnEncryptWhenPossible();
	if(m_pChosenLocalCap->IsMedia(eMediaType) && (bIgnoreContent || m_pChosenLocalCap->IsMedia(cmCapBfcp)))
	{

		PTRACE2INT(eLevelInfoNormal,"DBG CSipCntl::SipInviteResponseReqAnswererAddMediaCap  m_pChosenLocalCap->IsMedia(eMediaType) = ", m_pChosenLocalCap->IsMedia(eMediaType));
		exactCapsSize = m_pChosenLocalCap->AddCapsToCapStruct(cmCapReceiveAndTransmit, NO, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
															capsBufferLens, bfcpType, leaveAudioCaps, leaveVideoCaps, leaveDataCaps, leaveContentCaps, leaveBfcpCaps, bOverrideSavpWithAvp );
	}
	else
	{

		PTRACE2INT(eLevelInfoNormal,"DBG CSipCntl::SipInviteResponseReqAnswererAddMediaCap  pTempRemoteCap->IsMedia(eMediaType) = ", pTempRemoteCap->IsMedia(eMediaType));
		exactCapsSize = pTempRemoteCap->AddCapsToCapStruct(cmCapReceiveAndTransmit, NO, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
														capsBufferLens, bfcpType, leaveAudioCaps, leaveVideoCaps, leaveDataCaps, leaveContentCaps, leaveBfcpCaps, bOverrideSavpWithAvp );
	}
	return exactCapsSize;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// adds caps not from channels in case of Invite With SDP(Answerer).
// returns size of MediaLinesEntry with all added caps
int CSipCntl::SipInviteResponseReqAnswererAddMediaCapsNotFromChannels(sipSdpAndHeadersSt* pSdpAndHeaders, CSipCaps* pTempRemoteCap, int capsBufferLen, BYTE isBwmForIBM)
{

	#ifdef LOGS_FOR_EXTRA_DEBUG
			PTRACE2INT(eLevelInfoNormal, "dbg SipInviteResponseReqAnswererAddMediaCapsNotFromChannels : Entering Function ", 0);
	#endif

	int leaveAudioCaps		= NO;
	int leaveVideoCaps		= NO;
	int leaveDataCaps		= NO;
	int leaveContentCaps	= NO;
	int leaveBfcpCaps		= NO;
	SipInviteResponseReqLeaveMedia(TRUE, pTempRemoteCap, leaveAudioCaps, leaveVideoCaps, leaveDataCaps, leaveContentCaps, leaveBfcpCaps);

	#ifdef LOGS_FOR_EXTRA_DEBUG
		PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCapsNotFromChannels : After Executing SipInviteResponseReqLeaveMedia", 0);
		PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCapsNotFromChannels : leaveAudioCaps", leaveAudioCaps);
		PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCapsNotFromChannels : leaveVideoCaps", leaveVideoCaps);
		PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCapsNotFromChannels : leaveDataCaps", leaveDataCaps);
		PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCapsNotFromChannels : leaveContentCaps", leaveContentCaps);
		PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAnswererAddMediaCapsNotFromChannels : leaveBfcpCaps", leaveBfcpCaps);
	#endif
	
	//Audio behavior same as other media, like video
	//remove protection from BFCP
	eMediaLineSubType bfcpType	= GetBfcpType();
	int exactCapsSizeAdd		= 0;

	exactCapsSizeAdd = SipInviteResponseReqAnswererAddMediaCap(pSdpAndHeaders, pTempRemoteCap, capsBufferLen, cmCapAudio, leaveAudioCaps, bfcpType); // returns offset

	exactCapsSizeAdd = SipInviteResponseReqAnswererAddMediaCap(pSdpAndHeaders, pTempRemoteCap, capsBufferLen, cmCapVideo, leaveVideoCaps, bfcpType);

	exactCapsSizeAdd = SipInviteResponseReqAnswererAddMediaCap(pSdpAndHeaders, pTempRemoteCap, capsBufferLen, cmCapData, leaveDataCaps, bfcpType);

	exactCapsSizeAdd = SipInviteResponseReqAnswererAddMediaCap(pSdpAndHeaders, pTempRemoteCap, capsBufferLen, cmCapVideo, leaveContentCaps, bfcpType, kRolePresentation);

	exactCapsSizeAdd = SipInviteResponseReqAnswererAddMediaCap(pSdpAndHeaders, pTempRemoteCap, capsBufferLen, cmCapBfcp, leaveBfcpCaps, bfcpType);

	return exactCapsSizeAdd; // size of MediaLinesEntry with all added caps !!!
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
// copies caps from channels first, then from local or remote caps.
// sets port 0 for nonsupported, closed, panoramic media lines and
// for media caps which were added not from channels.
// sets dtmf cap, sets LPR cap
// sets ICE session generals
////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInviteResponseReqAcceptAnswererSetSdpAndCopyBuffers(mcReqInviteResponse* pInviteResponseMsg, int msgLen, BYTE isBwmForIBM)
{

	CSipCaps* pTempRemoteCap = new CSipCaps;
	PASSERT_AND_RETURN_VALUE(!pTempRemoteCap, FALSE);
	pTempRemoteCap->CreateIgnoringRemoveCodec(*m_pRemoteSdp, m_pParty->GetTargetMode()->GetConfMediaType(), m_bIsMrcCall);

	sipSdpAndHeadersSt* pSdpAndHeaders = &pInviteResponseMsg->sipSdpAndHeaders;

	int exactCapsSize			= 0;

	// add capabilities to the SDP from channels
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	APIU32 exactCapsSizeChannels	= 0;
	//int capChannelsBufferLen		= 0;
	//capChannelsBufferLen 			= msgLen - exactCapsSize;


	BOOL   bOverrideSavpWithAvp = IsForceAvpOnEncryptWhenPossible();
	APIU16 plcmRequireMask 		= bOverrideSavpWithAvp?m_plcmRequireAvp:0;

	//m_pParty->GetTargetMode()->Dump("CSipCntl::SipInviteResponseReqAcceptAnswererSetSdpAndCopyBuffers, TargetMode:", eLevelInfoNormal);

	//CSuperLargeString msgRC1;
	//pTempRemoteCap->DumpToString(msgRC1);
	//PTRACE2(eLevelInfoNormal,"CSipCntl::SipInviteResponseReqAcceptAnswererSetSdpAndCopyBuffers, pTempRemoteCap: ", msgRC1.GetString());

	//CSuperLargeString msgRC2;
	//m_pLastRemoteCaps->DumpToString(msgRC2);
	//PTRACE2(eLevelInfoNormal,"CSipCntl::SipInviteResponseReqAcceptAnswererSetSdpAndCopyBuffers, m_pLastRemoteCaps: ", msgRC2.GetString());

	//CSuperLargeString msgRC3;
	//m_pChosenLocalCap->DumpToString(msgRC3);
	//PTRACE2(eLevelInfoNormal,"CSipCntl::SipInviteResponseReqAcceptAnswererSetSdpAndCopyBuffers, m_pChosenLocalCap: ", msgRC3.GetString());

	//TRACEINTO << "msgLen:" << (DWORD)msgLen << ", GetIsAllowSdesInSdp:" << (DWORD)GetIsAllowSdesInSdp() << ", m_bIsReInviteTransaction:" << (DWORD)m_bIsReInviteTransaction
	//		  << ", GetIsTipCall:" << (DWORD)GetIsTipCall() << ", plcmRequireMask:" << (DWORD)plcmRequireMask;

	exactCapsSizeChannels = m_pCall->CopyCapsToCapStruct((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
														msgLen, pTempRemoteCap, (!GetIsTipCall()?m_pLastRemoteCaps:NULL), //TIP H/R black screen fix
														cmCapReceive, TRUE, //FIX - VNGR-22779
														m_bIsReInviteTransaction, GetIsAllowSdesInSdp(), kUnknown, plcmRequireMask,
														m_pChosenLocalCap);
	exactCapsSize += exactCapsSizeChannels;
	PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	PTRACE2INT(eLevelInfoNormal,"DBG CSipCntl::SipInviteResponseReqAcceptAnswererSetSdpAndCopyBuffers after adding caps from channels exactCapsSize = ", exactCapsSize);
	//-----------------------------------------------------------------------------------------------------------------------------------------------------


	// add the close media (by port = zero) into the responses or the other algorithms in case of dial in with no SDP flow.
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	int exactCapsSizeAdd		= 0;
	exactCapsSizeAdd = SipInviteResponseReqAnswererAddMediaCapsNotFromChannels(pSdpAndHeaders, pTempRemoteCap, msgLen, isBwmForIBM); // channels are closed and there is media in remote SDP

	if(exactCapsSizeAdd)	exactCapsSizeAdd -= exactCapsSize;
	exactCapsSize += exactCapsSizeAdd;
	PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	//-----------------------------------------------------------------------------------------------------------------------------------------------------

	// add DTMF cap
	//26/09/11 - Do not send back dtmf cap if remote not support it (HDX can't handle crypted rfc2833 dtmf - this fix
	//			 will cause the HDX to send crypted dtmfs within the media)
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	//int dtmfCapBufferLen		= 0;
	//dtmfCapBufferLen 			= msgLen - exactCapsSize;
	int exactCapSizeDtmf		= 0;
	eMediaLineSubType bfcpType	= GetBfcpType();
	CCapSetInfo dtmfInfo = eRfc2833DtmfCapCode;
	if (m_pChosenLocalCap->IsCapSet(dtmfInfo) && m_pLastRemoteCaps->IsCapSet(dtmfInfo))
	{
		int dtmfIndex  = m_pChosenLocalCap->GetIndexInArr(dtmfInfo,0);
		if (dtmfIndex != NA)
		{
			exactCapSizeDtmf = m_pChosenLocalCap->AddSingleCapToCapStruct(cmCapAudio, dtmfIndex, cmCapReceive, NO,
																		(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																		msgLen, bfcpType);
			if(exactCapSizeDtmf) exactCapSizeDtmf -= exactCapsSize;
			exactCapsSize += exactCapSizeDtmf;
			PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
		}
	}
	//-----------------------------------------------------------------------------------------------------------------------------------------------------

	int leaveAudioCaps		= NO; //  - remove this
	int leaveVideoCaps		= NO;
	int leaveDataCaps		= NO;
	int leaveContentCaps	= NO;
	int leaveBfcpCaps		= NO;
	SipInviteResponseReqLeaveMedia(TRUE, pTempRemoteCap, leaveAudioCaps, leaveVideoCaps, leaveDataCaps, leaveContentCaps, leaveBfcpCaps);

	//  add LPR cap for video and for content -
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	int exactCapSizeLpr		= 0;
	CCapSetInfo lprInfo		= eLPRCapCode;

	BYTE addLpr = m_pChosenLocalCap->GetIsLpr() && m_pChosenLocalCap->IsMedia(cmCapVideo) && m_pChosenLocalCap->IsCapSet(lprInfo);
	addLpr = addLpr && (((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->numberOfMediaLines > 1);
	addLpr = addLpr && !(GetIsTipCall() && m_bIsReInviteTransaction == TRUE);
	if (addLpr)
	{
		int lprIndex  = m_pChosenLocalCap->GetIndexInArr(lprInfo,0);
		if(lprIndex != NA)
		{
			TRACEINTOFUNC << "adding LPR for people";
			exactCapSizeLpr = m_pChosenLocalCap->AddSingleCapToCapStruct(cmCapVideo, lprIndex, cmCapReceive, NO,
																	(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																	msgLen, bfcpType);
		}
		if(m_pCall->IsMedia(cmCapVideo,cmCapReceive,kRolePresentation) || m_pCall->IsMedia(cmCapVideo,cmCapTransmit,kRolePresentation) || leaveContentCaps)
		{
			TRACEINTOFUNC << "adding LPR for content";
			int lprPresentationIndex = m_pChosenLocalCap->GetIndexInArr(lprInfo,0,kRolePresentation);
			if (lprPresentationIndex != NA)
				exactCapSizeLpr += m_pChosenLocalCap->AddSingleCapToCapStruct(cmCapVideo, lprPresentationIndex, cmCapReceive, NO,
																		(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																		msgLen, bfcpType, kRolePresentation);
		}

		if(exactCapSizeLpr) exactCapSizeLpr -= exactCapsSize;
		exactCapsSize += exactCapSizeLpr;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}


	////////////////////////////////////////////////////////////////////////////
	//LYNC2013_FEC_RED: add FEC cap (for video) and RED cap (for audio) if needed
	int exactCapSizeFec		= 0;
	CCapSetInfo fecInfo		= eFECCapCode;
	BYTE addFec = ( m_pParty && m_pParty->GetTargetMode() && m_pParty->GetTargetMode()->GetIsFec() &&
			m_pParty->GetTargetMode()->IsMediaOn(cmCapVideo) && m_pMaxLocalCaps->IsCapSet(fecInfo) );

	//TRACEINTO << "LYNC2013_FEC_RED: target:" << (DWORD)m_pParty->GetTargetMode()->GetIsFec() << ", chosen:" << (DWORD)m_pMaxLocalCaps->IsCapSet(fecInfo);

	addFec = addFec && (((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->numberOfMediaLines > 1);
	addFec = addFec && !(GetIsTipCall() && m_bIsReInviteTransaction == TRUE);
	if (addFec)
	{
		int fecIndex  = m_pMaxLocalCaps->GetIndexInArr(fecInfo,0);
		if(fecIndex != NA)
		{
			TRACEINTOFUNC << "LYNC2013_FEC_RED: adding FEC for people";
			exactCapSizeFec = m_pMaxLocalCaps->AddSingleCapToCapStruct(cmCapVideo, fecIndex, cmCapReceive, NO,
										(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,msgLen, bfcpType);
		}

		if(exactCapSizeFec) exactCapSizeFec -= exactCapsSize;
		exactCapsSize += exactCapSizeFec;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}

	int exactCapSizeRed		= 0;
	CCapSetInfo redInfo		= eREDCapCode;
	BYTE addRed = ( m_pParty && m_pParty->GetTargetMode() && m_pParty->GetTargetMode()->GetIsRed() &&
					m_pChosenLocalCap->IsMedia(cmCapAudio) && m_pChosenLocalCap->IsCapSet(redInfo) );
	addRed = addRed && !(GetIsTipCall() && m_bIsReInviteTransaction == TRUE);

	//TRACEINTO << "LYNC2013_FEC_RED: FEC: target:" << (DWORD)m_pParty->GetTargetMode()->GetIsRed() << ", chosen:" << (DWORD)m_pChosenLocalCap->IsCapSet(redInfo);

	if (addRed)
	{
		int redIndex  = m_pChosenLocalCap->GetIndexInArr(redInfo,0);
		if(redIndex != NA)
		{
			TRACEINTOFUNC << "LYNC2013_FEC_RED: adding RED for people";
			exactCapSizeRed = m_pChosenLocalCap->AddSingleCapToCapStruct(cmCapAudio, redIndex, cmCapReceive, NO,
							               (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,msgLen, bfcpType);
		}

		if(exactCapSizeRed) exactCapSizeRed -= exactCapsSize;
		exactCapsSize += exactCapSizeRed;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}
	////////////////////////////////////////////////////////////////////////////


	//  Add unsupported media lines and set port 0 for these mlines
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	int exactCapSizeNotSupported = 0;
	int numberOfNotSupported = ::GetNumberOfMediaLinesOfIntenalType(m_pRemoteSdp, kMediaLineInternalTypeNotSupported, exactCapSizeNotSupported);
	if(numberOfNotSupported > 0)
	{
		/*exactCapSizeNotSupported = */AddNotSupportedMediaLines(numberOfNotSupported, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders);
		exactCapsSize += exactCapSizeNotSupported;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}
	//-----------------------------------------------------------------------------------------------------------------------------------------------------


	//  Add media lines of closed channels (that are not exist in the localCaps but exist in the remote) :
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	vector<eMediaLineInternalType> closedChannelsCopiedTypes;
	vector<int> closedChannelsCopiedIndexes;
	int exactCapSizeCloseChannels = 0;
	int sizeOfClosed = 0;

	if (!IsAnatSupported())
		sizeOfClosed = GetClosedMediaSize();
	else
		sizeOfClosed = GetClosedMediaSizeForAnat();

	if (sizeOfClosed > 0)
	{
		if (!IsAnatSupported())
			exactCapSizeCloseChannels += AddClosedMediaLinesFromRemoteSDP(&pInviteResponseMsg->sipSdpAndHeaders, &closedChannelsCopiedTypes);
		else
			exactCapSizeCloseChannels += AddClosedMediaLinesFromRemoteSDPForAnat(&pInviteResponseMsg->sipSdpAndHeaders, &closedChannelsCopiedIndexes);

		exactCapsSize += exactCapSizeCloseChannels;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}
	//-----------------------------------------------------------------------------------------------------------------------------------------------------

	//  Add simulcast video mlines in case AVMCU
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	// set Lync2013 specific attributes:
	if( m_isMs2013Active )
		SetLync2013SpecificMLinesAttributes(*pSdpAndHeaders);

	int addSimulcastVideoMLinesSize = 0;
	int addSimulcastUnsupportedMLinesSize = 0;
	if( eMsft2013AvMCU == m_isMs2013Active )
	{
		addSimulcastVideoMLinesSize = AddSimulcastVideoMLinesToSDPForLync2013(pSdpAndHeaders);
		exactCapsSize += addSimulcastVideoMLinesSize;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}

	// add panoramic media line with port 0
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	//int exactCapSizePanoramicVideo = 0;
	int sizeOfPanoramicVideoInRemote = 0;
	int sizeOfVideo = 0;
	int numberOfVideoMLines = ::GetNumberOfMediaLinesOfIntenalType(m_pRemoteSdp, kMediaLineInternalTypeVideo, sizeOfVideo);
	if(::GetNumberOfMediaLinesOfPanoramicType(m_pRemoteSdp, sizeOfPanoramicVideoInRemote) > 0)
	{
		/*exactCapSizePanoramicVideo = */AddPanoramicMediaLines(numberOfVideoMLines, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders);
		exactCapsSize += sizeOfPanoramicVideoInRemote;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}
	//-----------------------------------------------------------------------------------------------------------------------------------------------------


	// update media lines headers in capsAndHeadersStruct:
	pSdpAndHeaders->sipMediaLinesOffset = 0;
	pSdpAndHeaders->sipMediaLinesLength = exactCapsSize;
	pSdpAndHeaders->lenOfDynamicSection = exactCapsSize;


	//  Add Ice Generals
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	BYTE* IceGeneralbuffer = (BYTE *)pSdpAndHeaders->capsAndHeaders + pSdpAndHeaders->lenOfDynamicSection; // change pSdpAndHeaders->lenOfDynamicSection to exactCapsSize ???
	DWORD TotalIceGeneralSize = BuildIceSessionPart(IceGeneralbuffer);

	if(TotalIceGeneralSize)
	{
		pSdpAndHeaders->sipIceOffset = pSdpAndHeaders->lenOfDynamicSection;
		pSdpAndHeaders->sipIceLength = TotalIceGeneralSize;
	}

	exactCapsSize += TotalIceGeneralSize;
	PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	//-----------------------------------------------------------------------------------------------------------------------------------------------------

	// update length of dynamic section - caps + ICE session generals
	pSdpAndHeaders->lenOfDynamicSection = exactCapsSize;
	//-----------------------------------------------------------------------------------------------------------------------------------------------------

	// Set  IP addresses and ports
	//--------------------------------------------------------------------------------------------------------------------------------------------
	SipInviteResponseReqAnswererSetIpAndPorts(pInviteResponseMsg, pTempRemoteCap, closedChannelsCopiedTypes,  closedChannelsCopiedIndexes,isBwmForIBM);
	//--------------------------------------------------------------------------------------------------------------------------------------------

	POBJDELETE(pTempRemoteCap);

	TRACEINTOFUNC   << "\n--- The exact SDP sizes -----"
			<< "\nDynamic section len = " << pSdpAndHeaders->lenOfDynamicSection
			<< "\nAdded Exact Cap len = " << exactCapsSize
			<< "\nAdded Current channels len = " << exactCapsSizeChannels
			<< "\nAdded Additional codecs len = " << exactCapsSizeAdd
			<< "\nAdded DTMF len = " << exactCapSizeDtmf
			<< "\nAdded LPR len = " << exactCapSizeLpr
			<< "\nAdded FEC len = " << exactCapSizeFec
			<< "\nAdded RED len = " << exactCapSizeRed
			<< "\nAdded not supported len = " << exactCapSizeNotSupported
			<< "\nAdded panoramic video len = " << sizeOfPanoramicVideoInRemote
			<< "\nAdded Close Channels len = " << exactCapSizeCloseChannels
			<< "\nAdded ICE Generals len = " << TotalIceGeneralSize
			<< "\nAdded Simulcast Video MLines len = " << addSimulcastVideoMLinesSize;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInviteResponseReqAcceptOffererSetSdpAndCopyBuffers(mcReqInviteResponse* pInviteResponseMsg, int msgLen)
{
	sipSdpAndHeadersSt* pSdpAndHeaders = &pInviteResponseMsg->sipSdpAndHeaders;
	int exactCapsSize		= 0;

	// copy caps from the current channels
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	APIU32 exactCapsSizeChannels	= 0;
	//int capChannelsBufferLen	= 0;
	//capChannelsBufferLen = msgLen - exactCapsSize;
	CSipCaps* pTempRemoteCap = new CSipCaps; // ?? we pass it to CopyCapsToCapStruct, but maybe we should pass NULL instead.
	BOOL   bOverrideSavpWithAvp = IsForceAvpOnEncryptWhenPossible();
	APIU16 plcmRequireMask 		= bOverrideSavpWithAvp?m_plcmRequireAvp:0;

	//BRIDGE-12009
	BYTE bTakeSdesFromTx = FALSE;
	if( m_pCall &&
					(kConnected == GetChannelConnectionState(cmCapAudio, cmCapTransmit, kRolePeople)) &&
					(kConnected == GetChannelConnectionState(cmCapVideo, cmCapTransmit, kRolePeople))
	  )
		bTakeSdesFromTx = TRUE;



	exactCapsSizeChannels = m_pCall->CopyCapsToCapStruct((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
														msgLen, pTempRemoteCap, (!GetIsTipCall()?m_pLastRemoteCaps:NULL), //TIP H/R black screen fix
														cmCapReceive, bTakeSdesFromTx, //FIX - VNGR-22779 //BRIDGE-12009
														m_bIsReInviteTransaction, GetIsAllowSdesInSdp(), kUnknown, plcmRequireMask,
														m_pChosenLocalCap);
	exactCapsSize += exactCapsSizeChannels;
	PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	//-----------------------------------------------------------------------------------------------------------------------------------------------------


	// set caps not from channels
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	int leaveAudioCaps		= NO;
	int leaveVideoCaps		= NO;
	int leaveDataCaps		= NO;
	int leaveContentCaps	= NO;
	int leaveBfcpCaps		= NO;
	SipInviteResponseReqLeaveMedia(FALSE, NULL, leaveAudioCaps, leaveVideoCaps, leaveDataCaps, leaveContentCaps, leaveBfcpCaps);

	//int addedCapsBufferLen		= 0;
	//addedCapsBufferLen 			= msgLen - exactCapsSize;
	eMediaLineSubType bfcpType	= GetBfcpType();
	int exactCapsSizeAdd		= 0;

	if (GetIsTipCall() && !(m_bIsReInviteTransaction == NO))
		leaveVideoCaps = NO;
	exactCapsSizeAdd = m_pChosenLocalCap->AddCapsToCapStruct(cmCapReceiveAndTransmit, NO, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																msgLen, bfcpType,leaveAudioCaps, leaveVideoCaps,
																leaveDataCaps, leaveContentCaps, NO, bOverrideSavpWithAvp);
	if(exactCapsSizeAdd)	exactCapsSizeAdd -= exactCapsSize;
	exactCapsSize += exactCapsSizeAdd;
	PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	//-----------------------------------------------------------------------------------------------------------------------------------------------------

	//  add DTMF cap
	//26/09/11 - Do not send back dtmf cap if remote not support it (HDX can't handle crypted rfc2833 dtmf - this fix
	//			 will cause the HDX to send crypted dtmfs within the media)
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	//int dtmfCapBufferLen		= 0;
	//dtmfCapBufferLen 			= msgLen - exactCapsSize;
	int exactCapSizeDtmf		= 0;
	CCapSetInfo dtmfInfo = eRfc2833DtmfCapCode;
	if (m_pChosenLocalCap->IsCapSet(dtmfInfo) && m_pLastRemoteCaps->IsCapSet(dtmfInfo))
	{
		int dtmfIndex  = m_pChosenLocalCap->GetIndexInArr(dtmfInfo,0);
		if (dtmfIndex != NA)
		{
			exactCapSizeDtmf = m_pChosenLocalCap->AddSingleCapToCapStruct(cmCapAudio, dtmfIndex, cmCapReceive, NO,
																		(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																		msgLen, bfcpType);
			if(exactCapSizeDtmf) exactCapSizeDtmf -= exactCapsSize;
			exactCapsSize += exactCapSizeDtmf;
			PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
		}
	}

	//-----------------------------------------------------------------------------------------------------------------------------------------------------

	//  add LPR cap for video and for content - SipInviteResponseAddLPRCaps
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	//int lprCapBufferLen		= 0;
	//lprCapBufferLen 		= msgLen - exactCapsSize;
	int exactCapSizeLpr		= 0;
	CCapSetInfo lprInfo		= eLPRCapCode;
	BYTE addLpr = m_pChosenLocalCap->GetIsLpr() && m_pChosenLocalCap->IsMedia(cmCapVideo) && m_pChosenLocalCap->IsCapSet(lprInfo);
	addLpr = addLpr && (((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->numberOfMediaLines > 1);
	addLpr = addLpr && !(GetIsTipCall() && m_bIsReInviteTransaction == TRUE);
	if (addLpr)
	{
		int lprIndex  = m_pChosenLocalCap->GetIndexInArr(lprInfo,0);
		if(lprIndex != NA)
		{
			TRACEINTOFUNC << "adding LPR for people";
			exactCapSizeLpr = m_pChosenLocalCap->AddSingleCapToCapStruct(cmCapVideo, lprIndex, cmCapReceive, NO,
																	(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																	msgLen, bfcpType);
		}
		if(m_pCall->IsMedia(cmCapVideo,cmCapReceive,kRolePresentation) || m_pCall->IsMedia(cmCapVideo,cmCapTransmit,kRolePresentation) || leaveContentCaps)
		{
			TRACEINTOFUNC << "adding LPR for content";
			int lprPresentationIndex = m_pChosenLocalCap->GetIndexInArr(lprInfo,0,kRolePresentation);
			if (lprPresentationIndex != NA)
				exactCapSizeLpr += m_pChosenLocalCap->AddSingleCapToCapStruct(cmCapVideo, lprPresentationIndex, cmCapReceive, NO,
																		(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																		msgLen, bfcpType, kRolePresentation);
		}
		if(exactCapSizeLpr)	exactCapSizeLpr -= exactCapsSize;
		exactCapsSize += exactCapSizeLpr;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}

	////////////////////////////////////////////////////////////////////////////
	//LYNC2013_FEC_RED: add FEC cap (for video) and RED cap (for audio) if needed
	int exactCapSizeFec		= 0;
	CCapSetInfo fecInfo		= eFECCapCode;
	BYTE addFec = ( m_pParty && m_pParty->GetTargetMode() && m_pParty->GetTargetMode()->GetIsFec() &&
					m_pParty->GetTargetMode()->IsMediaOn(cmCapVideo) && m_pMaxLocalCaps->IsCapSet(fecInfo) );

	//TRACEINTO << "LYNC2013_FEC_RED: FEC: target:" << (DWORD)m_pParty->GetTargetMode()->GetIsFec() << ", chosen:" << (DWORD)m_pMaxLocalCaps->IsCapSet(fecInfo);

	addFec = addFec && (((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->numberOfMediaLines > 1);
	addFec = addFec && !(GetIsTipCall() && m_bIsReInviteTransaction == TRUE);
	if (addFec)
	{
		int fecIndex  = m_pMaxLocalCaps->GetIndexInArr(fecInfo,0);
		if(fecIndex != NA)
		{
			TRACEINTOFUNC << "LYNC2013_FEC_RED: adding FEC for people";
			exactCapSizeFec = m_pMaxLocalCaps->AddSingleCapToCapStruct(cmCapVideo, fecIndex, cmCapReceive, NO,
				                        	(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,msgLen, bfcpType);
		}

		if(exactCapSizeFec)	exactCapSizeFec -= exactCapsSize;
		exactCapsSize += exactCapSizeFec;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}

	int exactCapSizeRed		= 0;
	CCapSetInfo redInfo		= eREDCapCode;
	BYTE addRed = ( m_pParty && m_pParty->GetTargetMode() && m_pParty->GetTargetMode()->GetIsRed() &&
			        m_pChosenLocalCap->IsMedia(cmCapAudio) && m_pChosenLocalCap->IsCapSet(redInfo) );
	addRed = addRed && !(GetIsTipCall() && m_bIsReInviteTransaction == TRUE);

	//TRACEINTO << "LYNC2013_FEC_RED: FEC: target:" << (DWORD)m_pParty->GetTargetMode()->GetIsRed() << ", chosen:" << (DWORD)m_pChosenLocalCap->IsCapSet(redInfo);

	if (addRed)
	{
		int redIndex  = m_pChosenLocalCap->GetIndexInArr(redInfo,0);
		if(redIndex != NA)
		{
			TRACEINTOFUNC << "LYNC2013_FEC_RED: adding RED for people";
			exactCapSizeRed = m_pChosenLocalCap->AddSingleCapToCapStruct(cmCapAudio, redIndex, cmCapReceive, NO,
					                         (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,msgLen, bfcpType);
		}
		if(exactCapSizeRed)	exactCapSizeRed -= exactCapsSize;
		exactCapsSize += exactCapSizeRed;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}
	////////////////////////////////////////////////////////////////////////////



	// Add unsupported media lines with port 0
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	int notSupportedCapBufferLen		= 0;
	notSupportedCapBufferLen 			= msgLen - exactCapsSize;
	int exactCapSizeNotSupported		= 0;
	int sizeOfNotSupported 				= 0;
	int numberOfNotSupported 			= 0;
	numberOfNotSupported = ::GetNumberOfMediaLinesOfIntenalType(m_pRemoteSdp, kMediaLineInternalTypeNotSupported, exactCapSizeNotSupported);

	if(numberOfNotSupported > 0)
	{
		TRACEINTOFUNC << "ANAT: type - " << kMediaLineInternalTypeNotSupported << ", not supported number - " << numberOfNotSupported;
		AddNotSupportedMediaLines(numberOfNotSupported, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders);
		exactCapsSize += exactCapSizeNotSupported;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}
	//-----------------------------------------------------------------------------------------------------------------------------------------------------

	//  Add closed channels (that are not exist in the localCps but exist in the remote) lines size:
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	int closeChannelsCapBufferLen		= 0;
	closeChannelsCapBufferLen 			= msgLen - exactCapsSize;
	int exactCapSizeCloseChannels		= 0;
	int sizeOfCloseChannels				= 0;

	vector<eMediaLineInternalType> closedChannelsCopiedTypes;
	vector<int> closedChannelsCopiedIndexes;
	int sizeOfClosed = 0;
	if (!IsAnatSupported())  //added for ANAT
		sizeOfClosed = GetClosedMediaSize();
	else
		sizeOfClosed = GetClosedMediaSizeForAnat();

	if (sizeOfClosed > 0)
	{
		if (!IsAnatSupported())  //added for ANAT
			exactCapSizeCloseChannels += AddClosedMediaLinesFromRemoteSDP(pSdpAndHeaders, &closedChannelsCopiedTypes);
		else
			exactCapSizeCloseChannels += AddClosedMediaLinesFromRemoteSDPForAnat(pSdpAndHeaders, &closedChannelsCopiedIndexes);
	}
	exactCapsSize += exactCapSizeCloseChannels;
	PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	//-----------------------------------------------------------------------------------------------------------------------------------------------------

	// add panoramic media line with port 0
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	//int exactCapSizePanoramicVideo = 0;
	int sizeOfPanoramicVideoInRemote = 0;
	int sizeOfVideo = 0;
	int numberOfVideoMLines = ::GetNumberOfMediaLinesOfIntenalType(m_pRemoteSdp, kMediaLineInternalTypeVideo, sizeOfVideo);
	if(::GetNumberOfMediaLinesOfPanoramicType(m_pRemoteSdp, sizeOfPanoramicVideoInRemote) > 0)
	{
		/*exactCapSizePanoramicVideo = */AddPanoramicMediaLines(numberOfVideoMLines, (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders);
		exactCapsSize += sizeOfPanoramicVideoInRemote;
		PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	}
	//-----------------------------------------------------------------------------------------------------------------------------------------------------

	// update media lines offset and length:
	pSdpAndHeaders->sipMediaLinesOffset = 0;
	pSdpAndHeaders->sipMediaLinesLength = exactCapsSize;
	pSdpAndHeaders->lenOfDynamicSection = exactCapsSize;

	// Add Ice Generals
	//-----------------------------------------------------------------------------------------------------------------------------------------------------
	BYTE* IceGeneralbuffer = (BYTE *)pSdpAndHeaders->capsAndHeaders + pSdpAndHeaders->lenOfDynamicSection;
	DWORD TotalIceGeneralSize = BuildIceSessionPart(IceGeneralbuffer);
	if(TotalIceGeneralSize)
	{
		pSdpAndHeaders->sipIceOffset = pSdpAndHeaders->lenOfDynamicSection;
		pSdpAndHeaders->sipIceLength = TotalIceGeneralSize;
	}

	exactCapsSize += TotalIceGeneralSize;
	PASSERT_AND_RETURN_VALUE((exactCapsSize > msgLen), FALSE);
	//-----------------------------------------------------------------------------------------------------------------------------------------------------

	// update length of dynamic section - media lines + ICE gelerals
	pSdpAndHeaders->lenOfDynamicSection = exactCapsSize;

	POBJDELETE(pTempRemoteCap);

	TRACEINTOFUNC   << "\n--- The exact SDP sizes -----"
			<< "\nDynamic section len = " << pSdpAndHeaders->lenOfDynamicSection
			<< "\nAdded Exact Cap len = " << exactCapsSize
			<< "\nAdded Current channels len = " << exactCapsSizeChannels
			<< "\nAdded Additional codecs len = " << exactCapsSizeAdd
			<< "\nAdded DTMF len = " << exactCapSizeDtmf
			<< "\nAdded LPR len = " << exactCapSizeLpr
			<< "\nAdded FEC len = " << exactCapSizeFec
			<< "\nAdded RED len = " << exactCapSizeRed
			<< "\nAdded not supported len = " << exactCapSizeNotSupported
			<< "\nAdded Close Channels len = " << exactCapSizeCloseChannels
			<< "\nAdded ICE Generals len = " << TotalIceGeneralSize;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInviteResponseReqAcceptOfferer(CSipHeaderList &headerList, BYTE isBwmForIBM)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteResponseReqAcceptOferer, isDialInNoSdp YES ");
	GetPlcmRequireHeaderMask(m_pRemoteSdp,&m_plcmRequireMask, m_plcmReqMaskMlineOrder);
	if(IsForceAvpOnEncryptWhenPossible())
	{
		m_plcmRequireMask = m_plcmRequireMask & ~m_plcmRequireSavp; /* turn off savp bit */
		m_plcmRequireMask |= m_plcmRequireAvp; /* turn on avp bit*/
	}

	BYTE bMessageSent 		= NO;

	// allocate the message buffer and set mcReqInviteResponse fields
	//--------------------------------------------------------------------------------------------------------------------------------------------
	mcReqInviteResponse* pInviteResponseMsg = (mcReqInviteResponse* )new BYTE[SIP_INIT_INVITE_RESPONSE_BUFFER_SIZE];
	PASSERT_AND_RETURN_VALUE(!pInviteResponseMsg, bMessageSent);
	DWORD sizeInviteRepsonseGenericFields = SipInviteResponseReqSetResponseMsg(pInviteResponseMsg, SIP_INIT_INVITE_RESPONSE_BUFFER_SIZE, STATUS_OK);
	//--------------------------------------------------------------------------------------------------------------------------------------------

	// copy data and set pSdpAndHeaders fields
	//--------------------------------------------------------------------------------------------------------------------------------------------
	SipInviteResponseReqAcceptOffererSetSdpAndCopyBuffers(pInviteResponseMsg, SIP_INIT_INVITE_RESPONSE_BUFFER_SIZE - sizeInviteRepsonseGenericFields);
	SipInviteResponseReqSetSDPGenericFields(pInviteResponseMsg, isBwmForIBM);
	//--------------------------------------------------------------------------------------------------------------------------------------------

	// Add SIP Headers to Buffer
	//--------------------------------------------------------------------------------------------------------------------------------------------
	sipSdpAndHeadersSt* pSdpAndHeaders  = &pInviteResponseMsg->sipSdpAndHeaders;
	pSdpAndHeaders->sipHeadersOffset = pSdpAndHeaders->lenOfDynamicSection;
	pSdpAndHeaders->sipHeadersLength = 	headerList.GetTotalLen();
	sipMessageHeaders* pHeaders		 = (sipMessageHeaders*)((char*)pSdpAndHeaders->capsAndHeaders + pSdpAndHeaders->sipHeadersOffset);
	pSdpAndHeaders->lenOfDynamicSection += headerList.BuildMessage(pHeaders);
	//--------------------------------------------------------------------------------------------------------------------------------------------

	TRACEINTOFUNC   << "\n--- DBG caps and headers -----"
				<< "\nDynamic section len = " << pSdpAndHeaders->lenOfDynamicSection
				<< "\nMedaia lines offset = " << pSdpAndHeaders->sipMediaLinesOffset
				<< "\nMedia lines length = " << pSdpAndHeaders->sipMediaLinesLength
				<< "\nICE Generals offset = " << pSdpAndHeaders->sipIceOffset
				<< "\nICE Generals length = " << pSdpAndHeaders->sipIceLength
				<< "\nHeaders offset = " << pSdpAndHeaders->sipHeadersOffset
				<< "\nHeaders length = " << pSdpAndHeaders->sipHeadersLength
				;

	// Set Session IP address
	//--------------------------------------------------------------------------------------------------------------------------------------------
	((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->bMainMediaIpPresent = TRUE;
	SetSessionIpAddress(((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->mainMediaIp);
	SetIpAddressToAllMedias(pSdpAndHeaders);

	//--------------------------------------------------------------------------------------------------------------------------------------------

	// set rates in sdp
	//--------------------------------------------------------------------------------------------------------------------------------------------
	SipInviteResponseReqSetMediaRatesInSDP(pSdpAndHeaders);
	ReduceVideoRate(YES, &pInviteResponseMsg->sipSdpAndHeaders);
	SetSelfFlowControl(NO); //clear the flag because does not expected any SDP in response
	//--------------------------------------------------------------------------------------------------------------------------------------------


	// set direction attribute
	//'a=INACTIVE, SENDONLY etc.
	if( m_bIsReInviteTransaction )
	{
		::SetTheDirectionAttribute(pSdpAndHeaders,cmCapReceiveAndTransmit,cmCapReceiveAndTransmit,cmCapReceiveAndTransmit,cmCapReceiveAndTransmit,cmCapReceiveAndTransmit, TRUE);
		PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteResponseReqAcceptOferer: reInvite dial-in no SDP : set all to a=sendrecv");
	}

	// In case we have content in sdp: set labels of media lines - SetLablesAndContentAttributesInSDP()
	//--------------------------------------------------------------------------------------------------------------------------------------------
	if (!IsAnatSupported()) //added for ANAT
		SetLabelsAndContentAttributesInLocalSdp(*pSdpAndHeaders);
	else
		SetLabelsAndContentAttributesInLocalSdpForAnat(*pSdpAndHeaders);
	//--------------------------------------------------------------------------------------------------------------------------------------------

	//change ICE subType (TCP/RTP/AVP etc.)
	SetIceMlineSubTypesIfNeeded(pSdpAndHeaders);

	// order media lines
	//--------------------------------------------------------------------------------------------------------------------------------------------
	if (!IsAnatSupported()) //added for ANAT
	{
		int sizeOfPanoramicMLines = 0;
		if(::GetNumberOfMediaLinesOfPanoramicType(m_pRemoteSdp, sizeOfPanoramicMLines) > 0)
			OrderMediaLinesWithPanoramic(*pSdpAndHeaders);
		else if (GetPlcmRequireMask() & m_plcmRequireAudio)
			OrderMediaLinesByPlcmRequireTags(pInviteResponseMsg->sipSdpAndHeaders);
		else
			OrderMediaLines(*pSdpAndHeaders);
	}
	else
		OrderMediaLinesForAnat(*pSdpAndHeaders);
	//--------------------------------------------------------------------------------------------------------------------------------------------


	// save the last sent sdp
	SetLocalSdp(pInviteResponseMsg->sipSdpAndHeaders);

        // Remove operation points for slave cascade
	if (GetCascadeMode()== CASCADE_MODE_SLAVE)
		RemoveOperationPointsFromSvcCap(pInviteResponseMsg->sipSdpAndHeaders);


	if(m_isMs2013Active)
		SetLync2013SpecificMLinesAttributes(*pSdpAndHeaders);

	//add for CG_SoftMCU
	if (IsCallGeneratorConf())// we set Call generator only for accept calls == when status is OK.
	{
		pInviteResponseMsg->callGeneratorParams.bIsCallGenerator=1;
		pInviteResponseMsg->callGeneratorParams.eEndpointModel=endpointModelHDX9000;
	}

	// send invite response message
	//--------------------------------------------------------------------------------------------------------------------------------------------
	bMessageSent = SipInviteResponseReqSendMsg(pInviteResponseMsg);

	if((IsValidTimer(PARTYCSKEEPALIVEFIRSTTOUT) == FALSE) && (pInviteResponseMsg->status == STATUS_OK))
	{
		// start the CS <-> party loop of keep alive (response 200 OK and first time we response to invite indication).
		StartCsPartyErrHandlingLoop();
	}
	//--------------------------------------------------------------------------------------------------------------------------------------------

	PDELETEA(pInviteResponseMsg);
	return bMessageSent;
}

void CSipCntl::SipInviteResponseReqAnswererSetIpAndPorts(mcReqInviteResponse* pInviteResponseMsg, CSipCaps* pTempRemoteCap, vector<eMediaLineInternalType> closedChannelsCopiedTypes, vector<int> closedChannelsCopiedIndexes, BYTE isBwmForIBM )
{
	sipSdpAndHeadersSt* pSdpAndHeaders = &pInviteResponseMsg->sipSdpAndHeaders;


    // Set Session IP address
    ((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->bMainMediaIpPresent = TRUE;
    SetSessionIpAddress(((sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders)->mainMediaIp);
    SetIpAddressToAllMedias(pSdpAndHeaders);
    m_pNetSetup->SetSipLocalMediaType((enIpVersion)ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.ipVersion);

    // set port 0 for media not from channels
    int leaveAudioCaps        = NO;
    int leaveVideoCaps        = NO;
    int leaveDataCaps        = NO;
    int leaveContentCaps    = NO;
    int leaveBfcpCaps        = NO;
    SipInviteResponseReqLeaveMedia(TRUE, pTempRemoteCap, leaveAudioCaps, leaveVideoCaps, leaveDataCaps, leaveContentCaps, leaveBfcpCaps);


    if (isBwmForIBM)
    {
        int remotePort  = 0;

        remotePort = m_pRemoteSdp ? ExtractMLineMediaIp(kMediaLineInternalTypeAudio, m_pRemoteSdp, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port : 0;
        if(leaveAudioCaps && !remotePort)
            ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;

        remotePort = m_pRemoteSdp ? ExtractMLineMediaIp(kMediaLineInternalTypeVideo, m_pRemoteSdp, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port : 0;
        if(leaveVideoCaps && !remotePort)
            ExtractMLineMediaIp(kMediaLineInternalTypeVideo, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;

        remotePort = m_pRemoteSdp ? ExtractMLineMediaIp(kMediaLineInternalTypeFecc, m_pRemoteSdp, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port : 0;
        if(leaveDataCaps && !remotePort)
            ExtractMLineMediaIp(kMediaLineInternalTypeFecc, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;

        remotePort = m_pRemoteSdp ? ExtractMLineMediaIp(kMediaLineInternalTypeContent, m_pRemoteSdp, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port : 0;
        if(leaveContentCaps && !remotePort)
            ExtractMLineMediaIp(kMediaLineInternalTypeContent, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;

        //Set BFCP port to 0 allways
        if(leaveBfcpCaps)
            ExtractMLineMediaIp(kMediaLineInternalTypeBfcp, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
    }
    else
    {
        if(leaveAudioCaps)// if we don't support audio in the response (leaveAudioCaps means we have no matching audio), the media should be removed (= port 0), but the caps should be remain - put audio in the SDP but with port=0.
            ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
        if(leaveVideoCaps)
            ExtractMLineMediaIp(kMediaLineInternalTypeVideo, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
        if(leaveDataCaps)
            ExtractMLineMediaIp(kMediaLineInternalTypeFecc, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
        if(leaveContentCaps)
            ExtractMLineMediaIp(kMediaLineInternalTypeContent, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
        if(leaveBfcpCaps)
            ExtractMLineMediaIp(kMediaLineInternalTypeBfcp, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
    }


    // update port for closed media
    if (!IsAnatSupported()) //added for ANAT
       UpdatePortInClosedMedias(&pInviteResponseMsg->sipSdpAndHeaders, closedChannelsCopiedTypes);
    else
       UpdatePortInClosedMediasForAnat(&pInviteResponseMsg->sipSdpAndHeaders, closedChannelsCopiedIndexes);

    if (IsSameTimeEP()) //In sametime EP we must set the IP of unused media lines to the MCU IP
    {
    	PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteResponseReqAnswererSetIpAndPorts - setting media line IP address for sametime client");
    	for (unsigned int i = 0;; i++)
    	{
    		mcXmlTransportAddress &rMediaIp = ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted(), i);
    		if (&rMediaIp == &m_dummyMediaIp) //no more media lines
    			break;
    		if (rMediaIp.transAddr.port == 0)
    		{
    			PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteResponseReqAnswererSetIpAndPorts - Media line with port 0 found - setting IP to local IP");
    			SetLocalMediaIp(rMediaIp.transAddr.addr, cmCapAudio);
    		}
    	}
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInviteResponseReqAcceptAnswerer(CSipHeaderList &headerList, BYTE isBwmForIBM)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipInviteResponseReqAcceptAnswerer, invite with SDP");

	m_pCall->UpdateSdesChannels(m_pChosenLocalCap , TRUE);

	if(IsForceAvpOnEncryptWhenPossible())
	{
		m_plcmRequireMask = m_plcmRequireMask & ~m_plcmRequireSavp; /* turn off savp bit */
		m_plcmRequireMask |= m_plcmRequireAvp; /* turn on avp bit*/
	}

	BYTE bMessageSent = NO;

	//  allocate the message buffer and set mcReqInviteResponse generic fields
	BYTE* tmp = new BYTE[SIP_INIT_INVITE_RESPONSE_BUFFER_SIZE]; AUTO_DELETE_ARRAY(tmp);
	mcReqInviteResponse* pInviteResponseMsg = (mcReqInviteResponse* )tmp;
	PASSERT_AND_RETURN_VALUE(!pInviteResponseMsg, bMessageSent);
	DWORD sizeInviteResponseGenericFields = SipInviteResponseReqSetResponseMsg(pInviteResponseMsg, SIP_INIT_INVITE_RESPONSE_BUFFER_SIZE, STATUS_OK);

	//TRACEINTO << "sizeInviteResponseGenericFields:" << (DWORD)sizeInviteResponseGenericFields;


	//  set caps
	SipInviteResponseReqAcceptAnswererSetSdpAndCopyBuffers(pInviteResponseMsg, SIP_INIT_INVITE_RESPONSE_BUFFER_SIZE - sizeInviteResponseGenericFields, isBwmForIBM);

	// set SDP generic fields
	SipInviteResponseReqSetSDPGenericFields(pInviteResponseMsg,isBwmForIBM);

	// set SIP Headers
	//--------------------------------------------------------------------------------------------------------------------------------------------
	sipSdpAndHeadersSt* pSdpAndHeaders  = &pInviteResponseMsg->sipSdpAndHeaders;
	pSdpAndHeaders->sipHeadersOffset = pSdpAndHeaders->lenOfDynamicSection;
	pSdpAndHeaders->sipHeadersLength = 	headerList.GetTotalLen();
	sipMessageHeaders* pHeaders		 = (sipMessageHeaders*)((char*)pSdpAndHeaders->capsAndHeaders + pSdpAndHeaders->sipHeadersOffset);
	pSdpAndHeaders->lenOfDynamicSection += headerList.BuildMessage(pHeaders);
	//--------------------------------------------------------------------------------------------------------------------------------------------

	TRACEINTOFUNC   << "--- DBG caps and headers -----"
					<< "\nDynamic section len = " << pSdpAndHeaders->lenOfDynamicSection
					<< "\nMedaia lines offset = " << pSdpAndHeaders->sipMediaLinesOffset
					<< "\nMedia lines length = " << pSdpAndHeaders->sipMediaLinesLength
					<< "\nICE Generals offset = " << pSdpAndHeaders->sipIceOffset
					<< "\nICE Generals length = " << pSdpAndHeaders->sipIceLength
					<< "\nHeaders offset = " << pSdpAndHeaders->sipHeadersOffset
					<< "\nHeaders length = " << pSdpAndHeaders->sipHeadersLength
					;

	// Set Session IP addresses
	// set media rates in SDP
	//--------------------------------------------------------------------------------------------------------------------------------------------
	SipInviteResponseReqSetMediaRatesInSDP(pSdpAndHeaders);
	ReduceVideoRate(YES, &pInviteResponseMsg->sipSdpAndHeaders);
	SetSelfFlowControl(NO);//clear the flag because does not expected any SDP in response
	//--------------------------------------------------------------------------------------------------------------------------------------------

	//set ICE subType (TCP/RTP/AVP etc.) - it was after the ANAT label set in the original code
	SetIceMlineSubTypesIfNeeded(pSdpAndHeaders);

	// set direction attributes
	//--------------------------------------------------------------------------------------------------------------------------------------------
	CSipCaps* pTempRemoteCap = new CSipCaps;
	PASSERT_AND_RETURN_VALUE(!pTempRemoteCap, FALSE);
	pTempRemoteCap->CreateIgnoringRemoveCodec(*m_pRemoteSdp, m_pParty->GetTargetMode()->GetConfMediaType(), m_bIsMrcCall);

	//'a=INACTIVE, SENDONLY etc.
	bool bIsAudioMedia 		= m_pLastRemoteCaps->IsMedia(cmCapAudio, cmCapReceiveAndTransmit, kRolePeople);
	bool bIsVideoMedia		= m_pLastRemoteCaps->IsMedia(cmCapVideo, cmCapReceiveAndTransmit, kRolePeople);
	bool bIsDataMedia		= m_pLastRemoteCaps->IsMedia(cmCapData,  cmCapReceiveAndTransmit, kRolePeople);
	bool bIsContentMedia	= m_pLastRemoteCaps->IsMedia(cmCapVideo, cmCapReceiveAndTransmit, kRolePresentation);
	bool bIsBfcpMedia		= m_pLastRemoteCaps->IsMedia(cmCapBfcp,  cmCapReceiveAndTransmit, kRolePeople);

	BYTE audioDirection		= bIsAudioMedia		? (m_pLastRemoteCaps->GetDirection(cmCapAudio)) : (pTempRemoteCap->GetDirection(cmCapAudio));
	BYTE videoDirection		= bIsVideoMedia		? (m_pLastRemoteCaps->GetDirection(cmCapVideo)) : (pTempRemoteCap->GetDirection(cmCapVideo));
	BYTE dataDirection		= bIsDataMedia		? (m_pLastRemoteCaps->GetDirection(cmCapData)) : (pTempRemoteCap->GetDirection(cmCapData));
	BYTE contentDirection	= bIsContentMedia	? (m_pLastRemoteCaps->GetDirection(cmCapVideo, kRolePresentation)) : (pTempRemoteCap->GetDirection(cmCapVideo, kRolePresentation));
	BYTE bfcpDirection		= bIsBfcpMedia		? (m_pLastRemoteCaps->GetDirection(cmCapBfcp)) : (pTempRemoteCap->GetDirection(cmCapBfcp));

	::SetTheDirectionAttribute(pSdpAndHeaders, audioDirection, videoDirection, dataDirection, contentDirection, bfcpDirection);
	if(eMsft2013AvMCU == m_isMs2013Active)
	{
		::SetDirectionAttributesForAVMCU(pSdpAndHeaders);
	}
	//--------------------------------------------------------------------------------------------------------------------------------------------
	POBJDELETE(pTempRemoteCap);
	// In case we have content in sdp: set labels and content attributes
	//--------------------------------------------------------------------------------------------------------------------------------------------
	if (!IsAnatSupported())
		SetLabelsAndContentAttributesInLocalSdp(*pSdpAndHeaders);
	else
		SetLabelsAndContentAttributesInLocalSdpForAnat(*pSdpAndHeaders);
	//--------------------------------------------------------------------------------------------------------------------------------------------

	// order media lines
	//--------------------------------------------------------------------------------------------------------------------------------------------
	if (!IsAnatSupported()) //added for ANAT
	{
		if(eMsft2013AvMCU == m_isMs2013Active)
		{
			#ifdef LOGS_FOR_EXTRA_DEBUG
					PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAcceptAnswerer : OrderMediaLine1 ", 0);
			#endif
				
			OrderMediaLinesForMsft2013AVMCU(*pSdpAndHeaders);
		} 
		else
		{
			int sizeOfPanoramicMLines = 0;
			if(::GetNumberOfMediaLinesOfPanoramicType(m_pRemoteSdp, sizeOfPanoramicMLines) > 0)
				{
					#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAcceptAnswerer : OrderMediaLine2 ", 0);
					#endif
					OrderMediaLinesWithPanoramic(*pSdpAndHeaders);
				}
			else
				{
					#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAcceptAnswerer : OrderMediaLine3 ", 0);
					#endif
					OrderMediaLines(*pSdpAndHeaders);
				}
		}
	}
	else
		{
			#ifdef LOGS_FOR_EXTRA_DEBUG
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SipInviteResponseReqAcceptAnswerer : OrderMediaLine4 ", 0);
			#endif
			OrderMediaLinesForAnat(*pSdpAndHeaders);
		}
	//--------------------------------------------------------------------------------------------------------------------------------------------



	// save in SIPControl the last sent SDP
	SetLocalSdp(pInviteResponseMsg->sipSdpAndHeaders);

    // Remove operation points for Cascade
    if (GetCascadeMode()== CASCADE_MODE_SLAVE)
		RemoveOperationPointsFromSvcCap(pInviteResponseMsg->sipSdpAndHeaders);


	//add for CG_SoftMCU
	if (IsCallGeneratorConf())// we set Call generator only for accept calls == when status is OK.
	{
		pInviteResponseMsg->callGeneratorParams.bIsCallGenerator=1;
		pInviteResponseMsg->callGeneratorParams.eEndpointModel=endpointModelHDX9000;
	}
	// send invite response message
	bMessageSent = SipInviteResponseReqSendMsg(pInviteResponseMsg);

	if((IsValidTimer(PARTYCSKEEPALIVEFIRSTTOUT) == FALSE) && (pInviteResponseMsg->status == STATUS_OK))
	{
		// start the CS <-> party loop of keep alive (response 200 OK and first time we response to invite indication).
		StartCsPartyErrHandlingLoop();
	}

	return bMessageSent;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInviteResponseReqReject(CSipHeaderList &headerList, DWORD status)
{
	BYTE bMessageSent = NO;
	// in reject build only the headers with zero SDP
	int headersSize			= headerList.GetTotalLen();
	int capsAndHeadersSize	= headersSize;//no length to capabilities size in reject (bridge responses only with headers).

	int msgLen = sizeof(mcReqInviteResponse) + capsAndHeadersSize;
	mcReqInviteResponse* pInviteResponseMsg = NULL;
	pInviteResponseMsg = (mcReqInviteResponse* )new BYTE[msgLen];
	PASSERT_AND_RETURN_VALUE(!pInviteResponseMsg, bMessageSent);

	SipInviteResponseReqSetResponseMsg(pInviteResponseMsg, msgLen, status);

	sipSdpAndHeadersSt* pSdpAndHeaders = &pInviteResponseMsg->sipSdpAndHeaders;
	SipInviteResponseReqSetSdpHeaderStuctFields(pSdpAndHeaders, 0, 0, 0, 0, 0, headersSize, capsAndHeadersSize);

	sipMessageHeaders* pHeaders  = (sipMessageHeaders*)((char*)pSdpAndHeaders->capsAndHeaders + pSdpAndHeaders->sipHeadersOffset);
	headerList.BuildMessage(pHeaders);

	bMessageSent = SipInviteResponseReqSendMsg(pInviteResponseMsg);
	if (SipCodesRequestPending==status)
		m_state = IP_CONNECTING;
	PDELETEA(pInviteResponseMsg);
	return bMessageSent;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInviteResponseReqAccept(CSipHeaderList &headerList, BYTE isDialInNoSdp, BYTE isBwmForIBM)
{
	BYTE bMessageSent = NO;

	if(m_IsEnableICE)
	{
		m_pCall->ClearIceData();
		m_pCall->SetIceData(m_pChosenLocalCap);
	}

	if(isDialInNoSdp)
		bMessageSent = SipInviteResponseReqAcceptOfferer(headerList, isBwmForIBM);
	else
		bMessageSent = SipInviteResponseReqAcceptAnswerer(headerList, isBwmForIBM);
	return bMessageSent;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInviteResponseReq(DWORD status, int warning, const char* alternativeAddrStr, BYTE isDialInNoSdp, BYTE isBwmForIBM)
{
	 TRACEINTO << "m_state at beginning: " << m_state;

	BYTE bMessageSent = NO;

	CSipHeaderList headerList(0,0);
	BYTE rVal = SipInviteResponseReqBuildHeadersList(headerList, status, warning, alternativeAddrStr);
	if(rVal == FALSE)
	{// failed to set the headers
		DBGPASSERT(201);
		return bMessageSent;
	}

	if(status == OK_VAL)
		bMessageSent = SipInviteResponseReqAccept(headerList, isDialInNoSdp,isBwmForIBM);
	else
		bMessageSent = SipInviteResponseReqReject(headerList, status);

	return bMessageSent;

}

/////////////////////////////////////////////////////////////////////////
void CSipCntl::SetIceMlineSubTypesIfNeeded(sipSdpAndHeadersSt* pSdpAndHeaders)
{
	sipMediaLineSt* pAudioMediaLine = NULL;
	sipMediaLineSt* pVideoMediaLine = NULL;
	sipMediaLineSt* pDataMediaLine = NULL;

	eMediaLineSubType audioIceSubType;
	eMediaLineSubType videoIceSubType;
	eMediaLineSubType dataIceSubType;

	bool bIsSdes = false;

	if(GetIsEnableICE())
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SetIceMlineSubTypesIfNeeded, Ice Enabled");

		CIceParams* pIceParams = GetICEParams();
		if(pIceParams)
		{
			//Audio
			pAudioMediaLine = GetMediaLine(*pSdpAndHeaders, kMediaLineInternalTypeAudio);
			if(pAudioMediaLine)
			{
				bIsSdes = pIceParams->IsSubTypeSdes((eMediaLineSubType)(pAudioMediaLine->subType));
				audioIceSubType = pIceParams->GetSubType(cmCapAudio, bIsSdes);
				if(audioIceSubType > eMediaLineSubTypeUnknown)
				{
					pAudioMediaLine->subType = audioIceSubType;
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetIceMlineSubTypesIfNeeded - Set Audio SubType - ",audioIceSubType);
				}
			}

			//Video
			pVideoMediaLine = GetMediaLine(*pSdpAndHeaders, kMediaLineInternalTypeVideo);
			if(pVideoMediaLine)
			{
				bIsSdes = pIceParams->IsSubTypeSdes((eMediaLineSubType)(pVideoMediaLine->subType));
				videoIceSubType = pIceParams->GetSubType(cmCapVideo, bIsSdes);
				if(videoIceSubType > eMediaLineSubTypeUnknown)
				{
					pVideoMediaLine->subType = videoIceSubType;
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetIceMlineSubTypesIfNeeded - Set Video SubType - ",videoIceSubType);
				}
			}
			pVideoMediaLine = GetMediaLine(*pSdpAndHeaders, kMediaLineInternalTypeContent);
			if(pVideoMediaLine)
			{
				bIsSdes = pIceParams->IsSubTypeSdes((eMediaLineSubType)(pVideoMediaLine->subType));
				videoIceSubType = pIceParams->GetSubType(cmCapVideo, bIsSdes);
				if(videoIceSubType > eMediaLineSubTypeUnknown)
				{
					pVideoMediaLine->subType = videoIceSubType;
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetIceMlineSubTypesIfNeeded - Set Content SubType - ",videoIceSubType);
				}
			}

			//Data
			pDataMediaLine = GetMediaLine(*pSdpAndHeaders, kMediaLineInternalTypeFecc);
			if(pDataMediaLine)
			{
				bIsSdes = pIceParams->IsSubTypeSdes((eMediaLineSubType)(pDataMediaLine->subType));
				dataIceSubType = pIceParams->GetSubType(cmCapData, bIsSdes);
				if(dataIceSubType > eMediaLineSubTypeUnknown)
				{
					pDataMediaLine->subType = dataIceSubType;
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetIceMlineSubTypesIfNeeded - Set Fecc SubType - ",dataIceSubType);
				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::BuildIceSessionPart(BYTE* Buffer)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::BuildIceSessionPart");

	DWORD TotalGeneralIceSize = 0;

	BYTE* offset = Buffer;

	int m_numOfElem = m_pChosenLocalCap ->GetNumOfIceGeneralCaps();

	for(int i=0; i<m_numOfElem; i++)
	{
		capBuffer* CurCapBuffer = NULL;
		CurCapBuffer = m_pChosenLocalCap ->GetIceGeneralCapList(i);

		int	sizeOfICECapBuffer	= sizeof(capBufferBase) + CurCapBuffer->capLength;

		memcpy(offset,CurCapBuffer,sizeOfICECapBuffer);

		TotalGeneralIceSize += sizeOfICECapBuffer;

		offset += sizeOfICECapBuffer;

	}
	return TotalGeneralIceSize;
}





/////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipByeReq()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipByeReq");

	BYTE bMessageSent = NO;
	mcReqBye* pByeMsg = new mcReqBye;
	size_t size = sizeof(mcReqBye);
	memset(pByeMsg, 0, size);
	SendSIPMsgToCS(SIP_CS_SIG_BYE_REQ, pByeMsg, size);
	bMessageSent = YES;

	StartTimer(PARTYDISCONNECTTOUT, GetSIPMsgTimeout() * SECOND);
	PDELETE(pByeMsg);
	return bMessageSent;
}


////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipBye200OkReq()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipBye200OkReq");
	BYTE bMessageSent = NO;
	mcReqBye200Ok* pBye200OkMsg = new mcReqBye200Ok;
	size_t size = sizeof(mcReqBye200Ok);
	memset(pBye200OkMsg, 0, size);
	SendSIPMsgToCS(SIP_CS_SIG_BYE_200_OK_REQ, pBye200OkMsg, size);
	bMessageSent = YES;
	SetCallDisconnectedAndRemoveFromRsrcTbl();
	PDELETE(pBye200OkMsg);
	return bMessageSent;
}


//////////////////////////////////////////////////////
BYTE CSipCntl::SipRingingReq()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipRingingReq");
	BYTE bMessageSent = NO;

	CSipHeaderList headerList(MIN_ALLOC_HEADERS,0);
	if (GetIsMrcCall())
	{
		AddMrdHeader(headerList);
		AddInfoHeader(headerList);
	}

	AddContactHeader(headerList);
	AddParamsToSupportedHeader(headerList); //_dtls_

	const CSipHeader* pCalledPartyId = m_pCall ? m_pCall->GetCdrSpecificHeader(strlen("P-Called-Party-ID"),"P-Called-Party-ID") : NULL;
	if (pCalledPartyId)
	{
		// build asserted identity header with the smae contant
		CSmallString strAssertedIdentity = "P-Asserted-Identity";
		const char* headerContant = pCalledPartyId->GetHeaderStr() + strlen("P-Called-Party-ID");
		strAssertedIdentity << headerContant;
		headerList.AddHeader(kPrivateHeader,strAssertedIdentity.GetStringLength(),strAssertedIdentity.GetString());
	}

	int headersSize = headerList.GetTotalLen() - sizeof(sipMessageHeadersBase);	// the header base is included inside the ringing base
	mcReqRinging* pRingingMsg = (mcReqRinging*)new BYTE[sizeof(mcReqRinging) + headersSize];
	sipMessageHeaders* pHeaders = &(pRingingMsg->sipHeaders);
	headerList.BuildMessage(pHeaders);
	size_t size = sizeof(mcReqRinging) + headersSize;
	SendSIPMsgToCS(SIP_CS_SIG_RINGING_REQ, pRingingMsg, size);
	m_state = IP_CONNECTING;

	bMessageSent = YES;
	PDELETEA(pRingingMsg);
	return bMessageSent;
}

/////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipCloseChannelReq( EIpChannelType chanType)
{
	TRACEINTO << "channelType: " << chanType;
	TRACEINTO << "m_state: " << m_state;
	PTRACE2INT(eLevelError,"CSipCntl::SipCloseChannelReq m_state ",m_state);
	BYTE bMessageSent = NO;
	BYTE bNoChannels  = NO;
	CSipChannel* pChannel = NULL;
	CSipChannel* pChannelEx=NULL;
	int chnType=OPEN_CHANNEL_NORMAL_MODE;

	if (m_pCall && m_pCall->GetNumOfChannels())
	{
		pChannel = m_pCall->GetChannel(chanType);
		if(pChannel)
		{
			if(pChannel->GetConnectionState() == kConnected)
			{
				if(pChannel->IsMediaChannel() && pChannel->IsMuted())
				{
					if(chanType == BFCP_IN || chanType == BFCP_OUT)
					{
						m_pParty->SetBfcpConnected(FALSE);
					}

			       if( !m_pParty->GetTipPartyOnHold() )
			       {
			    	   PTRACE(eLevelInfoNormal,"CSipCntl::SipCloseChannelReq  the channel is muted, send unmute");

				   //m_pParty->GetConfApi()->UpdateDB(m_pParty,MUTE_STATE,0xF000000E,1);
				   m_pPartyApi->SipPartyUnMuteClosingChannel(chanType);
			       }
				}

				if(m_bIsMrcCall)
				{
					CloseSvcChannel(pChannel, chnType);
				}
				else
				{
					if( (pChannelEx=ShouldOpenMRMPAvcChannel(pChannel,chnType)) != NULL)
					{
						CloseSvcChannel(pChannelEx,chnType);
						pChannelEx->SetConnectionState(kDisconnecting);
					}
					CloseInternalChannels(chanType);
					BYTE bIsRemovedChannel = Cm_FillAndSendCloseUdpPortStruct(pChannel);

					// fix memory overwrite in the next lines (pChannel->SetConnectionState(kDisconnecting))
					// and invalid read - CloseFecOrRedDueToChannelClose(pChannel)
					if (bIsRemovedChannel)
						pChannel = NULL;
				}

				if (pChannel)
					pChannel->SetConnectionState(kDisconnecting);

				CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());

				ETipPartyTypeAndPosition tipPartyType = m_pParty->GetTipPartyTypeAndPosition();

				CloseFecOrRedDueToChannelClose(pChannel);

				bMessageSent = YES;
			}
			else
			{
				DBGPASSERT(YES);
				// there is no possibility to get here when other channels are still connecting! something is wrong.
				PTRACE(eLevelError,"CSipCntl::SipCloseChannelReq: Channels are connecting. Cannot disconnect channels in this stage!!!");
			}
		}
	}
	else
		bNoChannels = YES;

	if (bNoChannels)
	{
		DBGPASSERT(YES);
		PTRACE(eLevelError,"CSipCntl::SipCloseChannelReq: No channel found!");
	}
	return bMessageSent;
}

//////////////////////////////////////////////////////
void CSipCntl::SipCloseSingleChannelsReq(CSipChannel* pChannel,BYTE& bNoChannels)
{
	CSipChannel* pChannelEx=NULL;
	int chnType=OPEN_CHANNEL_NORMAL_MODE;
	if(pChannel)
	{
		if( pChannel->GetConnectionState() == kConnected )
		{
			pChannel->SetConnectionState(kDisconnecting);
			if(m_bIsMrcCall)
			{
				CloseSvcChannel(pChannel, chnType);
			}
			else
			{
				if( (pChannelEx=ShouldOpenMRMPAvcChannel(pChannel,chnType)) != NULL)
				{
					CloseSvcChannel(pChannelEx,chnType);
					pChannelEx->SetConnectionState(kDisconnecting);
				}
				Cm_FillAndSendCloseUdpPortStruct(pChannel);
			}
		}
		bNoChannels = NO;
	}
}
//////////////////////////////////////////////////////
BYTE CSipCntl::SipCloseAllChannelsReq()
{
	// temp temp temp
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SipCloseAllChannelsReq, initial num of channels: ", m_pCall->GetNumOfChannels());
	BYTE confType;
	BYTE bMessageSent = NO;
	BYTE bNoChannels  = YES;
	CSipChannel* pChannel = NULL;
	TRACECOND_AND_RETURN_VALUE(m_pParty == NULL , "m_pParty is NULL", NO);
	ETipPartyTypeAndPosition tipPartyType = m_pParty->GetTipPartyTypeAndPosition();
	if(eTipMasterCenter == tipPartyType)
	{
		if (SipCloseAllDtlsChannelsReq())
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::SipCloseAllChannelsReq, started to close DTLS channels");
			return FALSE;
		}

		PTRACE(eLevelInfoNormal,"CSipCntl::SipCloseAllChannelsReq, initial num of channels: close tip call send end tip first to master");
		m_pParty->SendTipCallEndMsgAndDisconnectToSlaves();
	}

	// close channels only if we have at least one and non of them connecting
	if (m_pCall->GetNumOfChannels())
	{
		confType=m_pParty->GetTargetMode()->GetConfType();
		if (m_pCall->IsAtLeastOneChannelConnectionState(kConnecting)==NO &&
			m_pCall->AreAllOpenChannelsConnectionState(kDisconnecting,m_bIsMrcCall,confType)==NO)
		{
			// go over all open channels and close the CM
			if(m_pCall->GetNumOfChannels())
			{
				for (int i=0; i<MAX_SIP_CHANNELS; i++)
				{
					pChannel = m_pCall->GetChannel(i, true);
					SipCloseSingleChannelsReq(pChannel,bNoChannels);
				}
			}

		    CloseInternalChannels(AUDIO_IN);
            CloseInternalChannels(VIDEO_IN);
			if(bNoChannels)
			{
//				DBGPASSERT(YES);
				PTRACE(eLevelError,"CSipCntl::SipCloseAllChannelsReq: No channel found!");
			}

			/* Flora comment: We should do the same with Tip here, do not need to close UDP Port and waiting for the Rsp */
			if (tipPartyType == eTipSlaveLeft || tipPartyType == eTipSlaveRigth || tipPartyType == eTipSlaveAux
				 || IsMSSlaveParty())
				OnAllChannelsAreClosed();

		}
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::SipCloseAllChannelsReq: Channels are connecting or disconnecting. Wait until they are connected or disconnected.");
		}
	}
	else
	{
		TRACEINTO<<"!@# calling OnAllChannelsAreClosed";
		OnAllChannelsAreClosed();
	}


	return bMessageSent;
}


//////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipOpenBfcpChannelReq(cmCapDirection eDirection)
{
	ERoleLabel eRole;
	EIpChannelType chanType[1];
	cmCapDataType mediaType;

	PTRACE(eLevelInfoNormal,"CSipCntl::SipOpenBfcpChannelReq");
	BYTE bMessageSent = NO;

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SipOpenBfcpChannelReq - Direction ",eDirection);

	eRole = kRolePeople;
	mediaType = cmCapBfcp;
	if( m_pParty->IsActiveTransaction())
	{
	    PTRACE(eLevelInfoNormal,"CSipCntl::SipOpenBfcpChannelReq - patch - changing state CONNECTING or CONNECTED->CHANGEMODE");
	    m_state = IP_CHANGEMODE;
	}

	if (eDirection == cmCapReceive) //and not transmit
	{
		chanType[0] = BFCP_IN;
	}
	else if (eDirection == cmCapTransmit) //and not receive
	{
		chanType[0] = BFCP_OUT;
	}

	if (m_pCall == NULL)
	{
		DBGPASSERT(YES);
		PTRACE(eLevelError,"CSipCntl::SipOpenBfcpChannelReq: m_pCall is NULL!");
		return bMessageSent;
	}

	if(!GetChannel(mediaType,eDirection,eRole) && m_pCall)
	{
		m_pCall->InsertNewChannel(mediaType,eDirection,eRole,eBFCPCapCode, NULL, NULL, NULL, 0);
	}
	else
	{
		PTRACE2INT(eLevelError,"CSipCall::SipOpenBfcpChannelReq: Bfcp channel is already exist in direction=%d",(int)eDirection);
	}

	/*if(eDirection & cmCapTransmit) //Anna - update remote address in OPEN / UPDATE UDP port function
	{
		m_pCall->SetMediaRtpAddress(*m_pRemoteSdp, cmCapTransmit, FALSE);
		m_pCall->SetMediaRtcpPort(*m_pRemoteSdp, cmCapTransmit, FALSE);
	}
	if (eDirection & cmCapReceive)
	{
		mcTransportAddress address;
		memset(&address, 0, sizeof(mcTransportAddress));
		m_pCall->SetMediaRtpAddress(address,cmCapBfcp,cmCapReceive);
	}*/

	int numOfChannels = m_pCall->SetChannelsConnectingState(kConnecting, 1, chanType);

	if ( numOfChannels > 0 )
	{

		if ( OpenMediaChannels(kConnecting) > 0 )
		{
			bMessageSent = YES;
		}
		else
		{
			DBGPASSERT(YES);
			PTRACE(eLevelError,"CSipCntl::SipOpenBfcpChannelReq: No requests to open media");
		}
	}
	else
	{
		DBGPASSERT(YES);
		PTRACE(eLevelError,"CSipCntl::SipOpenBfcpChannelReq: No Channels");
	}

	return bMessageSent;
}

//////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipOpenChannelsReq(CSipComMode* pTargetMode,cmCapDirection eDirection,BYTE bIsAnswering, ETipPartyTypeAndPosition tipPartyType)
{
	TRACEINTOFUNC << "Direction: " << eDirection << ", bIsAnswering: " << (int)bIsAnswering
		<< ", TIP mode: " << (WORD)pTargetMode->GetIsTipMode() << ", tipPartyType: " << tipPartyType;

	m_pParty->GetTargetMode()->Dump("CSipCntl::SipOpenChannelsReq Target mode", eLevelInfoNormal);
    m_pParty->GetCurrentMode()->Dump("CSipCntl::SipOpenChannelsReq Current mode", eLevelInfoNormal);

	BYTE bMessageSent = NO;

	if (pTargetMode->GetIsTipMode())
	{
		m_pParty->SetTipPartyTypeAndPosition(tipPartyType);
		m_pCall->SetIsTipCall(TRUE);
	}

	// if there is at least one channel that we are trying to connect we won't send the open chan req
	if (m_pCall->IsAtLeastOneChannelConnectionState(kConnecting) == NO)
	{
		int				arrSize		= 0;
		EIpChannelType aChanArr[CHANNEL_TYPES_COUNT] = {AUDIO_IN,VIDEO_IN,FECC_IN,VIDEO_CONT_IN, BFCP_IN};// temporary initializing.

		if (eDirection == cmCapReceiveAndTransmit)
			arrSize = MAX_SIP_CHANNELS;
		else
		{
			arrSize  = CHANNEL_TYPES_COUNT;
			aChanArr[0] = (eDirection == cmCapReceive)? AUDIO_IN: AUDIO_OUT;
			aChanArr[1] = (eDirection == cmCapReceive)? VIDEO_IN: VIDEO_OUT;
			aChanArr[2] = (eDirection == cmCapReceive)? FECC_IN: FECC_OUT;
			aChanArr[3] = (eDirection == cmCapReceive)? VIDEO_CONT_IN: VIDEO_CONT_OUT;
			aChanArr[4] = (eDirection == cmCapReceive)? BFCP_IN: BFCP_OUT;
		}

		m_pCall->SetChannels(pTargetMode,eDirection);

		if (MAX_SIP_CHANNELS == arrSize)
		{
			m_pCall->SetMediaPayloadType(cmCapTransmit, m_pChosenLocalCap , arrSize, NULL, m_pLastRemoteCaps);
			m_pCall->SetMediaPayloadType(cmCapReceive,  m_pChosenLocalCap , arrSize, NULL, m_pLastRemoteCaps);
		}
		else
		{
			m_pCall->SetMediaPayloadType(cmCapTransmit, m_pChosenLocalCap , arrSize, aChanArr, m_pLastRemoteCaps);
			m_pCall->SetMediaPayloadType(cmCapReceive,  m_pChosenLocalCap , arrSize, aChanArr, m_pLastRemoteCaps);
		}

	    if (m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvcVsw && !m_bIsMrcCall)
	    {
			m_pCall->SetChannelsEx(pTargetMode,eDirection,m_bIsMrcCall);
			int arrSizeEx=MAX_INTERNAL_CHANNELS;
			m_pCall->SetMediaPayloadTypeEx(cmCapReceive,  m_pChosenLocalCap , arrSizeEx, &aChanArr[0] /* angelina to check out &aChanArr[1]*/, m_pLastRemoteCaps);
			m_pCall->SetMediaPayloadTypeEx(cmCapTransmit,  m_pChosenLocalCap , arrSizeEx,&aChanArr[0] /* angelina to check out &aChanArr[1]*/, m_pLastRemoteCaps);
	    }

		if (bIsAnswering && eDirection != cmCapTransmit)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::SipOpenChannelsReq updating paylod types in receive also according to remote caps");
			UpdatePayloadTypeInRecieveMediasWhenAnswering();
		}

		m_pCall->SetMediaTos(m_pQos->m_bIpAudio,m_pQos->m_bIpRtcp,cmCapAudio,eDirection);
		m_pCall->SetMediaTos(m_pQos->m_bIpVideo,m_pQos->m_bIpRtcp,cmCapVideo,eDirection);

		if (GetpPrecedenceSettingsDB()->IsPrecedenceEnabled())
		{
			m_pCall->SetMediaTos(m_pQos->m_bIpSignaling, m_pQos->m_bIpRtcp, cmCapBfcp, eDirection);
			m_pCall->SetMediaTos(m_pQos->m_bIpVideo,m_pQos->m_bIpRtcp,cmCapData,eDirection);
			m_pCall->SetMediaTos(m_pQos->m_bIpVideo, m_pQos->m_bIpRtcp, cmCapVideo, eDirection,kRolePresentation);
		}
		else
		{
			m_pCall->SetMediaTos(0, m_pQos->m_bIpRtcp,cmCapData,eDirection);
			m_pCall->SetMediaTos(0, m_pQos->m_bIpRtcp, cmCapVideo, eDirection,kRolePresentation);
		}

		int numOfChannels = m_pCall->SetChannelsConnectingState(kConnecting, arrSize, aChanArr, kDisconnected);

		if (numOfChannels > 0)
		{
			if (OpenMediaChannels(kConnecting) > 0)
			{
					bMessageSent = YES;
			}
			else
			{
				DBGPASSERT(YES);
				PTRACE(eLevelError,"CSipCntl::SipOpenChannelsReq: No requests to open media");
			}

			if (!m_bIsMrcCall && m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc )
			{
				TRACEINTO<<"!@# before open internal channels";
				int numOfInternalChannels;
				numOfInternalChannels = OpenInternalChannels(pTargetMode,
					(CSipComMode*)m_pParty->GetCurrentMode(), kConnecting);

			  if (numOfInternalChannels > 0)
			  {
			    bMessageSent = YES;
			  }
			  else
			  {
			    //DBGPASSERT(YES);
			    PTRACE(eLevelError,"CSipCntl::SipNewCallReq: No requests to open internal channels.");
			  }
			}
		}
		else
		{
			DBGPASSERT(YES);
			PTRACE(eLevelError,"CSipCntl::SipOpenChannelsReq: No Channels");
		}
	}
	else
		PTRACE(eLevelError,"CSipCntl::SipOpenChannelsReq: At least one channel is connecting");

	return bMessageSent;
}
//////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::OpenContentRecvChannelForSrtp(CSipComMode* pTargetMode)
{
	BYTE bMessageSent = FALSE;
	CSipChannel* pChannel = NULL;
	int				arrSize		= 1;
	EIpChannelType aChanArr[1] = {VIDEO_CONT_IN};

	m_pCall->SetChannels(pTargetMode, cmCapReceive);

	m_pCall->SetMediaPayloadType(cmCapReceive,  m_pChosenLocalCap , arrSize, aChanArr, m_pLastRemoteCaps);

	if (GetpPrecedenceSettingsDB()->IsPrecedenceEnabled())
	{
		m_pCall->SetMediaTos(m_pQos -> m_bIpVideo, m_pQos->m_bIpRtcp, cmCapVideo, cmCapReceive, kRolePresentation);
	}
	else
	{
		m_pCall->SetMediaTos(0, m_pQos->m_bIpRtcp, cmCapVideo, cmCapReceive, kRolePresentation);
	}

	int numOfChannels = m_pCall->SetChannelsConnectingState(kConnecting, arrSize, aChanArr, kDisconnected);

	if ( numOfChannels == arrSize )
	{

		pChannel = m_pCall->GetChannel(VIDEO_CONT_IN);
		if(NULL == pChannel)
		{
			TRACEINTOFUNC << "Channel is NULL!!!";
		}
		else if (pChannel->GetConnectionState() != kConnecting)
		{
			TRACEINTOFUNC << "Channel ConnectionState: " << pChannel->GetConnectionState();
		}
		else
		{
			TRACEINTOFUNC << "Send Open channel";
			Rtp_FillAndSendUpdatePortOpenRtpStruct(pChannel);
			Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStructInChannels(pChannel, NO);
			bMessageSent = TRUE;
		}
	}
	else
	{
        TRACEINTO << "No Content Channel. Do nothing!!!";
	}


	return bMessageSent;
}

void CSipCntl::SipUpgradeSvcChannelReq(CSipComMode* pTargetMode, EIpChannelType chanArr, int eUpdate, BOOL bIsReplyDiffPayload, BOOL bKeepCurrentPayload,WORD payload)
{
	CSipChannel * pCurChannel 			= NULL;
	pCurChannel 			= m_pCall->GetChannel(chanArr);

	TRACEINTO << "!@# ";

	if (pCurChannel)
	{
		m_state = IP_CHANGEMODE;
		pCurChannel->SetConnectionState(kUpdating);
		pCurChannel->SetRtpConnectionState(kUpdating);
		if(pCurChannel->IsMediaChannel())
		{
			pCurChannel->SetDiffPayloadState(kDiffPayload_NotNeeded);
			Rtp_FillAndSendUpdateRtpChannelStruct(pCurChannel);
		}
	}
}

BYTE CSipCntl::SipUpgradeAvcChannelReq(CSipComMode* pTargetMode,CSipComMode* pCurrentMode)
{
	BYTE bMessageSent = NO;
	TRACEINTO<<"!@# before open internal channels";
	TRACEINTO<<"m_state="<<m_state<<" m_bChangeModeWithinTransaction="<<(int)m_bChangeModeWithinTransaction;
	if (OpenInternalChannels(pTargetMode, (CSipComMode*)pCurrentMode, kConnecting) > 0)
	{
		m_state = IP_CHANGEMODE;
		bMessageSent = YES;
	}
	else
	{
		//DBGPASSERT(YES);
		PTRACE(eLevelError,"!@# CSipCntl::SipNewCallReq: No requests to open internal channels."); // ey_20866
	}

	// upgrade the VSW stream
	if (pTargetMode->IsHdVswInMixMode())
	{
		// get the video channel
	    CSipChannel *pChannel = GetChannel(cmCapVideo, cmCapReceive);
	    if (pChannel)
	    	Rtp_FillAndSendUpdateRtpChannelStruct(pChannel);
	}

	return bMessageSent;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipUpdateChannelReq(CSipComMode* pTargetMode, EIpChannelType chanArr, int eUpdate, BOOL bIsReplyDiffPayload, BOOL bKeepCurrentPayload,WORD payload)
{
	TRACEINTO << "channel type = " << chanArr << " eUpdate=" << eUpdate;
	//BYTE				bMessageSent	= NO;
	EConnectionState	eCallState		= m_pCall->GetConnectionState();
	BYTE				bCapCodeDifferent = NO;
	CSipChannel * pCurChannel 			= NULL;
	DWORD curPayload = _UnKnown;
	COstrStream msg1;
	int numOfUpdatedRtpChannels = 0;
	BYTE bIsChannelUpdating = NO;
	BYTE bIsUpdatingSdesOrDtls = NO;

	pCurChannel 			= m_pCall->GetChannel(chanArr);

	if (pCurChannel)
		curPayload = pCurChannel->GetPayloadType();

	if ((eCallState == kConnecting && m_pCall->IsAtLeastOneChannelConnectionState(kConnecting)==NO) ||
		(eCallState == kConnected))
	{
		// update remote media IP and port (could be changed by re-invite ind)
		if (m_bIsReInviteTransaction && (eUpdate != kChannelParams) && (eUpdate != kChangePayload))
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq (SetMediaRtpAddress)");
			BYTE confIsEncrypted = FALSE;
			if (m_pParty->GetTargetMode()->GetIsEncrypted() == Encryp_On) {
				confIsEncrypted = TRUE;
				PTRACE(eLevelInfoNormal,"Encryp_On");
			}

			//m_pCall->SetMediaRtpAddress(*m_pRemoteSdp,cmCapTransmit, confIsEncrypted);
			//m_pCall->SetMediaRtcpPort(*m_pRemoteSdp, cmCapTransmit, confIsEncrypted);
		}


		if (pTargetMode && ((eUpdate & kChannelParams) || (eUpdate & kChangePayload) || (eUpdate & kChangeLpr) || (eUpdate & kChangeMSSsrc) )) // if there is anything to update in cap struct
		{

			// not the best code but currently the update channel with target mode is initiate only in one place with no. of channels equal to 1
			// if the CapCode is different (different protocol) then we have to re-open the RTP and not use update.
			if (pCurChannel != NULL)
			{
				if(eUpdate & kChangeLpr)
				{
					bCapCodeDifferent = YES;
				}
				else if(eUpdate & kChangeMSSsrc)
				{
					bCapCodeDifferent = YES;
				}
				else
				{
					CapEnum capTarget = (CapEnum)pTargetMode->GetMediaType(pCurChannel->GetMediaType(), pCurChannel->GetDirection(), pCurChannel->GetRoleLabel());
					CapEnum capCurrent = pCurChannel->GetAlgorithm();
					bCapCodeDifferent  = (capTarget == capCurrent) ? NO:YES;
					if(capTarget == eH263CapCode )
						bCapCodeDifferent = YES;

				}
			}
			else
				bCapCodeDifferent = YES;

			PTRACE2INT(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq bCapCodeDifferent:",bCapCodeDifferent);

			if(eUpdate & kChannelParams)
				numOfUpdatedRtpChannels += m_pCall->SetUpdatingChannels(pTargetMode, 1, &chanArr, kChannelParams); //sets also the channel connection state
			else
				numOfUpdatedRtpChannels += m_pCall->SetUpdatingChannels(pTargetMode, 1, &chanArr, kChangeLpr); //sets also the channel connection state

			cmCapDirection eDirToSet = ::GetDirection(chanArr);// not the best code (assuming the char array has only one cell).

			if (bKeepCurrentPayload || payload == 0/*no payload inserted*/)
				m_pCall->SetMediaPayloadType(eDirToSet, m_pChosenLocalCap , 1, &chanArr, m_pLastRemoteCaps);
			else
				m_pCall->SetMediaPayloadTypeAccordingToNewPayload(eDirToSet,&chanArr,1,payload);

			if(/*!IsInviteInitiator()*/ !m_pParty->IsOfferer() && m_pParty->IsActiveTransaction() )
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq NOT OFFERER setting media paylod type according to remote.");
				UpdatePayloadTypeInRecieveChannelAccordingToRemoteCaps(pCurChannel);
				//UpdatePayloadTypeInRecieveChannelsAccordingToRemoteCaps();
			}

			if (bKeepCurrentPayload && pCurChannel && curPayload != _UnKnown)
				pCurChannel->SetPayloadType(curPayload);
		}

		if ((pTargetMode && (pTargetMode->GetIsEncrypted() == Encryp_On) && (eUpdate & kChangeSdes)) ||
            (pTargetMode && m_bIsMrcCall && (eUpdate & kChangeSdes))) // SVC call - change from encrypted call to non-encrypted is done by update channels
        {
			PTRACE(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq - update RTP with SDP sdes");
			numOfUpdatedRtpChannels = m_pCall->SetUpdatingChannels(pTargetMode, 1, &chanArr, kChangeSdes); //sets also the channel connection state
//			bCapCodeDifferent = YES;
			bIsUpdatingSdesOrDtls 	= YES;
			bCapCodeDifferent		= NO;
		}
		else if (pTargetMode && (pTargetMode->GetIsDtlsEncrypted() == Encryp_On) && (eUpdate & kChangeDtls))
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq - update RTP with DTLS sdes");

			bIsUpdatingSdesOrDtls 	= YES;
			bCapCodeDifferent		= NO;
		}

		if (GetIsNeedUpdateIceToNonIce())
		{
			TRACEINTO << "Update from ICE to Non-ICE";
			numOfUpdatedRtpChannels += 1;
		}
		// update the MFA
		// 1. Update the CM on the IP address changes. If its incoming channel we don't need to update the
		//		CM, since we only known the local IP address and that doesn't change.
		// 2. Update the RTP on channel parameters changes (Currently not supported).
		if (numOfUpdatedRtpChannels || bIsUpdatingSdesOrDtls)
		{// update the RTP on the new values
			PTRACE(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq (Update RTP)");

			if (pCurChannel)
			{
				bIsChannelUpdating = TRUE;

				pCurChannel->SetConnectionState(kUpdating);
				pCurChannel->SetRtpConnectionState(kUpdating);
				if(pCurChannel->IsMediaChannel())
				{
				    kChanneltype channelType = ::DataTypeToChannelType(pCurChannel->GetMediaType(), pCurChannel->GetRoleLabel());
				    if(!m_bIsMrcCall || (channelType == kIpContentChnlType))
					{
						if(bCapCodeDifferent)// send new RTP channel
							Rtp_FillAndSendUpdatePortOpenRtpStruct(pCurChannel);
						else// update the current channel.
							Rtp_FillAndSendUpdateRtpChannelStruct(pCurChannel);
					}
				    else
				    {
				    	PTRACE(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq : Update MRMP channel");
				    	UpdateRelayChannel(pCurChannel);
				    	Rtp_FillAndSendUpdateRtpChannelStruct(pCurChannel);
				    }

					if (bIsReplyDiffPayload)
					{
						TRACEINTO<<"!@#bIsReplyDiffPayload  m_state: "<<(int)m_state;
						pCurChannel->SetDiffPayloadState(kDiffPayload_UpdateSent);
					}
					else
					{
						PTRACE2INT(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq state = ",m_state);
						if (m_state != IP_CHANGEMODE) // If it is already in change mode don't change the flag value
						{
						  TRACEINTO<<"m_state="<<m_state<<" m_bChangeModeWithinTransaction="<<(int)m_bChangeModeWithinTransaction;

							if (m_state == IP_CONNECTING)
								m_bChangeModeWithinTransaction = YES; // Most of cases
							else
								m_bChangeModeWithinTransaction = NO; // In Invite No SDP the change mode occurs after the transaction completed (ack_ind has been received already)
						TRACEINTO<<"m_state="<<m_state<<" m_bChangeModeWithinTransaction="<<(int)m_bChangeModeWithinTransaction;
						}

						m_state = IP_CHANGEMODE;
						TRACEINTO<<"!@# m_state:"<<(int)m_state;
					}
				}
			}
		}
		if (eUpdate & kIpAddress)
		{// update the CM on the new IP address
			//(currently only for outgoing channels since we don't have remote opened channels source IP address)
			// need to update the CM on the new addresses of the outgoing channels
				// go over all the channels
				// take the outgoing ones
				// send update to the CM.
			PTRACE(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq (Update CM on IP address)");

			if (pCurChannel && pCurChannel->IsDirection(cmCapTransmit))
			{// maybe there is a better way to do it. Need to consult Atara
				bIsChannelUpdating = TRUE;

				pCurChannel->SetCmConnectionState(kUpdating);
				pCurChannel->SetConnectionState(kUpdating);

				Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStructOutChannels(pCurChannel, YES);

				if (bIsReplyDiffPayload==NO)
				{
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq state = ",m_state);
					if (m_state != IP_CHANGEMODE) // If it is already in change mode don't change the flag value
					{
					  TRACEINTO<<"m_state="<<m_state<<" m_bChangeModeWithinTransaction="<<(int)m_bChangeModeWithinTransaction;
						if (m_state == IP_CONNECTING)
							m_bChangeModeWithinTransaction = YES; // Most of cases
						else
							m_bChangeModeWithinTransaction = NO; // In Invite No SDP the change mode occurs after the transaction completed (ack_ind has been received already)
						TRACEINTO<<"m_state="<<m_state<<" m_bChangeModeWithinTransaction="<<(int)m_bChangeModeWithinTransaction;
					}
					m_state = IP_CHANGEMODE;
				}
			}
		}

		if (bIsChannelUpdating)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq (Timer)");
		}
		else
		{
			// there was no update return the response to the party
			PTRACE(eLevelInfoNormal,"CSipCntl::SipUpdateChannelReq (No Update)");
			m_state = (m_pCall->GetConnectionState() == kConnecting || m_bIsReInviteTransaction)? IP_CONNECTING: IP_CONNECTED;

			CSipComMode* pCurrentMode = new CSipComMode;

			pCurrentMode->Create(*m_pCall);
			pCurrentMode->CopyStaticAttributes(*(m_pParty->GetTargetMode()));

			m_pPartyApi->SipPartyChannelsUpdated(pCurrentMode);

			POBJDELETE(pCurrentMode);
		}
	}
	//else
	// if channels are in 'connecting' state we will send SipPartyChannelsConnected
	// to the party and it will send the update again.

	return bIsChannelUpdating;
}


//////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipInstantMessageReq(const char* instantMessageStr)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipInstantMessageReq");

	BYTE bMessageSent = NO;
	mcReqInstantMessage* pInstantMessageMsg = new mcReqInstantMessage;
	size_t size = sizeof(mcReqInstantMessage);
	if (instantMessageStr && instantMessageStr[0])
	{
		strncpy(pInstantMessageMsg->content,instantMessageStr,MaxLengthOfNonSdpContent - 1);
		pInstantMessageMsg->content[MaxLengthOfNonSdpContent - 1] = 0;
		//m_pSipCmd->SendSipReq((mcReqBase *)pInstantMessageMsg,SIP_CS_SIG_INSTANT_MESSAGE_REQ,size);
		bMessageSent = YES;
	}

	PDELETE(pInstantMessageMsg);
	return bMessageSent;
}




//////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipInviteAckIndConnecting(CSegment* pParam) // answer for 200 ok
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	CMedString str;

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipInviteAckIndConnecting");

	///////////////////////////////////////////////////
	//for debug SIPProxy CORE:
	//StartTimer(DEBUG_PROXY_CORE, 3 * SECOND);
	///////////////////////////////////////////////////


	if (IsValidTimer(PARTYCONNECTTOUT))
		DeleteTimer(PARTYCONNECTTOUT);

	mcIndInviteAck* pInviteAckMsg = (mcIndInviteAck*) pParam->GetPtr(1);
	DWORD status = pInviteAckMsg->status;

	if (status == STATUS_OK)
	{
		CSipChanDifArr*	pDifArr	= new CSipChanDifArr;
		BYTE bRemovedAudio, bRemovedVideo;
		bRemovedAudio = bRemovedVideo = 0;
		APIU32 capabilitiesLength	= pInviteAckMsg->sipSdpAndHeaders.sipMediaLinesLength; // old api: sipHeadersOffset;
		APIU32 capsAndHeadersLength = pInviteAckMsg->sipSdpAndHeaders.lenOfDynamicSection;
		DWORD isSdp = FALSE;

		SetToAndFromTagsForRmtSdp(pInviteAckMsg->sipSdpAndHeaders); //_mccf_

		if(capsAndHeadersLength && capabilitiesLength && capsAndHeadersLength >= capabilitiesLength)
		{// remote invite Ack indication includes SDP. Take it, and check changes in current setting.
			HandleSdpFromInviteAckInd(pInviteAckMsg, pDifArr, bRemovedAudio, bRemovedVideo);
			isSdp = TRUE;
		}
		if (m_bIsReInviteTransaction == NO || m_pCall->IsReInviteInitiator() == NO)
		{
			m_state = IP_CONNECTED;
			m_bChangeModeWithinTransaction= NO;
			StartFastUpdateTimer();

			if (m_bIsReInviteTransaction == NO)
				m_pCall->SetConnectionState(kConnected);
			else
			{
				str << "end of ReInviteTransaction will be done on the Party level ## ";
				//m_bIsReInviteTransaction = NO; // close transaction
			}

		}
		else	// local is initiator of re-invite. in that case this is an answer for SipCodesRequestPending
				// so we have to send the re-invite again cause the card dropped the first one we sent.
		{
			str << "Answer for SipCodesRequestPending. Now need to send again our ReInvite ## ";
		}
		m_pPartyApi->SipPartyReceivedAck(status, isSdp, bRemovedAudio, bRemovedVideo, pDifArr);
		POBJDELETE(pDifArr);

		/* IBM-811 - send RTCP TMMBR flow control when the call is connected */
		if (IsSameTimeEP()) {
			DWORD rtcpTmmbrInterval = 0;
			APIU32 	rate = 0;

			rate = CalcRateForIBM();
			if (rate)
			{
				CProcessBase::GetProcess()->GetSysConfig()->GetDWORDDataByKey("RTCP_FLOW_CONTROL_TMMBR_INTERVAL", rtcpTmmbrInterval);
				SendFlowControlReq(mainType, cmCapReceive, rate);
				rtcpTmmbrInterval = rtcpTmmbrInterval ? rtcpTmmbrInterval : 120;
				StartTimer(RTCP_FLOW_CONTROL, rtcpTmmbrInterval * SECOND);
			}
			str << "Send TMMBR for IBM rate= " << rate;
		}
	}
	else
	{
		// treat call as a connected one. after that party will disconnect it
		str << "Recevied Status=" << status << "disconnecting the call";
		m_state = IP_CONNECTED;
		m_bChangeModeWithinTransaction= NO;
		m_bIsReInviteTransaction = NO; // close transaction
		m_pCall->SetConnectionState(kConnected);
		m_pPartyApi->SipPartyReceivedAck(status, 0, 0, 0, NULL);
	}
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnSipInviteAckIndConnecting", str.GetString());
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipInviteAckIndDisconnecting(CSegment* pParam)
{




	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipInviteAckIndDisconnecting");

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

	if (IsValidTimer(PARTYCONNECTTOUT))
		DeleteTimer(PARTYCONNECTTOUT);

	mcIndInviteAck* pInviteAckMsg = (mcIndInviteAck *)pParam->GetPtr(1);
	DWORD status = pInviteAckMsg->status;
	if (status)
		PTRACE2INT(eLevelError,"CSipCntl::OnSipInviteAckIndDisconnecting: status - ",status);

	if (m_pCall->GetRejectReason()) // answer for reject or SipCodesRequestTerminated
	{
		SetCallDisconnectedAndRemoveFromRsrcTbl();
		CSipComMode* pCurrentMode = new CSipComMode;
		pCurrentMode->Create(*m_pCall);
		pCurrentMode->CopyStaticAttributes(*(m_pParty->GetTargetMode())); // copy necessary data members like ConfType from preffered mode to best mode.
		m_pPartyApi->SipPartyCallClosed(pCurrentMode);
		POBJDELETE(pCurrentMode);
	}
	else if (m_pCall->IsCloseInitiator())
	{
		if (m_bIsReInviteTransaction && m_pCall->IsReInviteInitiator() == NO)
		{
			// cross message when we got re-invite ind after we started to close call
			// it is ok to continue disconnecting now
			m_bIsReInviteTransaction = NO; // close transaction
			CloseCall(YES);
		}
		else if (m_pCall->IsViolentClose())
			PTRACE(eLevelInfoNormal,"CSipCntl::OnSipInviteAckIndDisconnecting: Violent close. Ignore ack ind");
		else
		{
			DBGPASSERT(YES);
			PTRACE(eLevelError,"CSipCntl::OnSipInviteAckIndDisconnecting: The mcu is not the initiator of close");
		}
	}
	else
	{
		DBGPASSERT(YES);
		PTRACE(eLevelError,"CSipCntl::OnSipInviteAckIndDisconnecting: The mcu is not the initiator of close");
	}
}



////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipCancelIndConnecting(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipCancelIndConnecting");

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

	if (GetIsIceCall() && !m_bIsIceHasSessionIndex)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::OnSipCancelIndConnecting, wait for ice make answer indication before canceling the call");

		if (m_cancelIndParams)
			POBJDELETE(m_cancelIndParams);

		m_cancelIndParams = new CSegment;

		*m_cancelIndParams << callIndex << channelIndex << mcChannelIndex << stat1 << srcUnitId;

		m_bNeedToCancelIceSession = TRUE;

		return;
	}

	mcIndCancel* pCancelMsg = (mcIndCancel *)pParam->GetPtr(1);

	DWORD status = pCancelMsg->status;
	if(status == STATUS_OK)
	{
		SetCallDisconnecting();
		m_pCall->SetCloseInitiator(NO);
		m_pPartyApi->SipPartyRemoteCloseCall(SIP_REMOTE_CANCEL_CALL);
	}
	else
		m_pPartyApi->SipPartyCallFailed(status);
}



////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipCancelIndDisconnecting(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipCancelIndDisconnecting");

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

	mcIndCancel* pCancelMsg = (mcIndCancel *)pParam->GetPtr(1);
	DWORD status = pCancelMsg->status;
	if(status == STATUS_OK) // cross message: cancel arrived after we sent reject
		CloseCall(NO,SipCodesRequestTerminated);
	else
		DBGPASSERT(status);
}


////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipInviteResponseIndConnecting(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipInviteResponseIndConnecting");

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;
	m_callIndex = callIndex;
	m_pCall->SetCallIndex(m_callIndex);

	// Allowing disconnections in an re/invite transaction is one time only, setting the flag to false
	m_allowMediaBasedDisconnectionInReinvite = FALSE;	// (checking first that it's true, is inefficient)

	if (IsValidTimer(PARTYCSKEEPALIVEFIRSTTOUT) == FALSE)
	{
		// start the CS <-> party loop of keep alive (response 200 OK and first time we response to invite indication).
		StartCsPartyErrHandlingLoop();
	}

	mcIndInviteResponse* pInviteResponseMsg = NULL;
	pInviteResponseMsg = (mcIndInviteResponse *)pParam->GetPtr(1);
	PASSERT_AND_RETURN(NULL == pInviteResponseMsg);
	DWORD status = pInviteResponseMsg->status;
	m_isUpdateAnatIpType = FALSE;  //added for ANAT

	sipSdpAndHeadersSt* pSdpAndHeaders = (sipSdpAndHeadersSt *)&pInviteResponseMsg->sipSdpAndHeaders;

	if (pSdpAndHeaders)
	{
		//added for ANAT
		if (IsAnatSupported() && pSdpAndHeaders->sipMediaLinesLength != 0)
		{
			//currently, RMX does not support fallback to non-ANAT case during the ANAT call. or ConfParty core dump
			BOOL isANATContained = IsANATPresentInSDP(pSdpAndHeaders);
			if (!isANATContained)
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::OnSipInviteResponseIndConnecting-RMX does not support fallback to non-ANAT case during the ANAT call.");
				SetCallDisconnecting();
				m_pCall->SetRejectReason((enSipCodes)SipCodesGlobNotAcceptable);
				m_pPartyApi->SipPartyCallFailed(SipCodesGlobNotAcceptable);
				if (IsValidTimer(PARTYCONNECTTOUT))
					DeleteTimer(PARTYCONNECTTOUT);
				return;
			}
		}

		SetToAndFromTagsForRmtSdp(*pSdpAndHeaders);//_mccf_
		SetMediaLinesInternalTypeForRmtSdp(*pSdpAndHeaders);
		SetCapsRolesForRmtSdp(*pSdpAndHeaders, kMediaLineInternalTypeVideo, kRolePeople);
		SetCapsRolesForRmtSdp(*pSdpAndHeaders, kMediaLineInternalTypeContent, kRolePresentation);
	}

	if (status == STATUS_OK)
	{
		RestoreVideoRate((sipSdpAndHeadersSt *)&pInviteResponseMsg->sipSdpAndHeaders);
	}

	if (m_bIsReInviteTransaction)
	{
		if (m_pCall->IsReInviteInitiator())
			HandleReInviteResponse(pInviteResponseMsg);
		else
			DBGPASSERT(YES);
	}
	else
	{
		SetRemoteSdp(pInviteResponseMsg->sipSdpAndHeaders);
		SetRemoteHeaders(&pInviteResponseMsg->sipSdpAndHeaders);

		bool isVendorPolycom = StoreRemoteVendorInfo();

		// for Call Generator - Vendor detection
		if (status == STATUS_OK)
		{
			if ((CProcessBase::GetProcess()->GetProductFamily() == eProductFamilyCallGenerator) &&
				::GetVendorDetection() && !isVendorPolycom)
			{
				PASSERTMSG(m_callIndex, "CSipCntl::OnSipInviteResponseIndConnecting -  Call Generator - Not a Polycom manufacturer");
				status = SipCodesForbidden;
			}
		}

		if (status == STATUS_OK)
		{
			SetRecevRingback(FALSE); // Clear Ringback flag when receives 2XX(not 3456XX)

			//VNGFE-4207 if the SIP comes from Mediation server don't go through ICE.
			if (GetRemoteIdent() == MicrosoftMediationServer)
			{
				PTRACE(eLevelInfoNormal, "CSipCntl::OnSipInviteResponseIndConnecting: call is coming from MediationServer set no ICE");
				SetIsEnableICE(FALSE);
				m_pNetSetup->SetEnableSipICE(FALSE);
			} else
				SetIsEnableICE(m_pNetSetup->GetEnableSipICE());

			//added for ANAT
			if (IsAnatSupported())
			{
				m_isUpdateAnatIpType = UpdateAnatSelectedIpVersionIfNecessary(m_pRemoteSdp);
			}
			else if (m_LastAnatSelectedIpVersion !=enIpVersionMAX && checkForMediaIpVersionMismatchForPreAnat(&pInviteResponseMsg->sipSdpAndHeaders))
			{
				m_isUpdateAnatIpType = TRUE;
			}
			else
			{
			if (checkForMediaIpVersionMismatch(&pInviteResponseMsg->sipSdpAndHeaders))
			{
				if ( m_UdpAddressesParams.IpType == eIpType_Both)
				{
					BYTE isSameCallIndex = NO;
					mcXmlTransportAddress &mediaIp = ExtractMLineMediaIp(kMediaLineInternalTypeAudio, m_pRemoteSdp, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());

					if (mediaIp.transAddr.ipVersion == (DWORD)eIpVersion4)
						m_pNetSetup->SetPerferedIpV6ScopeAddr(eScopeIdOther);
					else
						m_pNetSetup->SetPerferedIpV6ScopeAddr((enScopeId)mediaIp.transAddr.addr.v6.scopeId);

					HandleMediaIpAddrVersionMismatch(isSameCallIndex);
					return;
				}
				else
				{
					SetCallDisconnecting();
					m_pCall->SetRejectReason((enSipCodes)SipCodesGlobNotAcceptable);
					m_pPartyApi->SipPartyCallFailed(SipCodesGlobNotAcceptable);
					if (IsValidTimer(PARTYCONNECTTOUT))
						DeleteTimer(PARTYCONNECTTOUT);
					return;
				}
			}
			}
			m_pLastRemoteCaps->Create(*m_pRemoteSdp, m_pParty->GetTargetMode()->GetConfMediaType(), m_bIsMrcCall);
			BYTE isRmxInitiateTransaction = TRUE;
			BYTE bFixVideoRate = CheckIsMobilePhoneByHeader(isRmxInitiateTransaction);

			m_pLastRemoteCaps->FixRemoteCapsBySystemSettings(GetRmtHeaders(), bFixVideoRate);
			//send remote caps before changing them (for update db)


			m_pPartyApi->SipPartyOriginalRemoteCaps(m_pLastRemoteCaps);
			BYTE bRemovedAudio,bRemovedVideo;
			bRemovedAudio = bRemovedVideo = 0;

			m_pLastRemoteCaps->CheckAndRemoveCapSetsWithInvalidPayloadType(bRemovedAudio, bRemovedVideo);
		//	m_pLastRemoteCaps->CompleteDataFromOtherCap(*m_pChosenLocalCap );

			CompleteDataFromOtherCapUsingUserAgent(m_pLastRemoteCaps);


			UpdateReceivedBfcpProtocol();


			m_pPartyApi->SipPartyReceived200Ok(bRemovedAudio, bRemovedVideo, m_isUpdateAnatIpType); //add a param for ANAT
			FindSiteAndVisualNamePlusProductIdAndSendToConfLevel();
			//-------TCP-KEEP-ALIVE ---------------------------------------------------------------------//
			//m_dwKeepAliveFrequency_Sec = GetRmtMsKeepAliveTimeOut();
            this->GetKeppAliveParameters();

            {
                char szLog[256]="";
                sprintf(szLog, "%d|%d|%d|%d"
                    ,m_dwKeepAliveFrequency_Sec, m_MsKeepAlivePongTimeOut, m_dwKeppAliveBehavior, m_dwKeepAliveType);
                PTRACE2(eLevelError,"TCP-KEEP-ALIVE:  200 OK IND. - ",szLog);
            }

			if( m_dwKeepAliveFrequency_Sec > 0 )
            {
                char szLog[256]="";

                DeleteTimer(MS_KEEP_ALIVE_CLIENT_TIMER);
                DeleteTimer(MS_KEEP_ALIVE_SERVER_TIMER);

                sprintf(szLog, "TCP-KEEP-ALIVE:  Start Timer for %d [%d]", m_dwKeepAliveFrequency_Sec, (m_dwKeepAliveFrequency_Sec/2) * SECOND);
                PTRACE2(eLevelError,"%s",szLog);

			    StartTimer(MS_KEEP_ALIVE_CLIENT_TIMER, (m_dwKeepAliveFrequency_Sec/2) * SECOND);
            }
			//--------------------------------------------------------------------------------------------//
		}
		else
		{
			TRACEINTO<<"lyncCryptoLinesDebugBridge8497: status"<<(int)status;
			if(m_pCall->IsCallInitiator()==TRUE)
			{
				TRACEINTO<<"lyncCryptoLinesDebugBridge8497: (m_pCall->IsCallInitiator()==TRUE";
			}
			else
			{
				TRACEINTO<<"lyncCryptoLinesDebugBridge8497: (m_pCall->IsCallInitiator()==FALSE";
			}
			if(IsRemoteMicrosoft ()==TRUE)
			{
				TRACEINTO<<"lyncCryptoLinesDebugBridge8497: IsRemoteMicrosoft ()==TRUE";
			}
			else
			{
				TRACEINTO<<"lyncCryptoLinesDebugBridge8497: IsRemoteMicrosoft ()==FALSE";
			}



			if (status < LOW_REJECT_VAL || status >= HIGH_REJECT_VAL)
				DBGPASSERT(status);

			if (status == SipCodesMovedPerm || status == SipCodesMovedTemp ||status == SipCodesMultiChoice) // call forwards
			{
				BYTE* pStart = (BYTE *)&pInviteResponseMsg->sipSdpAndHeaders.capsAndHeaders + pInviteResponseMsg->sipSdpAndHeaders.sipHeadersOffset;
				sipMessageHeaders* pHeaders = (sipMessageHeaders *)pStart;
				CSipHeaderList	headers(*pHeaders);
				const CSipHeader* pContact = headers.GetNextHeader(kContact);

				if (pContact)
				{
					const char* forwardAddrStr = pContact->GetHeaderStr();
					m_pCall->SetForwardAddr(forwardAddrStr);
				}
			}
			else if(status == SipCodesIntervalTooSmall)
			{// the session timer values was too small increase them to remote min values
				DWORD rmtMinSec = 0;
				DWORD lclMinSec	= GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_MIN_SEC);
				//DWORD MinSeconds 	= GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_MIN_SEC);

				rmtMinSec = GetRmtSessionTimerMinSec();

				if(lclMinSec >= rmtMinSec)
				{
					PTRACE(eLevelInfoNormal,"CSipCntl::OnSipInviteResponseIndConnecting, Remote's incorrect behaviour.");
					SipInviteAckReq();
				}
				else
				{
					m_state = IP_DISCONNECTING;
					SipInviteAckReq(NO);
					m_state = IP_CONNECTING;
					SipInviteReq(NULL, rmtMinSec);
					return;// to avoid the rest of the actions still in the function
				}
			}
			else if(status == SipCodesGlobNotAcceptable)
			{
				if ( m_UdpAddressesParams.IpType == eIpType_Both)
				{
					BYTE isSameCallIndex = YES;
					// Media IP Mismatch
					if (m_pNetSetup->GetSipLocalMediaType() == eIpVersion4)
						m_pNetSetup->SetPerferedIpV6ScopeAddr(eScopeIdGlobal);
					else
						m_pNetSetup->SetPerferedIpV6ScopeAddr(eScopeIdOther);

					HandleMediaIpAddrVersionMismatch(isSameCallIndex);
					return;
				}

			}
			//added for ANAT
			else if(status == SipCodesBadExtension)
			{// Currently only ANAT come to this step,  since CS does not send unsupported header to MCMS, for future need to distinguish unsupported header
				if (IsAnatSupported())
				{
					m_state = IP_DISCONNECTING;
					SipInviteAckReq(NO);
					m_state = IP_CONNECTING;
					m_LastAnatSelectedIpVersion = m_AnatSelectedIpVersion;
					m_AnatSelectedIpVersion = enIpVersionMAX;

					//Reset the BFCP transport type to TCP/UDP/BOTH
					if (m_pSipBfcpCtrl)
					{
						CreateSipBfcpCtrl(); //re-create sipBfcpCtrl in order to re-intialize it.
					}
					SipInviteReq();
					return;
				}
			}
			// BRIDGE-8497 - (Regression) RMX4000/Ninja WW >> RTV >> 8.3.0.32>> Ninja can't dial out lync client when "Encrypt when possible" is selected.
			// Bridge-13499 - for mobile add failed reason (unsupported media), remove FECC caps and redial (like above GetNeedReInviteToActiveMedia)
			else if( (status == SipCodesNotAcceptedInHere  || status == SipCodesUnsuppMediaType ) && m_pCall->IsCallInitiator()  )
			{
				SipInviteAckReq(NO);
				SetCallDisconnecting();
				m_pCall->SetRejectReason((enSipCodes)status);
				std::ostringstream msg;
				msg << " LYNC_REDIAL reject reason = " << status << " , " << ::GetRejectReasonStr((enSipCodes)status) << ", start re-dial flow to Lync client";
				if(status == SipCodesNotAcceptedInHere){
					status=SipPseudoCodesNotAcceptedInHereLyncDialOut;
					msg << " , setting status to: " << (DWORD)SipPseudoCodesNotAcceptedInHereLyncDialOut;
				}else if(status == SipCodesUnsuppMediaType){
					status=SipPseudoCodesUnsuppMediaTypeDialOut;
					msg << " , setting status to: " << (DWORD)SipPseudoCodesUnsuppMediaTypeDialOut;
				}
				PTRACE2(eLevelInfoNormal,"CSipCntl::OnSipInviteResponseIndConnecting, ", msg.str().c_str());
				m_pPartyApi->SipPartyCallFailed(status);
				return;
			}

			SetCallDisconnecting();
			m_pCall->SetRejectReason((enSipCodes)status);
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipInviteResponseIndConnecting, reject reason = ", status);
			m_pPartyApi->SipPartyCallFailed(status);
		}
	}

	// we do the delete timer here in order not to take special action when we receive 422 - session timer values to small.
	if (IsValidTimer(PARTYCONNECTTOUT))
		DeleteTimer(PARTYCONNECTTOUT);
}


///////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipInviteResponseIndDisconnecting(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipInviteResponseIndDisconnecting");

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;
	if (IsValidTimer(PARTYDISCONNECTTOUT))
		DeleteTimer(PARTYDISCONNECTTOUT);

	mcIndInviteResponse* pInviteResponseMsg = (mcIndInviteResponse *)pParam->GetPtr(1);
	DWORD status = pInviteResponseMsg->status;

	if (status >= LOW_REJECT_VAL && status < HIGH_REJECT_VAL)
	{
		BYTE bIsCancel			= (m_pCall->GetCancelType() == kCancelAfterInvite);
		BYTE bIsCloseInitiator	= m_pCall->IsCloseInitiator();
		m_pCall->SetCancelType(kNoCancel);

		if (status == SipCodesRequestTerminated)
			// answer for cancel
			CloseCall(YES,SipCodesRequestTerminated);
		else if (bIsCancel)	//(send ack)
			// cross message between cancel and reject from ep
			CloseCall(NO,(enSipCodes)status); //(forget the cancel)
		else if (m_bIsReInviteTransaction && bIsCloseInitiator == NO)
			// cross message between re-invite and "bye" from ep.
			SipInviteAckReq(NO); //(send ack and let disconnecting process to end by sending "bye ok" when conf is ready)
		else
		{
			CSmallString str;
			if (bIsCancel)
				str << "Cancel sent to EP, ";
			if (m_bIsReInviteTransaction)
				str << "Re-invite transaction, ";
			if (bIsCloseInitiator)
				str << "MCU closed call.";
			else
				str << "EP closed call.";

			DBGPASSERT(YES);
			PTRACE2(eLevelError,"CSipCntl::OnSipInviteResponseIndDisconnecting - ",str.GetString());
		}
	}
	else if (status == STATUS_OK) // 200 ok arrived after we sent cancel so we send ack for the 200 ok and then bye request
	{
		SipInviteAckReq();
		CloseCall(YES); //local is the close initiator
	}
	else
		m_pPartyApi->SipPartyCallFailed(status);
}


//////////////////////////////////////////////////////////////////////////
void CSipCntl::HandleSdpFromInviteAckInd(mcIndInviteAck* pInviteAckMsg, CSipChanDifArr* pDifArr, BYTE &bRemovedAudio, BYTE &bRemovedVideo)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::HandleSdpFromInviteAckInd");
	if(pInviteAckMsg->status == STATUS_OK)
	{
		APIU32 capabilitiesLength	= pInviteAckMsg->sipSdpAndHeaders.sipMediaLinesLength; // old api: sipHeadersOffset;
		APIU32 capsAndHeadersLength = pInviteAckMsg->sipSdpAndHeaders.lenOfDynamicSection;
		if(capsAndHeadersLength && capabilitiesLength && capsAndHeadersLength >= capabilitiesLength)
		{// remote invite Ack indication includes SDP. Take it, and check changes in current setting.
			RestoreVideoRate((sipSdpAndHeadersSt *)&pInviteAckMsg->sipSdpAndHeaders);

			sipSdpAndHeadersSt* pSdpAndHeaders	= (sipSdpAndHeadersSt *)&pInviteAckMsg->sipSdpAndHeaders;
			if (pSdpAndHeaders)
			{
				SetMediaLinesInternalTypeForRmtSdp(*pSdpAndHeaders);
				SetCapsRolesForRmtSdp(*pSdpAndHeaders, kMediaLineInternalTypeVideo, kRolePeople);
				SetCapsRolesForRmtSdp(*pSdpAndHeaders, kMediaLineInternalTypeContent, kRolePresentation);
			}
			if (m_bIsReInviteTransaction)
			{
				if (m_pCall->IsReInviteInitiator() == FALSE)
				{
					CSipCaps*			pRemoteCaps		= new CSipCaps;

					pRemoteCaps->Create(*pSdpAndHeaders, m_pParty->GetTargetMode()->GetConfMediaType(), m_bIsMrcCall);
					pRemoteCaps->CheckAndRemoveCapSetsWithInvalidPayloadType(bRemovedAudio,bRemovedVideo);
					//pRemoteCaps->CompleteDataFromOtherCap(*m_pChosenLocalCap );
					CompleteDataFromOtherCapUsingUserAgent(pRemoteCaps);

					AnalyzeDifferencesInSdp(pSdpAndHeaders,pRemoteCaps,pDifArr);
					SetRemoteSdp(*pSdpAndHeaders);
					SavePreviousRemoteCaps();
					POBJDELETE(m_pLastRemoteCaps);
					m_pLastRemoteCaps = pRemoteCaps;
					UpdateReceivedBfcpProtocol();
					RemoveH263FromRemoteIfNeeded(pDifArr); //BRIDHE-10595
					if (GetIsTipCall() && !CheckIfCallIsResumed(pDifArr))
						AddTipNegotiationCapsToRemoteCaps();
					if( GetIsTipCall() && CheckIfCallIIsPutOnHold(pDifArr) )
					{
						m_pParty->SetTipPartyOnHold(TRUE);
						PTRACE(eLevelInfoNormal,"CSipCntl::HandleSdpFromInviteAckInd - tip is set on hold");
					}
					else if( GetIsTipCall() && CheckIfCallIsResumed(pDifArr) )
					{
						m_pParty->SetTipPartyOnHold(FALSE);
						PTRACE(eLevelInfoNormal,"CSipCntl::HandleSdpFromInviteAckInd - resume undo hold");
					}
					//Set the onhold/resume medias
					if(!GetIsTipCall())
					{
						enMediaOnHold mediaOnHold =  CheckIfCallisPutOnHoldByMedia(pDifArr);
						if(mediaOnHold)
						{
							enMediaOnHold eMediaOnHeld = m_pParty->GetNonTipPartyOnHold();
							PTRACE2INT(eLevelInfoNormal,"CSipCntl::HandleSdpFromInviteAckInd - MediaOnHeld: ",(WORD)eMediaOnHeld);
							int	iMediaOnHold = mediaOnHold | eMediaOnHeld;
							m_pParty->SetNonTipPartyOnHold((enMediaOnHold) iMediaOnHold);
						}
						enMediaOnHold mediaResume = eMediaOnHoldNon;
						mediaResume = CheckIfCallisResumedByMedia(pDifArr);
						if(mediaResume)
						{
							enMediaOnHold eMediaOnHeld = m_pParty->GetNonTipPartyOnHold();
							PTRACE2INT(eLevelInfoNormal,"CSipCntl::HandleSdpFromInviteAckInd - resume, MediaOnHeld: ",(WORD)eMediaOnHeld);
							int iMediaOnHold = (~mediaResume) & eMediaOnHeld;
							m_pParty->SetNonTipPartyOnHold((enMediaOnHold) iMediaOnHold);
						}

					}

				}
				else
					DBGPASSERT(YES);
			}
			else
			{
				SetRemoteSdp(*pSdpAndHeaders);
				CheckAndStoreRemoteOriginVersionField();
				m_pLastRemoteCaps->Create(*m_pRemoteSdp, m_pParty->GetTargetMode()->GetConfMediaType(), m_bIsMrcCall);
				BYTE isRmxInitiateTransaction = TRUE;
				BYTE bFixVideoRate = CheckIsMobilePhoneByHeader(isRmxInitiateTransaction);

				sipMessageHeaders* pHeaders = NULL;
				if (pSdpAndHeaders->sipHeadersLength)
					pHeaders = (sipMessageHeaders*)((char*)pSdpAndHeaders->capsAndHeaders + pSdpAndHeaders->sipHeadersOffset);
				m_pLastRemoteCaps->FixRemoteCapsBySystemSettings(pHeaders, bFixVideoRate);

				//send remote caps before changing them (for update db)
				m_pPartyApi->SipPartyOriginalRemoteCaps(m_pLastRemoteCaps);
				m_pLastRemoteCaps->CheckAndRemoveCapSetsWithInvalidPayloadType(bRemovedAudio, bRemovedVideo);
				//m_pLastRemoteCaps->CompleteDataFromOtherCap(*m_pChosenLocalCap );
				CompleteDataFromOtherCapUsingUserAgent(m_pLastRemoteCaps);
				UpdateReceivedBfcpProtocol();
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::HandleReInviteResponse(mcIndInviteResponse* pReInviteResponseMsg)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::HandleReInviteResponse");
	BYTE bRemovedAudio, bRemovedVideo;
	bRemovedAudio = bRemovedVideo = 0;

	DWORD						status					= pReInviteResponseMsg->status;
	CSipChanDifArr*				pDifArr					= new CSipChanDifArr;

	if (status == STATUS_OK)
	{
		sipSdpAndHeadersSt* pSdpAndHeaders	= (sipSdpAndHeadersSt *)&pReInviteResponseMsg->sipSdpAndHeaders;
		
		CSipCaps*			pRemoteCaps		= new CSipCaps;

		pRemoteCaps->Create(*pSdpAndHeaders, m_pParty->GetTargetMode()->GetConfMediaType(), m_bIsMrcCall);
		pRemoteCaps->CheckAndRemoveCapSetsWithInvalidPayloadType(bRemovedAudio, bRemovedVideo);
		//pRemoteCaps->CompleteDataFromOtherCap(*m_pChosenLocalCap );
		CompleteDataFromOtherCapUsingUserAgent(pRemoteCaps);

		AnalyzeDifferencesInSdp(pSdpAndHeaders,pRemoteCaps,pDifArr);

		SetRemoteSdp(*pSdpAndHeaders);

		POBJDELETE(m_pLastRemoteCaps);

		m_pLastRemoteCaps = pRemoteCaps;

		if(m_pLastRemoteCaps->IsBfcpSupported() == TRUE)
			UpdateBfcpParametersByRemoteSdp();

		UpdateReceivedBfcpProtocol();

		if (GetIsTipCall())
			AddTipNegotiationCapsToRemoteCaps();

		if( GetIsTipCall() && CheckIfCallIIsPutOnHold(pDifArr) )
		{
			m_pParty->SetTipPartyOnHold(TRUE);
			PTRACE(eLevelInfoNormal,"CSipCntl::HandleReInviteResponse - tip is set on hold");
		}
		else if( GetIsTipCall() && CheckIfCallIsResumed(pDifArr) )
		{
			m_pParty->SetTipPartyOnHold(FALSE);
			PTRACE(eLevelInfoNormal,"CSipCntl::HandleReInviteResponse - resume undo hold");
		}
		//Set the onhold/resume medias
		if(!GetIsTipCall())
		{
			enMediaOnHold mediaOnHold =  CheckIfCallisPutOnHoldByMedia(pDifArr);
			if(mediaOnHold)
			{
				enMediaOnHold eMediaOnHeld = m_pParty->GetNonTipPartyOnHold();
				PTRACE2INT(eLevelInfoNormal,"CSipCntl::HandleReInviteResponse - MediaOnHeld: ",(WORD)eMediaOnHeld);
				int iMediaOnHold = mediaOnHold | eMediaOnHeld;
				m_pParty->SetNonTipPartyOnHold((enMediaOnHold) iMediaOnHold);
			}
			enMediaOnHold mediaResume = eMediaOnHoldNon;
			mediaResume = CheckIfCallisResumedByMedia(pDifArr);
			if(mediaResume)
			{
				enMediaOnHold eMediaOnHeld = m_pParty->GetNonTipPartyOnHold();
				PTRACE2INT(eLevelInfoNormal,"CSipCntl::HandleReInviteResponse - resume, MediaOnHeld: ",(WORD)eMediaOnHeld);
				int iMediaOnHold = (~mediaResume) & eMediaOnHeld;
				m_pParty->SetNonTipPartyOnHold((enMediaOnHold) iMediaOnHold);
			}

		}

		m_pPartyApi->SipPartyReInviteResponse(status, bRemovedAudio, bRemovedVideo, pDifArr);
	}
	else if ( (status < LOW_REJECT_VAL) || (status >= HIGH_REJECT_VAL) //1xx, 2xx, 7xx...
			|| (!IsRejectCall(status)))  // rollack transaction
	{
		m_pPartyApi->SipPartyReInviteResponse(status, bRemovedAudio, bRemovedVideo, pDifArr);
	}
	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::HandleReInviteResponse-re -invite was not sent to party -but failed!");
		m_pCall->SetRejectReason((enSipCodes)status);
		m_pPartyApi->SipPartyCallFailed(status);
	}
	POBJDELETE(pDifArr);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::IsRejectCall(DWORD status)
{
	// This function check, according to RFC-5057, whether the meaning of the ReInvite-Reject is to reject the call (and we should disconnect call)
	// or to reject the last transaction only (and we should rollback the last ReInvite transaction).
	switch (status)
	{
		case SipCodesNotFound:			// 404
		case SipCodesGone:				// 410
		case 416:						// 416
		case SipCodesLoopDetected:		// 482
		case SipCodesTooManyHops:		// 483
		case SipCodesAddressIncomp:		// 484
		case SipCodesAmbiguous:			// 485
		case SipCodesBadGateway:		// 502
		case SipCodesDoesNotExist:		// 604
			return TRUE; // reject the dialog
		case SipCodesMethNotAllowed:	// 405
		case SipCodesTempNotAvail:		// 480
		case SipCodesCallNotExist:		// 481
		case 489:						// 489
		case SipCodesNotImplemented:	// 501
			return TRUE; // reject the usage
	}
	return FALSE;  // reject transaction only
}
///////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipByeIndConnecting(CSegment* pParam)
{
//RFC-3261 : [15] HOMOLOGATION : SIP_CC_TE_CR_V_003
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipByeIndConnecting");

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

	mcIndBye* pByeMsg = (mcIndBye *)pParam->GetPtr(1);
	DWORD status = pByeMsg->status;
	DBGPASSERT(status); // only if status != STATUS_OK

	SetCallDisconnecting();
	m_pCall->SetCloseInitiator(NO);
	m_pPartyApi->SipPartyRemoteCloseCall(SIP_REMOTE_CLOSED_CALL);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
EPendingTransType CSipCntl::CheckActiveAndPendingTransactions(CSegment* pParam)
{
	if( m_pParty->IsActiveTransaction() && m_SavedTrans == NULL && pParam!= NULL)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::CheckActiveAndPendingTransactions -bye in a middle of another trans save segment.");
		//m_SavedTrans =new CSegment;
		//*m_SavedTrans = *pParam;
		m_SavedTrans = new CSegment(*pParam);
		m_PendTransType = etransBye;

	}
	else if(m_pParty->IsActiveTransaction() && m_SavedTrans != NULL && pParam!= NULL && m_PendTransType != eNoPendTrans)
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::CheckActiveAndPendingTransactions -another pending reinvite old trans is .",(WORD)m_PendTransType);
		POBJDELETE(m_SavedTrans);
		m_SavedTrans = new CSegment(*pParam);
		m_PendTransType = etransBye;

	}
	else if(m_SavedTrans && pParam == NULL && m_PendTransType == etransBye)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::CheckActiveAndPendingTransactions -begin bye from pending trans");
		pParam = new CSegment(*m_SavedTrans);
		POBJDELETE(m_SavedTrans);
		m_PendTransType = eNoPendTrans;

	}
	else if(m_SavedTrans == NULL && pParam == NULL)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::CheckActiveAndPendingTransactions -invalid trans calling.");
		m_PendTransType = eNoPendTrans;
		//DBGPASSERT_AND_RETURN(1);
	}

	return m_PendTransType;

}

///////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipByeInd(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipByeInd");

	EPendingTransType pendingtransaction = CheckActiveAndPendingTransactions(pParam);
	if(pendingtransaction == etransBye){ // N.A. want to make sure we don't start handling BYE_IND when we are in the middle of disconnecting already
		TRACEINTO << "already has pending transaction etransBye";
		return;
	}

	TRACECOND_AND_RETURN(!pParam , "pParam is NULL");
	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

	std::ostringstream msg;
	PartyDisconnectionPrint(msg,"Start Disconnection From EP , setting reason SIP_REMOTE_CLOSED_CALL");
	// msg << "PARTY_DISCONNECTION - confRsrcId: " << m_pParty->GetConfId() << " , partyRsrcId: " << m_pParty->GetPartyRsrcID() << " , Start Disconnection From EP , setting reason SIP_REMOTE_CLOSED_CALL";
	TRACEINTO << msg.str().c_str();

	mcIndBye* pByeMsg = (mcIndBye *)pParam->GetPtr(1);
	DWORD status = pByeMsg->status;
	DBGPASSERT(status); // only if status != STATUS_OK

	if (m_bIsReInviteTransaction && m_pCall->IsReInviteInitiator())
	{
		// this is a cross message between re-invite we sent to bye that the EP sent.
		// the card must dropped our re-invite. we have to forget about the re-invite and answer the bye.
		m_bIsReInviteTransaction = NO; // close transaction
	}
	// else
		// the EP sent a non standard bye after it sent a re-invite.
		// we must answer the re-invite and then close the call.
		// but since sip-control has already transfer the re-invite to the party level,
		// the party level should be the one to answer.

	SetCallDisconnecting();
	m_pCall->SetCloseInitiator(NO);
	m_pPartyApi->SipPartyRemoteCloseCall(SIP_REMOTE_CLOSED_CALL);
}


////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipByeIndDisconnecting(CSegment* pParam)
{
	EPendingTransType pendingtransaction = CheckActiveAndPendingTransactions(pParam);
	if(pendingtransaction == etransBye) // N.A. want to make sure we don't start handling BYE_IND when we are in the middle of disconnecting already
		return;

	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipByeIndDisconnecting");
	CloseCall(NO);
}


////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipBye200OkInd(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipBye200OkInd");

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

	if (IsValidTimer(PARTYDISCONNECTTOUT))
		DeleteTimer(PARTYDISCONNECTTOUT);

	mcIndBye200Ok* pBye200OkMsg = (mcIndBye200Ok *)pParam->GetPtr(1);
	DWORD status = pBye200OkMsg->status;

	if (status < LOW_REJECT_VAL || status >= HIGH_REJECT_VAL) // something is wrong
	{
		DBGPASSERT(status);
	}
	else if (status) // normally cross message
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipBye200OkInd: status - ", status);
	}

	SetCallDisconnectedAndRemoveFromRsrcTbl();
	CSipComMode* pCurrentMode = new CSipComMode;
	pCurrentMode->Create(*m_pCall);
	pCurrentMode->CopyStaticAttributes(*(m_pParty->GetTargetMode())); // copy necessary data members like ConfType from preffered mode to best mode.
	m_pPartyApi->SipPartyCallClosed(pCurrentMode);
	POBJDELETE(pCurrentMode);
}

////////////////////////////////////////////////////////////////////////
/*Begin:added by Richer for BRIDGE-12062 ,2014.3.3*/
void CSipCntl::OnSipBye200OkInd_Avoid(CSegment* pParam)
{
    PTRACE(eLevelInfoNormal,"CSipCntl::OnSipBye200OkInd_Avoid");

}
/*End:added by Richer for BRIDGE-12062 ,2014.3.3*/

///////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipBadStatusInd(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	CMedString str;

	str << "Name - " << PARTYNAME;
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnSipBadStatusInd, Name - ", str.GetString());

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

	mcIndBadStatus* pBadStatusMsg = (mcIndBadStatus*)pParam->GetPtr(1);
	DWORD opcode = pBadStatusMsg->FailedrequestOpcode;
	char*  strDescription	= pBadStatusMsg->sErrMsg;
	int len = min(strlen(strDescription), MaxErrorMessageSize);

	// meaning that the card did not send the cancel cause there were no ringing. so don't wait for an answer
	if (opcode == SIP_CS_SIG_CANCEL_REQ && IsValidTimer(PARTYDISCONNECTTOUT))
		DeleteTimer(PARTYDISCONNECTTOUT);

	m_pPartyApi->SipPartyBadStatus(opcode,len,(BYTE*)strDescription);
	//POBJDELETE(pParam);

}


///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipTraceInfoInd(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipTraceInfoInd");
	// we should only print this message and it is already printed in rhdlcsrv.cpp
//	mcIndTraceInfo* pTraceInfoMsg = (mcIndTraceInfo *)pParam->GetPtr();
}


///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipInstantMessageInd(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	CMedString str;

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;
	mcIndInstantMessage* pInstantMessageMsg = (mcIndInstantMessage *) pParam->GetPtr(1);
	DWORD status = pInstantMessageMsg->status;
	str << "Message Is: " << pInstantMessageMsg->message;
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnSipInstantMessageInd, ", str.GetString());
}
///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipReInviteIndChangeMode(CSegment* pParam)
{
	// Can occur after invite no sdp.
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndChangeMode");
	OnSipReInviteIndConnected(pParam);
}

///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipReInviteIndDisconnecting(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	CMedString str;

	PTRACE2(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndDisconnecting, Name - ", str.GetString());
	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;
	mcIndReInvite* pReInviteMsg = (mcIndReInvite *)pParam->GetPtr(1);

	DWORD status = pReInviteMsg->status;
	DBGPASSERT(status); // only if status != STATUS_OK
	SipInviteResponseReq(SipCodesRequestTerminated); // reject the EP request
	m_bIsReInviteTransaction = YES;
	m_pCall->SetReInviteInitiator(NO);

	if (m_pCall->IsCloseInitiator() == NO)
	{
		DBGPASSERT(YES);
		PTRACE(eLevelError,"CSipCntl::OnSipReInviteIndDisconnecting: The mcu is not the initiator of close!");
	}
	// else: some ind arrived after we tried to close the call - cross message.
	//		 this means that the card did not send the bye to the EP.
}


/////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipReInviteIndConnecting(CSegment* pParam)
{
	// if this message arrived we understood that there was a cross messages between our re-invite to the ep's.
	// the card must have dropped ours and deliver the ep's.
	// we reject this request and after we get the ack for the reject we send the re-invite again

	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

		PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnecting, Cross message between 2 re-invites");
		mcIndReInvite* pReInviteMsg = (mcIndReInvite *)pParam->GetPtr(1);
		DWORD status = pReInviteMsg->status;
		DBGPASSERT(status); // only if status != STATUS_OK

	// Send the ReInvite-Ind to Party (Transaction) to handle the cross between ReInvite messages:
	BYTE isRejectReInvite = YES;
	BYTE isReInviteWithSdp = YES;
	CSipChanDifArr* pDifArr = new CSipChanDifArr;
	m_pPartyApi->SipPartyReceivedReInvite(pDifArr, isReInviteWithSdp, isRejectReInvite);
	POBJDELETE(pDifArr);
}

//////////////////////////////////////////////////////////////////////////////
//eFeatureRssDialin
// ACK for 491 Request Pending
void CSipCntl::OnSipInviteAckIndChangeMode(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipInviteAckIndChangeMode");
	return;
}


/////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::IsRenderingHeader(sipSdpAndHeadersSt* pSdpAndHeaders)
{
	BYTE* pStart = (BYTE *)(pSdpAndHeaders->capsAndHeaders) + pSdpAndHeaders->sipHeadersOffset;
	sipMessageHeaders* pHeaders = (sipMessageHeaders *)pStart;
	CSipHeaderList	headers(*pHeaders);
	const CSipHeader* pContactRendering = headers.GetNextHeader(kContactRendering);

	if (pContactRendering && pContactRendering->GetHeaderStr() && strcmp(pContactRendering->GetHeaderStr(),""))
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::IsRenderingHeader - SDP contains rendering");
		return TRUE;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////
int CSipCntl::GetNewMOCStateAccoringToSdp(sipSdpAndHeadersSt* pSdpAndHeaders)
{
	int retState  = MocStateUnknown;

	BYTE bRendering = IsRenderingHeader(pSdpAndHeaders);
	CSmallString strTrace;
	strTrace << "Rendering = " << bRendering << ", current hold = " << m_bIsHold << ", current PauseMyVideo = " << m_bPauseMyVideo;
	PTRACE2(eLevelInfoNormal, "CSipCntl::GetNewMOCStateAccoringToSdp : ", strTrace.GetString());

	mcXmlTransportAddress &remoteVideoIp = ExtractMLineMediaIp(kMediaLineInternalTypeVideo, m_pRemoteSdp, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());
	mcXmlTransportAddress &sdpAudioIp = ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());
	mcXmlTransportAddress &sdpVideoIp = ExtractMLineMediaIp(kMediaLineInternalTypeVideo, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());

	if (!bRendering
		&& (m_bIsHold==FALSE)
		&& (remoteVideoIp.transAddr.port)
		&& !(sdpAudioIp.transAddr.port)
		&& !(sdpAudioIp.transAddr.addr.v4.ip)
		&& !(sdpVideoIp.transAddr.port)
		&& !(sdpVideoIp.transAddr.addr.v4.ip))
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::GetNewMOCStateAccoringToSdp MocStateVtoA");
		m_bPauseMyVideo = FALSE;
		retState = MocStateVtoA;
	}
	else if(!bRendering
			&& (m_bIsHold==FALSE)
			&& !(remoteVideoIp.transAddr.port)
			&& !(sdpAudioIp.transAddr.port))
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::GetNewMOCStateAccoringToSdp MocStateAtoV");
		m_bPauseMyVideo = FALSE;
		retState = MocStateAtoV;
	}
	else if(!bRendering
			&& (m_bIsHold==FALSE)
			&& (remoteVideoIp.transAddr.port)
			&& !(sdpAudioIp.transAddr.port)
			&& (GetMediaDirectionAttribute(pSdpAndHeaders, cmCapVideo) == kRecvOnly))
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::GetNewMOCStateAccoringToSdp MocStatePauseMyVideo");
		m_bPauseMyVideo = TRUE;
		retState = MocStatePauseMyVideo;
	}
	else if(!bRendering
			&& (m_bIsHold==FALSE)
			&& (m_bPauseMyVideo==TRUE)
			&& (remoteVideoIp.transAddr.port)
			&& !(sdpAudioIp.transAddr.port))
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::GetNewMOCStateAccoringToSdp MocStateResumeMyVideo");
		m_bPauseMyVideo = FALSE;
		retState = MocStateResumeMyVideo;
	}
	else if(bRendering
			&& (m_bIsHold==FALSE)
			&& !(sdpAudioIp.transAddr.port))
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::GetNewMOCStateAccoringToSdp MocStateHold");
		m_bIsHold = TRUE;
		retState = MocStateHold;
	}
	else if(!bRendering
			&& (m_bIsHold==TRUE)
			&& !(sdpAudioIp.transAddr.port))
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::GetNewMOCStateAccoringToSdp MocStateResume");
		m_bIsHold = FALSE;
		retState = MocStateResume;
	}
	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::GetNewMOCStateAccoringToSdp MocStateUnknown");
	}

	return retState;
}

/////////////////////////////////////////////////////////////////////////
void CSipCntl::SaveAudioAndVideoParams(sipSdpAndHeadersSt* pSdpAndHeaders)
{
	mcXmlTransportAddress &remoteAudioIp = ExtractMLineMediaIp(kMediaLineInternalTypeAudio, m_pRemoteSdp, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());
	mcXmlTransportAddress &remoteVideoIp = ExtractMLineMediaIp(kMediaLineInternalTypeVideo, m_pRemoteSdp, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());
	mcXmlTransportAddress &sdpAudioIp = ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());
	mcXmlTransportAddress &sdpVideoIp = ExtractMLineMediaIp(kMediaLineInternalTypeVideo, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());

	// save ports and ips:
	if (sdpAudioIp.transAddr.port)
		m_savedAudioPort = sdpAudioIp.transAddr.port;
	else if (remoteAudioIp.transAddr.port)
		m_savedAudioPort = remoteAudioIp.transAddr.port;

	if (sdpVideoIp.transAddr.port)
		m_savedVideoPort = sdpVideoIp.transAddr.port;
	else if (remoteVideoIp.transAddr.port)
		m_savedVideoPort = remoteVideoIp.transAddr.port;

	if (sdpVideoIp.transAddr.addr.v4.ip)
		m_savedVideoIp = sdpVideoIp.transAddr.addr.v4.ip;
	else if (remoteVideoIp.transAddr.addr.v4.ip)
		m_savedVideoIp = remoteVideoIp.transAddr.addr.v4.ip;
}

/////////////////////////////////////////////////////////////////////////
static void CloneSdpAndHeaders(sipSdpAndHeadersSt *pRemoteSdp, sipSdpAndHeadersSt*& pSdpAndHeaders, BYTE &bDelSdpHeader) //BRIDGE-11137 added '&' before pSdpAndHeaders
{
	int length = sizeof(sipSdpAndHeadersBaseSt) + pRemoteSdp->lenOfDynamicSection;
	pSdpAndHeaders = (sipSdpAndHeadersSt *)new BYTE[length];
	memset(pSdpAndHeaders, 0, length);
	memcpy(pSdpAndHeaders, pRemoteSdp, length);
	bDelSdpHeader = TRUE;
}

//BRIDGE-15745
/////////////////////////////////////////////////////////////////////////
BOOL CSipCntl::IsTipCallTryToResumeAndPendingIsToHold(CSipChanDifArr* pDifArr, BOOL bIsReInviteWithSdp)
{
	PASSERTMSG_AND_RETURN_VALUE(!m_pParty || !pDifArr, "!m_pParty || !pDifArr", FALSE);

	BOOL 	bRetVal 			= FALSE;
	BOOL 	bIsTipCall 			= GetIsTipCall();
	BOOL 	bIsTipPartyOnHold	= m_pParty->GetTipPartyOnHold();
	BOOL 	bIsPendingOnHold	= bIsReInviteWithSdp && CheckIfCallIIsPutOnHold(pDifArr);


	if(bIsTipCall && !bIsTipPartyOnHold && bIsPendingOnHold)
		bRetVal = TRUE;

	TRACEINTO 	<< " bRetVal " << (int)bRetVal
				<< " bIsTipCall " << (int)bIsTipCall
				<< " bIsTipPartyOnHold " << (int)bIsTipPartyOnHold
				<< " bIsPendingOnHold " << (int)bIsPendingOnHold
				<< " bIsReInviteWithSdp " << (int)bIsReInviteWithSdp;

	return bRetVal;
}

//BRIDGE-15745
/////////////////////////////////////////////////////////////////////////
void CSipCntl::NotifyTransactionOnPendingIfNeeded()
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	BYTE isReInviteWithSdp = NO;

	PASSERTMSG_AND_RETURN(!m_SavedTrans || !m_pPartyApi || !m_pParty, "!m_SavedTrans || !m_pPartyApi || !m_pParty");
	CSegment* pPendTrans = new CSegment(*m_SavedTrans);
	*pPendTrans >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

	BOOL				bNeedToNotify		= FALSE;
	mcIndReInvite* 		pReInviteMsg 		= (mcIndReInvite *)pPendTrans->GetPtr(1);

	if(!pReInviteMsg)
	{
		POBJDELETE(pPendTrans);
		PASSERT_AND_RETURN(1);
	}

	sipSdpAndHeadersSt* pSdpAndHeaders		= (sipSdpAndHeadersSt *)&pReInviteMsg->sipSdpAndHeaders;
	if(!pSdpAndHeaders)
	{
		POBJDELETE(pPendTrans);
		PASSERT_AND_RETURN(1);
	}
	CSipChanDifArr*		pDifArr				= new CSipChanDifArr;
	CSipCaps*			pRemoteCaps			= new CSipCaps;

	SetMediaLinesInternalTypeForRmtSdp(*pSdpAndHeaders);
	SetCapsRolesForRmtSdp(*pSdpAndHeaders, kMediaLineInternalTypeVideo, kRolePeople);
	SetCapsRolesForRmtSdp(*pSdpAndHeaders, kMediaLineInternalTypeContent, kRolePresentation);

	APIU32 capabilitiesLength	= pSdpAndHeaders->sipMediaLinesLength; // old api: sipHeadersOffset;
	APIU32 capsAndHeadersLength = pSdpAndHeaders->lenOfDynamicSection;
	if(capsAndHeadersLength && capabilitiesLength && capsAndHeadersLength >= capabilitiesLength && m_pParty->GetTargetMode())
	{
		isReInviteWithSdp = YES;

		pRemoteCaps->Create(*pSdpAndHeaders, m_pParty->GetTargetMode()->GetConfMediaType(), FALSE);
		AnalyzeDifferencesInSdp(pSdpAndHeaders, pRemoteCaps, pDifArr);
	}

	bNeedToNotify = IsTipCallTryToResumeAndPendingIsToHold(pDifArr , isReInviteWithSdp);

	TRACEINTO 	<< " bNeedToNotify " << (int)bNeedToNotify;
	if(bNeedToNotify)
		m_pPartyApi->NotifySipPendingTransaction(m_PendTransType);

	POBJDELETE(pPendTrans);
	POBJDELETE(pDifArr);
	POBJDELETE(pRemoteCaps);
}
/////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipReInviteIndConnected(CSegment* pParam)
{
	PASSERT_AND_RETURN(!m_pParty);
	PASSERT_AND_RETURN(!m_pCall);
	CConfParty* pConfParty = m_pParty->GetConfPartyNonConst();
	PASSERT_AND_RETURN(!pConfParty);

	CSegment* pSavedParam = NULL;
	if( (m_pParty->IsNeedToPendNewTransaction()) && m_SavedTrans == NULL && pParam!= NULL)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected -reinvite in a middle of another trans save segment.");
		//m_SavedTrans =new CSegment;
		//*m_SavedTrans = *pParam;

		//eFeatureRssDialin
		if(m_pParty->IsThereActiveInviteReq())
		{
			// Send the ReInvite-Ind to Party (Transaction) to handle the cross between ReInvite messages:
			BYTE isRejectReInvite = NO;
			BYTE isReInviteWithSdp = YES;
			CSipChanDifArr* pDifArr = new CSipChanDifArr;
			m_pPartyApi->SipPartyReceivedReInvite(pDifArr, isReInviteWithSdp, isRejectReInvite);
			POBJDELETE(pDifArr);
			PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected -tell trans to reject the outgoing reINVITE  -- start Glare.");
		}
		m_SavedTrans = new CSegment(*pParam);
		m_PendTransType = etransReinvite;
		NotifyTransactionOnPendingIfNeeded(); //BRIDGE-15745

		return;
	}
	else if(m_pParty->IsNeedToPendNewTransaction() && m_SavedTrans != NULL && pParam!= NULL && m_PendTransType != eNoPendTrans)
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected -another pending reinvite old pending trans is.",(WORD)m_PendTransType);
		POBJDELETE(m_SavedTrans);
		m_SavedTrans = new CSegment(*pParam);
		m_PendTransType = etransReinvite;
		return;

	}
	else if(pConfParty -> GetTokenRecapCollisionDetection() == etrcdTokenHandlingInProgress)
	{
		//==================================================================
		// Token is being granted/released at the moment, pending reinvite
		//==================================================================
		m_pParty -> PendRecapOnToken(pParam);
		return;
	}
	else if(m_SavedTrans && pParam == NULL && m_PendTransType == etransReinvite)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected -begin reinvite from pending trans");
		pParam = new CSegment(*m_SavedTrans);
		/*we save the point here since we need free it in the end of this function*/
		pSavedParam = pParam;
		POBJDELETE(m_SavedTrans);
		m_PendTransType = eNoPendTrans;

	}
	else if(m_SavedTrans == NULL && pParam == NULL)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected -invalid trans calling.");
		DBGPASSERT_AND_RETURN(1);
	}
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	BYTE bDelSdpHeader = FALSE;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected");
	BYTE bRemovedAudio, bRemovedVideo;
	bRemovedAudio = bRemovedVideo = 0;

	TRACECOND_AND_RETURN(!pParam , "pParam is NULL");
	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

	mcIndReInvite* pReInviteMsg = (mcIndReInvite *)pParam->GetPtr(1);

	if(NULL == pReInviteMsg)
	{
		if(m_PendTransType == eNoPendTrans)
			POBJDELETE(pParam);  // pParam is new by us, delete it before return
		PASSERT_AND_RETURN(1);
	}


	DWORD status = pReInviteMsg->status;
	DBGPASSERT(status); // only if status != STATUS_OK

	sipSdpAndHeadersSt* pSdpAndHeaders	= (sipSdpAndHeadersSt *)&pReInviteMsg->sipSdpAndHeaders;
	if (pSdpAndHeaders)
	{
		SetMediaLinesInternalTypeForRmtSdp(*pSdpAndHeaders);
		SetCapsRolesForRmtSdp(*pSdpAndHeaders, kMediaLineInternalTypeVideo, kRolePeople);
		SetCapsRolesForRmtSdp(*pSdpAndHeaders, kMediaLineInternalTypeContent, kRolePresentation);
	}
	BYTE isRejectReInvite  = NO;
	BYTE isReInviteWithSdp = YES;

	pConfParty -> SetTokenRecapCollisionDetection(etrcdRecapInProgress);

	CSipChanDifArr*		pDifArr			= new CSipChanDifArr;
	if (status == STATUS_OK)
	{
		APIU32 capabilitiesLength	= pSdpAndHeaders->sipMediaLinesLength; // old api: sipHeadersOffset;
		APIU32 capsAndHeadersLength = pSdpAndHeaders->lenOfDynamicSection;
		if(capsAndHeadersLength && capabilitiesLength && capsAndHeadersLength >= capabilitiesLength)
		{
			isReInviteWithSdp = YES;
			RestoreVideoRate(pSdpAndHeaders);
			CSipCaps*			pRemoteCaps		= new CSipCaps;
			if (m_remoteIdent == MicrosoftEP_R2 || m_remoteIdent == MicrosoftEP_Lync_R1 || m_remoteIdent == MicrosoftEP_Lync_2013 ||  m_remoteIdent == Microsoft_AV_MCU2013 )  // patch for MOC R2 features (hold,resume,a->v)
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected - Handle MOC/Lync ReInvite");

				// save ports and ips:
				SaveAudioAndVideoParams(pSdpAndHeaders);

				int NewMocState = GetNewMOCStateAccoringToSdp(pSdpAndHeaders);

				if (NewMocState==MocStateHold)
				{
					CloneSdpAndHeaders(m_pRemoteSdp, pSdpAndHeaders, bDelSdpHeader);

					TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kInactive,kInactive,kInactive,kInactive,kInactive)";
					SetTheDirectionAttribute(pSdpAndHeaders,kInactive,kInactive,kInactive,kInactive,kInactive);
				}
				else if (NewMocState==MocStateResume)
				{
					CloneSdpAndHeaders(m_pRemoteSdp, pSdpAndHeaders, bDelSdpHeader);

					TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv," << (m_bPauseMyVideo? "kSendOnly" : "kSendRecv") << "kSendRecv,kSendRecv,kSendRecv,TRUE)";
					SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv, m_bPauseMyVideo? kSendOnly : kSendRecv, kSendRecv, kSendRecv, kSendRecv, TRUE);
				}
				else if(NewMocState==MocStateAtoV)
				{
					CSipCaps*	pRemoteCapsWithVideo	= new CSipCaps;
					pRemoteCapsWithVideo->Create(*pSdpAndHeaders, m_pParty->GetTargetMode()->GetConfMediaType(), m_bIsMrcCall);
				//	pRemoteCapsWithVideo->Set4CifMpi ((APIS8)-1);

					int oldCapabilitiesLength = m_pRemoteSdp->sipMediaLinesLength;
					int oldLength = sizeof(sipSdpAndHeadersBaseSt) + oldCapabilitiesLength;
					int newCapsLen = pRemoteCapsWithVideo->CalcCapBuffersSize(cmCapReceiveAndTransmit, NO);
					int newLength = oldLength + newCapsLen;
					pSdpAndHeaders = (sipSdpAndHeadersSt *)new BYTE[newLength];
					memset(pSdpAndHeaders, 0, newLength);
					memcpy(pSdpAndHeaders,m_pRemoteSdp,oldLength);
							pSdpAndHeaders->sipMediaLinesLength = oldCapabilitiesLength;
					pSdpAndHeaders->lenOfDynamicSection = oldCapabilitiesLength;

					int exactCapsSize = pRemoteCapsWithVideo->AddCapsToCapStruct(cmCapReceiveAndTransmit,
																					NO,(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																					newLength, GetBfcpType());

					pSdpAndHeaders->sipMediaLinesLength = exactCapsSize;
					pSdpAndHeaders->lenOfDynamicSection = exactCapsSize;

					TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendRecv,kSendRecv,kSendRecv,kSendRecv,TRUE)";
					SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendRecv,kSendRecv,kSendRecv,kSendRecv,TRUE);

					mcXmlTransportAddress &videoIp = ExtractMLineMediaIp(kMediaLineInternalTypeVideo, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());
					videoIp.transAddr.port = m_savedVideoPort;
					videoIp.transAddr.addr.v4.ip =  m_savedVideoIp;

					POBJDELETE(pRemoteCapsWithVideo);
					bDelSdpHeader = TRUE;
				}
				else if(NewMocState==MocStateVtoA)
				{
					// take the previous sdp:
					CloneSdpAndHeaders(m_pRemoteSdp, pSdpAndHeaders, bDelSdpHeader);
					ExtractMLineMediaIp(kMediaLineInternalTypeVideo, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
				}
				else if(NewMocState==MocStatePauseMyVideo)
				{
					CloneSdpAndHeaders(m_pRemoteSdp, pSdpAndHeaders, bDelSdpHeader);

					TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendOnly,kSendRecv,kSendRecv,kSendRecv)";
					SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendOnly,kSendRecv,kSendRecv,kSendRecv);

					ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = m_savedAudioPort;
				}
				else if(NewMocState==MocStateResumeMyVideo)
				{
					CloneSdpAndHeaders(m_pRemoteSdp, pSdpAndHeaders, bDelSdpHeader);

					TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendRecv,kSendRecv,kSendRecv,kSendRecv)";
					SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendRecv,kSendRecv,kSendRecv,kSendRecv);

					ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = m_savedAudioPort;
				}
			}

			if (m_remoteIdent == IbmSametimeEp_Legacy)  // BRIDGE-11137 patch for Sametime-Softphone 8.5.2 Legacy
			{
				sipMediaLinesEntrySt* pMediaLinesEntry 	= (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders;
				BOOL bIsVideoExistsOnRemoteSdp 			= IsMediaContainedInDirtySdp(pMediaLinesEntry, kMediaLineInternalTypeVideo);
				BOOL bIsCurrentMediaOnHold 	   			= m_pParty && (m_pParty->GetNonTipPartyOnHold() & eMediaOnHoldAplusV);
				BOOL bIsVideoChannelMuted 	   			= m_pCall && (m_pCall->IsChannelMuted(cmCapVideo, cmCapTransmit));

				TRACEINTO << "Handle legacy Sametime-Softphone-8.5.2 ReInvite."
						  << " bIsVideoExistsOnRemoteSdp " << (int)bIsVideoExistsOnRemoteSdp
						  << " bIsCurrentMediaOnHold " << (int)bIsCurrentMediaOnHold
				  	  	  << " bIsVideoChannelMuted " << (int)bIsVideoChannelMuted;

				m_IsST852Resume = FALSE;

				if (bIsCurrentMediaOnHold && bIsVideoChannelMuted && !bIsVideoExistsOnRemoteSdp  && GetIsEnableICE())
				{
					TRACEINTO << "This is first resume reInvite with missing m-video line - Ignore it.";
					m_IsST852Resume = TRUE;
				}
			}

			pRemoteCaps->Create(*pSdpAndHeaders, m_pParty->GetTargetMode()->GetConfMediaType(), m_bIsMrcCall);

//			if (GetCascadeMode()== CASCADE_MODE_SLAVE)
//			{
//				CSuperLargeString sBeforeReplace;
//				pRemoteCaps->DumpToString(sBeforeReplace);
//				TRACEINTO << "---cascade_slave_audio--- Send and Recv streams before: " << sBeforeReplace.GetString();
//
//				pRemoteCaps->ReplaceSendRecvStreams();
//
//				CSuperLargeString sAfterReplace;
//				pRemoteCaps->DumpToString(sAfterReplace);
//				TRACEINTO << "---cascade_slave_audio--- Send and Recv streams were replaced. " <<  sAfterReplace.GetString();
//			}

			//ANAT for debug
			CSuperLargeString msgRC;
			pRemoteCaps->DumpToString(msgRC);
			PTRACE2(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected, remote caps reinvite1 for anat: ", msgRC.GetString());

			BYTE isRmxInitiateTransaction = TRUE;
			BYTE bFixVideoRate = CheckIsMobilePhoneByHeader(isRmxInitiateTransaction);

			sipMessageHeaders* pHeaders = NULL;
			if (pSdpAndHeaders->sipHeadersLength)
				pHeaders = (sipMessageHeaders*)((char*)pSdpAndHeaders->capsAndHeaders + pSdpAndHeaders->sipHeadersOffset);
			pRemoteCaps->FixRemoteCapsBySystemSettings(pHeaders, bFixVideoRate);
			//pRemoteCaps->CompleteDataFromOtherCap(*m_pChosenLocalCap );
			CompleteDataFromOtherCapUsingUserAgent(pRemoteCaps);
			pRemoteCaps->CheckAndRemoveCapSetsWithInvalidPayloadType(bRemovedAudio, bRemovedVideo);

			DecideAnatSelectedIpVersion(pSdpAndHeaders); //Added for ANAT

			AnalyzeDifferencesInSdp(pSdpAndHeaders, pRemoteCaps, pDifArr);

			CSipChanDif* pChanDif = pDifArr->GetChanDif(cmCapVideo, cmCapTransmit);
			if(pChanDif)
			{
				if ((m_remoteIdent == MicrosoftEP_R1 || m_remoteIdent == MicrosoftEP_R2 || m_remoteIdent == MicrosoftEP_Lync_R1 || m_remoteIdent == MicrosoftEP_MAC || m_remoteIdent == MicrosoftEP_MAC_Lync || IsSameTimeEP())
						&& (pChanDif->IsAddChannel() || pChanDif->IsUnMute() || pChanDif->IsChangeIp() || pChanDif->IsChangePort() || pChanDif->IsChangeRtcpPort()))
				{
					PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected - Set send Intra at end of transaction");
					m_pParty->SetSendIntraOnEndOfTransaction(TRUE);
				}
			}

			SavePreviousRemoteCaps();

			POBJDELETE(m_pLastRemoteCaps);

			m_pLastRemoteCaps = pRemoteCaps;

			if (GetIsTipCall() && !CheckIfCallIsResumed(pDifArr))
				AddTipNegotiationCapsToRemoteCaps();

			if( GetIsTipCall() && CheckIfCallIIsPutOnHold(pDifArr) )
			{
				m_pParty->SetTipPartyOnHold(TRUE);
				PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected - tip is set on hold");
			}
			else if( GetIsTipCall() && CheckIfCallIsResumed(pDifArr) )
			{
				m_pParty->SetTipPartyOnHold(FALSE);
				PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected - resume undo hold");
			}
			//Set the onhold/resume medias
			if(!GetIsTipCall())
			{
				enMediaOnHold mediaOnHold =  CheckIfCallisPutOnHoldByMedia(pDifArr);
				if(mediaOnHold)
				{
					enMediaOnHold eMediaOnHeld = m_pParty->GetNonTipPartyOnHold();
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected - MediaOnHeld: ",(WORD)eMediaOnHeld);
					int iMediaOnHold = mediaOnHold | eMediaOnHeld;
					m_pParty->SetNonTipPartyOnHold((enMediaOnHold) iMediaOnHold);
				}
				enMediaOnHold mediaResume = eMediaOnHoldNon;
				mediaResume = CheckIfCallisResumedByMedia(pDifArr);
				if(mediaResume)
				{
					enMediaOnHold eMediaOnHeld = m_pParty->GetNonTipPartyOnHold();
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected - resume, MediaOnHeld: ",(WORD)eMediaOnHeld);
					int iMediaOnHold = (~mediaResume) & eMediaOnHeld;
					m_pParty->SetNonTipPartyOnHold((enMediaOnHold) iMediaOnHold);
				}

			}

			SetRemoteSdp(*pSdpAndHeaders);
			//CUCM - first invite sent without SDP and the second sent with SDP, so we will store the received protocol to response correctly

			CSipChanDif* pChanDifTx = pDifArr->GetChanDif(cmCapBfcp, cmCapTransmit);
			CSipChanDif* pChanDifRx = pDifArr->GetChanDif(cmCapBfcp, cmCapReceive);

			if (((pChanDifTx && pChanDifTx->IsAddChannel()) 	&&
				 (pChanDifRx && pChanDifRx->IsAddChannel())) 	&&
				 !m_pSipBfcpCtrl)
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected - CreateSipBfcpCtrl");
				CreateSipBfcpCtrl();
			}
			else if (m_pSipBfcpCtrl)
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected - UpdateBfcpParametersByRemoteSdp");
				UpdateBfcpParametersByRemoteSdp(TRUE);
			}
			else
				PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected - m_pSipBfcpCtrl is NULL and remote didn't add BFCP to SDP");
		}
		else
		{// do nothing just send the party the indication a new re-invite arrived (without SDP).
			isReInviteWithSdp = NO;
		}
	}
	else
	{// go to party to reject the transaction.
		isRejectReInvite = YES;
		isReInviteWithSdp = YES;  // in case we reject the invite, we use the remote re-invite with SDP transaction type.
	}

	m_pParty->StopWaitForContentReInvite();
	m_pPartyApi->SipPartyReceivedReInvite(pDifArr, isReInviteWithSdp, isRejectReInvite);// no need to send the removed caps since we answer with the requested mode we intend to support at this new transaction.
	m_state = IP_CONNECTING;
	m_bIsReInviteTransaction = YES;
	m_pCall->SetReInviteInitiator(NO);
	POBJDELETE(pDifArr);
	/*Free the pParam if we create in this function.*/
	POBJDELETE(pSavedParam);

	if(bDelSdpHeader) //BRIDGE-11137
		PDELETEA(pSdpAndHeaders);


}

/////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SetMediaMuteState(cmCapDataType eMediaType, cmCapDirection eDirection, BYTE *muteChanges, ERoleLabel eRole) const
{
	CSipChannel* pChannel = NULL;
	BYTE bIsChanged = NO;
	BYTE bIsMute	= NO;
	pChannel	= GetChannel(eMediaType, eDirection, eRole);
	bIsMute		= IsMediaMuted(eMediaType, eDirection, m_pRemoteSdp, m_pLastRemoteCaps, eRole);
	PTRACE2(eLevelError, "CSipCntl::SetMediaMuteState ", PARTYNAME);
	if(pChannel)
	{
		if(bIsMute && !pChannel->IsMuted())
		{
			PTRACE2(eLevelError, "CSipCntl::SetMediaMuteState channel muting ", PARTYNAME);
			*muteChanges = YES;
			bIsChanged = YES;
		}
		if(!bIsMute && pChannel->IsMuted())
		{
			PTRACE2(eLevelError, "CSipCntl::SetMediaMuteState unmuting channel ", PARTYNAME);
			*muteChanges = NO;
			bIsChanged = YES;
		}
		else
			PTRACE2(eLevelError, "CSipCntl::SetMediaMuteState doing nothing! ", PARTYNAME);
	}
	PTRACE2INT(eLevelError, "CSipCntl::SetMediaMuteState channel bIsChanged ", bIsChanged);
	return bIsChanged;
}

/////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::IsMediaMuted(cmCapDataType eMediaType, cmCapDirection eDirection, const sipSdpAndHeadersSt* pSdpAndHeaders,
								const CSipCaps* pCaps, ERoleLabel eRole) const
{
	// PTRACE(eLevelError, "CSipCntl::IsMediaMuted   ");
	BYTE bIsMuteMedia = FALSE;
		cmCapDirection eOppositeDirection = (eDirection == cmCapTransmit)? cmCapReceive: cmCapTransmit;
	if( GetIsTipCall() && (eRole & kRoleContentOrPresentation)  )
	{
		PTRACE2(eLevelError, "CSipCntl::IsMediaMuted for tip changing presentation to people for reomte sdp! ", PARTYNAME);
		bIsMuteMedia = pCaps->IsMediaMuted(eMediaType, eOppositeDirection, kRolePeople);

	}
	else
	{
		//cmCapDirection eOppositeDirection = (eDirection == cmCapTransmit)? cmCapReceive: cmCapTransmit;
		bIsMuteMedia = pCaps->IsMediaMuted(eMediaType, eOppositeDirection, eRole);
	}

    //on msft w15 - take mute decision base on flag in case of tx video
    if (m_isMs2013Active && (eDirection & cmCapTransmit) && (cmCapVideo ==  eMediaType) && (eRole == kRolePeople))
    {
       PTRACE(eLevelError, "CSipCntl::IsMediaMuted  2013 ");
       if(m_bShouldMsftVideoTxStreamOn == FALSE)
       {
    	   bIsMuteMedia = TRUE;
    	   PTRACE2INT(eLevelError, "CSipCntl::IsMediaMuted channel bIsMuteMedia ", bIsMuteMedia);
       }

    }

	return bIsMuteMedia;


}
/////////////////////////////////////////////////////////////////////////
const char* CSipCntl::GetDtmfForwardSource()
{
	const char* pDtmfHeaderStr = NULL;
	sipMessageHeaders *pHeaders = GetRemoteCallLegHeaders();

	if(pHeaders)
	{
		CSipHeaderList headerList(*pHeaders);
		const CSipHeader* pDtmpHeader = headerList.GetNextPrivateOrProprietyHeader(kProprietyHeader, strlen(DTMF_FORWARDING_SOURCE_HEADER), DTMF_FORWARDING_SOURCE_HEADER);

		if (pDtmpHeader)
			pDtmfHeaderStr = pDtmpHeader->GetHeaderStr();
		if (pDtmfHeaderStr)
		{
			TRACEINTO << "header str - " << pDtmfHeaderStr;
			pDtmfHeaderStr += sizeof(DTMF_FORWARDING_SOURCE_HEADER); 	// (skipping header, semicolon & space)
			if(pDtmfHeaderStr && pDtmfHeaderStr[0])
				TRACEINTO << "DTMF Forward: field value - " << pDtmfHeaderStr;
		}
	}
	return pDtmfHeaderStr;
}

////////////////////////////////////////////////////////////////////////

// pSdpAndHeaders - from the re-invite
// caps - translation of the sdp in the re-invite
// arr  - out parameter, array of chanDif
//-------------------------------------------------------------------------
void CSipCntl::AnalyzeDifferencesInSdp(const sipSdpAndHeadersSt* pSdpAndHeaders,const CSipCaps* pSdpCaps,
									   CSipChanDifArr* pDifArr)
{
	// the order of analyzed function must NOT change since each function relays on the previous one.

	// (1) checks for close channels (ip=0, port=0, or bandwidth=0)
	AnalyzeDifferencesInSdpCloseChannels(pSdpAndHeaders, pSdpCaps, pDifArr);

	// (2) check for new channels (media that is not active - not part of one of the current open channels - but its declared as a valid algorithm in the remote caps)
	AnalyzeDifferencesInSdpNewChannelsIncludingMute(pSdpAndHeaders, pSdpCaps, pDifArr);

	// (3) check for mute state (inactive channels or one direction channels: send only or receive only - mute actions) and update channels (already open channels that there parameters changed).
	AnalyzeDifferencesInSdpUpdateChannelsIncludingMuteState(pSdpAndHeaders, pSdpCaps, pDifArr);

	// (4) check for CM changes (IP+Port)
	AnalyzeDifferencesInSdpCmChanges(pSdpAndHeaders, pDifArr);

	CMedString str;
	pDifArr->DumpToString(str);
	PTRACE2(eLevelInfoNormal, "CSipCntl::AnalyzeDifferencesInSdp:\n", str.GetString());
}

////////////////////////////////////////////////////////////////////////////
void  CSipCntl::AnalyzeDifferencesInSdpCloseChannels(const sipSdpAndHeadersSt* pSdpAndHeaders, const CSipCaps* pSdpCaps,
														CSipChanDifArr* pDifArr)
{// the order of the functions is very important. Do not change it.
	APIU16	partyPort	= 0;
	DWORD 	partyIP  	= 0;

	// (1) checks for close channels (ip=0, port=0, or bandwidth=0)
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for (int i = 0 ; i < CHANNEL_TYPES_COUNT; i++)
	{
		if (GetIsTipCall()
			&& i < MAX_SIP_MEDIA_TYPES
			&& globalMediaArr[i] == kSipMediaChannelContent)
		{
			continue;
		}

			GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);


		//int				index			= GetCardSdpArrayIndex((cmCapDataType)i);
		CSipChanDif* pChanOutDif		= pDifArr->GetChanDif(mediaType,cmCapTransmit,eRole);
		CSipChanDif* pChanInDiff 		= pDifArr->GetChanDif(mediaType,cmCapReceive,eRole);
		BYTE bRemoveOut = NO;
		BYTE bRemoveIn = NO;

		eMediaLineInternalType mlineInternalType;

		mlineInternalType = GetMediaLineInternalType(globalMediaArr[i]);

		//added for ANAT
		int	index = -1;
		if (IsAnatSupported())
		{
			index = GetIndexAccordingToInternalTypeAndIpVersion(mlineInternalType, const_cast<sipSdpAndHeadersSt*>(pSdpAndHeaders), m_AnatSelectedIpVersion);
		}


		mcXmlTransportAddress &mediaIp = ExtractMLineMediaIp(mlineInternalType, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted(), index);
		partyPort = mediaIp.transAddr.port;
		partyIP = mediaIp.transAddr.addr.v4.ip;

		if (0 == partyPort)
		{
			bRemoveOut = YES;
			bRemoveIn = YES;
		}
		else if (0 == partyIP)
		{
			bRemoveOut = YES;
		}
		else if((mediaType == cmCapVideo) && (eRole == kRolePeople))
		{//checking for algorithm rate for video, for audio check the session rate
			CSipChannel* pInVideoChannel  = NULL;
			CSipChannel* pOutVideoChannel = NULL;
			DWORD inRate  = 0;
			DWORD outRate = 0;
			pInVideoChannel = m_pCall->GetChannel(true, cmCapVideo,cmCapReceive);
			pOutVideoChannel = m_pCall->GetChannel(true, cmCapVideo,cmCapTransmit);
			if(pInVideoChannel)
			{
				inRate = pSdpCaps->GetMaxVideoBitRate();
				if(inRate == 0)
					bRemoveIn = YES;
			}
			if(pOutVideoChannel)
			{
				outRate = pSdpCaps->GetMaxVideoBitRate();
				if(outRate == 0)
					bRemoveOut = YES;
			}
		}
		else if(mediaType == cmCapAudio)
		{//media type is audio, check the session rate
			if(( 0 == pSdpAndHeaders->callRate ))
			{
				bRemoveOut = YES;
				bRemoveIn = YES;
			}
		}
		else if(mediaType == cmCapData)
		{//media type is data
			if(( 0 == pSdpAndHeaders->callRate ))
			{
				bRemoveOut = YES;
				bRemoveIn = YES;
			}
		}

		if(bRemoveOut)
		{
			if(pChanOutDif && m_pCall->IsMedia(mediaType,cmCapTransmit,eRole))// only if the media exist it can be removed.
				pChanOutDif->SetRemoveChannel(YES);
		}
		if(bRemoveIn)
		{
			if(pChanInDiff && m_pCall->IsMedia(mediaType,cmCapReceive,eRole))
				pChanInDiff->SetRemoveChannel(YES);
		}
	}
	CSipChannel* pContentTxChannel = m_pCall->GetChannel(true,cmCapVideo, cmCapTransmit, kRolePresentation);
	if( (GetIsTipCall() && m_pParty->GetTipPartyTypeAndPosition() == eTipMasterCenter && pContentTxChannel &&  pContentTxChannel->GetConnectionState() == kConnected))
	{
		CSipChanDif* pChanDifVideo		= NULL;
		pChanDifVideo		            = pDifArr->GetChanDif(cmCapVideo, cmCapTransmit);
		CSipChanDif* pChanDifContentTx	= NULL;
		pChanDifContentTx	        	= pDifArr->GetChanDif(cmCapVideo, cmCapTransmit,kRolePresentation);

		if(GetIsTipCall() && pChanDifVideo && pChanDifVideo->IsRemoveChannel() && pChanDifContentTx)
		{
			pChanDifContentTx->SetRemoveChannel(YES);
			PTRACE(eLevelInfoNormal,"CSipCntl::AnalyzeDifferencesInSdpCloseChannels SetRemoveChannel(YES) for content tx in tip");
		}

	}
}

////////////////////////////////////////////////////////////////////////////
void  CSipCntl::AnalyzeDifferencesInSdpNewChannelsIncludingMute(const sipSdpAndHeadersSt* pSdpAndHeaders,
																const CSipCaps* pSdpCaps, CSipChanDifArr* pDifArr)
{// the order of the functions is very important. Do not change it.
	// check for new channels: if its declared on the remote SDP and exist in the local caps than add it.
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for (int i = 0 ; i < MAX_SIP_MEDIA_TYPES; i++)
	{
		if (GetIsTipCall() && globalMediaArr[i] == kSipMediaChannelContent)
			continue;
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);
		for (int j = 0; j < 2; j++)// 2 = number of direction (receive, transmit).
		{
			CSipChannel* pCurChannel	= NULL;
			CSipChanDif* pChanDif		= NULL;
			pCurChannel		= m_pCall->GetChannel(true, mediaType,globalDirectionArr[j],eRole);
			pChanDif		= pDifArr->GetChanDif(mediaType,globalDirectionArr[j],eRole);
			if (pCurChannel == NULL)
			{// no channel open, if exist in the SDP we may add the new media and direction
				cmCapDirection eOppositeDirection	= (globalDirectionArr[j] == cmCapTransmit)? cmCapReceive: cmCapTransmit;
				if (pSdpCaps->IsMedia(mediaType, eOppositeDirection, eRole))
				{
					if( pChanDif )
						pChanDif->SetAddChannel(YES);

					if (mediaType == cmCapBfcp)
						continue;

					BYTE bIsHoldMedia = IsMediaMuted(mediaType, globalDirectionArr[j], pSdpAndHeaders, pSdpCaps, eRole);
					if (bIsHoldMedia && pChanDif)
					{
						//PTRACE2INT(eLevelInfoNormal,"CSipCntl::AnalyzeDifferencesInSdpNewChannelsIncludingMute", mediaType);
						pChanDif->SetMute(YES);
					}
				}
			}
		}
	}

}


////////////////////////////////////////////////////////////////////////////
void  CSipCntl::AnalyzeDifferencesInSdpUpdateChannelsIncludingMuteState(const sipSdpAndHeadersSt* pSdpAndHeaders,
																const CSipCaps* pSdpCaps, CSipChanDifArr* pDifArr)
{// the order of the functions is very important. Do not change it.
	// the channel is not new nor close
	// check for mute, check for update.
	DWORD partyIP = 0;
	cmCapDataType mediaType;
	ERoleLabel eRole;
	BYTE	bIsSdesEnabled = FALSE;

	//=======================================================================
	// For incoming calls - Checking if new precedence values were received
	//=======================================================================
	BOOL	newQosRetrieved = FALSE;
	BYTE	oldAudioTos = m_pQos -> m_bIpAudio;
	BYTE	oldVideoTos = m_pQos -> m_bIpVideo;

	TRACECOND_AND_RETURN(!m_pCall , "m_pCall is NULL"); // klocwork
	TRACECOND_AND_RETURN(!m_pParty , "m_pParty is NULL"); // klocwork

	if(pSdpAndHeaders && !m_pCall -> IsCallInitiator())
	{
		const sipMessageHeaders* pHeaders = reinterpret_cast<const sipMessageHeaders*>(&pSdpAndHeaders->capsAndHeaders[pSdpAndHeaders->sipHeadersOffset]);
		newQosRetrieved = m_pParty -> ParseIncomingPrecedenceInfo(pHeaders, *m_pQos);
	}
	//=======================================================================

	for (int i = 0 ; i < MAX_SIP_MEDIA_TYPES; i++)
	{
		if (GetIsTipCall() && globalMediaArr[i] == kSipMediaChannelContent)
			continue;
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);

		if (mediaType == cmCapBfcp)
			continue;

		for (int j = 0; j < 2; j++)// 2 = number of direction (receive, transmit).
		{
			CSipChannel* pCurChannel	= NULL;
			CSipChanDif* pChanDif		= NULL;
			pCurChannel		= m_pCall->GetChannel(true, mediaType,globalDirectionArr[j],eRole);
			pChanDif = pDifArr->GetChanDif(mediaType,globalDirectionArr[j],eRole);
			// mute = inactive channel or opposite direction only in the algorithm attributes
			cmCapDirection eOppositeDirection	= (globalDirectionArr[j] == cmCapTransmit)? cmCapReceive: cmCapTransmit;
			if((pCurChannel != NULL) && pChanDif && (pChanDif->GetNumOfChanges() == 0))
			{// there is a channel and no change yet.
				// check if we are able to stay with the same channel that we are already in
				CBaseCap* pCurMode = pCurChannel->GetDataAsCapClass();
				if (pCurMode)
				{
					DWORD details	= 0;
					DWORD videoValuesToCompare = kCapCode|kFormat|kFrameRate|kH264Profile|kH264Level|kH264Additional_FS|kH264Additional_MBPS|kBitRate| kMaxFR | kH264Mode | kPacketizationMode;
					if(CProcessBase::GetProcess()->GetProductType()==eProductTypeSoftMCUMfw)
					{
						videoValuesToCompare &= ~kPacketizationMode;
					}
					DWORD audioValuesToCompare = kCapCode|kFrameRate;
					DWORD dataValuesToCompare = kCapCode;
					DWORD valueToCompare		  = 0;
					int  arrIndex			  = 0;
					if(mediaType == cmCapAudio)
						valueToCompare = audioValuesToCompare;
					else if((mediaType == cmCapVideo) && (eRole == kRolePeople))
						valueToCompare = videoValuesToCompare;
					else if(mediaType == cmCapData)
						valueToCompare = dataValuesToCompare;
					else
						valueToCompare = kCapCode; // always check at least cap code

					BYTE bIsContaining 	 = YES;

				//	if (globalDirectionArr[j] == cmCapReceive)
					//{// does the remote caps contained in the current incoming channel (we only check CapCode, and the remote responsible not to transmit more than the local declaration).
						bIsContaining	= pSdpCaps->IsContainedInCapSet(*pCurMode, kCapCode, &details, &arrIndex);

					//}
					//else if(globalDirectionArr[j] == cmCapTransmit)
					//{
						bIsContaining	= pSdpCaps->IsContainingCapSet(eOppositeDirection, *pCurMode, valueToCompare, &details, &arrIndex);
					//}
						//BYTE bIsContainingforHighIsContainedInCapSet = pSdpCaps->IsContainedInCapSet(eOppositeDirection, *pCurMode, valueToCompare, &details, &arrIndex);
					BYTE bIsContainingforHighIsContainedInCapSet = pSdpCaps->IsContainedInCapSet(*pCurMode, valueToCompare, &details, &arrIndex);
					// change RTP mode
					if (bIsContaining == NO || bIsContainingforHighIsContainedInCapSet == NO )
						pChanDif->SetChangeAlg(YES); // right now we mark all change mode as change alg

					if(m_pChosenLocalCap ->GetIsLpr() && m_pParty->GetTargetMode()->GetIsLpr() && mediaType == cmCapVideo && eRole == kRolePeople)
					{// current SDP (from re-invite Ind) plus current channel mode
						PTRACE2INT(eLevelInfoNormal,"CSipCntl::AnalyzeDifferencesInSdpUpdateChannelsIncludingMuteState -MEDIA IS ,",(WORD)(mediaType));
						if((!(pCurChannel->GetIsSupportLpr()) && ((CSipCaps*)pSdpCaps)->GetIsLpr()) || (pCurChannel->GetIsSupportLpr() && !(((CSipCaps*)pSdpCaps)->GetIsLpr())))	// No LPR support in curr chann and lpr support in remote SDP
						{
							pChanDif->SetChangeLpr(YES);
						}
					}

					// change mute state:
					BYTE bIsHoldMedia = IsMediaMuted(mediaType, globalDirectionArr[j], pSdpAndHeaders, pSdpCaps, eRole);
					if (bIsHoldMedia)
					{
						if (pCurChannel->IsMuted() == NO)
							pChanDif->SetMute(YES);
					}
					else
					{//unmute
						if (pCurChannel->IsMuted())
							pChanDif->SetUnMute(YES);
					}

					//====================================================================
					// Checking if channel needs to be reopened with new QoS parameters:
					// Only for incoming calls, and only if actual tos values changed
					//====================================================================
					if (newQosRetrieved && globalDirectionArr[j] != cmCapReceive &&
						((mediaType == cmCapVideo && m_pQos -> m_bIpVideo != oldVideoTos) ||
						(mediaType == cmCapAudio && m_pQos -> m_bIpAudio != oldAudioTos)))
					{
						pChanDif->SetChangeQoS(YES);
					}
					//====================================================================

					//change payload type
					if(globalDirectionArr[j] == cmCapTransmit)
					{// we need to set the payload type only for transmitted channels.
						// in case the algorithm has changed, we defenetly need to change the payload type
						// but that us during the change mode process, if the Alg is the same (or just internal parameters)
						// we need to check if the payload has changed.
						int arrInd						= 0;
						CCapSetInfo	capInfo				= pCurChannel->GetAlgorithm();
						APIU8		uiPayloadType		= pCurChannel->GetPayloadType();
						BYTE  		bIsContainPayload	= pSdpCaps->IsContainingPayloadType(capInfo, uiPayloadType, &arrInd, pCurChannel->GetRoleLabel());
						if (bIsContainPayload == NO)
						{
							pChanDif->SetChangePayload(YES);
						}
					}
					if (globalDirectionArr[j] == cmCapReceive) {
						CSdesCap* pCurSdesMode = pCurChannel->GetChannelSdes();

						BYTE bIsSdesEqual = pSdpCaps->IsSdesEquals(pCurSdesMode,mediaType, globalDirectionArr[j],eRole);
						if(bIsSdesEqual == NO) {
							pChanDif->SetChangeSdes(YES);
							PTRACE(eLevelInfoNormal,"CSipCntl::AnalyzeDifferencesInSdpUpdateChannelsIncludingMuteState SetChangeSdes(YES)");
						} else {
							//pChanDif->SetChangeSdes(NO);
							//PTRACE(eLevelInfoNormal,"CSipCntl::UpdateChannels SetChangeSdes(NO)");
						}
					}
				}
				POBJDELETE(pCurMode);
			}
			//else continue to next channel.
		}
	}




	CSipChannel* pContentRxChannel = m_pCall->GetChannel(true,cmCapVideo, cmCapReceive, kRolePresentation);
	CSipChannel* pContenTxChannel = m_pCall->GetChannel(true,cmCapVideo, cmCapTransmit, kRolePresentation);
	if (GetIsTipCall() && m_pParty->GetTipPartyTypeAndPosition() == eTipMasterCenter && pContentRxChannel &&  pContentRxChannel->GetConnectionState() == kConnected)
	{
		//CSipChannel* pVideotRxChannel = m_pCall->GetChannel(cmCapVideo, cmCapReceive, kRolePresentation);
		CSipChanDif* pChanDifVideo		= NULL;
		CSipChanDif*   pChanDifVideoOut = NULL;
		pChanDifVideo		            = pDifArr->GetChanDif(cmCapVideo, cmCapReceive);
		pChanDifVideoOut		            = pDifArr->GetChanDif(cmCapVideo, cmCapTransmit);
		CSipChanDif* pChanDifContentRec = NULL;
		pChanDifContentRec		        = pDifArr->GetChanDif(cmCapVideo, cmCapReceive,kRolePresentation);
		CSipChanDif* pChanDifContentTx	= NULL;
		pChanDifContentTx	        	= pDifArr->GetChanDif(cmCapVideo, cmCapTransmit,kRolePresentation);


		if(pChanDifVideo && pChanDifVideo->IsChangeSdes() && pChanDifContentRec)
		{
			pChanDifContentRec->SetChangeSdes(YES);
			PTRACE(eLevelInfoNormal,"CSipCntl::AnalyzeDifferencesInSdpUpdateChannelsIncludingMuteState SetChangeSdes(YES) for content rx in tip");
		}

		//BRIDGE-769
		if(pChanDifVideoOut && pChanDifVideoOut->IsMute() && pChanDifContentTx && pContenTxChannel && pContenTxChannel->GetConnectionState() == kConnected)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::AnalyzeDifferencesInSdpUpdateChannelsIncludingMuteState SetMute(YES) for content tx in tip");
			pChanDifContentTx->SetMute(YES);
		}
		if(pChanDifVideo && pChanDifVideo->IsMute() && pChanDifContentRec && pContentRxChannel->GetConnectionState() == kConnected)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::AnalyzeDifferencesInSdpUpdateChannelsIncludingMuteState SetMute(YES) for content Rx in tip");
			pChanDifContentRec->SetMute(YES);
		}
	}

}

////////////////////////////////////////////////////////////////////////////
void  CSipCntl::AnalyzeDifferencesInSdpCmChanges(const sipSdpAndHeadersSt* pSdpAndHeaders, CSipChanDifArr* pDifArr)
{// the order of the functions is very important. Do not change it.
	// IpV6
	mcTransportAddress	partyIP, originalIP;
	memset(&partyIP,0,sizeof(mcTransportAddress));
	memset(&originalIP,0,sizeof(mcTransportAddress));
	APIU16	partyPort	= 0, originalPort	= 0;
	APIU32	partyRtcpPort = 0, originalRtcpPort = 0;
	BYTE	bIsMedia	= NO;
	cmCapDataType mediaType;
	ERoleLabel eRole;
	// (1) checks for change ip change port and zero ip (mute out)
	for (int i = 0 ; i < CHANNEL_TYPES_COUNT; i++)
	{
		if (GetIsTipCall()
			&& i < MAX_SIP_MEDIA_TYPES
			&& globalMediaArr[i] == kSipMediaChannelContent)
			continue;
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);
		//int				index			= GetCardSdpArrayIndex(mediaType);
		CSipChanDif* pChanOutDif		= pDifArr->GetChanDif(mediaType,cmCapTransmit,eRole);

		if (pChanOutDif && (pChanOutDif->IsRemoveChannel()== NO))
		{// if its remove channel we don't need to check the changes in the IP address
			// IpV6
			eMediaLineInternalType mlineInternalType;

			mlineInternalType = GetMediaLineInternalType(globalMediaArr[i]);

			//added for ANAT begin
			//firstly check if ip version change, MARS currently does not support this type of change.
			/*if (IsAnatSupported() && m_LastAnatSelectedIpVersion != enIpVersionMAX && m_AnatSelectedIpVersion != m_LastAnatSelectedIpVersion)
			{
				pChanOutDif->SetChangeIp(YES);
				pChanOutDif->SetChangePort(YES);
				pChanOutDif->SetChangeRtcpPort(YES);
				continue;
			}*/

			int	index = -1;
			if (IsAnatSupported())
			{
				index = GetIndexAccordingToInternalTypeAndIpVersion(mlineInternalType, const_cast<sipSdpAndHeadersSt*>(pSdpAndHeaders), m_AnatSelectedIpVersion);
				if (index == -1)
					continue;
			}
			//added for ANAT end

			mcXmlTransportAddress &mediaIp = ExtractMLineMediaIp(mlineInternalType, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted(), index);

			if (mediaIp.transAddr.ipVersion == eIpVersion4) //v4
				partyIP.addr.v4.ip = mediaIp.transAddr.addr.v4.ip;
			else
			{
				partyIP.ipVersion = eIpVersion6;
				memcpy(partyIP.addr.v6.ip, mediaIp.transAddr.addr.v6.ip, 16);
				partyIP.addr.v6.scopeId = mediaIp.transAddr.addr.v6.scopeId;
			}

//			memcpy(partyIP,pSdpAndHeaders->mediaIps[index].transAddr,sizeof(mcTransportAddress));
			GetRemoteMediaIpAsTrAddr(mediaType,eRole,originalIP);

			bIsMedia = IsMedia(mediaType,cmCapTransmit,eRole);
			partyPort	= mediaIp.transAddr.port;
			originalPort	= GetRemoteMediaPort(mediaType,eRole);

			unsigned int dummyRtcpPort;

			if(mediaType != cmCapBfcp)
			{
				partyRtcpPort = ExtractMLineRtcpPort(mlineInternalType, pSdpAndHeaders, dummyRtcpPort, m_pParty->GetTargetMode()->GetIsEncrypted(), index);  //added "index" for ANAT

				originalRtcpPort = GetRemoteMediaRtcpPort(mediaType, eRole);
			}
			else{
				partyRtcpPort = originalRtcpPort = 0;
			}

			// party is not set to "hold" (zero IP)
			BOOL isBFCPoverUDP = FALSE;
			if (mlineInternalType == kMediaLineInternalTypeBfcp)
			{
				sipMediaLineSt *pMediaLine = NULL;
				pMediaLine = GetMLineAccordingToInternalTypeAndIpVersion(mlineInternalType, const_cast<sipSdpAndHeadersSt*>(pSdpAndHeaders), (enIpVersion)partyIP.ipVersion);

				if (pMediaLine && pMediaLine->subType == eMediaLineSubTypeUdpBfcp)
				{
					isBFCPoverUDP = TRUE;
				}
			}

			if (bIsMedia && ::isApiTaNull(const_cast<mcTransportAddress*>(&partyIP)) == FALSE &&
				((::isApiTaNull(const_cast<mcTransportAddress*>(&originalIP)) == FALSE && isIpAddressEqual(&originalIP,&partyIP) == FALSE)  ||
				(partyPort	&& originalPort && originalPort != partyPort) ||
				(partyRtcpPort && originalRtcpPort && originalRtcpPort != partyRtcpPort)))
			{
				if (isIpAddressEqual(&originalIP,&partyIP) == FALSE)
					pChanOutDif->SetChangeIp(YES);

				if (originalPort != partyPort)
				{
				    if((mlineInternalType != kMediaLineInternalTypeBfcp) || isBFCPoverUDP)
				        pChanOutDif->SetChangePort(YES);
				    else
				        TRACEINTO<<"CSipCntl::AnalyzeDifferencesInSdpCmChanges skip port change for bfcp tcp, original port="<<
				                   originalPort<<" partyPort="<<partyPort;
				}
				if (originalRtcpPort != partyRtcpPort)
					pChanOutDif->SetChangeRtcpPort(YES);
			}
		}
	}
}


//=========================================================================================================
// PropagatePacketLostStatus
// ===========================
//
// Propagates the packet loss state from the card manager to the conference, after adjusting to LPR
// state.  This is done as follows:
// 1) If LPR is active inbound and/or outbound packet loss states are first promoted to be at least Major
// 2) Current cell state is defined to be the inbound state
// 3) Current layout state is defined to be the worse (max) between the inbound and outbound states.
// 4) If current states differ from last states, the conference is updated (via the party)
// 5) Last states are updated to current
//=========================================================================================================
void CSipCntl::PropagatePacketLostStatus(const eRtcpPacketLossStatus InLoss, const eRtcpPacketLossStatus OutLoss, const BYTE InLpr, const BYTE OutLpr)
{
	DBGPASSERT_AND_RETURN(m_pParty == NULL);
	BYTE shouldSendStatus = FALSE;

	CMedString entryLog;
	entryLog 	<< "CSipCntl::PropagatePacketLostStatus - " << m_pParty -> GetFullName()
				<< " InLoss:" << InLoss << " OutLoss:" << OutLoss << " InLpr:" << InLpr << " OutLpr:" << OutLpr;
	PTRACE(eLevelInfoNormal,entryLog.GetString());

	//=============================================
	// Adjusting quality indications to LPR state
	//=============================================
	eRtcpPacketLossStatus	adjInLoss 			= (InLpr? 	max(InLoss,	ePacketLossMajor) 	: 	InLoss);
	eRtcpPacketLossStatus	adjOutLoss 			= (OutLpr? 	max(OutLoss,ePacketLossMajor) 	: 	OutLoss);
	eRtcpPacketLossStatus	layoutInd 			= max(adjInLoss, adjOutLoss);

	//===============================================================================
	// Deciding whether a new quality indication should be propagated to conference
	// Based on whether cell state OR layout state has changed.
	//===============================================================================
	if (adjInLoss != m_adjInboundPacketLossStatus ||
		layoutInd != max(m_adjInboundPacketLossStatus, m_adjOutboundPacketLossStatus))
	{
		shouldSendStatus = true;
	}

	//===================================
	// Updating quality related members
	//===================================
	m_cmInboundPacketLossStatus		= InLoss;
	m_cmOutboundPacketLossStatus	= OutLoss;
	m_adjInboundPacketLossStatus	= adjInLoss;
	m_adjOutboundPacketLossStatus	= adjOutLoss;

	//===============================================================================================================
	// Sending quality indication (Only for MPMx,MpmRx, for other boards the indications are calculated only for the log)
	//===============================================================================================================
	if (shouldSendStatus)
	{
		CSmallString sendLog;
		if (IsFeatureSupportedBySystem(eFeatureIndicationOnLayout_PacketLost))
		{
			m_pParty -> InformConfOnPacketLossState(adjInLoss, layoutInd);
			sendLog	<< "CSipCntl::PropagatePacketLostStatus - sent CellInd:" << adjInLoss << " LayoutInd:" << layoutInd;
		}
		else
		{
			sendLog	<< "CSipCntl::PropagatePacketLostStatus - Not MPMx, only logging CellInd:" << adjInLoss << " LayoutInd:" << layoutInd;
		}
		PTRACE(eLevelInfoNormal,sendLog.GetString());
	}
}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipPacketLostStatusConnected(CSegment* pParam)
{
	DBGPASSERT_AND_RETURN(m_pParty == NULL);
	CSmallString entryLog;
	entryLog << "CSipCntl::OnSipPacketLostStatusConnected - " << m_pParty -> GetFullName();
	PTRACE(eLevelInfoNormal,entryLog.GetString());

	//========================================
	// Preparing loss status for propagation
	//========================================
	RTCP_PACKET_LOSS_STATUS_IND_S packetLossStatus;
	eRtcpPacketLossStatus 	InLoss 			= m_cmInboundPacketLossStatus;
	eRtcpPacketLossStatus 	OutLoss			= m_cmOutboundPacketLossStatus;
	BYTE 					CommandValid	= TRUE;
	memset(&packetLossStatus, 0, sizeof(packetLossStatus));
	pParam -> Get((BYTE*)&packetLossStatus, sizeof(packetLossStatus));

	if (packetLossStatus.mediaDirection == cmCapReceive)
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnSipPacketLostStatusConnected - got new inbound:", packetLossStatus.ePacketLossStatus);
		InLoss = packetLossStatus.ePacketLossStatus;
	}
	else if (packetLossStatus.mediaDirection == cmCapTransmit)
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnSipPacketLostStatusConnected - got new outbound:", packetLossStatus.ePacketLossStatus);
		OutLoss = packetLossStatus.ePacketLossStatus;
	}
	else
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnSipPacketLostStatusConnected - Handling Transmit OR Receive directions only, received direction: ", packetLossStatus.mediaDirection);
		CommandValid = FALSE;
	}

	//====================================
	// Conditionally propagating to conf
	//====================================
	if (CommandValid)
	{
		DWORD newFecRedPercent= packetLossStatus.fractionLossInPercent;
		DWORD mediaType = packetLossStatus.eMediaType;  //  kIpAudioChnlType=1=cmCapAudio, kIpVideoChnlType=2=cmCapVideo
		DWORD remoteSsrc = packetLossStatus.unSSRC;

		//Ms FEC
		if (packetLossStatus.mediaDirection == cmCapTransmit && OutLoss == ePacketLossFecInd)
		{

			TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId() << " - Handling FEC/RED packet loss ind: newFecRedPercent:" << newFecRedPercent
					  << ", mediaType:" << mediaType << ", remoteSsrc:" << remoteSsrc << ", m_bIsCMStartFec:" << (DWORD)GetIsFecStarted() << ", m_bIsCMStartRed:" << (DWORD)GetIsRedStarted();

			/*if (m_isMs2013Active == eMsft2013AvMCU && mediaType == cmCapVideo && GetIsFecStarted() == TRUE )
			{
				CSegment*  seg = new CSegment;
				*seg << mediaType << remoteSsrc << newFecRedPercent;
				m_pPartyApi->UpdateRateWithFECorRED(seg);
			}*/
			//without AVMCU or RED case:
			//else
			if (mediaType == cmCapVideo && GetIsFecStarted() == TRUE)
				HandleFecPacketLossInd(newFecRedPercent, mediaType, 0);
			else if (mediaType == cmCapAudio && GetIsRedStarted() == TRUE)
				HandleRedPacketLossInd(newFecRedPercent, mediaType, 0);
			else TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId() << " - ERROR - not handled - check m_bIsCMStartFec and m_bIsCMStartRed values";

			return;
		}
		else if (packetLossStatus.mediaDirection == cmCapReceive && InLoss == ePacketLossFecInd && mediaType == cmCapVideo)
		{
			DWORD localSsrc = m_pChosenLocalCap->getMsftSsrcVideoFirst(1);

			if ( m_isMs2013Active == eMsft2013AvMCU )
				for (int i=0; i < MAX_STREAM_MUX_LYNC_CONN; ++i)
					if (remoteSsrc == m_pLastRemoteCaps->getMsftSsrcVideoFirst(i+1))
						localSsrc = m_pChosenLocalCap->getMsftSsrcVideoFirst(i+1);

			TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId() << " - mediaDirection is Rec with packetLoss of:"
					  << newFecRedPercent << ", remoteSsrc:" << remoteSsrc << ", localSsrc:" << localSsrc;

			if ( m_pVsrControl != NULL )
				m_pVsrControl->PacketlossOnRecDirectionNeedToSendVsr(localSsrc,newFecRedPercent);
		}

		// Full implementation including LPR should be:
		// PropagatePacketLostStatus(InLoss, OutLoss, m_inboundLprActive, m_outboundLprActive);
		//
		// However due to SRS requirements LPR is omitted
		PTRACE(eLevelInfoNormal, "CH323Cntl::OnSipPacketLostStatusConnected - propagating packet loss indication, ignoring LPR state in video indication on layout due to SRS requirements");
		PropagatePacketLostStatus(InLoss, OutLoss, FALSE, FALSE);
	}
}
////////////////////////////////////////////////////////////////////////////
void  CSipCntl::HandleFecPacketLossInd(DWORD newFecPercent,DWORD mediaType,DWORD ssrc)
{
	if (m_isMs2013Active)
	{
		TRACEINTO << "LYNC2013_FEC_RED: Ms2013 is active - don't handle PacketLossInd regarding fec, PartyID:" << m_pParty->GetPartyId();
		return;
	}

	if (GetIsActiveFecFlow())
	{
		TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId()
				  << " - There is active flow of FEC, we will handle the latest msg later. newFecPercent:" << newFecPercent << ", ssrc:" << ssrc;
		m_savedFecPacketLossStatus.isNeedToHandleNewData = TRUE;
		m_savedFecPacketLossStatus.mediaType = mediaType;
		m_savedFecPacketLossStatus.fractionLossInPercent = newFecPercent;
		m_savedFecPacketLossStatus.ssrc = ssrc;
		return;
	}

	CSegment*  seg = new CSegment;
	*seg << mediaType << ssrc << newFecPercent;

	if( (newFecPercent>0 && m_FecFractionLossInPercent==0) ||
		(newFecPercent>=9 && m_FecFractionLossInPercent<9) ||
		(newFecPercent>=4 && newFecPercent<=8 && m_FecFractionLossInPercent<4 && m_FecFractionLossInPercent>8) ||
		(newFecPercent>=1 && newFecPercent<=3 && m_FecFractionLossInPercent>3) )
	{
		TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId() << " - Set FEC ON - ssrc:" << ssrc << ", newFecPercent:" << newFecPercent << ", mediaType:" << mediaType;
		m_FecFractionLossInPercent = newFecPercent;
		SetIsFecOn(TRUE); 
		SetIsActiveFecFlow(TRUE);
		m_pPartyApi->UpdateRateWithFECorRED(seg);
	}
	else if(newFecPercent==0 &&  GetIsFecOn()==TRUE && m_FecFractionLossInPercent)
	{
		TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId() << " - Set FEC OFF - ssrc:" << ssrc << ", newFecPercent:" << newFecPercent << ", mediaType:" << mediaType;
		m_FecFractionLossInPercent = 0;
		SetIsFecOn(FALSE); 
		SetIsActiveFecFlow(TRUE);
		m_pPartyApi->UpdateRateWithFECorRED(seg);
	}
	else
		TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId() << " - no changes are needed- newFecPercent:" << newFecPercent
				  << ", m_bIsFecOn:" << (DWORD)GetIsFecOn() << ", m_FecFractionLossInPercent:" << m_FecFractionLossInPercent;

}
////////////////////////////////////////////////////////////////////////////
//LYNC2013_FEC_RED:
void  CSipCntl::HandleRedPacketLossInd(DWORD newRedPercent,DWORD mediaType,DWORD ssrc)
{
	if (GetIsActiveRedFlow())
	{
		TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId()
				  << " - There is active flow of RED, we will handle the latest msg later. newRedPercent:" << newRedPercent << ", ssrc:" << ssrc;
		m_savedRedPacketLossStatus.isNeedToHandleNewData = TRUE;
		m_savedRedPacketLossStatus.mediaType = mediaType;
		m_savedRedPacketLossStatus.fractionLossInPercent = newRedPercent;
		m_savedRedPacketLossStatus.ssrc = ssrc;
		return;
	}
	if(m_isMs2013Active == eMsft2013None)
	{
		TRACEINTO << "red is only for 2013 client/avmuu- returning";
		return;
	}

	CSegment*  seg = new CSegment;
	*seg << mediaType << ssrc << newRedPercent;;

	if(newRedPercent > 2)
	{
		if( m_RedFractionLossInPercent == 0 )  
		{
			m_RedFractionLossInPercent = newRedPercent;
			SetIsRedOn(TRUE); 
			SetIsActiveRedFlow(TRUE);

			if ( m_pCall->IsMedia(cmCapVideo,cmCapTransmit) && m_isMs2013Active!=eMsft2013AvMCU )
			{
				TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId()
						  << " - Set RED ON - ssrc:" << ssrc << ", newRedPercent:" << newRedPercent << ", mediaType:" << mediaType;
				m_pPartyApi->UpdateRateWithFECorRED(seg);
			}
			else//audio only or m_isMs2013Active==eMsft2013AvMCU
			{
				TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId()
						  << " - Set RED ON for AUDIO ONLY - ssrc:" << ssrc << ", newRedPercent:" << newRedPercent << ", mediaType:" << mediaType;
				SendFecOrRedReqToART(mediaType,statOK);
			}
		}
		else //m_RedFractionLossInPercent != 0
		{
			TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId()
					  << " - RED is already ON - ssrc:" << ssrc << ", newRedPercent:" << newRedPercent << ", mediaType:" << mediaType;
			m_RedFractionLossInPercent = newRedPercent;
			SetIsActiveRedFlow(TRUE);
			SendFecOrRedReqToART(mediaType,statOK);
		}

	}
	else if(newRedPercent==0 && GetIsRedOn()==TRUE && m_RedFractionLossInPercent)
	{
		m_RedFractionLossInPercent = 0;
		SetIsRedOn(FALSE); 
		SetIsActiveRedFlow(TRUE);

		if ( m_pCall->IsMedia(cmCapVideo,cmCapTransmit) )
		{
			TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId()
					  << " - Set RED OFF - ssrc:" << ssrc << ", newRedPercent:" << newRedPercent << ", mediaType:" << mediaType;
			m_pPartyApi->UpdateRateWithFECorRED(seg);
		}
		else  //audio only
		{
			TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId()
					  << " - Set RED OFF for AUDIO ONLY - ssrc:" << ssrc << ", newRedPercent:" << newRedPercent << ", mediaType:" << mediaType;
			SendFecOrRedReqToART(mediaType,statOK);
		}

	}
	else
		TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId()
				  << " - There is no change regarding RED packet loss last msg - newRedPercent:" << newRedPercent
				  << ", m_bIsRedOn:" << (DWORD)GetIsRedOn() << ", m_RedFractionLossInPercent:" << m_RedFractionLossInPercent;

}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipPacketLostStatusImproperState(CSegment* pParam)
{
	DBGPASSERT_AND_RETURN(m_pParty == NULL);
	CSmallString entryLog;
	entryLog << "CSipCntl::OnSipPacketLostStatusImproperState - " << m_pParty -> GetFullName() << " - does nothing for state " << m_state;
	PTRACE(eLevelInfoNormal,entryLog.GetString());
}

////////////////////////////////////////////////////////////////////////////
void  CSipCntl::OnSipCsVideoUpdatePicInd(CSegment* pParam)
{
	char videoLabel[MAX_LABEL_LENGTH + 1];
	char * pRemoteStreamLabel = GetRemoteStreamLabel(kRolePeople);

	memset(videoLabel,0,MAX_LABEL_LENGTH + 1);
	pParam->Get((BYTE*)(videoLabel),MAX_LABEL_LENGTH);
	videoLabel[MAX_LABEL_LENGTH] = '\0';

	ERoleLabel eRole = kRolePeople;

	PTRACE2(eLevelInfoNormal,"CSipCntl::OnSipCsVideoUpdatePicInd received label=",videoLabel);

	// AN - TB ask intra for local label, so need also to check if label is the remote label
	if ((strncmp(videoLabel, "", MAX_LABEL_LENGTH) == 0) 								||
		(strncmp(videoLabel, GetLocalStreamLabel(kRolePeople), MAX_LABEL_LENGTH) == 0)	||
		((pRemoteStreamLabel != NULL) &&
		(strncmp(videoLabel, pRemoteStreamLabel, MAX_LABEL_LENGTH) == 0)) )
		eRole = kRolePeople;
	else if ((strncmp(videoLabel, GetLocalStreamLabel(kRolePresentation), MAX_LABEL_LENGTH) == 0) ||
				((pRemoteStreamLabel != NULL) && (strncmp(videoLabel, pRemoteStreamLabel, MAX_LABEL_LENGTH) == 0)) )
			eRole = kRolePresentation;
	else
	{
		eRole = kRolePeople; // default
		DBGPASSERT(1);
	}

	CSipChannel* pChannel = m_pCall->GetChannel(true, cmCapVideo, cmCapTransmit, eRole);

	if (pChannel == NULL)
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipCsVideoUpdatePicInd - channel was not found. Role=",eRole);
		DBGPASSERT(1);
		return;
	}

	if (pChannel->GetConnectionState() == kConnected)
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipCsVideoUpdatePicInd Outgoing channel, Ask VB/CB for new intra. eRole=",eRole);
		BYTE bIsGradualIntra = FALSE;
		CSegment*  seg = new CSegment;
		*seg << (WORD)Fast_Update << (WORD)eRole << (WORD)1 << bIsGradualIntra;// Remote report on Intra

		m_pPartyApi->IpRmtH230(seg); // forward task to party manager
		POBJDELETE(seg);
	}
	else
		PTRACE(eLevelInfoNormal,"CSipCntl::OnSipCsVideoUpdatePicInd, Channel is not in connected state.");
}

////////////////////////////////////////////////////////////////////////////
void  CSipCntl::OnSipRtpVideoUpdatePicInd(CSegment* pParam)
{
	if(	m_pCall->GetConnectionState() == kDisconnecting)// no need because of the State Machine
	{	// if the call is in closing process no need to send fast update.
		PTRACE(eLevelInfoNormal,"CSipCntl::OnSipRtpVideoUpdatePicInd bIsClosing process");
		return;
	}

	TRtpVideoUpdatePictureInd rtpVideoUpdateInd;
	DWORD  structLen = sizeof(TRtpVideoUpdatePictureInd);
	memset(&rtpVideoUpdateInd,0,structLen);
	pParam->Get((BYTE*)(&rtpVideoUpdateInd),structLen);

	TRACEINTO << "dbg  unSsrcID: " << rtpVideoUpdateInd.unSsrcID << ", unPrID: " << rtpVideoUpdateInd.unPrID;

	DWORD remoteSsrc = rtpVideoUpdateInd.unSsrcID;
	DWORD prID = rtpVideoUpdateInd.unPrID;

	ETipVideoPosition tipVideoPosition = eTipVideoPosLast;
	if ((kChanneltype)rtpVideoUpdateInd.unChannelType == kIpContentChnlType)
		tipVideoPosition = eTipVideoPosAux5Fps;
	else
	{
		ETipPartyTypeAndPosition tipPartyType = m_pParty->GetTipPartyTypeAndPosition();
		tipVideoPosition = ::GetVideoPosition(tipPartyType);
	}

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipRtpVideoUpdatePicInd - uSeqNumber:",rtpVideoUpdateInd.uSeqNumber);
	m_LossPacketSeqNum = rtpVideoUpdateInd.uSeqNumber;

	BYTE bIsGradualIntra = FALSE;

	if(m_isMs2013Active)
	{
		SendH230FastUpdateToPartyMS2013((kChanneltype)rtpVideoUpdateInd.unChannelType, (cmCapDirection)rtpVideoUpdateInd.unChannelDirection, bIsGradualIntra, tipVideoPosition, remoteSsrc, prID);
	} else
	{
		SendH230FastUpdateToParty((kChanneltype)rtpVideoUpdateInd.unChannelType, (cmCapDirection)rtpVideoUpdateInd.unChannelDirection, bIsGradualIntra, tipVideoPosition);
	}

}

/////////////////////////////////////////////////////////////////////////////
void  CSipCntl::SendH230FastUpdateToParty(kChanneltype channelType, cmCapDirection channelDirection, BYTE bIsGradualIntra, ETipVideoPosition tipPosition)
{
	ERoleLabel eRole;
	cmCapDataType mediaType;
	mediaType = ::ChannelTypeToDataType(channelType, eRole);
	CSipChannel* pChannel = m_pCall->GetChannel(true, mediaType, channelDirection, eRole);

	if(pChannel == NULL)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SendH230FastUpdateToParty - channel was not found");
		DBGPASSERT(1);
		return;
	}

	WORD rtpReport = 2;
	if (pChannel->GetMediaType() == cmCapVideo)
	{
		if(pChannel->GetConnectionState() == kConnected)
		{
			if(channelDirection == cmCapTransmit)
				rtpReport = 2;// Outgoing channel - Ask VB
			else
				rtpReport = 3;// Outgoing channel - Ask CS, who send it to EP.

			PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendH230FastUpdateToParty Outgoing channel, rtpReport is - ", rtpReport);
			CSegment*  seg = new CSegment;

			*seg << (WORD)Fast_Update << (WORD)eRole << rtpReport << bIsGradualIntra;// RTP report on Intra

			if (GetIsTipCall() && (tipPosition == eTipVideoPosLeft || tipPosition == eTipVideoPosRight))
				m_pPartyApi->ForwardIpRmtH230(seg, tipPosition);
			else
				m_pPartyApi->IpRmtH230(seg); // forward task to party manager
			POBJDELETE(seg);
		}
		else
			PTRACE(eLevelInfoNormal,"CSipCntl::SendH230FastUpdateToParty, Channel is not in connected state");
	}
	else
		PTRACE(eLevelInfoNormal,"CSipCntl::SendH230FastUpdateToParty: Channel is not video");
}

void  CSipCntl::SendH230FastUpdateToPartyMS2013(kChanneltype channelType, cmCapDirection channelDirection, BYTE bIsGradualIntra, ETipVideoPosition tipPosition, DWORD remoteSsrc , DWORD prID)
{
	ERoleLabel eRole;
	cmCapDataType mediaType;
	mediaType = ::ChannelTypeToDataType(channelType, eRole);
	CSipChannel* pChannel = m_pCall->GetChannel(true, mediaType, channelDirection, eRole);

	if(pChannel == NULL)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SendH230FastUpdateToParty - channel was not found");
		DBGPASSERT(1);
		return;
	}

	WORD rtpReport = 2;
	if (pChannel->GetMediaType() == cmCapVideo)
	{
		if(pChannel->GetConnectionState() == kConnected)
		{
			if(channelDirection == cmCapTransmit)
				rtpReport = 2;// Outgoing channel - Ask VB
			else
				rtpReport = 3;// Outgoing channel - Ask CS, who send it to EP.

			PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendH230FastUpdateToParty Outgoing channel, rtpReport is - ", rtpReport);
			CSegment*  seg = new CSegment;

			*seg << (WORD)Fast_Update << (WORD)eRole << rtpReport << bIsGradualIntra << remoteSsrc << prID;// RTP report on Intra

			if (GetIsTipCall() && (tipPosition == eTipVideoPosLeft || tipPosition == eTipVideoPosRight))
				m_pPartyApi->ForwardIpRmtH230(seg, tipPosition);
			else
				m_pPartyApi->IpRmtH230(seg); // forward task to party manager
			POBJDELETE(seg);
		}
		else
			PTRACE(eLevelInfoNormal,"CSipCntl::SendH230FastUpdateToParty, Channel is not in connected state");
	}
	else
		PTRACE(eLevelInfoNormal,"CSipCntl::SendH230FastUpdateToParty: Channel is not video");
}

/////////////////////////////////////////////////////////////////////////////
void  CSipCntl::FastUpdateReq(ERoleLabel eRole, ETipVideoPosition tipPosition, DWORD remoteSSRC, DWORD priorityID, DWORD msSlavePartyIndex, DWORD isSlaveRTV)
{
	CSegment *pParam = new CSegment;
	*pParam << (DWORD)eRole;
	*pParam << (DWORD)tipPosition;
	*pParam << (DWORD)remoteSSRC;
	*pParam << (DWORD)priorityID;
	*pParam << (DWORD)msSlavePartyIndex;
	*pParam << isSlaveRTV;

	DispatchEvent(SIP_CS_SIG_VIDEO_FAST_UPDATE_REQ, pParam);
	POBJDELETE(pParam);
}


///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnTimerSendRtcpFlowControl()
{
	DWORD rtcpTmmbrInterval = 0;
	CProcessBase::GetProcess()->GetSysConfig()->GetDWORDDataByKey("RTCP_FLOW_CONTROL_TMMBR_INTERVAL", rtcpTmmbrInterval);

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnTimerRtcpFlowControl sending Flow control via RTCP due to timer expiration, timer(seconds) =", rtcpTmmbrInterval);
	SendFlowControlReq(mainType, cmCapReceive, CalcRateForIBM());
	rtcpTmmbrInterval = 120;
	StartTimer(RTCP_FLOW_CONTROL, rtcpTmmbrInterval * SECOND);

}


///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnTimerFastUpdate(CSegment* pParam)
{
	CSipChannel* pChannel = m_pCall->GetChannel(true, cmCapVideo,cmCapTransmit);
	ERoleLabel eRole = kRolePeople;
	BYTE bIsGradualIntra = FALSE;
	if (pChannel)
	{
		if (pChannel->GetMediaType() == cmCapVideo)
		{
			if(pChannel->GetConnectionState() == kConnected)
			{
				eRole = pChannel->GetRoleLabel();
				PTRACE(eLevelInfoNormal,"CSipCntl::OnTimerFastUpdate Outgoing channel, Ask VB for new intra");
				CSegment*  seg = new CSegment;
				*seg << (WORD)Fast_Update << (WORD)eRole << (WORD)1 << bIsGradualIntra;// Remote report on Intra

				m_pPartyApi->IpRmtH230(seg); // forward task to party manager
				POBJDELETE(seg);
			}
			else
				PTRACE(eLevelInfoNormal,"CSipCntl::OnTimerFastUpdate, Channel is not in connected state.");
		}
	}
	else
	{
		PTRACE(eLevelError,"CSipCntl::OnTimerFastUpdate: No video out channel found");
	}

	StartFastUpdateTimer();
}


///////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::StartFastUpdateTimer()
{
	DWORD numOfSec = GetSystemCfgFlagInt<DWORD>(m_serviceId, CFG_KEY_SIP_FAST_UPDATE_INTERVAL_ENV);
	if((numOfSec == 0) && ((m_remoteIdent == MicrosoftEP_R2) || (m_remoteIdent == MicrosoftEP_R1) || (m_remoteIdent == MicrosoftEP_Lync_R1) || (m_remoteIdent == MicrosoftEP_MAC) || (m_remoteIdent == MicrosoftEP_MAC_Lync) || (IsSameTimeEP())))
		numOfSec = GetSystemCfgFlagInt<DWORD>(m_serviceId, CFG_KEY_SIP_FAST_UPDATE_INTERVAL_EP);

	if (numOfSec) // zero indicates that there is no interval.
	{
		/*
		 * Fot Microsoft enviorment - currently decided not to use it, but send to all EPs in the conf.
		 *
		// send internal fast update only to specific EPs.
		char cUserAgent[256];cUserAgent[0] = '\0';
		std::string sValue;
		sipMessageHeaders *pRemoteSipHeaders = GetRmtHeaders();
		sValue = GetSystemCfgFlagStr<std::string>(CFG_KEY_SIP_USER_AGENT_INTRA_INTERVAL);

		//if value received from header
		if (pRemoteSipHeaders)
		{
			::SipGetHeaderValue(pRemoteSipHeaders, kUserAgent, cUserAgent);
		}

		//If the flag value is NULL
		//The intra interval will be sent to all EPs
		if ( 0 != sValue.length() )
		{
			PTRACE2(eLevelInfoNormal,"CSipCntl::StartFastUpdateTimer - Not NULL, ", sValue.c_str());
			if(NULL == strstr(sValue.c_str(), MOC_PRODUCT_NAME))
				return;// if the flag name is not MICROSOFT we haven't defined a way to handle it yet.
			if ( cUserAgent && (strlen(cUserAgent) > 0) )
			{
				{
					if((NULL == strstr(cUserAgent, MICROSOFT_EP1)) && (NULL == strstr(cUserAgent, MICROSOFT_EP2)))
					{
						PTRACE(eLevelInfoNormal,"CSipCntl::StartFastUpdateTimer - Other Microsoft EPs");
						return;// if its not OC/2 currently we don't initiate the intra interval
					}
				}
			}
		}
		*/

		StartTimer(FASTUPDATETOUT, numOfSec * SECOND);
	}
}

// field 7091

/* The function get the rtcp-fb mask from one of the remote content cap */
APIS32 CSipCntl::GetRemoteRTCPMaskfromVideoCap(ERoleLabel role)
{
	APIS32 rtcpFBMask = 0;

	rtcpFBMask = m_pLastRemoteCaps->GetRtcpFbMask(role);


	return rtcpFBMask;

}
///////////////////////////////////////////////////////////////////////////
void CSipCntl::SendFastUpdateReq(CSegment *pParam)
{
	//=================================================================================================================
	// The following flag will raise when an intra is sent or considered as not allowed.  As tempting as it is to add
	// return statements into this function, this sort of half-assed methodology caused bugs here, so please avoid it.
	//=================================================================================================================
	BOOL completedIntraReqHandling = FALSE;
	DWORD role = 0, tipPosition = eTipVideoPosLast, remoteSSRC = NON_SSRC, priorityID = INVALID, msSlavePartyIndex = 0;
	DWORD isSlaveRTV = FALSE;

	ERoleLabel eRole;
	*pParam >> (DWORD&)role;
	eRole = (ERoleLabel)role;
	*pParam >> (DWORD&)tipPosition;
	if (!pParam->EndOfSegment())
	{
		*pParam >> (DWORD&)remoteSSRC;
		*pParam >> (DWORD&)priorityID;
		*pParam >> (DWORD&)msSlavePartyIndex;
		if (!pParam->EndOfSegment())
			*pParam >> (DWORD&)isSlaveRTV;
	}

	char *label = NULL; // add actual value
	BOOL enableFirCfg = YES;
	BOOL enablePliCfg = YES;
	CMedString	str;
	// field 7091
		BOOL checkRemoteCaps = NO;


	CProcessBase::GetProcess()->GetSysConfig()->GetBOOLDataByKey("RTCP_FIR_ENABLE", enableFirCfg);
	CProcessBase::GetProcess()->GetSysConfig()->GetBOOLDataByKey("RTCP_PLI_ENABLE", enablePliCfg);
	// field 7091
	CProcessBase::GetProcess()->GetSysConfig()->GetBOOLDataByKey("RTCP_SEND_BY_RM_CAPS", checkRemoteCaps);

	CapEnum algorithm = (CapEnum)(m_pParty->GetTargetMode()->GetMediaType(cmCapVideo, cmCapReceive));

	if (m_bIsMrcCall && (eRole & kRoleContentOrPresentation))
	{
        enableFirCfg = NO;
        enablePliCfg = NO;
	}
	else if (m_bIsMrcCall)
	{// SVC not content - send the intra request to MRMP
	    CreateFastUpdateMsgToMrmp();
		completedIntraReqHandling = TRUE;
		str << "\nMrc call, forwarded the fast update request to the MRMP";
	}
	else if (m_isMs2013Active && eMsSvcCapCode == algorithm && !isSlaveRTV )
	{
	    CreateFastUpdateMsgToMsft2013(remoteSSRC, priorityID,msSlavePartyIndex);
		completedIntraReqHandling = TRUE;
		str << "\nMs SVC call, created appropriate VFU request";
	}

	if (!completedIntraReqHandling)
	{
		if ((CProcessBase::GetProcess()->GetProductType()==eProductTypeSoftMCUMfw) && (IsSameTimeEP()))
		{
			enableFirCfg = NO;
			enablePliCfg = NO;
			str << "\nDisable RCTP fast update for sametime in MFW product type";
		}

		str << "\n	RTCP_FIR_ENABLE = " << enableFirCfg << "\n	RTCP_PLI_ENABLE = "<< enablePliCfg << "\n	eRole =" << eRole;
	}

	if (!completedIntraReqHandling && (eRole == kRolePeople || (eRole & kRoleContentOrPresentation)))
	{
		if(m_pCall->IsMedia(cmCapVideo,cmCapReceive,eRole))
		{
			// field 7091
			APIU32 mediaType = (eRole == kRolePeople) ? kIpVideoChnlType : kIpContentChnlType;
			BOOL   standardRtcpRuledOut = FALSE;

			//========================================================
			// Checking for RTCP intra requests based on remote caps
			//========================================================
			if (checkRemoteCaps && !GetIsTipCall()) //8.1.6 merge - not in TIP
			{
				APIS32 rtcpFBMask = GetRemoteRTCPMaskfromVideoCap(eRole);
				PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq: checkRemoteCaps is set to YES, rtcpFBMask=", int(rtcpFBMask));

				if ((rtcpFBMask & RTCP_MASK_FIR) && enableFirCfg) {
					if(IsWebRtcCntl())
					{
						PTRACE(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq : WebRtc FIR");
						CreateFastUpdateMsgToCM(mediaType,RTCP_WEBRTC_FIR,0xFFFFFFFF,0);
					}
					else
						CreateFastUpdateMsgToCM(mediaType,RTCP_FIR,0xFFFFFFFF,0);
					completedIntraReqHandling = TRUE;
				}
				else if ((rtcpFBMask & RTCP_MASK_PLI) && enablePliCfg)
				{
					CreateFastUpdateMsgToCM(mediaType,RTCP_PLI,0xFFFFFFFF,0);
					completedIntraReqHandling = TRUE;
				}
				else
				{
					standardRtcpRuledOut = TRUE;
				}
			}


			//====================================================
			// Checking for special cases of RTCP intra requests
			//====================================================
			if (!completedIntraReqHandling)
			{
				//============================================
				// Checking special case of Lync Intra style
				//============================================
				if ((m_remoteIdent == MicrosoftEP_Lync_R1 || m_remoteIdent == MicrosoftEP_Lync_2013) && IsLyncRTCPIntraEnabled())
				{
					PTRACE(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq: Sending RTCP_INTRA_RTV to Lync client");
					CreateFastUpdateMsgToCM(mediaType,RTCP_INTRA_RTV,0xFFFFFFFF,m_LossPacketSeqNum);
					completedIntraReqHandling = TRUE;
				}
				else if( m_UserAgent && strstr(m_UserAgent, "AV-MCU") && IsLyncRTCPIntraForAVMCUEnabled())
				{
					if(m_isMs2013Active && msSlavePartyIndex && isSlaveRTV) // SLAVE PARTY
					{
						DWORD remoteSsrc = m_pLastRemoteCaps->getMsftSsrcVideoFirst(msSlavePartyIndex+1);
						TRACEINTO << "Sending RTCP_INTRA_RTV to avmcu 2013 slave" << ". remoteSsrc:" << remoteSsrc << ", msSlavePartyIndex:" << msSlavePartyIndex;
						CreateFastUpdateMsgToCM(mediaType, RTCP_INTRA_RTV, 0xFFFFFFFF, m_LossPacketSeqNum, remoteSsrc);
					}else
					{
						TRACEINTO << "Sending RTCP_INTRA_RTV to avmcu 2010 or main party (avmcu 2013)";
						CreateFastUpdateMsgToCM(mediaType, RTCP_INTRA_RTV, 0xFFFFFFFF, m_LossPacketSeqNum);
					}
				}

				//===============================
				// Checking special case of TIP
				//===============================
				else if (GetIsTipCall())
				{
					CSipChannel* pChannel = m_pCall->GetChannel(true, cmCapVideo, cmCapReceive,kRolePeople);//amirk-rebase
					BYTE isBlockSendIntra = FALSE;
						if(pChannel && (pChannel->IsMuted() == TRUE || m_bIsOnHold || m_bIsResuming))
						isBlockSendIntra = TRUE;
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq: isBlockSendIntra ",isBlockSendIntra);
					if ( m_pParty->GetTargetMode()->IsTipNegotiated() == FALSE ||  isBlockSendIntra )
					{
						PTRACE(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq: not sending intra req because TipNegotiation is Active (for example:still creating slaves)");
						completedIntraReqHandling = TRUE;
					}
					else
					{
						PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq : decoder side ask for IDR:",tipPosition);

						if (tipPosition == eTipVideoPosLeft)
							tipPosition = eTipVideoPosRight;
						else if (tipPosition == eTipVideoPosRight)
							tipPosition = eTipVideoPosLeft;

						PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq : send IDR request to encoder side:",tipPosition);

						PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq : Send via Tip RTCP mediaType=",mediaType);
						CreateFastUpdateMsgToCM(mediaType,RTCP_TIP_IDR,tipPosition,0);
						completedIntraReqHandling = TRUE;
					}
				}
				else if(IsWebRtcCntl())
				{
					PTRACE(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq : WebRtc Intra");
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq : Send via WebRtc Intra mediaType=",mediaType);
					CreateFastUpdateMsgToCM(mediaType,RTCP_WEBRTC_FIR,0xFFFFFFFF,0);
					completedIntraReqHandling = TRUE;
				}
			}

			//============================================================================================================
			// RTCP intra requests based on local caps for all other cases where RTCP was not yet ruled out as an option
			//============================================================================================================
			if (!completedIntraReqHandling && !standardRtcpRuledOut)
			{
				CIpComMode 	*currMode = m_pParty->GetCurrentMode();
				if (currMode)
				{
					CBaseVideoCap *pCap = (CBaseVideoCap *)currMode->GetMediaAsCapClass(cmCapVideo,cmCapReceive,eRole);
					if (pCap)
					{
						str << "\n	GetRtcpFeedbackMask = " << pCap->GetRtcpFeedbackMask();
						APIU32 mediaType = (eRole == kRolePeople) ? kIpVideoChnlType : kIpContentChnlType;

						if (pCap->IsSupportFIR() /*&& m_remoteIdent != TandbergEp */ && enableFirCfg) //Ignor TandbergEp for VNGR-25020
						{
							CreateFastUpdateMsgToCM(mediaType,RTCP_FIR,0xFFFFFFFF,0);
							completedIntraReqHandling = TRUE;
						}
						else if (pCap->IsSupportPLI() /* && m_remoteIdent != TandbergEp */ && enablePliCfg)
						{
							PTRACE(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq Incoming video channel, Ask Remote for new intra through RTCP_PLI");
							CreateFastUpdateMsgToCM(mediaType,RTCP_PLI,0xFFFFFFFF,0);
							completedIntraReqHandling = TRUE;
						}
						POBJDELETE(pCap);
					}
					else
					{
						PTRACE(eLevelError,"CSipCntl::SendFastUpdateReq pCap is NULL;");
					}
				}
				else
				{
					PTRACE(eLevelError,"CSipCntl::SendFastUpdateReq currMode is NULL;");
				}
			}

			//========================================
			// Checking for signaling intra requests
			//========================================
			if (!completedIntraReqHandling)
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq Incoming video channel, remote does not support FIR/PLI");
				label = GetRemoteStreamLabel(eRole);

				// Preparing a buffer "union style" for the fast update request we'll send to the CS
				//====================================================================================
				char infoMsgBuf[sizeof(mcReqInfo) + max(sizeof(mcReqVideoFastUpdateV2), max(sizeof(mcReqVideoFastUpdateSametime), sizeof(VideoFastUpdate)))];
				mcReqInfo* pInfoReq = reinterpret_cast<mcReqInfo*>(&infoMsgBuf);
				size_t size = 0;

		                if ((CProcessBase::GetProcess()->GetProductType()==eProductTypeSoftMCUMfw) && (IsSameTimeEP()))
				{
					size = sizeof(mcReqInfo) + sizeof(mcReqVideoFastUpdateSametime);
					pInfoReq->subOpcode = VideoFastUpdateSametime;
					pInfoReq->dynamicLen = (APIU32)(sizeof(mcReqVideoFastUpdateSametime));
				}
				else if( label == NULL || label[0] == '\0')
				{
					size = sizeof(mcReqInfo) + sizeof(VideoFastUpdate);
					pInfoReq->subOpcode = VideoFastUpdate;
					pInfoReq->dynamicLen = (APIU32)(sizeof(VideoFastUpdate));
				}
				else
				{
					size = sizeof(mcReqInfo) + sizeof(mcReqVideoFastUpdateV2);
					mcReqVideoFastUpdateV2* pVideoFastUpdateV2Req = (mcReqVideoFastUpdateV2*)(&(pInfoReq->buff));

					if((m_remoteIdent != PolycomEp && m_eMediaStreamAttrType == eMediaStreamNone && m_bfcpMStreamType != bfcp_m_stream) ||
					   (m_eMediaStreamAttrType == eMediaStreamId))
					{
						pInfoReq->subOpcode = VideoFastUpdateV2StreamId;
					}
					else
					{
						pInfoReq->subOpcode = VideoFastUpdate_v2;
					}

					pInfoReq->dynamicLen = (APIU32)(sizeof(mcReqVideoFastUpdateV2));
					memset(pVideoFastUpdateV2Req->label, 0, MAX_LABEL_LENGTH);
					if (label)
					{
						strncpy(pVideoFastUpdateV2Req->label , label, sizeof(pVideoFastUpdateV2Req->label) - 1);
						pVideoFastUpdateV2Req->label[sizeof(pVideoFastUpdateV2Req->label) - 1] = '\0';
					}
				}
				SendSIPMsgToCS(SIP_CS_SIG_INFO_REQ, pInfoReq, size);
				completedIntraReqHandling = TRUE;
			}
		}
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq Incoming video channel, No incoming video channel. Ignore the request");
		}
	}
	else if (!completedIntraReqHandling)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SendFastUpdateReq, role is not supported");
		DBGPASSERT(eRole+1000);
	}

	str << "\nCompleted handling: " << static_cast<DWORD>(completedIntraReqHandling);
	PTRACE2(eLevelInfoNormal, "CSipCntl::SendFastUpdateReq ", str.GetString());
}


/**
 * SendFlowControlToCM - send flow control message to card manager.
 * This will send the flow control using RTCP TMMBR msg.
 */
void CSipCntl::SendFlowControlToCM(APIU32 mediaType ,APIU32 rate)
{

	TCmRtcpRTPFB 		dataStruct;
	uint32_t 			exp = 0 ,
						mantissa = 0,
						overhead = RTP_HEADER_SIZE;
	CMedString 			str;

	memset(&dataStruct,0,sizeof(TCmRtcpRTPFB));

	RateToTmmbrParams(rate*100, &mantissa, &exp);
    (dataStruct.tCmRtcpRTPFBInfo).uMediaType = mediaType; /* kIpVideoChnlType / kIpContentChnlType */
    if(!IsWebRtcCntl())
    	(dataStruct.tCmRtcpRTPFBInfo).uMsgType = RTCP_TMMBR;
    else
    	(dataStruct.tCmRtcpRTPFBInfo).uMsgType = RTCP_WEBRTC_TMMBR;
    (dataStruct.tCmRtcpRTPFBInfo).MxTBRExp = exp;
    (dataStruct.tCmRtcpRTPFBInfo).MxTBRMantissa = mantissa;
    (dataStruct.tCmRtcpRTPFBInfo).MxTBRMeasuredOverhead = overhead;

	str << " mediaType=" << mediaType << ", uMsgType=RTCP_TMMBR, MxTBRExp=" << exp << ", MxTBRMantissa=" << mantissa << ", MxTBRMeasuredOverhead=" << overhead;

	PTRACE2(eLevelInfoNormal,"CSipCntl::SendFlowControlToCM through RTCP, ", str.GetString());

    SendMsgToMpl((BYTE*)(&dataStruct), sizeof(TCmRtcpRTPFB), IP_CM_RTCP_RTPFB_REQ);
}

/**
 * SendInfoFlowControlReq - Send flow control using SIP signaling INFO msg.
 */
void CSipCntl::SendInfoFlowControlReq(APIU32 videoType , cmCapDirection mediaDirection,APIU32 rate)
{
	if(m_isMs2013Active)
		return;

	char 	*label 	= NULL; // add actual value
	DWORD  	indLen  = sizeof(mcReqInfo) + sizeof(mcReqFlowControl);// + 1000; //+1000
	BYTE	pReqArray[indLen];
	mcReqInfo* mcReq = (mcReqInfo*)(&pReqArray);
	ERoleLabel 		eRole = (videoType == mainType)? kRolePeople : kRolePresentation;

	memset(pReqArray, 0, indLen);

	if(m_remoteIdent == TandbergEp)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SendFlowControlReq, TandbergEp - not sending INFO FlowControl");
		return;
	}

	label = GetRemoteStreamLabel(eRole);
	TRACEINTOFUNC << "Rate recieved: " << (APIU32)(rate) << ", videoType: " << videoType;

	mcReqFlowControl* flowControlReq=(mcReqFlowControl*)(&(mcReq->buff));
	mcReq->subOpcode 	= FlowControl;
	mcReq->dynamicLen 	= (APIU32)(sizeof(mcReqFlowControl));

	memset(flowControlReq->label, 0, MAX_LABEL_LENGTH);

	if (label)
	{
		strncpy(flowControlReq->label , label, sizeof(flowControlReq->label) - 1);
		flowControlReq->label[sizeof(flowControlReq->label) - 1] = '\0';
	}

	flowControlReq->mediaDirection = mediaDirection;
	flowControlReq->rate = rate / 10;

	SendSIPMsgToCS(SIP_CS_SIG_INFO_REQ, pReqArray, indLen);
}

//BRIDGE-14807
void CSipCntl::SetPreferTIPFlowCtrlRateIfNeeded(APIU32& rate, APIU32 videoType)
{
	ERoleLabel 	 eRole 				= (videoType == mainType)? kRolePeople : kRolePresentation;
	CCommConfDB* pCCommConfDB 		= ::GetpConfDB();
	BOOL     	 bIsPreferTip 		= FALSE;
	BOOL		 bIsArtContentOn	= FALSE;
	CCommConf* 	 pCommConf			= NULL;
	CIpComMode*  pTargetMode		= NULL;
	BOOL  		 bIsNeedToSet		= FALSE;
	BOOL 		 bIfFlagOn			= FALSE;

	PASSERTMSG_AND_RETURN(!pCCommConfDB || !m_pParty, "!pCCommConfDB || !m_pParty");
	pTargetMode = m_pParty->GetTargetMode();
	PASSERTMSG_AND_RETURN(!pTargetMode, "!pTargetMode");

	bIsArtContentOn 		= (m_eContentInState == eSendStreamOn)?TRUE:FALSE;
	pCommConf   			= pCCommConfDB->GetCurrentConf(m_pParty->GetMonitorConfId());
	bIfFlagOn 				= GetBOOLDataByKey(CFG_KEY_ENABLE_CONTENT_IN_PREFER_TIP_FOR_CALL_RATES_LOWER_THAN_768K);

	if (pCommConf && pCommConf->GetIsTipCompatible() == eTipCompatiblePreferTIP)
		bIsPreferTip = TRUE;

	DWORD AudRate 	  	   	= pTargetMode->GetMediaBitRate(cmCapAudio, cmCapTransmit) * 10;
    DWORD contentRate 	   	= pTargetMode->GetMediaBitRate(cmCapVideo, cmCapTransmit, kRoleContentOrPresentation);
    DWORD totalRate   	   	= pTargetMode->GetTotalBitRate(cmCapTransmit) / 100 ;

    if(bIsArtContentOn && contentRate == 0)
       contentRate = GetFullContentRate();

    bIsNeedToSet = bIfFlagOn && bIsPreferTip && bIsArtContentOn && eRole == kRolePeople && (rate + AudRate + contentRate > totalRate);

    TRACEINTO << " bIsNeedToSet " << (int)bIsNeedToSet << " eRole " << (int)eRole << " bIsPreferTip " << (int)bIsPreferTip << " bIfFlagOn " << (int)bIfFlagOn << " bIsArtContentOn "
			  << (int)bIsArtContentOn << " AudRate " << (int)AudRate << " contentRate " << (int)contentRate << " totalRate " << (int)totalRate << " m_eContentInState " << (int)m_eContentInState;

	if(bIsNeedToSet)
	{
		rate = 640;
		TRACEINTO << "Flow control for PreferTIP with active content : video + content + audio exceed total rate : set video rate to 64k";
	}
}


////////////////////////////////////////////////////
void CSipCntl::SendFlowControlReq(APIU32 videoType , cmCapDirection mediaDirection,APIU32 rate)
{

	ERoleLabel 		eRole = (videoType == mainType)? kRolePeople : kRolePresentation;
	CMedString 		str;
	CIpComMode 		*currMode = m_pParty->GetCurrentMode();
	CBaseVideoCap 	*pCap = NULL;
	BOOL 			enableTmmbrCfg = YES;
	CProcessBase::GetProcess()->GetSysConfig()->GetBOOLDataByKey("RTCP_FLOW_CONTROL_TMMBR_ENABLE", enableTmmbrCfg);

	if (currMode) {
		pCap = (CBaseVideoCap *)currMode->GetMediaAsCapClass(cmCapVideo,cmCapReceive,eRole);
		if (pCap)
		{
			if (GetIsTipCall())
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::SendFlowControlReq, TIP call - not sending INFO FlowControl");
				POBJDELETE(pCap);
				return;
			}
	            if (m_bIsMrcCall && eRole == kRolePeople)  //FSN-613: Dynamic Content for SVC/Mix Conf
	            {
				PTRACE(eLevelInfoNormal,"CSipCntl::SendFlowControlReq, MRC call - no need to send flow control for the video");
				POBJDELETE(pCap);
				return;
            }
			str << " rate received is =" << (APIU32)(rate) << ", videoType = " << videoType;
			PTRACE2(eLevelInfoNormal,"CSipCntl::SendFlowControlReq ", str.GetString());

			SetPreferTIPFlowCtrlRateIfNeeded(rate, videoType); //BRIDGE-14807

			m_pCall->SetChannelRate(rate, cmCapVideo, mediaDirection, eRole);

			if (pCap->IsSupportTMMBR() && enableTmmbrCfg) {
				SendFlowControlToCM((videoType == mainType)? kIpVideoChnlType : kIpContentChnlType, rate);
			} else {
				SendInfoFlowControlReq(videoType, mediaDirection, rate);
			}
		} else {
			PTRACE(eLevelInfoNormal,"CSipCntl::SendFlowControlReq pCap is NULL exit");
		}
		/*Free the pCap here since GetMediaAsCapClass will allocate it*/
		POBJDELETE(pCap);
	}
}

//////////////////////////////////////////////////////////////////////////
void CSipCntl::SendInfoLprReq(APIU32 lossProtection , APIU32 mtbf,APIU32 congestionCeiling ,APIU32 fill,APIU32 modeTimeout)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SendInfoLprReq ");
	DWORD  indLen    = sizeof(mcReqInfo) + sizeof(mcReqSipLPRModeChange);// + 1000; //+1000
	BYTE*  pReqArray = new BYTE [indLen];
	memset((char *)pReqArray,0,indLen);
	mcReqInfo* mcReq = (mcReqInfo*)pReqArray;

	mcReqSipLPRModeChange* LprReq=(mcReqSipLPRModeChange*)(&(mcReq->buff));
	mcReq->subOpcode = LprChangeMode;
	mcReq->dynamicLen = (APIU32)(sizeof(mcReqSipLPRModeChange));
	LprReq->lossProtection = lossProtection;
	LprReq->mtbf = mtbf;
	LprReq->congestionCeiling = congestionCeiling;
	LprReq->fill = fill;
	LprReq->modeTimeout = modeTimeout;
	SendSIPMsgToCS(SIP_CS_SIG_INFO_REQ, pReqArray, indLen);
	PDELETEA(pReqArray);


}

////////////////////////////////////////////////////
void CSipCntl::SendIvrProviderEQReq(const char* numericConfId)
{
	TRACEINTO<<"CSipCntl::SendIvrProviderEQReq numericConfId="<<numericConfId;

	DWORD  indLen    = sizeof(mcReqInfo) + sizeof(mcReqPlcmIvr);
	BYTE*  pReqArray = new BYTE [indLen];
	memset((char *)pReqArray,0,indLen);
	mcReqInfo* mcReq = (mcReqInfo*)pReqArray;

	mcReqPlcmIvr* plcmIvrReq=(mcReqPlcmIvr*)(&(mcReq->buff));
	mcReq->subOpcode 		= PlcmIvrService;
	mcReq->dynamicLen 		= (APIU32)(sizeof(mcReqPlcmIvr));

	strncpy((char*)plcmIvrReq->digits, numericConfId, sizeof(plcmIvrReq->digits) - 1);

	SendSIPMsgToCS(SIP_CS_SIG_INFO_REQ, pReqArray, indLen);

	PDELETEA(pReqArray);
}

///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnPartyFastUpdateReqNotConnectedState(CSegment *pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnPartyFastUpdateReqNotConnectedState, When we are not in connected state there is no need to send fast update request");
	TRACEINTO<<"m_state="<<m_state;
	if(!m_pParty)
		return;
	
	if((!m_bIsMrcCall) && m_pParty->GetTargetMode() && m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvcVsw)
	{
		CSegment* pseg=new CSegment(*pParam);
		StartTimer(RELAY_FASTUPDATETOUT, ( 1 * SECOND),/* pParam pseg*/pseg);
		//SendInfoFastUpdateReq(pParam);
	}
}


///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnIpVideoUpdatePictureIndDisconnecting(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnIpVideoUpdatePictureIndDisconnecting: No fast update on disconnecting");
	if ( IsValidTimer(FASTUPDATETOUT) )
	{
		DeleteTimer(FASTUPDATETOUT);
	}
}

///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipTransportErrorInd(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipTransportErrorInd");

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;
	//PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipTransportErrorInd call index is ", callIndex);
	mcIndTransportError* pTransportErrorMsg = (mcIndTransportError*) pParam->GetPtr(1);
	DWORD status = pTransportErrorMsg->status;
	sipTransportErrorExpectedReq transportErrorType = (sipTransportErrorExpectedReq)pTransportErrorMsg->expectedReq;

	if (m_state == IP_CONNECTING && !m_bIsReInviteTransaction && transportErrorType == SipTransportErrorDelete && m_transportType != eTransportTypeTls)
	{
		// If we received transport error as a response to our first invite request
		// we should inform CS that the previous invite is deleted
		// and then we create a new invite request with UDP (the incoming channels remain open but no session was made, try to make UDP session).
		// If we received transport error as a response to our first invite request
		// we should inform CS that the previous invite is deleted
		// and then we create a new invite request with UDP (the incoming channels remain open but no session was made, try to make UDP session).
		mcReqDelNewCall sDelNewCall;
		int size = sizeof(mcReqDelNewCall);
		memset(&sDelNewCall, 0, size);
		//SendSIPMsgToCS(SIP_CS_SIG_DEL_NEW_CALL_REQ, &sDelNewCall, size);
		CSegment* pSegment = new CSegment;
		pSegment->Put((BYTE*)(&sDelNewCall), size);
			m_pCsInterface->SendMsgToCS(SIP_CS_SIG_DEL_NEW_CALL_REQ, pSegment, m_serviceId,
				m_serviceId, m_pDestUnitId,	callIndex, 0, 0, 0);
		delete pSegment;

		m_transportType = eTransportTypeUdp;
		SipInviteReq();
	}
	else
	{
		// It will cause us to close the call
		SetCallDisconnecting(); //N.A. for Bye glare issues
		m_pPartyApi->SipTransportError((DWORD)transportErrorType);
	}
}

///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipSessionTimerExpire(CSegment* pParam)
{
	BOOL isFaultEnabled = NO;
	std::string key = "ENABLE_SESSION_TIMER_EXPIRED_ALERT";
	CProcessBase::GetProcess()->GetSysConfig()->GetBOOLDataByKey(key, isFaultEnabled);

	if( isFaultEnabled )
	{
	   char messageDescription[256];
	   CSipChannel* pAudioChannel = m_pCall->GetChannel(true, cmCapAudio, cmCapTransmit);
	   mcTransportAddress* pChannelAddr = pAudioChannel->GetRmtAddress();

	   char tempName[IPV6_ADDRESS_LEN];
	   memset (&tempName,'\0',IPV6_ADDRESS_LEN);
	   ipToString(*pChannelAddr,tempName,1);

	   const char* strToAddr = NULL;
	   const char* strDestAddr = m_pNetSetup->GetDestPartyAddress();
	   const char* strRemoteUri = m_pNetSetup->GetRemoteSipAddress();
	   strToAddr = strRemoteUri[0]? strRemoteUri: strDestAddr;


	   snprintf(messageDescription, sizeof(messageDescription), "Warning, Participant disconnected with session timeout. Participant media address: (%s), port: %d. Participant signaling address: (%s)",
	                                tempName,pChannelAddr->port,  strToAddr);
	   PTRACE2(eLevelInfoNormal,"CSipCntl::OnSipSessionTimerExpire (Remote Stop Responding), Send fault; description:\n", messageDescription);

	   CHlogApi::SessionTimerFault(messageDescription);
	}

	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::OnSipSessionTimerExpire, Remote Stop Responding (Fault disabled)");
	}

	m_pPartyApi->SipPartyCallFailed(SIP_REMOTE_STOP_RESPONDING);
}

///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipSessionTimerReinvite(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnSipSessionTimerReinvite, start re-invite");
	m_pPartyApi->SipPartyCallReinvite(SIP_CS_SIG_SESSION_TIMER_REINVITE_IND);
}

///////////////////////////////////////////////////////////////////////////
void CSipCntl::GetOutboundSipProxy(char* pProxyAddress)
{
	CIpServiceListManager* pIpServiceListManager = ::GetIpServiceListMngr();
	CConfIpParameters* pServiceParams = pIpServiceListManager->FindIpService(m_serviceId);
	if (pServiceParams == NULL)
	{
		PASSERTMSG(m_pCsRsrcDesc->GetConnectionId(), "CSipCntl::GetOutBoudSipProxy - IP Service does not exist!!!");
		return;
	}
	if (m_transportType == 0) // update only if we don't have a transport type
		m_transportType = (enTransportType)pServiceParams->GetSipTransportType();

	WORD sipState	= pServiceParams->GetConfigurationOfSipServers();

	if (pServiceParams->GetSipProxyStatus() != eServerStatusOff)
	{
		if(sipState == eConfSipServerManually)
		{
			CSmallString outboundProxyName = pServiceParams->GetSipProxyName();
			if(outboundProxyName.IsEmpty() == NO)
			{
				memcpy(pProxyAddress,outboundProxyName.GetString(),MaxLengthOfSingleUrl);
				pProxyAddress[MaxLengthOfSingleUrl - 1] = '\0';
			}
			return;
		}
		if(sipState == eConfSipServerAuto)
		{
			CSmallString	domainName		= pServiceParams->GetLocalDomainName();
			if(domainName.IsEmpty() == NO)
			{
				memcpy(pProxyAddress,domainName.GetString(),MaxLengthOfSingleUrl);
				pProxyAddress[MaxLengthOfSingleUrl - 1] = '\0';
			}
			return;
		}
	}
}

///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnCsDtmfInd(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	PTRACE(eLevelInfoNormal,"CSipCntl::OnCsDtmfInd");
	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

	//PTRACE(eLevelInfoNormal,"CSipCntl::OnIpDtmfInd");
	mcIndDtmfDigit* pDtmfMsg = (mcIndDtmfDigit*) pParam->GetPtr(1);

	APIU8* buffer = new APIU8[2];// in the DTMF structure there is only one digit
	buffer[0] = pDtmfMsg->digit;
	buffer[1] = 0;

	m_pPartyApi->sendPartyDTMFInd(buffer,1, SIGNALLING_DTMF_INPUT_IND);
	PDELETEA(buffer);
}

void CSipCntl::OnCsDtmfIndIgnore(CSegment* pParam)
{
	TRACEINTO << "state: " << m_state;
}


///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnTimerChangeMode(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnTimerChangeMode");
	TRACEINTO<<"m_state="<<m_state<<" m_bChangeModeWithinTransaction="<<(int)m_bChangeModeWithinTransaction;

	m_state = (m_bChangeModeWithinTransaction == YES) ? IP_CONNECTING : IP_CONNECTED;
	m_bChangeModeWithinTransaction= NO;
	TRACEINTO<<"m_state="<<m_state<<" m_bChangeModeWithinTransaction="<<(int)m_bChangeModeWithinTransaction;

	if (m_pCall->IsAtLeastOneChannelConnectionState(kUpdating))
	{
		DWORD MipErrorNumber = 0;
		MipErrorNumber = GetMipErrorNumber();

		// if update ind didn't arrive we treat it like an update failure for party's matters
		m_pPartyApi->SipPartyCallFailed(SIP_CARD_REJECTED_CHANNELS,MipErrorNumber);
	}
	else
	{
		m_pPartyApi->SipPartyCallFailed(SIP_TIMER_POPPED_OUT);
	}
}


///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnTimerConnectCall(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnTimerConnectCall");

	if (IsValidTimer(PARTYCONNECTTOUT))
		DeleteTimer(PARTYCONNECTTOUT);

	m_pPartyApi->SipPartyConnectTout();
}

///////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnTimerDisconnectCall(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnTimerDisconnectCall");
	m_pPartyApi->SipPartyDisconnectTout();
}

///////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnTimerCloseAllChannels(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnTimerCloseChannels");
	DBGPASSERT(m_pCall->GetNumOfChannels());
	DBGPASSERT(m_pCall->GetNumOfChannelsEx());
	TRACEINTO<<"!@# calling OnAllChannelsAreClosed";
	OnAllChannelsAreClosed(); //continue as if close channels arrived (in field)
}
///////////////////////////////////////////////////////////////////
eVideoPartyType CSipCntl::GetMaxRemoteVideoPartyType(CSipCaps*	pRemoteCaps,BYTE isRtv) const
{
	eVideoPartyType RemoteVideoPartyType = eVideo_party_type_none;

	if (pRemoteCaps->IsMedia(cmCapVideo) == FALSE)
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::GetMaxRemoteVideoPartyType no remote video ");
		RemoteVideoPartyType = eVideo_party_type_none;
	}
	else
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::GetMaxRemoteVideoPartyType ");

		CBaseCap* pCap = NULL;
		RemoteVideoPartyType = eCP_H264_upto_CIF_video_party_type;
		int numOfVideoCapSets = pRemoteCaps->GetNumOfMediaCapSets(cmCapVideo);

		for (int index=0; index < numOfVideoCapSets; index++)
		{
			if(isRtv)
				pCap = pRemoteCaps->GetCapSet(eRtvCapCode,index,kRolePeople);
			else
				pCap = pRemoteCaps->GetCapSet(eH264CapCode,index,kRolePeople);

			if (pCap)
			{
				if (isRtv)
				{
					eVideoPartyType tempVideoPartyType = ((CRtvVideoCap*)pCap)->GetCPVideoPartyType();
					RemoteVideoPartyType = max(RemoteVideoPartyType, tempVideoPartyType);
				}
				else if ((((CH264VideoCap*)pCap)->GetProfile() == H264_Profile_BaseLine)
					|| (((CH264VideoCap*)pCap)->GetProfile() == H264_Profile_High)
					|| (((CH264VideoCap*)pCap)->GetProfile() == H264_Profile_Main))// TIP
				{
					eVideoPartyType tempVideoPartyType = ((CH264VideoCap*)pCap)->GetCPVideoPartyType();
					RemoteVideoPartyType = max(RemoteVideoPartyType, tempVideoPartyType);
				}

				POBJDELETE (pCap);
			}
			else
				break;

		}
	}

	return RemoteVideoPartyType;
}


//////////////////////////////////////////////////////////////////////////////
H264VideoModeDetails CSipCntl::GetH264ModeAccordingToRemoteVideoPartyType(eVideoPartyType videoPartyType,DWORD partyRate, BYTE isRtv/*=FALSE*/) const
{
	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	eVideoQuality vidQuality = eVideoQualityAuto;
	if (pCommConf)
	{
	    vidQuality = pCommConf->GetVideoQuality();

		PTRACE2INT(eLevelInfoNormal, "CSipCntl::GetH264ModeAccordingToRemoteVideoPartyType video quality:",vidQuality);
	}
	else
	    PTRACE(eLevelInfoNormal, "CSipCntl::GetH264ModeAccordingToRemoteVideoPartyType - pCommConf is NULL - set eVideoQualityAuto");

	//on RTV always use Sharpness !!!
	if (isRtv)
	{
		vidQuality = eVideoQualitySharpness;
		PTRACE(eLevelInfoNormal, "CSipCntl::GetH264ModeAccordingToRemoteVideoPartyType RTV video quality ALWAYS Sharpness");
	}
	else
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::GetH264ModeAccordingToRemoteVideoPartyType video quality:",vidQuality);
	}

	Eh264VideoModeType videoModeType = TranslateCPVideoPartyTypeToMaxH264VideoModeType(videoPartyType);

	H264VideoModeDetails h264VidModeDetails;
	CH264VideoMode* pH264VidMode = new CH264VideoMode();
	pH264VidMode->GetH264VideoParams(h264VidModeDetails, partyRate, vidQuality, (Eh264VideoModeType)videoModeType);
	POBJDELETE(pH264VidMode);
	h264VidModeDetails.profileValue = H264_Profile_None;

	return h264VidModeDetails;

}

///////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::RemoveSdesCapFromLocalCaps(cmCapDataType mediaType, ERoleLabel eRole)
{
	m_pChosenLocalCap->RemoveSdesCaps(mediaType, eRole);
	m_pFullLocalCaps->RemoveSdesCaps(mediaType, eRole);
	m_pPartialLocalCaps->RemoveSdesCaps(mediaType, eRole);
	m_pMaxLocalCaps->RemoveSdesCaps(mediaType, eRole);
}

///////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::RemoveUnsupportedSdesCapFromLocalCaps(APIU16 cryptoSuite, BOOL bIsMkiInUse, cmCapDataType mediaType, ERoleLabel eRole)
{
	m_pChosenLocalCap->RemoveSdesCapsDifferentFromCryptoSuiteAndMKI(cryptoSuite, bIsMkiInUse, mediaType, eRole);
	m_pFullLocalCaps->RemoveSdesCapsDifferentFromCryptoSuiteAndMKI(cryptoSuite, bIsMkiInUse, mediaType, eRole);
	m_pPartialLocalCaps->RemoveSdesCapsDifferentFromCryptoSuiteAndMKI(cryptoSuite, bIsMkiInUse ,mediaType, eRole);
	m_pMaxLocalCaps->RemoveSdesCapsDifferentFromCryptoSuiteAndMKI(cryptoSuite, bIsMkiInUse, mediaType, eRole);
}

///////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateSdesTagFromBestModeToLocalCaps(CSdesCap *sdesCap, cmCapDataType mediaType, ERoleLabel eRole)
{
	m_pChosenLocalCap->UpdateSdesTagFromBestMode(sdesCap, mediaType, eRole);
	m_pFullLocalCaps->UpdateSdesTagFromBestMode(sdesCap, mediaType, eRole);
	m_pPartialLocalCaps->UpdateSdesTagFromBestMode(sdesCap, mediaType, eRole);
	m_pMaxLocalCaps->UpdateSdesTagFromBestMode(sdesCap, mediaType, eRole);
}
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::RemoveUnsupportedSdesCapsFromAllLocalCaps(APIU16 supportedCryptoSuite, BOOL bSupportedMkiInUse)
{
	TRACEINTO << " supportedCryptoSuite " << (int)supportedCryptoSuite << " bSupportedMkiInUse " << (int)bSupportedMkiInUse;

	for(int i = 0; i < MAX_SIP_MEDIA_TYPES; i++)
	{
		cmCapDataType mediaType;
		ERoleLabel eRole;

		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);

		if (mediaType == cmCapBfcp)
			continue;

		//remove unchosen SDES from local caps
		RemoveUnsupportedSdesCapFromLocalCaps(supportedCryptoSuite, bSupportedMkiInUse, mediaType,eRole);
	}
}


////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetIsCiscoTagExist(BOOL bIsCiscoTagExist)
{
	TRACEINTO << " SetIsCiscoTagExist " << bIsCiscoTagExist;

	m_bIsCiscoTagExist = bIsCiscoTagExist;
}

////////////////////////////////////////////////////////////////////////////////
BOOL CSipCntl::GetIsCiscoTagExist()
{
	TRACEINTO << " GetIsCiscoTagExist " << m_bIsCiscoTagExist;

	return m_bIsCiscoTagExist;
}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::RemoveUnsupportedSdesCapsForCiscoCallIfNeeded()
{
	bool 		bIsNeedToRemove	= false;
	RemoteIdent	remoteIdent 	= GetRemoteIdent();

	TRACEINTO<<"m_remoteIdent: "<<remoteIdent;

	if(remoteIdent == PolycomRMX) //RMX always supports both with MKI or without (GW for example)
		bIsNeedToRemove = false;

	else if(GetIsCiscoTagExist() || remoteIdent == TandbergEp)
		bIsNeedToRemove = true;

	if(bIsNeedToRemove)
	{
		TRACEINTO << " remoteIdent: "<< remoteIdent << " call supports SDES SHA_80 or SHA_32 with MKI=0 only";
		RemoveUnsupportedSdesCapsFromAllLocalCaps(eSha1_length_80_32,FALSE);
	}

}
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::RemoveUnsupportedSdesCapsForRadVisionCallIfNeeded()
{
	bool 		bIsNeedToRemove = false;
	RemoteIdent	remoteIdent 	= GetRemoteIdent();

	if(remoteIdent == PolycomRMX) //RMX always supports both with MKI or without (GW for example)
		bIsNeedToRemove = false;

	else if(remoteIdent == RvEp)
		bIsNeedToRemove = true;

	if(bIsNeedToRemove)
	{
		TRACEINTO << " remoteIdent: "<< remoteIdent << " call supports SDES SHA_80 or SHA_32 with MKI=0 only";
		RemoveUnsupportedSdesCapsFromAllLocalCaps(eSha1_length_80_32,FALSE);
	}
}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::RemoveUnsupportedSdesCapsForMrcCall()
{
	TRACEINTO << " MRC call supports SDES only SHA_80 and MKI=0 ";

	RemoveUnsupportedSdesCapsFromAllLocalCaps(eSha1_length_80,FALSE);
}

///////////////////////////////////////////////////////////////////////////////////////////////
// we look for the best mode to open from the remote caps and the target mode
// of the conference.
CSipComMode* CSipCntl::FindBestModeToOpen(const CSipComMode& rPreferredMode, BYTE bTryUpgradeFromSecondary,BYTE isIntersectwithMaxCaps)
{
	CSipComMode* pBestMode = NULL;
	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	CConfParty* pConfParty = NULL;

	if (pCommConf)
	{
	    pConfParty = pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());

	    if (!pConfParty)
	    {
	        PTRACE(eLevelError, "CSipCntl::FindBestModeToOpen - pConfParty is NULL!");
	        DBGPASSERT(1120);
	        return pBestMode;
	    }
	}
	else
	{
	    PTRACE(eLevelError, "CSipCntl::FindBestModeToOpen - pCommConf is NULL!");
	    DBGPASSERT(1121);
	    return pBestMode;
	}

	if (m_pLastRemoteCaps && m_pLastRemoteCaps->GetNumOfCapSets())
	{
		//relevant for CUCM NGR-21169
		m_pLastRemoteCaps->FixUnkownProfileInCapsIfNeeded();

		////*********1. First we'll check rsrc - By flag limitations or by remote caps limitations*****//
		BYTE IsCIFForce = FALSE;
		H264VideoModeDetails h264VidModeDetails;
/////////////////////////////////////////////////////////////////////////////////////
		CSipCaps*	ptmpRemoteCaps	= new CSipCaps(*m_pLastRemoteCaps);

		//N.A. DEBUG VP8
		CSuperLargeString msg1;
		ptmpRemoteCaps->DumpToString(msg1);
		PTRACE2(eLevelInfoNormal,"N.A. DEBUG CSipCntl::FindBestModeToOpen, ptmpRemoteCaps->DumpToString(msg1); : ", msg1.GetString());


		if (!ptmpRemoteCaps)
		{
			PTRACE(eLevelError, "CSipCntl::FindBestModeToOpen - new remote cap failed!");
			DBGPASSERT(1122);
			return pBestMode;
		}

		capBuffer** pMediaCapList = NULL;
		int numOfRemoteSdesCapSets = 0 ;
		ptmpRemoteCaps->GetSdesMediaCaps(cmCapAudio,&numOfRemoteSdesCapSets,&pMediaCapList, kRolePeople);

		for (int k = 0; k < numOfRemoteSdesCapSets; k++)
		{
			CSdesCap* pCap = (CSdesCap*)CBaseCap::AllocNewCap((CapEnum)pMediaCapList[k]->capTypeCode,pMediaCapList[k]->dataCap);

			PTRACE2INT(eLevelError, "CSipComMode* CSipCntl::FindBestModeToOpen pCap->GetSdesTag() = ",pCap->GetSdesTag());
			POBJDELETE(pCap);
		}
/////////////////////////////////////////////////////////////////////////////////////

		DWORD partyRate = ptmpRemoteCaps->GetTotalRate()*100;
		eVideoPartyType RemoteVideoPartyType = eVideo_party_type_none;
		IsCIFForce = IsSetCIFRsrcForUser(GetUserAgent());

		TRACEINTOFUNC << "PartyRate: " << partyRate << ", m_UserAgent: " << GetUserAgent();

		if (IsCIFForce && rPreferredMode.GetConfType() == kCp)
		{
			PTRACE2(eLevelInfoNormal, "CSipCntl::FindBestModeToOpen - force CIF rsrc -Name:", PARTYNAME);
			RemoteVideoPartyType = eCP_H264_upto_CIF_video_party_type;
			h264VidModeDetails = GetH264ModeAccordingToRemoteVideoPartyType(RemoteVideoPartyType,partyRate);
			ptmpRemoteCaps->SetLevelAndAdditionals(h264VidModeDetails,kRolePeople);
			m_pChosenLocalCap ->Set4CifMpi(-1);
			m_pChosenLocalCap ->Reomve4cifFromCaps();
		}

		BYTE IsReduceToHd720 = IsSetHD720RsrcForUser(GetUserAgent());
		BOOL bEnableHighfProfile = GetSystemCfgFlagInt<BOOL>(CFG_KEY_SUPPORT_HIGH_PROFILE);
		BYTE isRemoteSupportHighProfie = FALSE;

		if (ptmpRemoteCaps && bEnableHighfProfile  && ptmpRemoteCaps->IsCapableOfHD1080() && ptmpRemoteCaps->IsSupportHighProfile() )
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen - FORCE Hd1080 -support");
			isRemoteSupportHighProfie = TRUE;
		}

		if (isRemoteSupportHighProfie == FALSE && IsReduceToHd720 && rPreferredMode.GetConfType() == kCp && ptmpRemoteCaps && ptmpRemoteCaps->IsCapableOfHD1080() )
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen - FORCE Hd720");
			H264VideoModeDetails h264VidModeDetails = GetH264ModeAccordingToRemoteVideoPartyType(eCP_H264_upto_HD720_30FS_Symmetric_video_party_type,partyRate);

			if (ptmpRemoteCaps)
			    ptmpRemoteCaps->SetLevelAndAdditionals(h264VidModeDetails,kRolePeople);
			else
			    PTRACE(eLevelError,"CSipCntl::FindBestModeToOpen - ptmpRemoteCaps");
		}

		if (GetIsTipCall())
		{
			if (m_bIsReInviteTransaction == YES && GetIsTipCall() && m_pParty->GetTargetMode()->GetIsTipMode() &&
			        ptmpRemoteCaps && !ptmpRemoteCaps->IsSupportMainProfile() && ptmpRemoteCaps->IsSupportBaseProfile())
			{
			    PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen - ptmpRemoteCaps set MainProfile instead of BaselineProfile");

			    ptmpRemoteCaps->SetNewProfileInsteadOfOldProfile(H264_Profile_Main,H264_Profile_BaseLine);
			}
			else if (NULL == ptmpRemoteCaps)
			    PASSERTMSG(1, "ptmpRemoteCaps is NULL");

			PTRACE2INT(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen - check for rate supporting Hd1080. Rate is ", partyRate);

			if( partyRate >= 936000 && partyRate < 3000000 )
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen - downgrade to Hd720");
				CH264VideoMode* pH264VidMode = new CH264VideoMode();
				pH264VidMode->GetH264VideoModeDetailsAccordingToTypeForTIP(h264VidModeDetails, eHD720Symmetric);
				POBJDELETE(pH264VidMode);
				if (ptmpRemoteCaps)
				    ptmpRemoteCaps->SetLevelAndAdditionalsForMainProfile(h264VidModeDetails,kRolePeople);
				else
				    PTRACE(eLevelError,"CSipCntl::FindBestModeToOpen - ptmpRemoteCaps");
			}
		}

		CSipComMode* pTempPreferredMode = new CSipComMode(rPreferredMode);

		if ((rPreferredMode.GetConfType() == kCop) && (rPreferredMode.IsMediaOn(cmCapVideo, cmCapTransmit, kRolePeople) || bTryUpgradeFromSecondary))
		{
			pTempPreferredMode->SetCopTxLevel(INVALID_COP_LEVEL);
			ptmpRemoteCaps->FindBestVidTxModeForCop(m_pCopVideoModes, pTempPreferredMode, pConfParty->GetVideoProtocol(), pConfParty->GetVideoRate());
			if (ptmpRemoteCaps && (pTempPreferredMode->GetCopTxLevel() >= NUMBER_OF_COP_LEVELS) ) // cop level not found
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen: Remote caps do not contain any cop level");
				pTempPreferredMode->SetMediaOff(cmCapVideo, cmCapTransmit, kRolePeople);
			}
		}

		int ms_cac_min_video_threshold_rate = (GetSystemCfgFlagInt<DWORD>(CFG_KEY_MS_CAC_VIDEO_MIN_BR))*10;

		if ((m_AllocatedBandwidth != -1) && (m_AllocatedBandwidth >= ms_cac_min_video_threshold_rate) &&
				( (unsigned int)m_AllocatedBandwidth < ( pTempPreferredMode->GetVideoBitRate(cmCapReceive,kRolePeople) + pTempPreferredMode->GetVideoBitRate(cmCapReceive,kRoleContentOrPresentation) ) ) )
		{
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen: noa DBG this is new bandwidth ",m_AllocatedBandwidth);
			CapEnum videoAlg = (CapEnum)(pTempPreferredMode->GetMediaType(cmCapVideo, cmCapReceive));

		    if ((CapEnum)videoAlg == eH264CapCode || (CapEnum)videoAlg == eRtvCapCode)
		    {
		    	 if (rPreferredMode.GetConfType() == kCp && rPreferredMode.GetConfMediaType()!=eMixAvcSvcVsw)
		    	 {
		    		 H264VideoModeDetails h264VidModeDetails;
		    		 RTVVideoModeDetails rtvVidModeDetails;
		    		 BYTE isHighprofie = FALSE;
		    		 if(videoAlg == eH264CapCode && pTempPreferredMode->GetH264Profile(cmCapReceive) == H264_Profile_High)
		    		 	isHighprofie = TRUE;

		    		 eVideoPartyType eRemoteVideoPartyTypeTransmit = pTempPreferredMode->GetVideoPartyType(cmCapTransmit, DEFAULT_STATIC_MB);
		    		 eVideoPartyType eRemoteVideoPartyTypeReceive  = pTempPreferredMode->GetVideoPartyType(cmCapReceive);
		    		 eVideoPartyType eCurrentVideoType = max (eRemoteVideoPartyTypeTransmit, eRemoteVideoPartyTypeReceive);
		    		 Eh264VideoModeType resourceMaxVideoMode = TranslateCPVideoPartyTypeToMaxH264VideoModeType(eCurrentVideoType);
		    		 CCommConf* pComConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
		    		 eVideoQuality vidQuality = eVideoQualityAuto;
		    		 if (pComConf)
		    		 eVideoQuality vidQuality = pComConf->GetVideoQuality();
		    		 else
		    		     PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen - pComConf is NULL - set eVideoQualityAuto");
		    		 if(videoAlg == eH264CapCode)
		    		 {
		    			 if(resourceMaxVideoMode == eHD720Asymmetric || resourceMaxVideoMode == eHD720At60Asymmetric || resourceMaxVideoMode == eHD1080Asymmetric || resourceMaxVideoMode == eHD1080At60Asymmetric)
		    				::GetH264AssymetricVideoParams(h264VidModeDetails, (m_AllocatedBandwidth *100), vidQuality,resourceMaxVideoMode,isHighprofie);
		    			 else
		    			    ::GetH264VideoParams(h264VidModeDetails, (m_AllocatedBandwidth *100), vidQuality,resourceMaxVideoMode,isHighprofie);

		    			 long NewFs = 0;
		    		     long ScmFS = 0;
		    		     long ScmMBPS = 0;
		    			 long ScmSAR = 0;
		    			 APIU8 ScmLevel = 0;
		    			 APIU16 ScmProfile = 0;
		    			 long ScmStaticMB = 0;
		    		     long ScmDPB = 0;
		    			 APIU8 level = 0;
		    			 NewFs = h264VidModeDetails.maxFS;
		    			 cmCapDirection direction = cmCapReceive;
		    			if( NewFs == ((long)INVALID) )
		    			{
				    		 CH264Details thisH264Details = h264VidModeDetails.levelValue;
		    				 NewFs = thisH264Details.GetDefaultFsAsDevision();
		    		    }

		    			pTempPreferredMode->GetFSandMBPS(direction, ScmProfile, ScmLevel, ScmFS, ScmMBPS, ScmSAR, ScmStaticMB,ScmDPB);

		    		    CH264Details ScmH264Details = ScmLevel;

		    		    if (ScmFS == -1)
		    					ScmFS = ScmH264Details.GetDefaultFsAsDevision();
		                if(NewFs < ScmFS )
		    		     {
		    				 pTempPreferredMode->SetH264VideoParams(h264VidModeDetails,H264_ALL_LEVEL_DEFAULT_SAR);

		    				 CCapSetInfo Info = eH264CapCode;

		    				 if(!ptmpRemoteCaps->IsCapSet(Info,kRolePeople))
		    				 {
		    					 eVideoPartyType partyType = CRtvVideoCap::GetCPRtvResourceVideoPartyTypeByRate(m_AllocatedBandwidth);
		    		    		 Eh264VideoModeType resourceMaxVideoModeByCAC = TranslateCPVideoPartyTypeToMaxH264VideoModeType(partyType);

		    					 PTRACE2INT(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, resourceMaxVideoModeByCAC=",resourceMaxVideoModeByCAC);
		    					 resourceMaxVideoMode = min(resourceMaxVideoMode, resourceMaxVideoModeByCAC);
		    					 PTRACE2INT(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, new resourceMaxVideoMode=",resourceMaxVideoMode);

		    		    		 CRtvVideoMode::GetRtvVideoParams(rtvVidModeDetails,resourceMaxVideoMode);
		    					 PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, pTempPreferredMode rate was change because of CAC rtv -remote caps has no H264  ");
		    					 pTempPreferredMode->SetRtvVideoParams(rtvVidModeDetails);
		    				 }
		    		    }

						//Shmulik: Change rate only for H264 remote caps (it does't work on RTV!!!)
	    				 CCapSetInfo Info = eRtvCapCode;
	    				 if(ptmpRemoteCaps && (!ptmpRemoteCaps->IsCapSet(Info,kRolePeople)) )
	    				 {


							pTempPreferredMode->SetVideoBitRate(m_AllocatedBandwidth);
							pTempPreferredMode->SetVideoBitRate(m_AllocatedBandwidth,cmCapTransmit);
							int dVideoRate = ptmpRemoteCaps->GetVideoRate();
							int dVideoRate2 = ptmpRemoteCaps->GetTotalRate();

							if( m_AllocatedBandwidth < dVideoRate )
							{
								ptmpRemoteCaps->SetVideoRateInallCaps(m_AllocatedBandwidth);
							}
	    				 }

		    	 }
		    	 else if((CapEnum)videoAlg == eRtvCapCode)
		    	 {
					 eVideoPartyType partyType = CRtvVideoCap::GetCPRtvResourceVideoPartyTypeByRate(m_AllocatedBandwidth);
		    		 Eh264VideoModeType resourceMaxVideoMode = TranslateCPVideoPartyTypeToMaxH264VideoModeType(partyType);
					 CRtvVideoMode::GetRtvVideoParams(rtvVidModeDetails,resourceMaxVideoMode);
					 PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, pTempPreferredMode rate was change because of CAC rtv -remote caps has no H264  ");
					 pTempPreferredMode->SetRtvVideoParams(rtvVidModeDetails);

					 long ScmFS = 0;
		    		 long ScmMBPS = 0;
		    		 cmCapDirection direction = cmCapReceive;

		    		 pTempPreferredMode->GetRtvFSandMBPS(direction,ScmFS, ScmMBPS);
		    		 long NewFs = ((rtvVidModeDetails.Width) * (rtvVidModeDetails.Height))/256;
		    		 if(NewFs < ScmFS )
		    		 {
		    			 PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, pTempPreferredMode rate was change because of CAC rtv  ");
		    			 pTempPreferredMode->SetRtvVideoParams(rtvVidModeDetails);
		    		 }

		    	 }
		     }//end cp
		    }//end h264 or rtv

		    if( (CapEnum)videoAlg == eH263CapCode )
		    {
		    	pTempPreferredMode->SetVideoBitRate(m_AllocatedBandwidth);
		    	pTempPreferredMode->SetVideoBitRate(m_AllocatedBandwidth,cmCapTransmit);
		    	if (ptmpRemoteCaps)
		    	{
		    		int dVideoRate = ptmpRemoteCaps->GetVideoRate();
		    		if( m_AllocatedBandwidth < dVideoRate )
		    		ptmpRemoteCaps->SetVideoRateInallCaps(m_AllocatedBandwidth);
		    	}
		    }

		    COstrStream msgPM4;
		    pTempPreferredMode->Dump(msgPM4);
		    PTRACE2(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, pTempPreferredMode rate was change because of CAC : ", msgPM4.str().c_str());
		}//end of cac

		BYTE bWithinProtocolLimitation = FALSE;

		CSuperLargeString msgRC;
		ptmpRemoteCaps->DumpToString(msgRC);
		PTRACE2(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, remote caps Before : ", msgRC.GetString());

		CSuperLargeString msgPM3;
		m_pChosenLocalCap->DumpToString(msgPM3);
		PTRACE2(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, m_pChosenLocalCap  : ", msgPM3.GetString());

		CSuperLargeString msgPM4;
		m_pMaxLocalCaps->DumpToString(msgPM4);
		PTRACE2(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, m_pMaxLocalCaps  : ", msgPM4.GetString());

		BYTE bIsMrcSlave = (m_bIsMrcCall && (GetCascadeMode() == CASCADE_MODE_SLAVE));
		if (!isIntersectwithMaxCaps)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen: intersect with local caps");
			pBestMode = ptmpRemoteCaps->FindBestMode(cmCapReceiveAndTransmit, *pTempPreferredMode, *m_pChosenLocalCap, bWithinProtocolLimitation, m_pParty->IsOfferer(), bIsMrcSlave);

		}
		else if (m_pMaxLocalCaps)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen: intersect with max caps");
			pBestMode = ptmpRemoteCaps->FindBestMode(cmCapReceiveAndTransmit, *pTempPreferredMode, *m_pMaxLocalCaps, bWithinProtocolLimitation, m_pParty->IsOfferer(), bIsMrcSlave);
		}
		else
			PASSERTMSG(m_pCsRsrcDesc->GetConnectionId(), "CSipCntl::FindBestModeToOpen - Trying to use max caps although it is NULL!!!");

		if (!pBestMode)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen: find BestMode with FullLocalCaps");
			pBestMode = ptmpRemoteCaps->FindBestMode(cmCapReceiveAndTransmit, *pTempPreferredMode, *m_pFullLocalCaps, bWithinProtocolLimitation, m_pParty->IsOfferer(), bIsMrcSlave);
		}
		else
		{
			CBaseCap* tmpCapOfAudioRec = NULL;
			CBaseCap* tmpCapOfAudioTx = NULL;
			if (  ( ((tmpCapOfAudioRec = pBestMode->GetMediaAsCapClass(cmCapAudio,cmCapReceive)) == NULL) ||
				 ((tmpCapOfAudioTx = pBestMode->GetMediaAsCapClass(cmCapAudio,cmCapTransmit)) == NULL) ) && !m_isMs2013Active )
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen: there is no audio BestMode (but there is video BestMode)!");
				CSipComMode* pBestModeForAudioCaps = ptmpRemoteCaps->FindBestMode(cmCapReceiveAndTransmit, *pTempPreferredMode, *m_pFullLocalCaps, bWithinProtocolLimitation, m_pParty->IsOfferer(), bIsMrcSlave);
				CBaseCap* CapOfAudioRec = pBestModeForAudioCaps->GetMediaAsCapClass(cmCapAudio,cmCapReceive);
				CBaseCap* CapOfAudioTx  = pBestModeForAudioCaps->GetMediaAsCapClass(cmCapAudio,cmCapTransmit);

				pBestMode->SetMediaMode(CapOfAudioRec,cmCapAudio,cmCapReceive);
				pBestMode->SetMediaMode(CapOfAudioTx,cmCapAudio,cmCapTransmit);
			}
			POBJDELETE(tmpCapOfAudioRec);
			POBJDELETE(tmpCapOfAudioTx);
		}

		if(m_AllocatedBandwidth >= 0 && m_AllocatedBandwidth < ms_cac_min_video_threshold_rate)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen: Setting BEST mode to audio only");
			pBestMode->SetMediaOff(cmCapVideo, cmCapReceiveAndTransmit, kRolePeople);
			pBestMode->SetMediaOff(cmCapVideo, cmCapReceiveAndTransmit, kRoleContentOrPresentation);
			pBestMode->SetMediaOff(cmCapData, cmCapReceiveAndTransmit);
		 }

		if (pBestMode)
		{
			// IP 0:
			cmCapDataType mediaType;
			ERoleLabel eRole;
			for (int i = 0 ; i < MAX_SIP_MEDIA_TYPES; i++)
			{
				if (GetIsTipCall() && globalMediaArr[i] == kSipMediaChannelContent)
					continue;

				GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);

				//if(0 == GetRemoteMediaIp(mediaType,eRole))
				if (IsRemoteMediaIpZero(mediaType,eRole) && m_pParty &&  m_pParty->GetAvMcuLinkType() == eAvMcuLinkNone)
				{
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen: Setting BEST mode OFF for media ",mediaType);
					pBestMode->SetMediaOff(mediaType, cmCapTransmit, eRole);
			}
			}
			//if Best Mode without video than we should close the FECC as well.
			if(pBestMode->IsMediaOff(cmCapVideo,cmCapTransmit) && pBestMode->IsMediaOn(cmCapData,cmCapTransmit))
			{
				pBestMode->SetMediaOff(cmCapData, cmCapReceiveAndTransmit);
			}

		}

		if (pBestMode)	//update video out rate in case audio rate was opened with higher rate than expected:
		{
			//For VNGR-25590, save RtcpFeedback
			DWORD rtcpFbMaskForVidRcv = 0;
			DWORD rtcpFbMaskForVidTx = 0;
			DWORD rtcpFbMaskForContRcv = 0;
			DWORD rtcpFbMaskForContTx = 0;

			if (pBestMode->IsMediaOn(cmCapVideo,cmCapReceive))
				rtcpFbMaskForVidRcv = pBestMode->GetRtcpFeedbackMask(cmCapReceive);
			if (pBestMode->IsMediaOn(cmCapVideo,cmCapTransmit))
				rtcpFbMaskForVidTx = pBestMode->GetRtcpFeedbackMask(cmCapTransmit);
			if (pBestMode->IsMediaOn(cmCapVideo,cmCapReceive, kRoleContentOrPresentation))
				rtcpFbMaskForContRcv = pBestMode->GetRtcpFeedbackMask(cmCapReceive, kRoleContentOrPresentation);
			if (pBestMode->IsMediaOn(cmCapVideo,cmCapTransmit, kRoleContentOrPresentation))
				rtcpFbMaskForContTx = pBestMode->GetRtcpFeedbackMask(cmCapTransmit, kRoleContentOrPresentation);

			//2. Check if rsrc has changed after best mode...
			BYTE IsRcrsChanged = FALSE;
			CapEnum algorithm = (CapEnum)(pBestMode->GetMediaType(cmCapVideo, cmCapTransmit));
			bool is_rtv = (algorithm == eRtvCapCode);
			bool is_mssvc = (algorithm == eMsSvcCapCode);

			if (rPreferredMode.GetConfType() == kCp || rPreferredMode.GetConfType() == kVSW_Fixed) // not relevant for cop
			{
				COstrStream msg1;
				pBestMode->Dump(msg1);
				PTRACE2(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, Best Mode Before update: ", msg1.str().c_str());
				IsRcrsChanged = CheckRsrcLimitation(pBestMode,ptmpRemoteCaps,h264VidModeDetails);
				if( m_bIsReInviteTransaction == YES && GetIsTipCall() && m_pParty->GetTargetMode()->GetIsTipMode() )
				{
				    PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen - TIP CALL - don't change the RCRS");
				    IsRcrsChanged = FALSE;
                    CapEnum algorithm = (CapEnum)(pBestMode->GetMediaType(cmCapAudio, cmCapReceive));
                    if( eAAC_LDCapCode != algorithm )
                    {
                    	pBestMode->SetAudioAlg(eAAC_LDCapCode, cmCapReceive);
                    }

				}
				enMediaOnHold eMediaOnHold = m_pParty->GetNonTipPartyOnHold();
				PTRACE2INT(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen - MediaOnHold: ",(WORD)eMediaOnHold);
				if( m_bIsReInviteTransaction == YES && !GetIsTipCall() && eMediaOnHold )
				{
				    PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen - call is onHold - don't change the RCRS");
				    IsRcrsChanged = FALSE;
				}
			}

			if( IsRcrsChanged && !is_mssvc && !m_isMs2013Active )
			{
				if(is_rtv)
				 {
					 RTVVideoModeDetails rtvVidModeDetails;

					 PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen RcrsChanged, Changing RTV caps");
					 CRtvVideoMode::GetRtvVideoParams(rtvVidModeDetails,h264VidModeDetails.videoModeType);
					 int dVideoRate = pBestMode->GetVideoBitRate(cmCapReceive, kRolePeople);
					 m_pChosenLocalCap->SetRtvParams(rtvVidModeDetails,kRolePeople, dVideoRate); //VNGFE-8982 - Changed to videoRate instead of partyRate
					 pBestMode->SetRtvVideoParams(rtvVidModeDetails);
				 }
				 else //capTarget == eH264CapCode
				 {
					 //Update caps and scm
					 m_pChosenLocalCap->SetLevelAndAdditionals(h264VidModeDetails,kRolePeople);
					 APIU8 profileRx = pBestMode->GetH264Profile(cmCapReceive);
					 APIU8 profileTx = pBestMode->GetH264Profile(cmCapTransmit);

					 pBestMode->SetH264VideoParams(h264VidModeDetails, H264_ALL_LEVEL_DEFAULT_SAR);
					 pBestMode->SetH264Profile(profileRx,cmCapReceive);
					 pBestMode->SetH264Profile(profileTx,cmCapTransmit);

				 }
			}

			if(!is_rtv)
			{
				DWORD rmtRate = 0;
				if( !GetIsTipCall())
				{
					DWORD callRate = min( m_pNetSetup->GetMaxRate(), partyRate );
					if ( callRate > 0 )
					{
						//Jason.MA : seting up the acture call rate to the pBestMode, for the case of 384k EP call into 512k conf,
						//           or for the case 512k conf invite 384k EP,  BRIDGE-3004.
						pBestMode->SetCallRate( callRate/1000 );
					}
				}
				if (IsRemoteMicrosoft())
					rmtRate = ptmpRemoteCaps->GetMaxVideoBitRate(cmCapReceive, kRolePeople);
				else
					rmtRate = ptmpRemoteCaps->GetMaxVideoBitRate(cmCapTransmit, kRolePeople);
				PTRACE2INT(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen remote rate=:  ",rmtRate);

				//AN vngfe-4195: add remoteIdent for IBM
				BYTE isFecOrRedOn = FALSE;
				if (GetIsFecOn() || GetIsRedOn())
					isFecOrRedOn = TRUE;
				pBestMode->UpdateVideoOutRateIfNeeded(*pTempPreferredMode, rmtRate, m_remoteIdent, m_bIsMrcCall, isFecOrRedOn);

				CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
				BYTE confBitRate = pCommConf->GetConfTransferRate();
				//TRACEINTO<< "confBitRate " << confBitRate;
				//PTRACE2INT(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen  confBitRate",confBitRate);
				BOOL bDisableAvMcuLowRate = GetSystemCfgFlag<BOOL>("DISABLE_LYNC_AV_MCU_128_192_KBPS");
				if(! bDisableAvMcuLowRate && m_isMs2013Active == eMsft2013AvMCU && (confBitRate == Xfer_128 || confBitRate == Xfer_192 ))
				{
					if(confBitRate == Xfer_128)
					{
						TRACEINTO << "PATCH FOR AV-MCU in 128k which don't send video changing in only to 128k - out should remain 64k";
						pBestMode->SetVideoBitRate(640,cmCapTransmit);
					}
					else if(confBitRate == Xfer_192)
					{
						TRACEINTO << "PATCH FOR AV-MCU in 192k which don't send video changing in only to 128k - out should remain 64k";
						pBestMode->SetVideoBitRate(1280,cmCapTransmit);
					}
				}

				if( (pBestMode->IsMediaOn(cmCapVideo,cmCapReceive,kRolePeople) && pBestMode->GetVideoBitRate(cmCapReceive,kRolePeople) == 0 )||( pBestMode->IsMediaOn(cmCapVideo,cmCapTransmit,kRolePeople) &&  pBestMode->GetVideoBitRate(cmCapTransmit,kRolePeople) == 0 ))
				{
					PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen video bit rate is 0 remove video  ");
					pBestMode->SetMediaOff(cmCapVideo,cmCapReceive,kRolePeople);
					pBestMode->SetMediaOff(cmCapVideo,cmCapTransmit,kRolePeople);
					pBestMode->SetMediaOff(cmCapVideo,cmCapReceive,kRolePresentation);
					pBestMode->SetMediaOff(cmCapVideo,cmCapTransmit,kRolePresentation);
					pBestMode->SetMediaOff(cmCapBfcp,cmCapReceive,kRolePeople);
					pBestMode->SetMediaOff(cmCapBfcp,cmCapTransmit,kRolePeople);
				}
			}

			if(rPreferredMode.GetConfType() == kVSW_Fixed)
			{
				DWORD Bestmodevideorate = (pBestMode->GetMediaBitRate(cmCapVideo, cmCapTransmit, kRolePeople) );
				DWORD RemoteCapsVideorate = ptmpRemoteCaps->GetMaxVideoBitRate(cmCapReceive);
				BOOL bEnableFlowControlVSW = GetSystemCfgFlagInt<BOOL>(CFG_KEY_SUPPORT_VSW_FLOW_CONTROL);
				if( pBestMode->IsMediaOn(cmCapVideo, cmCapReceive, kRolePeople) && (RemoteCapsVideorate < Bestmodevideorate) )
				{
					PTRACE(eLevelInfoNormal, "CSipCntl::FindBestModeToOpen: VSW with lower rate - ");
					if( RemoteCapsVideorate < ( Bestmodevideorate * VSW_FLOW_CONTROL_RATE_THRESHOLD) || !m_bIsReInviteTransaction ||
						(m_pParty && m_pParty->GetCurrentMode() && m_pParty->GetCurrentMode()->IsMediaOff(cmCapVideo, cmCapTransmit, kRolePeople)) ) // patch : bridge-6516
					{
						PTRACE(eLevelInfoNormal, "CSipCntl::FindBestModeToOpen: VSW with lower rate -below treshold changing to secondary ");
						pBestMode->SetMediaOff(cmCapVideo, cmCapTransmit, kRolePeople);
						pBestMode->SetMediaOff(cmCapVideo, cmCapReceive, kRolePeople);
					}
					else
					{
						PTRACE(eLevelInfoNormal, "CSipCntl::FindBestModeToOpen: VSW with lower rate -sending as flow control the new rate ");
						m_pPartyApi->UpdatePartyVideoBitRate(RemoteCapsVideorate, cmCapTransmit, kRolePeople);
					}

				}

			}


			// If SRTP enable- update local caps
			/*DWORD isEncrypted;
			isEncrypted = pBestMode->GetIsEncrypted();
			if(isEncrypted == Encryp_On )
			{
				for(int i = 0; i < MAX_SIP_MEDIA_TYPES; i++)
				{
					if (pBestMode->IsMediaOn(globalMediaArr[i],cmCapReceive)) {
						CSdesCap *pSdesCap = NULL;
						pSdesCap =  pBestMode->GetSipSdes(globalMediaArr[i],cmCapReceive);
						if (pSdesCap) {
							m_pChosenLocalCap ->UpdateSingleSdesCapSet(globalMediaArr[i],pSdesCap);
						}
					}
				}
			}*/
			if(rPreferredMode.GetConfType() == kCop && pBestMode->GetCopTxLevel()< NUMBER_OF_COP_LEVELS && pBestMode->GetCopTxLevel() != INVALID_COP_LEVEL && pBestMode->IsMediaOn(cmCapVideo, cmCapTransmit, kRolePeople) )
			{
				DWORD levelvideoraterate = (pBestMode->GetMediaBitRate(cmCapVideo, cmCapTransmit, kRolePeople) ) / 10;
				DWORD audioRateAccordingToLevel = CalculateAudioRateAccordingToVideoRateOfCopLevel(levelvideoraterate);
				//audioRateAccordingToLevel = audioRateAccordingToLevel *10;
				DWORD maxLevelConfRate = levelvideoraterate + audioRateAccordingToLevel;
				DWORD RecCallRate = pBestMode->GetMediaBitRate(cmCapVideo, cmCapReceive, kRolePeople) /10  + pBestMode->GetMediaBitRate(cmCapAudio, cmCapReceive, kRolePeople);
				if(RecCallRate > maxLevelConfRate)
				{
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen: cop rate exceed change in AUDIO is ",pBestMode->GetMediaBitRate(cmCapAudio, cmCapReceive, kRolePeople));
					DWORD newVideoRateForRx = maxLevelConfRate - audioRateAccordingToLevel;
					newVideoRateForRx = newVideoRateForRx *10;
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen: cop rate exceed newVideoRateForRx ",newVideoRateForRx);
					pBestMode->SetVideoBitRate(newVideoRateForRx,cmCapReceive);
				}
			}

			//VNGR-24227
			if (rPreferredMode.GetConfType() == kCop && (pBestMode->GetCopTxLevel() >= NUMBER_OF_COP_LEVELS || pBestMode->GetCopTxLevel() == INVALID_COP_LEVEL) && pBestMode->IsMediaOff(cmCapVideo, cmCapTransmit, kRolePeople))
			{
				PTRACE2INT(eLevelInfoNormal, "CSipCntl::FindBestModeToOpen: cop, pBestMode->GetCopTxLevel() is  ", pBestMode->GetCopTxLevel());
				pBestMode->SetMediaOff(cmCapVideo, cmCapReceive, kRolePeople);
			}

			//VNGR-21599
			if ( (rPreferredMode.GetConfType() == kVSW_Fixed)       &&
				 (pBestMode->IsVidModeRcvAndXmitMediaOn() == FALSE) &&
				 (ptmpRemoteCaps->IsCapsContainingVideo() == TRUE)  &&
				 ( m_pParty->IsActiveTransaction() ) && (m_bIsReInviteTransaction == NO) &&
				 (ptmpRemoteCaps->GetH264ProfileFromCapCode(cmCapVideo) == H264_Profile_Main) )
			{
				CVidModeH323 *pVidMode		= &(CVidModeH323 &)rPreferredMode.GetMediaMode(cmCapVideo,cmCapReceive);
				pBestMode->SetMediaMode(*pVidMode,cmCapVideo);// the default is receive
				m_pParty->SetIsPartialConnectionForVSW(TRUE);
			}

			/*
			if ((m_bIsReInviteTransaction == YES) && GetIsTipCall() && m_pParty->GetTargetMode()->GetIsTipMode() &&
				(pBestMode->GetH264Profile(cmCapReceive) == H264_Profile_BaseLine)) // or check for GetIsTipCall() will be enough
			{
				pBestMode->SetH264Profile(H264_Profile_Main, cmCapTransmit);
			}
*/
			//For VNGR-25590, restore RtcpFeedback
			if (pBestMode->IsMediaOn(cmCapVideo,cmCapReceive))
				pBestMode->SetRtcpFeedbackMask(rtcpFbMaskForVidRcv, cmCapReceive);
			if (pBestMode->IsMediaOn(cmCapVideo,cmCapTransmit))
				pBestMode->SetRtcpFeedbackMask(rtcpFbMaskForVidTx, cmCapTransmit);
			if (pBestMode->IsMediaOn(cmCapVideo,cmCapReceive, kRoleContentOrPresentation))
				pBestMode->SetRtcpFeedbackMask(rtcpFbMaskForContRcv, cmCapReceive, kRoleContentOrPresentation);
			if (pBestMode->IsMediaOn(cmCapVideo,cmCapTransmit, kRoleContentOrPresentation))
				pBestMode->SetRtcpFeedbackMask(rtcpFbMaskForContTx, cmCapTransmit, kRoleContentOrPresentation);

			if( GetIsTipCall() && m_pParty->GetTipPartyTypeAndPosition() == eTipMasterCenter &&  pBestMode->IsMediaOn(cmCapVideo,cmCapReceive, kRoleContentOrPresentation) && pBestMode->IsMediaOn(cmCapVideo,cmCapReceive) && pBestMode->GetSipSdes(cmCapVideo,cmCapReceive) != NULL)
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, TIP copy SDES video Rx key to content Rx");
				CSdesCap *pSdesCap = pBestMode->GetSipSdes(cmCapVideo,cmCapReceive, kRolePeople);
				pBestMode->SetSipSdes(cmCapVideo,cmCapReceive,kRoleContentOrPresentation,pSdesCap);
			}
			//BRIDGE-15111
			if( GetIsTipCall() && m_pParty->GetTipPartyTypeAndPosition() == eTipMasterCenter &&  pBestMode->IsMediaOn(cmCapVideo,cmCapTransmit, kRoleContentOrPresentation) && pBestMode->IsMediaOn(cmCapVideo,cmCapTransmit) && pBestMode->GetSipSdes(cmCapVideo,cmCapTransmit) != NULL)
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, TIP copy SDES video Tx key to content Tx");
				CSdesCap *pSdesCap = pBestMode->GetSipSdes(cmCapVideo,cmCapTransmit, kRolePeople);
				pBestMode->SetSipSdes(cmCapVideo,cmCapTransmit,kRoleContentOrPresentation,pSdesCap);
			}

			if(GetIsTipCall() && m_pParty->GetTipPartyTypeAndPosition() == eTipMasterCenter && pBestMode->IsMediaOn(cmCapVideo,cmCapTransmit, kRoleContentOrPresentation) && pBestMode->IsMediaOff(cmCapVideo,cmCapTransmit))
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, remove also content tx on hold");
				pBestMode->SetMediaOff(cmCapVideo, cmCapTransmit, kRoleContentOrPresentation);
			}
			if( is_rtv && MicrosoftEP_Lync_2013 == GetRemoteIdent() )
			{
				// 13003
				CRtvVideoCap* pCurrentRtvCap = (CRtvVideoCap*) pBestMode->GetMediaAsCapClass(cmCapVideo,cmCapTransmit, kRolePeople);
				if (pCurrentRtvCap)
				{
					RTVVideoModeDetails rtvVidModeDetails;
					DWORD CurrentBitRate = 0;
					pCurrentRtvCap->GetRtvCap(rtvVidModeDetails,CurrentBitRate);
					if(288 == rtvVidModeDetails.Height && 352 == rtvVidModeDetails.Width)
					{
						TRACEINTO << "set video bit rate in RTV cap for CIF participant";
						DWORD maxRateForCIFParticipant = GetRTVMaxBitRateForForceCIFParticipant() * 10;
						pBestMode->SetVideoBitRate( min(pBestMode->GetVideoBitRate(cmCapTransmit,kRolePeople), maxRateForCIFParticipant) , cmCapReceiveAndTransmit);
					}
				}
			}

			//case of audio only, set off all rest channels
			if(pBestMode->IsMediaOff(cmCapVideo, cmCapReceiveAndTransmit,kRolePeople) && !m_bIsCCSPlugin)
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, audio only call. set off content, bfcp and data");
				pBestMode->SetMediaOff(cmCapVideo, cmCapReceiveAndTransmit, kRoleContentOrPresentation);
				pBestMode->SetMediaOff(cmCapBfcp, cmCapReceiveAndTransmit);
				pBestMode->SetMediaOff(cmCapData, cmCapReceiveAndTransmit);

			}

			COstrStream msg;
			pBestMode->Dump(msg);
			PTRACE2(eLevelInfoNormal,"***CSipCntl::FindBestModeToOpen, Best Mode : ", msg.str().c_str());
		}
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::FindBestModeToOpen, Best Mode wasn't changed: ");

		}
		POBJDELETE(ptmpRemoteCaps);
		POBJDELETE(pTempPreferredMode);
	}
	else
	{
		pBestMode = new CSipComMode;
//		DBGPASSERT(YES);
		PTRACE(eLevelError,"CSipCntl::FindBestModeToOpen: Function was called when remote has no active capabilities");
	}

	return pBestMode;
}
///////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::CheckRsrcLimitation(CSipComMode* pBestMode,CSipCaps*	ptmpRemoteCaps,H264VideoModeDetails& h264VidModeDetails)
{
	BYTE res = FALSE;
	BYTE isRtv = FALSE;

	bool isEnableHdVsw = false;
	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	if (pCommConf && (pCommConf->GetConfMediaType() == eMixAvcSvc))
	{
		if (pCommConf->GetEnableHighVideoResInAvcToSvcMixMode() || pCommConf->GetEnableHighVideoResInSvcToAvcMixMode())
			isEnableHdVsw = true;
	}

	if (pBestMode->GetConfMediaType() == eMixAvcSvcVsw || isEnableHdVsw)
	{
	    TRACEINTO << "MFW VSW or EnableHighVideoResInAvcToSvcMixMode: return FALSE;";
	    return FALSE;
	}

	DWORD partyRate = ptmpRemoteCaps->GetTotalRate()*100;
	eVideoPartyType RemoteVideoPartyType = eVideo_party_type_none;

	CapEnum algorithm = (CapEnum)(pBestMode->GetMediaType(cmCapVideo, cmCapTransmit));
	if(algorithm == eRtvCapCode)
		isRtv = TRUE;

	RemoteVideoPartyType = GetMaxRemoteVideoPartyType(ptmpRemoteCaps,isRtv);
	h264VidModeDetails = GetH264ModeAccordingToRemoteVideoPartyType(RemoteVideoPartyType,partyRate,isRtv);

	if(RemoteVideoPartyType == eCP_H264_upto_HD1080_60FS_Asymmetric_video_party_type)
	{
		TRACEINTOFUNC << "RemoteVideoPartyType: " <<  eVideoPartyTypeNames[RemoteVideoPartyType] << "; Mode Assymetry of HD1080 rsrc - Do nothing";
	}
	else
	{
		BYTE IsChangeBestModeNeededForTx  = checkRsrcLimitationsByPartyType(cmCapTransmit,pBestMode,h264VidModeDetails);
		BYTE IsChangeBestModeNeededForRcv = checkRsrcLimitationsByPartyType(cmCapReceive,pBestMode,h264VidModeDetails);

		if((IsChangeBestModeNeededForTx || IsChangeBestModeNeededForRcv) && (pBestMode->GetConfType() == kCp))
		{
			TRACEINTOFUNC << "RemoteVideoPartyType: " <<  eVideoPartyTypeNames[RemoteVideoPartyType] << "; Need to change !!";
			res = TRUE;
		}
		else
		{
			TRACEINTOFUNC << "RemoteVideoPartyType: " << eVideoPartyTypeNames[RemoteVideoPartyType];
		}
	}

	return res;
}
///////////////////////////////////////////////////////////////////////////////////////
/*CSipComMode* CSipCntl::FindTargetMode(const CSipComMode& rPreferredMode) const
{
	CSipComMode* pTargetMode = NULL;
	if (m_pChosenLocalCap  && m_pChosenLocalCap ->GetNumOfCapSets())
	{
		pTargetMode = m_pChosenLocalCap ->FindTargetMode(cmCapReceiveAndTransmit, rPreferredMode);

		if ( NULL != pTargetMode )
		{
			pTargetMode->SetConfType(rPreferredMode.GetConfType());
		}
		else
		{
			DBGPASSERT(YES);
			PTRACE(eLevelError,"CSipCntl::FindTargetMode: Target mode is NULL");
		}
	}
	else
	{
		DBGPASSERT(YES);
		PTRACE(eLevelError,"CSipCntl::FindTargetMode: Function was called when no local capabilities");
	}

	return pTargetMode;
}*/


////////////////////////////////////////////////////////
BYTE CSipCntl::IsMedia(cmCapDataType eMediaType,cmCapDirection eDirection, ERoleLabel eRole) const
{
	BYTE res = m_pCall->IsMedia(eMediaType,eDirection,eRole);
	return res;
}



////////////////////////////////////////////////////////
BYTE CSipCntl::IsChannelMuted(cmCapDataType eMediaType,cmCapDirection eDirection, ERoleLabel eRole) const
{
	BYTE res = m_pCall->IsChannelMuted(eMediaType,eDirection,eRole);
	return res;
}



////////////////////////////////////////////////////////
EConnectionState CSipCntl::GetCallConnectionState() const
{
	EConnectionState eRes = m_pCall->GetConnectionState();
	return eRes;
}


/////////////////////////////////////////////////////////
void CSipCntl::SetLocalCaps(const CSipCaps& rCaps, APIU16 plcmRequireMask) //N.A. VNGFE-7854
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SetLocalCaps, Local Caps and update lpr params according to it");
	*m_pFullLocalCaps  = rCaps;

	CLprCap* pLprLocalCap = m_pFullLocalCaps ->GetLprCap();

	// LPR - Setting remote LPR caps in m_pMcCall
	if (m_pFullLocalCaps ->GetIsLpr() == TRUE && pLprLocalCap)
	{
		lprCapCallStruct lprLocalCapStruct;
		memset(&lprLocalCapStruct,0, sizeof(lprCapCallStruct));
		lprLocalCapStruct.versionID = pLprLocalCap->GetLprVersionID();
		lprLocalCapStruct.minProtectionPeriod = pLprLocalCap->GetLprMinProtectionPeriod();
		lprLocalCapStruct.maxProtectionPeriod = pLprLocalCap->GetLprMaxProtectionPeriod();
		lprLocalCapStruct.maxRecoverySet = pLprLocalCap->GetLprMaxRecoverySet();
		lprLocalCapStruct.maxRecoveryPackets = pLprLocalCap->GetLprMaxRecoveryPackets();
		lprLocalCapStruct.maxPacketSize = pLprLocalCap->GetLprMaxPacketSize();

		m_pCall->SetLprCapStruct(&lprLocalCapStruct, 0);

	}
	POBJDELETE(pLprLocalCap);

	//N.A. VNGFE-7854
	BOOL isAudioOnlyMinCaps = ((plcmRequireMask == (m_plcmRequireAudio | m_plcmRequireAvp)) || (plcmRequireMask == (m_plcmRequireAudio | m_plcmRequireSavp)));
	BOOL bisRequestTinyAudio = GetSystemCfgFlagInt<BOOL>(CFG_KEY_OFFER_SHORT_AUDIO_CODEC_LIST_AFTER_AUDIO_CALL_OFFERLESS_INVITE);

	//update partial audio caps
	*m_pPartialLocalCaps = *m_pFullLocalCaps;
	if(isAudioOnlyMinCaps && bisRequestTinyAudio)//N.A. VNGFE-7854
	{
		m_pPartialLocalCaps->CreatePartialAudioCapsForAudioOnly();
	}
	else
	{
		m_pPartialLocalCaps->CreatePartialAudioCaps();
	}
}
/////////////////////////////////////////////////////////////////
void CSipCntl::SetRemoteCaps(const CSipCaps& rCaps)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SetRemoteCaps");
	*m_pLastRemoteCaps  = rCaps;
}

//////////////////////////////////////////////////////////////////
void CSipCntl::SetMaxLocalCaps(const CSipCaps& rCaps)
{
	*m_pMaxLocalCaps  = rCaps;
}
////////////////////////////////////////////////////////////
void CSipCntl::SetLprOfRemoteCapsCapStruct(kChanneltype channelType )
{
	if (m_pLastRemoteCaps->GetIsLpr() == TRUE)
	{
		CLprCap* pLprLocalCap = NULL;
		lprCapCallStruct lprLocalCapStruct;
		memset(&lprLocalCapStruct,0, sizeof(lprCapCallStruct));
		pLprLocalCap = m_pLastRemoteCaps->GetLprCap();
		if(!pLprLocalCap)
		{
			PTRACE(eLevelInfoNormal,"NOA DBG CSipCntl::SetLprOfRemoteCapsCapStruct No Video LPR Supported! ");

			if (channelType == kIpContentChnlType)
			{
				pLprLocalCap = m_pLastRemoteCaps->GetContentLprCap();
				if(!pLprLocalCap)
				{
					PTRACE(eLevelInfoNormal,"NOA DBG CSipCntl::SetLprOfRemoteCapsCapStruct No Content LPR Supported! ");
					return;
				}
			}
			else
			{
				PTRACE(eLevelInfoNormal,"NOA DBG CSipCntl::SetLprOfRemoteCapsCapStruct No LPR Supported! ");
				return;
			}
		}


		lprLocalCapStruct.versionID = pLprLocalCap->GetLprVersionID();
		//PTRACE2INT(eLevelInfoNormal,"NOA DBG CSipCntl::SetLprOfRemoteCapsCapStruct v",lprLocalCapStruct.versionID);
		lprLocalCapStruct.minProtectionPeriod = pLprLocalCap->GetLprMinProtectionPeriod();
		lprLocalCapStruct.maxProtectionPeriod = pLprLocalCap->GetLprMaxProtectionPeriod();
		lprLocalCapStruct.maxRecoverySet = pLprLocalCap->GetLprMaxRecoverySet();
		lprLocalCapStruct.maxRecoveryPackets = pLprLocalCap->GetLprMaxRecoveryPackets();
		lprLocalCapStruct.maxPacketSize = pLprLocalCap->GetLprMaxPacketSize();

		m_pCall->SetLprCapStruct(&lprLocalCapStruct, 1);
		POBJDELETE(pLprLocalCap);
		if( m_pParty->GetTargetMode()->GetIsLpr())
		{	if(!m_ChannelsWithLprPayload)
			{
				m_ChannelsWithLprPayload =YES;
				m_pPartyApi->UpdateChannelLprHeaderDB(YES);
				//update db on lpr
			}
		}

	}
}
////////////////////////////////////////////////////////
void CSipCntl::SetLastRemoteCaps(const CSipCaps& rCaps)
{
	*m_pLastRemoteCaps = rCaps;
}

////////////////////////////////////////////////////////
void CSipCntl::SavePreviousRemoteCaps()
{
	// Save remote caps in order to be able to return to these caps if transaction will fail
	if (m_pPreviousRemoteCaps && m_pLastRemoteCaps)
		*m_pPreviousRemoteCaps = *m_pLastRemoteCaps;
}

////////////////////////////////////////////////////////
void CSipCntl::ReturnRemoteCapsToThePreviousCaps()
{
	// Return to the previous remote caps that was saved before the transaction.
	if (m_pPreviousRemoteCaps && m_pLastRemoteCaps)
		*m_pLastRemoteCaps = *m_pPreviousRemoteCaps;
}

////////////////////////////////////////////////////////
void CSipCntl::SetRejectReason(enSipCodes eReason)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetRejectReason, reject reason = ", (WORD)eReason);
	m_pCall->SetRejectReason(eReason);
}

////////////////////////////////////////////////////////
void CSipCntl::MuteChannels(BYTE bIsMute,int arrSize,EIpChannelType chanArr[])
{
	// get channel type and if its out channel and its mute status changed send stream on or stream off (according to the change).
	CSipChannel* pChannel = NULL;
	PTRACE2(eLevelError, "CSipCntl::MuteChannels NAME  ", PARTYNAME);
	for (int i=0; i<arrSize; i++)
	{
		if (arrSize == MAX_SIP_CHANNELS)
			pChannel = m_pCall->GetChannel(i, true);
		else if (chanArr)
			pChannel = m_pCall->GetChannel(chanArr[i]);
		else
			break;

		if (pChannel)
		{
			if((bIsMute && !pChannel->IsMuted()) || (!bIsMute && pChannel->IsMuted()))
			{
				pChannel->Mute(bIsMute);

				// TIP
				//if (GetIsTipCall())
			//	{
					if(pChannel->IsChannelType(AUDIO_OUT))
					{
						PTRACE2INT(eLevelInfoNormal, "CSipCntl::MuteChannels, TIP mute audio channel out: ", bIsMute);
						if(bIsMute)// mute
							SendStreamOffReq(pChannel);
						else// unmute
							SendStreamOnReq(pChannel);
					}
					else if (pChannel->IsChannelType(VIDEO_CONT_OUT))
					{
						PTRACE2INT(eLevelInfoNormal, "CSipCntl::MuteChannels, TIP mute content channel out: ", bIsMute);
						if(bIsMute)// mute
							SendStreamOffReq(pChannel);
						else// unmute
							SendStreamOnReq(pChannel);
					}
			//	}

				if(pChannel->IsChannelType(VIDEO_OUT))
				{// we only send stream on/off for video out channels, otherwise the bridge level only handle the mute/unmute.
					PTRACE2INT(eLevelInfoNormal, "CSipCntl::MuteChannels, TIP mute video channel out: ", bIsMute);
					if(bIsMute)// mute
						SendStreamOffReq(pChannel);
					else// unmute
						SendStreamOnReq(pChannel);
				}
			}
		}
		else
		{
			PTRACE2(eLevelError, "CSipCntl::MuteChannels no channel!  ", PARTYNAME);
		}
	}
}



////////////////////////////////////////////////////////
int	CSipCntl::GetNumOfChannels() const
{
	int res = m_pCall->GetNumOfChannels();
	return res;
}

////////////////////////////////////////////////////////
CSipChannel *CSipCntl::GetChannel(cmCapDataType eMediaType, cmCapDirection eDirection, ERoleLabel eRole) const
{
	return m_pCall->GetChannel(true, eMediaType, eDirection, eRole);
}

CSipChannel *CSipCntl::GetChannelEx(cmCapDataType eMediaType, cmCapDirection eDirection, ERoleLabel eRole) const
{
	return m_pCall->GetChannel(false, eMediaType, eDirection, eRole);
}

////////////////////////////////////////////////////////
EConnectionState CSipCntl::GetChannelConnectionState(cmCapDataType eMediaType, cmCapDirection eDirection, ERoleLabel eRole) const
{
	return m_pCall->GetChannelConnectionState(eMediaType, eDirection, eRole);
}


////////////////////////////////////////////////////////
void CSipCntl::SetOutBoundProxyIp(DWORD ip)
{
	m_outboundProxyIp = ip;
}


////////////////////////////////////////////////////////
DWORD CSipCntl::GetOutBoundProxyIp() const
{
	return m_outboundProxyIp;
}


////////////////////////////////////////////////////////
WORD CSipCntl::GetConId() const
{
	WORD conId = m_pCall->GetConId();
	return conId;
}


////////////////////////////////////////////////////////
void CSipCntl::SetConfParamInfo(const char* strInfo)
{
	if (strInfo)
	{
		m_strConfParamInfo = ""; // clear string
		m_strConfParamInfo << "P-RMX-Info:" << strInfo;
	}
}





//////////////////////////////////////////////////////////////
void CSipCntl::AddParamToConfParamInfo(const char* strParamInfo)
{
	if (strParamInfo)
	{
		int last = m_strConfParamInfo.GetStringLength() - 1;
		if (m_strConfParamInfo[last] != ',') // space
			m_strConfParamInfo << ","; // add comma
		m_strConfParamInfo << strParamInfo;
	}
}


//////////////////////////////////////////////////////////////
void CSipCntl::SetTransportType(enTransportType eTransportType)
{
	m_transportType = eTransportType;
	if(m_transportType == 0)
	{
		CIpServiceListManager* pIpServiceListManager = ::GetIpServiceListMngr();
		CConfIpParameters* pServiceParams = pIpServiceListManager->FindIpService(m_serviceId);
		if (pServiceParams == NULL)
		{
			PASSERTMSG(m_pCsRsrcDesc->GetConnectionId(), "CSipCntl::SetTransportType - IP Service does not exist!!!");
			return;
		}

		m_transportType = (enTransportType)pServiceParams->GetSipTransportType();
	}
}

//////////////////////////////////////////////////////////////
CConfIpParameters* CSipCntl::GetServiceParams() const
{
	CIpServiceListManager* pIpServiceListManager = ::GetIpServiceListMngr();
	CConfIpParameters* pServiceParams = pIpServiceListManager->FindIpService(m_serviceId);
	return pServiceParams;
}

//////////////////////////////////////////////////////////////
CSipHeaderList* CSipCntl::GetCdrHeaders() const
{
	CSipHeaderList* pRes = m_pCall->GetCdrPrivateHeaders();
	return pRes;
}


//////////////////////////////////////////////////////////////
const char*	CSipCntl::GetForwardAddr() const
{
	const char* res = m_pCall->GetForwardAddr();
	return res;
}



//////////////////////////////////////////////////////////////
enTransportType CSipCntl::GetTransportProtocol() const
{
	return m_transportType;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::GetVideoRateOverflowFix(BYTE bCheckUserAgentHeader, CBaseVideoCap* cVideoCapForFix)
{
	CBaseVideoCap* pVidCap = NULL;
	DWORD wOrigVideoRate = 0, wFixedVideoBitRate = 0;
	BYTE bFlowControl = NO;
	std::string sValue;
	ALLOCBUFFER(cUserAgent, MaxUserAgentSize);

	if ( YES == bCheckUserAgentHeader )
	{
		sipMessageHeaders *pRemoteSipHeaders = GetRemoteCallLegHeaders();

		//if value received from header
		if (pRemoteSipHeaders)
		{
			::SipGetHeaderValue(pRemoteSipHeaders, kUserAgent, cUserAgent, MaxUserAgentSize);
		}

		sValue = GetSystemCfgFlagStr<std::string>(CFG_KEY_SIP_USER_AGENT_FLOW_CONTROL);

		if ( strlen(cUserAgent) > 0 )
		{
			//If the flag value is NULL all the call will be done without
			//reducing the rate (stay in there current rate)

			if ( 0 == sValue.length() )
			{
				PTRACE2(eLevelInfoNormal, "CSipCntl::GetVideoRateOverflowFix FLOW_CONTROL: UserAgent passed out because NULL in system.cfg", cUserAgent);
				bFlowControl = NO; //void system.cfg - no changes
			}
			else
			{
				//If the flag value is different than NULL (e.g. "Polycom") all the EPs
				//(User Agent) that has different UA name, or different prefix of the UA
				//name, the rate declared towards those EPs will be reduced according the
				//known values (the table that defined in advance).
				if ( NULL != strstr(cUserAgent, sValue.c_str()) )
				{
					PTRACE2(eLevelInfoNormal, "CSipCntl::GetVideoRateOverflowFix FLOW_CONTROL: UserAgent different from system.cfg - ", cUserAgent);
					bFlowControl = YES;
				}
				else
				{
					PTRACE2(eLevelInfoNormal, "CSipCntl::GetVideoRateOverflowFix FLOW_CONTROL: UserAgent contain system.cfg flag - ", cUserAgent);
					bFlowControl = NO;
				}
			}
		}
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::GetVideoRateOverflowFix FLOW_CONTROL: No UserAgent header");

			//If the flag value is NULL all the call will be done without
			//reducing the rate (stay in there current rate)
			if ( 0 == sValue.length() )
			{
					PTRACE2(eLevelInfoNormal, "CSipCntl::GetVideoRateOverflowFix FLOW_CONTROL: No system.cfg definition - ", cUserAgent);
					bFlowControl = NO;
			}
			else
			{
				//because UserAgent is void and value in system.cfg exist
				//UserAgent does not contain the value
				PTRACE2(eLevelInfoNormal, "CSipCntl::GetVideoRateOverflowFix FLOW_CONTROL: UserAgent different from system.cfg - ", cUserAgent);
				bFlowControl = YES;
			}
		}
	}
	else
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::GetVideoRateOverflowFix FLOW_CONTROL: No UserAgent check. Reduce.");
		bFlowControl = YES;
	}

	//Send reINVITE with lower bit rate for video
	if ( YES == bFlowControl )
	{
		bFlowControl = NO;

		//fix video bit rate
		if ( (GetLastRemoteCaps() && GetLastRemoteCaps()->IsMedia(cmCapVideo)) ||
				 (GetLocalCaps() && GetLocalCaps()->IsMedia(cmCapVideo)) )
		{
			//fix the bit rate
/*
			//I do it directly here for safe the time. Later it must be placed in
			//relevant objects and interfaces
			CSipCall* pCall = NULL;
			CSipChannel* pVidChannel = NULL;

			pCall = GetCallObj();
			if (pCall)
				pVidChannel = pCall->GetChannel(cmCapVideo, cmCapReceive);

			if (pVidChannel)
				*cFixedVideoCap = (CBaseVideoCap*) pVidChannel->GetDataAsCapClass();
*/
			if (cVideoCapForFix)
			{
				wOrigVideoRate = cVideoCapForFix->GetBitRate();
				wFixedVideoBitRate = ::SipGetVideoFlowControlRateFix(wOrigVideoRate / 10) * 10;

				//using cUserAgent for log :) not nice but no power to define new one
				memset(cUserAgent, 0, 256);
				sprintf(cUserAgent, " wFixedVideoBitRate [%d] wOrigVideoRate [%d]", wFixedVideoBitRate, wOrigVideoRate);
				PTRACE2(eLevelInfoNormal, "CSipCntl::GetVideoRateOverflowFix FLOW_CONTROL: ", cUserAgent);
			}
			else
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::GetVideoRateOverflowFix FLOW_CONTROL: No Video rate fixed");
			}
		}
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::GetVideoRateOverflowFix FLOW_CONTROL: No Video IN");
		}
	}
	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::GetVideoRateOverflowFix FLOW_CONTROL: Passed out");
	}

	DEALLOCBUFFER(cUserAgent);
	return wFixedVideoBitRate;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::ReduceVideoRate(BYTE bCheckUserAgentHeader, sipSdpAndHeadersSt *pSdpAndHeaders)
{
		BYTE bRetVal = NO;
		DWORD wFixedVideoBitRate, wOrigVideoRate;

		std::string sValue;

		sValue = GetSystemCfgFlagStr<std::string>(CFG_KEY_SIP_USER_AGENT_FLOW_CONTROL);
		if(sValue.length() == 0)
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::ReduceVideoRate, User Agent flag is OFF" );
			return bRetVal;
		}

		//pSdpAndHeaders->sipHeadersOffset is actually size of media capabilities in the message
		if ( (NULL != pSdpAndHeaders) && (pSdpAndHeaders->sipMediaLinesLength > 0) )
		{
			sipMediaLinesEntrySt *pMediaLinesEntry = (sipMediaLinesEntrySt *) &pSdpAndHeaders->capsAndHeaders[pSdpAndHeaders->sipMediaLinesOffset];
			int mediaLinePos = 0;

			for (unsigned int j = 0; j < pMediaLinesEntry->numberOfMediaLines; j++)
			{

				sipMediaLineSt *pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
				capBuffer* pCapBuffer	= (capBuffer *) &pMediaLine->caps[0];
				BYTE* pTemp	= (BYTE *)pCapBuffer;

				mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;

				if (pMediaLine->internalType != kMediaLineInternalTypeVideo)
					continue;

				for (unsigned int i = 0 ; i < pMediaLine->numberOfCaps; i++)
				{
					CCapSetInfo capInfo = (CapEnum) pCapBuffer->capTypeCode;
					if (capInfo.IsType(cmCapVideo))
					{
						CBaseVideoCap* pVideoCap = (CBaseVideoCap*) CBaseCap::AllocNewCap((CapEnum)pCapBuffer->capTypeCode,pCapBuffer->dataCap);
						wFixedVideoBitRate = GetVideoRateOverflowFix(bCheckUserAgentHeader, pVideoCap);

						if ( pVideoCap )
						{
							wOrigVideoRate = pVideoCap->GetBitRate();
							if ( (wFixedVideoBitRate > 0) && (wOrigVideoRate != wFixedVideoBitRate) )
							{
								SetSelfFlowControl(YES);
								SetOriginalVideoRate(wOrigVideoRate);
								pVideoCap->SetBitRate(wFixedVideoBitRate);
								bRetVal = YES;
							}
							else
							{
								CSmallString str;
								str << "No rate changed returned by GetVideoRateOverflowFix - " << wFixedVideoBitRate;
								PTRACE2(eLevelInfoNormal, "CSipCntl::ReduceVideoRate, ", str.GetString());
							}
						}
						else
						{
							PTRACE(eLevelError, "CSipCntl::ReduceVideoRate No video cap  - error");
						}

						POBJDELETE(pVideoCap);
					}

					//move ahead
					pTemp += (sizeof(capBufferBase) + pCapBuffer->capLength);
					pCapBuffer = (capBuffer*)pTemp;
				}
			}
		}
		else
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::ReduceVideoRate No capabilities.");
		}

		return bRetVal;
}

//return YES if rate changed
////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::RestoreVideoRate(sipSdpAndHeadersSt *pSdpAndHeaders)
{
		BYTE bRetVal = NO;

		DWORD originalVideoRate = GetOriginalVideoRate();

		std::string sValue;
		sValue = GetSystemCfgFlagStr<std::string>(CFG_KEY_SIP_USER_AGENT_FLOW_CONTROL);
		if(sValue.length() == 0)
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::RestoreVideoRate, User Agent flag is OFF" );
			return bRetVal;
		}


		if ( (pSdpAndHeaders) && (pSdpAndHeaders->sipMediaLinesLength > 0) && (YES == GetSelfFlowControl()) )
		{
			SetSelfFlowControl(NO);
			//fix video rate
			if ( originalVideoRate > 0 )
			{
				sipMediaLinesEntrySt *pMediaLinesEntry = (sipMediaLinesEntrySt *) &pSdpAndHeaders->capsAndHeaders[pSdpAndHeaders->sipMediaLinesOffset];
				int mediaLinePos = 0;

				for (unsigned int j = 0; j < pMediaLinesEntry->numberOfMediaLines; j++) {

					sipMediaLineSt *pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
					capBuffer* pCapBuffer	= (capBuffer *) &pMediaLine->caps[0];
					BYTE* pTemp	= (BYTE *)pCapBuffer;

					mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;

					if (pMediaLine->internalType != kMediaLineInternalTypeVideo)
						continue;

					for (unsigned int i = 0 ; i < pMediaLine->numberOfCaps; i++)
				{
					CCapSetInfo capInfo = (CapEnum) pCapBuffer->capTypeCode;

					if (capInfo.IsType(cmCapVideo))
					{
						CBaseVideoCap* pCap = (CBaseVideoCap*) CBaseCap::AllocNewCap((CapEnum)pCapBuffer->capTypeCode,pCapBuffer->dataCap);
						if ( pCap && (pCap->GetBitRate() < (APIS32)originalVideoRate) )
						{
							pCap->SetBitRate(originalVideoRate);

							TRACEINTO << "FLOW CONTROL: Restored video rate for [" << capInfo.GetH323CapName() << "] to [" << originalVideoRate << "]Kb from [" << pCap->GetBitRate() << "]Kb";

							bRetVal = YES;
						}
						else
						{
							if (pCap)
							{
							TRACEINTO << "FLOW CONTROL: Video rate of [" << capInfo.GetH323CapName() << "] not restored [" << originalVideoRate << "]Kb from [" << pCap->GetBitRate() << "]Kb";
						}
							else
							{
							    PTRACE(eLevelInfoNormal, "CSipCntl::RestoreVideoRate - pCap is NULL");
							}
						}
						POBJDELETE(pCap);
					}

					//move ahead
					pTemp += (sizeof(capBufferBase) + pCapBuffer->capLength);
					pCapBuffer = (capBuffer*)pTemp;
				}
			}
			}
			else
			{
				PTRACE(eLevelInfoNormal, "CSipCntl::RestoreVideoRate FLOW CONTROL: No original video rate defined");
			}
		}

		return bRetVal;
}

////////////////////////////////////////////////////////////////////////////
void  CSipCntl::SendRemoteNumbering()
{
	PTRACE(eLevelInfoNormal, "CSipCntl::SendRemoteNumbering");
	if (m_pCall->IsMedia(cmCapData, cmCapTransmit))
	{
		SendUpdateMtPairReq();
	}
}

//////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendSIPMsgToCS(DWORD opcode, void* pMsg, size_t size)
{
	DWORD subServiceId = 0;

	if ( opcode == SIP_CS_SIG_INVITE_REQ)
		subServiceId = m_pNetSetup->GetSubServiceId();
	CSegment* pSegment = new CSegment;
	pSegment->Put((BYTE*)pMsg, size);
	m_pCsInterface->SendMsgToCS(opcode, pSegment, m_serviceId,
		(!subServiceId ? m_serviceId : subServiceId), m_pDestUnitId,	m_pCall->GetCallIndex(), 0, 0, 0);
	delete pSegment;
}



//////////////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::GetSIPMsgTimeout()
{
	DWORD nRetVal;
	nRetVal = GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_MSG_TIMEOUT);
	return nRetVal;
}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetNewUdpPorts(UdpAddresses sUdpAddressesParams)
{
	memset(&m_UdpAddressesParams, 0, sizeof(UdpAddresses));
	memcpy(&m_UdpAddressesParams, &sUdpAddressesParams, sizeof(UdpAddresses));
}

/////////////////////////////////////////////////////////////////////////
int CSipCntl::OpenMediaChannels(EConnectionState iChannelsInState /*-1*/)
{
	int iNumOfChannels = 0;
	int iNumOfSentChannels = 0;
	CSipChannel* pChannel = NULL;

	iNumOfChannels = m_pCall->GetNumOfChannels();
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::OpenMediaChannels - Num of channels: ",iNumOfChannels);

	for (int i = 0; i < iNumOfChannels; i++)
	{
		pChannel = m_pCall->GetChannel(i, true);

		if (NULL == pChannel)
		{
			TRACEINTOFUNC << "Channel " << i << " (out of " << iNumOfChannels << " channels) is NULL!!!";
		}
		else if ((iChannelsInState == -1) || (pChannel->GetConnectionState() == iChannelsInState))
		{
			TRACEINTOFUNC << "Send Rtp channel " << i << " (out of " << iNumOfChannels << " channels)";

            if (pChannel->IsMediaChannel())
			{// open ART for SVC+AVC calls
				Rtp_FillAndSendUpdatePortOpenRtpStruct(pChannel);
			}

			if(pChannel->IsDirection(cmCapReceive))
				Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStructInChannels(pChannel, NO);
			else
				Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStructOutChannels(pChannel, NO);

			iNumOfSentChannels++;
		}
		else
		{
			TRACEINTOFUNC << "Channel " << i << " (out of " << iNumOfChannels << " channels):"
						  << "\niChannelsInState: " << iChannelsInState << ", ConnectionState: " << pChannel->GetConnectionState();
		}
	}

	return iNumOfSentChannels;
}

/////////////////////////////////////////////////////////////////////////
int CSipCntl::OpenInternalChannels(CSipComMode* pTargetMode, CSipComMode* pCurrentMode, EConnectionState iChannelsInState /*-1*/)
{
	TRACEINTO << " 1";

	if (m_pParty->GetTargetMode()->GetConfMediaType() != eMixAvcSvc)
	{
		TRACEINTO<<"!@# not in mixed mode yet - internal channels will not be opened";
		return 0;
	}

    // no internal channels for SVC call
    if (m_bIsMrcCall)
        return 0;

    int iNumOfSentChannels = 0;

    if (!IsSoftMcu())
    {
    	iNumOfSentChannels += OpenInternalChannelsByMedia(cmCapAudio, pTargetMode, pCurrentMode, iChannelsInState);
    }

	TRACEINTO<<" 2";

    	iNumOfSentChannels += OpenInternalChannelsByMedia(cmCapVideo, pTargetMode, pCurrentMode, iChannelsInState);

    return iNumOfSentChannels;
}

/////////////////////////////////////////////////////////////////////////
int CSipCntl::OpenInternalChannelsByMedia(cmCapDataType aDataType, CSipComMode* pTargetMode, CSipComMode* pCurrentMode, EConnectionState iChannelsInState /*-1*/)
{
    TRACEINTO << "Open internal channels for " << ::GetTypeStr(aDataType);

	if (m_pParty->GetTargetMode()->GetConfMediaType() != eMixAvcSvc)
    {
      TRACEINTO <<"!@#  not in mixed mode - internal channels will not be opened m_pParty->GetTargetMode()="<<(int)m_pParty->GetTargetMode();
      return 0;
    }

    CapEnum protocol = eUnknownAlgorithemCapCode;

    if (aDataType == cmCapAudio)
    {
        protocol = eSirenLPR_Scalable_48kCapCode;
    }
    else if (aDataType == cmCapVideo)
    {
        protocol = eSvcCapCode;
    }
    else
	{
        // no internal channels for this data type
        return 0;
	}

    int iNumOfChannels = 0;
    int iNumOfSentChannels = 0;
    int artInternalTxChannels;
    CSipChannel* pChannel = NULL;

    // go over target mode and for each stream in the target mode which is not in the current mode,
    // open an internal channel
    pTargetMode->Dump("CSipCntl::OpenInternalChannelsByMedia Target mode", eLevelInfoNormal);

    APIU32* ssrcIds = NULL;
    int numOfSsrcIds = 0;
    pTargetMode->GetSsrcIds(aDataType, cmCapReceive, ssrcIds, &numOfSsrcIds);

    APIU32* currentSsrcIds = NULL;
    int currentNumOfSsrcIds = 0;
    pCurrentMode->GetSsrcIds(aDataType, cmCapReceive, currentSsrcIds, &currentNumOfSsrcIds);

    bool found = false;
    artInternalTxChannels=numOfSsrcIds;

	if (numOfSsrcIds > GetNumberOfActiveInternalArts())
    {
    	artInternalTxChannels=GetNumberOfActiveInternalArts();
    }

	TRACEINTO << "mix_mode: Open ART channel numOfSsrcIds = " << numOfSsrcIds
		<< ", artInternalTxChannels = " << artInternalTxChannels;

    for (int i = 0; i < artInternalTxChannels; i++)
    {
        // check if the channel is already open - i.e. exists in current mode
        found = false;

        for (int j = 0; !found && j < currentNumOfSsrcIds; j++)
        {
            if (ssrcIds[i] == currentSsrcIds[j])
            {
                found = true;
            }
        }

        if (found)
		{
			// channel is already open, skip to next one
            TRACEINTO << "dynMixedErr SSRC " << ssrcIds[i] << " exists in current mode, therefore a channel will not be created for it.";

            continue;
		}

        // add the channel to the channels array in SipCall
        TRACEINTO << "mix_mode: add the channel to the channels array in SipCall";
        pChannel = m_pCall->AddChannelInternal(pTargetMode, aDataType, cmCapTransmit, protocol, ssrcIds[i]);

		if (NULL == pChannel)
        {
            TRACEINTO << "dynMixedErr Channel " << i << " (out of " << numOfSsrcIds << " internal channels) is NULL - was not created!!!";
            delete []ssrcIds;
            delete []currentSsrcIds;
            // @#@ - indicate error somehow!
            return iNumOfSentChannels;
        }

            pChannel->SetRtpConnectionId(GetAvcToSvcArtConnectionId(i));

            if (aDataType == cmCapAudio)
            {
            		TRACEINTO << "mix_mode: Open Tx ART audio channel #" << i << " on connectionId = " << pChannel->GetRtpConnectionId();
            }
            else
            {
        		TRACEINTO << "mix_mode: Open Tx ART video channel #" << i << " on connectionId = " << pChannel->GetRtpConnectionId();
            }

        // send message to ART
		TRACEINTO << "mix_mode: dynMixedPosAck request to Open internal Tx ART channel for "
			<< ::GetTypeStr(aDataType) << "  #" << i << " on connectionId = "
			<< GetAvcToSvcArtConnectionId(i);

        pChannel->SetRtpConnectionState(iChannelsInState);
        pChannel->SetCmConnectionState(kConnected);
        pChannel->SetConnectionState(iChannelsInState);

        Rtp_FillAndSendUpdatePortOpenRtpStruct(pChannel, TRUE, i);
        iNumOfSentChannels++;
    }

    if (iNumOfSentChannels>0 && currentNumOfSsrcIds==0)
    {
        // add the MRMP channel to the channels array in SipCall
        pChannel = m_pCall->AddChannelInternal(pTargetMode, aDataType, cmCapReceive, protocol);

		if (NULL == pChannel)
        {
            TRACEINTOFUNC << "dynMixedErr MRMP Channel is NULL in channels array!!!";
            delete []ssrcIds;
            delete []currentSsrcIds;
            // @#@ - indicate error somehow!

            return iNumOfSentChannels;
        }

        // open MRMP channel
        TRACEINTO << "!@# dynMixedPosAck request to Open internal Rx MRMP channel for "<<::GetTypeStr(aDataType);
        mcTransportAddress rmtAddress;
        memset(&rmtAddress, 0, sizeof(mcTransportAddress));
        APIU32 rmtRtcpPort = 0;
        int chnType=OPEN_CHANNEL_MIX_MODE;
        pChannel->SetRtpConnectionState(kConnected);
        pChannel->SetCmConnectionState(iChannelsInState);
        pChannel->SetConnectionState(iChannelsInState);
        OpenSvcChannel(pChannel, rmtAddress, rmtRtcpPort, chnType); // @#@ isUpdate
    }
    else if (currentNumOfSsrcIds > 0 && aDataType==cmCapVideo && ShouldUpdateMrmpPhysicalIdInfo()) // change this to check change in physical info
    {// update the MRMP channel with the physical info

        pChannel = m_pCall->GetChannel(false, aDataType, cmCapReceive, kRolePeople);
        if (NULL == pChannel)
        {
            TRACEINTOFUNC << "dynMixedErr MRMP Channel is NULL in channels array!!! No channel to update.";
            delete []ssrcIds;
            delete []currentSsrcIds;
            // @#@ - indicate error somehow!
            return iNumOfSentChannels;
        }

        // open MRMP channel
        TRACEINTO << "Update internal Rx MRMP channel for " << ::GetTypeStr(aDataType);
        mcTransportAddress rmtAddress;
        memset(&rmtAddress, 0, sizeof(mcTransportAddress));
        APIU32 rmtRtcpPort = 0;
        int chnType=OPEN_CHANNEL_MIX_MODE;
        pChannel->SetRtpConnectionState(kConnected);
        pChannel->SetCmConnectionState(iChannelsInState);
        pChannel->SetConnectionState(iChannelsInState);
        OpenSvcChannel(pChannel, rmtAddress, rmtRtcpPort, chnType, true);
        iNumOfSentChannels++;
    }

    delete []ssrcIds;
    delete []currentSsrcIds;

    return iNumOfSentChannels;
}

/////////////////////////////////////////////////////////////////////////
bool CSipCntl::UpdateMrmpInternalChannelIfNeeded()
{
    // update the MRMP channel with the physical info
    CSipChannel* pChannel = NULL;
    pChannel = m_pCall->GetChannel(false, cmCapVideo, cmCapReceive, kRolePeople);
    if (NULL == pChannel)
    {
        TRACEINTO << "mix_mode: MRMP Channel is NULL in channels array!!! No channel to update.";
        return false;
    }

    // update MRMP channel
    TRACEINTO << "Update internal Rx MRMP channel.";
    mcTransportAddress rmtAddress;
    memset(&rmtAddress, 0, sizeof(mcTransportAddress));
    APIU32 rmtRtcpPort = 0;
    int chnType = OPEN_CHANNEL_MIX_MODE;
    pChannel->SetRtpConnectionState(kConnected);
    pChannel->SetCmConnectionState(kConnecting);
    pChannel->SetConnectionState(kConnecting);
    OpenSvcChannel(pChannel, rmtAddress, rmtRtcpPort, chnType, true);
    return true;
}

/////////////////////////////////////////////////////////////////////////
void CSipCntl::CloseInternalChannels(EIpChannelType chanType)
{
    TRACEINTO << "!@# starting to close internal channels";

    // no internal channels for SVC call
    if (m_bIsMrcCall)
      {
        TRACEINTO << "mrc call - no internal channels";
        return;
      }

    // no internal channels for non-mix conference
    if (m_pParty->GetCurrentMode()->GetConfMediaType() != eMixAvcSvc)
      {
    	TRACEINTO<<"no need to close internal channels (m_pParty->GetCurrentMode()->GetConfMediaType()"<<(int)m_pParty->GetCurrentMode()->GetConfMediaType() ;
        return;
      }

    TRACEINTO << "chanType=" << chanType;

    cmCapDataType chType = cmCapEmpty;
    if (chanType == AUDIO_IN)
    {// close audio internal channels
        chType = cmCapAudio;
    }
    else if (chanType == VIDEO_IN)
    {// close video internal channels
        chType = cmCapVideo;
    }
    else // nothing to close
    {
        TRACEINTO << "mix_mode: No channels to close for chanType=" << chanType;
        return;
    }


    // go over all open channels and close the CM
    CSipChannel *pChannel = NULL;
    if (m_pCall->GetNumOfChannelsEx())
    {
        for (int i=0; i < MAX_INTERNAL_CHANNELS; i++)
        {
            pChannel = m_pCall->GetChannel(i, false);
            if (pChannel && pChannel->GetConnectionState()==kConnected && pChannel->GetMediaType()==chType )
            {
                if (pChannel->GetDirection() == cmCapReceive)
                {// this is MRMP channel - close it
                    TRACEINTO << "mix_mode: dynMixedPosAck  mrmp vid rx channel - close it";
                    pChannel->SetCmConnectionState(kDisconnecting);
                    pChannel->SetRtpConnectionState(kDisconnected);
                    pChannel->SetConnectionState(kDisconnecting);
                    CloseSvcChannel(pChannel, OPEN_CHANNEL_MIX_MODE);
                }
                else
                {// this is ART channel - no message is sent, just mark it as disconnected
                    TRACEINTO << "mix_mode: dynMixedPosAck ART channel - mark it as disconnected and remove";
                    pChannel->SetRtpConnectionState(kDisconnected);
                    pChannel->SetCmConnectionState(kDisconnected);
                    pChannel->SetConnectionState(kDisconnected);
                    RemoveChannel(pChannel);
                }
            }
	    else
	    {
	      if(pChannel)
	      {
                    TRACEINTO << "!@# pChannel->GetConnectionState() "<<pChannel->GetConnectionState()<<" pChannel->GetMediaType() "<<pChannel->GetMediaType();
	      }

	    }
        }
    }
}

/////////////////////////////////////////////////////////////////////////
void CSipCntl::SetVideoParamInCaps(H264VideoModeDetails h264VidModeDetails, BYTE cif4Mpi,BYTE bIsRtv,DWORD videoRate)
{
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::SetVideoParamInCaps, videoRate=",videoRate);

	if (bIsRtv)
	{
		RTVVideoModeDetails rtvVidModeDetails;

		CRtvVideoMode* pRtvVidMode = new CRtvVideoMode();
		pRtvVidMode->GetRtvVideoParams(rtvVidModeDetails,h264VidModeDetails.videoModeType);
		POBJDELETE(pRtvVidMode);

		m_pChosenLocalCap->SetRtvParams(rtvVidModeDetails,kRolePeople,videoRate);
	}

	m_pChosenLocalCap->SetLevelAndAdditionals(h264VidModeDetails, kRolePeople);
	m_pChosenLocalCap ->SetVideoRateInallCaps(videoRate,kRolePeople);

	m_pChosenLocalCap ->Set4CifMpi(cif4Mpi);
	if( cif4Mpi == (BYTE)-1 )
		m_pChosenLocalCap ->Reomve4cifFromCaps();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetMsSvcVideoParamInCaps(MsSvcVideoModeDetails MsSvcModeDetails, BYTE cif4Mpi,BYTE bIsRtv,DWORD videoRate)
{
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::SetMsSvcVideoParamInCaps, videoRate=",videoRate);
	//tbd rtv ERROR handling
	m_pChosenLocalCap->SetMsSvcVidMode(MsSvcModeDetails);
	m_pChosenLocalCap->SetVideoRateInallCaps(videoRate);

	if(bIsRtv)
	{
		RTVVideoModeDetails rtvDetail;
		CRtvVideoMode::GetRtvVideoParams(rtvDetail, MsSvcModeDetails.videoModeType);  // BRIDGE-7850

		m_pChosenLocalCap->SetRtvParams(rtvDetail, kRolePeople, videoRate);

	}

}

/////////////////////////////////////////////////////////////////////////
void CSipCntl::SetLocalCapToAudioOnly()
{
	PTRACE(eLevelInfoNormal, "CSipCntl::SetLocalCapToAudioOnly");

	m_pChosenLocalCap->CleanMedia(cmCapVideo, kRolePeople);
	m_pChosenLocalCap->CleanMedia(cmCapVideo, kRolePresentation);
	m_pChosenLocalCap ->CleanMedia(cmCapData);
	m_pChosenLocalCap->CleanMedia(cmCapBfcp);

	//CLargeString str;
	//m_pChosenLocalCap->DumpToString(str);
	//PTRACE2(eLevelInfoNormal,"CSipCntl::SetLocalCapToAudioOnly m_pChosenLocalCap: ",str.GetString());
}

/////////////////////////////////////////////////////////////////////////
void CSipCntl::SetMaxLocalCapToAudioOnly()
{
	PTRACE(eLevelInfoNormal, "CSipCntl::SetMaxLocalCapToAudioOnly");
	m_pMaxLocalCaps->CleanMedia(cmCapVideo, kRolePeople);
	m_pMaxLocalCaps->CleanMedia(cmCapVideo, kRolePresentation);
	m_pMaxLocalCaps ->CleanMedia(cmCapData);
	m_pMaxLocalCaps->CleanMedia(cmCapGeneric);
}

/////////////////////////////////////////////////////////////////////////
void CSipCntl::SetLastRemoteCapToAudioOnly()
{
	PTRACE(eLevelInfoNormal, "CSipCntl::SetLastRemoteCapToAudioOnly");
	m_pLastRemoteCaps->CleanMedia(cmCapVideo, kRolePeople);
	m_pLastRemoteCaps->CleanMedia(cmCapVideo, kRolePresentation);
	m_pLastRemoteCaps ->CleanMedia(cmCapData);
	m_pLastRemoteCaps->CleanMedia(cmCapGeneric);
}

////////////////////////////////////////////////
void CSipCntl::AdjustLocalCapToNonTip(CIpComMode* pTargetMode)
{
    //CLargeString str;
    //m_pChosenLocalCap->DumpToString(str);
    //PTRACE2(eLevelInfoNormal,"CSipCntl::AdjustLocalCapToNonTip m_pChosenLocalCap:",str.GetString());

    m_pChosenLocalCap->RemoveH264SpecifProfileCapSet(eH264CapCode,kRolePeople,H264_Profile_Main);
	m_pChosenLocalCap->RemoveCapSet(eAAC_LDCapCode);
//	m_pChosenLocalCap->SetBfcp(m_pParty->GetTargetMode(),PARTYNAME);
	//if(pTargetMode->GetIsLpr() && m_pLastRemoteCaps->GetIsLpr())
	//{
	//	m_pChosenLocalCap->AddLprCap(kRolePeople);
	//}
	if( pTargetMode->GetH264Profile(cmCapReceive) )
	{
		m_pChosenLocalCap->AddH264HPCap(pTargetMode);

	}
}
////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
// Party CS Timers
////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnPartyCsErrHandleKeepAliveFirstTout(CSegment* pParam)
{
	//PTRACE(eLevelInfoNormal, "CSipCntl::OnPartyCsErrHandleKeepAliveFirstTout");
	// Sending the request
	m_pCsInterface->SendMsgToCS(SIP_CS_PARTY_KEEP_ALIVE_REQ,NULL,m_serviceId,
									m_serviceId,m_pDestUnitId,m_callIndex,0,0,0);

	if (m_isKeepAliveIndArrived)
	{
		//PTRACE(eLevelInfoNormal, "CSipCntl::OnPartyCsErrHandleKeepAliveFirstTout : Begin again ");
		m_isKeepAliveIndArrived = 0;
	}

	if (m_keepAliveTimerCouter == 0)
	{  	// The first time the 55 second timer jumped
	//	PTRACE(eLevelInfoNormal, "CSipCntl::OnPartyCsErrHandleKeepAliveFirstTout : First time ");
		m_keepAliveTimerCouter++;
		DWORD partyKeepAliveFirstTimerVal = GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_MSG_TIMEOUT) + 5;
		StartTimer(PARTYCSKEEPALIVEFIRSTTOUT,partyKeepAliveFirstTimerVal*SECOND);
	}
	else if (m_keepAliveTimerCouter == 1)
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::OnPartyCsErrHandleKeepAliveFirstTout : Second time ");
		m_keepAliveTimerCouter++;
		DWORD partyKeepAliveSecondTimerVal = GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_KEEPALIVE_SECOND_TIMEOUT);
		StartTimer(PARTYCSKEEPALIVESECONDTOUT,partyKeepAliveSecondTimerVal*SECOND);
	}
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnPartyCsErrHandleKeepAliveSecondTout(CSegment* pParam)
{
	BOOL isDebugMode = FALSE;
	CProcessBase::GetProcess()->GetSysConfig()->GetBOOLDataByKey(CFG_KEY_DEBUG_MODE, isDebugMode);

	PTRACE(eLevelInfoNormal, "CSipCntl::OnPartyCsErrHandleKeepAliveSecondTout");
	// In this case we will disconnect the party regardelss to whatever stage it's in.
	// This means that the CS party Call task is dead.

	if (m_keepAliveTimerCouter == 0 || isDebugMode)
	{  	// we receive keep alive indication during the second timer start the loop again
		if(m_keepAliveTimerCouter == 0)
			PTRACE(eLevelInfoNormal, "CSipCntl::OnPartyCsErrHandleKeepAliveSecondTout : Start the loop again");
		else
			PTRACE(eLevelInfoNormal, "CSipCntl::OnPartyCsErrHandleKeepAliveSecondTout : Debug mode, ignore the keep alive error.");
		// Sending the request
		m_pCsInterface->SendMsgToCS(H323_CS_PARTY_KEEP_ALIVE_REQ,NULL,m_serviceId,
						m_serviceId,m_pDestUnitId,m_callIndex,0,0,0);
		m_keepAliveTimerCouter++;
		DWORD partyKeepAliveFirstTimerVal = GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_MSG_TIMEOUT) + 5;
		StartTimer(PARTYCSKEEPALIVEFIRSTTOUT,partyKeepAliveFirstTimerVal*SECOND);
		return;
	}

	if (m_keepAliveTimerCouter != 2)
	{
		DBGPASSERT(m_keepAliveTimerCouter);
	}
	// Need to have a meeting on all disconnect reasons.
	m_pCall->SetViolentClose(YES);
	m_pCall->SetCloseInitiator(YES);
	m_pPartyApi->SipPartyCallFailed(H323_CALL_CLOSED_BY_MCU);
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnPartyCsErrHandleKeepAliveInd(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal, "CSipCntl::OnPartyCsErrHandleKeepAliveInd");

	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIS32 status = 0;
	APIU16 srcUnitId = 0;

	// only stat1 srcUnitId are valid values at this place.
	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;
	status = (APIS32)stat1;
	mcIndKeepAlive* pKeepAliveMessageMsg = (mcIndKeepAlive *) pParam->GetPtr(1);

	if ( status == -1  || pKeepAliveMessageMsg->status != STATUS_OK)
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnPartyCsErrHandleKeepAliveInd : Status is wrong. Connection ID - ",m_pCsRsrcDesc->GetConnectionId());
		m_pCall->SetViolentClose(YES);
		m_pCall->SetCloseInitiator(YES);
		m_pPartyApi->SipPartyCallFailed(H323_CALL_CLOSED_BY_MCU);
	}
	else
	{
		// Renew the timer
		m_keepAliveTimerCouter  = 0;
		m_isKeepAliveIndArrived = 1;
	}
}


////////////////////////////////////////////////////////////////////////////
void CSipCntl::StartCsPartyErrHandlingLoop()
{
	if(GetSystemCfgFlagInt<BOOL>(CFG_KEY_SIP_IS_KEEPALIVE_ENABLE))
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::StartCsPartyErrHandlingLoop");
		m_pCsInterface->SendMsgToCS(SIP_CS_PARTY_KEEP_ALIVE_REQ,NULL,m_serviceId,
									m_serviceId,m_pDestUnitId,m_callIndex,0,0,0);
		// Renew the timer
		m_keepAliveTimerCouter=0;
		DWORD partyKeepAliveFirstTimerVal = GetSystemCfgFlagInt<DWORD>(CFG_KEY_SIP_MSG_TIMEOUT) + 5;
		StartTimer(PARTYCSKEEPALIVEFIRSTTOUT,partyKeepAliveFirstTimerVal*SECOND);
	}
}


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////								 MFA				             ///////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::ShouldInitTimerForSendMsg(DWORD opcode)
{
	if(	(opcode == H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ) 	||
		(opcode == H323_RTP_UPDATE_CHANNEL_REQ) 			||
		(opcode == CONFPARTY_CM_OPEN_UDP_PORT_REQ)  				||
		(opcode == CONFPARTY_CM_UPDATE_UDP_ADDR_REQ)  			||
		(opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ)   ||
		 (opcode == CONF_PARTY_MRMP_OPEN_CHANNEL_REQ) ||
		 (opcode == CONF_PARTY_MRMP_UPDATE_CHANNEL_REQ) ||
		 (opcode == CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ)		||
		 (opcode == IP_CM_DTLS_CLOSE_REQ) ||
		 (opcode == TB_MSG_OPEN_PORT_REQ) ||
		 (opcode == TB_MSG_CLOSE_PORT_REQ) ||
		 (opcode == CONF_PARTY_MRMP_STREAM_IS_MUST_REQ)
		)
    {
        return TRUE;
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::InitAllChannelsSeqNum()
{
    CSipChannel* pCurChannel = NULL;
    for (int i = 0; i < m_pCall->GetNumOfChannels(); i++)
    {
        pCurChannel = m_pCall->GetChannel(i, true);
        if(pCurChannel)
        {
            pCurChannel->SetSeqNumRtp(0);
            pCurChannel->SetSeqNumCm(0);
        }
    }

    for (int i = 0; i < m_pCall->GetNumOfChannelsEx(); i++)
    {
        pCurChannel = m_pCall->GetChannel(i, false);
        if(pCurChannel)
        {
            pCurChannel->SetSeqNumRtp(0);
            pCurChannel->SetSeqNumCm(0);
        }
    }
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::CreateFastUpdateMsgToCM(APIU32 mdiaType, APIU32 msgType, APIU32 tipPosition,APIU32 SeqNum, APIU32 remoteSsrc)
{
    CMedString str;

    str << "Sending Fast update request to CM mediaType=" << mdiaType << " msgType = "  << msgType << " tipPosition = "<< tipPosition << " SeqNum = "<< SeqNum << "remoteSsrc = " << remoteSsrc;

    /* AllScript, send RTCP INTRA only if outgoing channel is active. */
    if (m_pCall->IsMedia(cmCapVideo,cmCapTransmit,(ERoleLabel)(mdiaType==kIpVideoChnlType?kRolePeople:kRoleContentOrPresentation)))
    {
        TCmRtcpMsg dataStruct;
        memset(&dataStruct,0,sizeof(TCmRtcpMsg));
        dataStruct.tCmRtcpMsgInfo.uMediaType   = mdiaType;
        dataStruct.tCmRtcpMsgInfo.uMsgType     = msgType;
        dataStruct.tCmRtcpMsgInfo.uTipPosition = tipPosition;
        dataStruct.tCmRtcpMsgInfo.uSeqNumber   = SeqNum;
        dataStruct.tCmRtcpMsgInfo.uSsrc   = remoteSsrc;

        if (GetIsIceCall()) {
        	if (mdiaType == kIpVideoChnlType)
        		dataStruct.tCmRtcpMsgInfo.ulIce_rtcp_channel_id = m_pIceParams->GetVideoRtcpId();
        	else
        		dataStruct.tCmRtcpMsgInfo.ulIce_rtcp_channel_id = m_pIceParams->GetContentRtcpId();
        }

        SendMsgToMpl((BYTE*)(&dataStruct), sizeof(TCmRtcpMsg), IP_CM_RTCP_MSG_REQ);

    } else
    	str << " TX channel is not open, can't send FastUpdateRequest to CM ";

    PTRACE2(eLevelInfoNormal,"CSipCntl::CreateFastUpdateMsgToCM", str.GetString());

}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendUpdateMtPairReq()
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendUpdateMtPairReq - ",GetHWInterface(H323_RTP_UPDATE_MT_PAIR_REQ,FALSE)->GetConnectionId());
	TUpdateMtPairReq *pStruct = new TUpdateMtPairReq;
	memset(pStruct, 0, sizeof(TUpdateMtPairReq));
	pStruct->unDestMcuId      = m_pParty->GetMcuNum();
	pStruct->unDestTerminalId = m_pParty->GetTerminalNum();

    // for Call Generator
	if (CProcessBase::GetProcess()->GetProductFamily() == eProductFamilyCallGenerator)
    {	// we use this opcode for forwarding party's alias name to MM (for "CG audio improvements" feature)
    	const char *pPartyAlias = m_pNetSetup->GetRemoteSipAddress() ;
    	DWORD partyAlias = atoi(pPartyAlias);
    	pStruct->unDestMcuId = partyAlias;
    	TRACEINTO << "CSipCntl::SendUpdateMtPairReq - partyAlias: " << partyAlias;
    }

	SendMsgToMpl((BYTE*)(pStruct), sizeof(TUpdateMtPairReq), H323_RTP_UPDATE_MT_PAIR_REQ);

	PDELETE(pStruct);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SendStreamOffReq(CSipChannel* pChannel)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SendStreamOffReq");
	TStreamOffReq sStruct;
	sStruct.unChannelType		= ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel());
	sStruct.unChannelDirection	= pChannel->GetDirection();
	SendMsgToMpl((BYTE*)(&sStruct), sizeof(TStreamOffReq), H323_RTP_STREAM_OFF_REQ);
	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SendStreamOnReq(CSipChannel* pChannel)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SendStreamOnReq");
	TStreamOnReq sStruct;
	sStruct.unChannelType		= ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel());
	sStruct.unChannelDirection	= pChannel->GetDirection();
	SendMsgToMpl((BYTE*)(&sStruct), sizeof(TStreamOnReq), H323_RTP_STREAM_ON_REQ);
	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::PartyMonitoringReq(int partyid_to_send)
{
	if (m_bIsMrcCall)
	{
		TRACEINTOFUNC << "MRC call";
		return MrcPartyMonitoringReq(partyid_to_send);
	}

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::PartyMonitoringReq : partyid_to_send=", partyid_to_send);
	TPartyMonitoringReq sStruct;
	sStruct.ulTipChannelPartyID = partyid_to_send;

	int partyRsrcId = GetHWInterface(H323_RTP_PARTY_MONITORING_REQ,FALSE)->GetPartyRsrcId();
	if( GetIsTipCall() && partyRsrcId != partyid_to_send )
		m_tipPartySlaveIdToMonitor = partyid_to_send;
	else
		m_tipPartySlaveIdToMonitor = 0;

	if (GetHWInterface(H323_RTP_PARTY_MONITORING_REQ,FALSE)->GetRsrcParams() != NULL)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::PartyMonitoringReq - send monitoring req");
		SendMsgToMpl((BYTE*)(&sStruct), sizeof(TPartyMonitoringReq), H323_RTP_PARTY_MONITORING_REQ);
		return 0;
	}
	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::PartyMonitoringReq - Party is not connected yet");
		return 1;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::PartyMonitoringForAvMcuReq(int partyid_to_send)
{


	PTRACE2INT(eLevelInfoNormal,"CSipCntl::PartyMonitoringForAvMcuReq : partyid_to_send=", partyid_to_send);
	cmPartyMonitoringAvMcuReq sStruct;
	memset(&sStruct, 0, sizeof(cmPartyMonitoringAvMcuReq));
	sStruct.bIsIceParty = m_IsEnableICE;
	//first thing we fill mux part (out streams) and first is main
	int lastMuxIndex = 0;
	for (int i=0; i < MAX_STREAM_MUX_LYNC_CONN; ++i)
	{
		if(m_LastAvMcuMux.txConnectedParties[i].unPartyId != 0 && m_LastAvMcuMux.txConnectedParties[i].unPartyId!= (DWORD) NUMERIC_NULL)
		{
				sStruct.DSPInfoList[i].unPartyId = m_LastAvMcuMux.txConnectedParties[i].unPartyId;
				lastMuxIndex = i;
		}
	}
	if(sStruct.DSPInfoList[0].unPartyId == 0)
	{
		sStruct.DSPInfoList[0].unPartyId = m_pMfaInterface->GetPartyRsrcId();
	}
	//now we fill in stream start from 1 as first is main which is already found from mux

	mcDmuxLync2013InfoReq* demuxInfo = m_pVsrControl->getDemuxInfo();
	for (int i = 1; i < MAX_STREAM_DMUX_LYNC_CONN; ++i)
	{
		if(demuxInfo->rxConnectedParties[i].unPartyId != 0 && demuxInfo->rxConnectedParties[i].unPartyId != (DWORD) NUMERIC_NULL && demuxInfo->rxConnectedParties[i].bIsActive == TRUE)
			sStruct.DSPInfoList[lastMuxIndex+i].unPartyId = demuxInfo->rxConnectedParties[i].unPartyId;

	}

	if (GetHWInterface(RTP_PARTY_MONITORING_AV_MCU_REQ,FALSE)->GetRsrcParams() != NULL)
	{
			PTRACE(eLevelInfoNormal,"CSipCntl::PartyMonitoringForAvMcuReq - send monitoring req");
			SendMsgToMpl((BYTE*)(&sStruct), sizeof(cmPartyMonitoringAvMcuReq), RTP_PARTY_MONITORING_AV_MCU_REQ);
			return 0;
	}
	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::PartyMonitoringForAvMcuReq - Party is not connected yet");
		return 1;
	}





}

////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::MrcPartyMonitoringReq(int partyid_to_send)
{
	TRACEINTOFUNC << "Partyid_to_send: " << partyid_to_send;

	MrmpPartyMonitoringReq sStruct;
	sStruct.unPartyID = partyid_to_send;

	if (GetHWInterface(CONF_PARTY_MRMP_PARTY_MONITORING_REQ,FALSE)->GetRsrcParams() != NULL)
	{
		SendMsgToMpl((BYTE*)(&sStruct), sizeof(TPartyMonitoringReq), CONF_PARTY_MRMP_PARTY_MONITORING_REQ);
		return 0;
	}
	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::MrcPartyMonitoringReq - Party is not connected yet");
		return 1;
	}
}
////////////////////////////////////////////////////////////////////////////////////////
//for CDR_MCCF feature: In SendRtpVideoChannelStatisticsReq we send a request to RTP to collect the statistics of video out + content out for DMA CDR sent by MCCF
BYTE CSipCntl::SendRtpVideoChannelStatisticsReq(int partyid_to_send)
{
	PTRACE2INT(eLevelInfoNormal,"CDR_MCCF: CSipCntl::SendRtpVideoChannelStatisticsReq : partyid_to_send=", partyid_to_send);

	TPartyMonitoringReq sStruct;
	BYTE ans = FALSE;

	sStruct.ulTipChannelPartyID = partyid_to_send;

	int partyRsrcId = GetHWInterface(RTP_PARTY_VIDEO_CHANNELS_STATISTICS_REQ,FALSE)->GetPartyRsrcId();

	if( GetIsTipCall() && partyRsrcId != partyid_to_send )
		m_tipPartySlaveIdToMonitor = partyid_to_send;
	else
		m_tipPartySlaveIdToMonitor = 0;


	if (GetHWInterface(RTP_PARTY_VIDEO_CHANNELS_STATISTICS_REQ,FALSE)->GetRsrcParams() != NULL)
	{
	    ans = SendMsgToMpl((BYTE*)(&sStruct), sizeof(TPartyMonitoringReq), RTP_PARTY_VIDEO_CHANNELS_STATISTICS_REQ);
	    StartTimer(IP_CM_PARTY_STATISTIC_INFO_IND_TOUT, 10*SECOND);
	}
	else
		PTRACE(eLevelInfoNormal,"CDR_MCCF: CSipCntl::SendRtpVideoChannelStatisticsReq - Party is not connected yet");

	return !ans;
}

///////////////////////////////////////////////////////////////////////////////////
// H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ instead of SIP_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ

mediaModeEnum CSipCntl::ConfigureMediaModeForParty(CSipChannel* pChannel,kChanneltype channelType)
{
	mediaModeEnum mediaMode = eMediaModeTranscoding;

	// set MediaMode
	if (m_bIsMrcCall)
	{
		// SVC
    /************************************************************************
    ART should know how to handle the media (MIX MODE):
    SVC ART:  video in - E_MEDIA_MODE_RELAY_AND_TRANSCODING
              audio in - E_MEDIA_MODE_RELAY_AND_TRANSCODING
              fecc in - E_MEDIA_MODE_RELAY_ONLY
              content in - E_MEDIA_MODE_TRANSCODING
              video out - E_MEDIA_MODE_RELAY_ONLY
              audio out - E_MEDIA_MODE_RELAY_ONLY
              fecc out - E_MEDIA_MODE_RELAY_ONLY
              content out - E_MEDIA_MODE_TRANSCODING
    ************************************************************************/

		mediaMode = eMediaModeRelayOnly;

		if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc &&
				pChannel->GetDirection()==cmCapReceive &&
				(channelType == kIpVideoChnlType || channelType == kIpAudioChnlType))
		{
			mediaMode = eMediaModeRelayAndTranscoding;
		}
		else if (channelType == kIpContentChnlType)
		{
			mediaMode = eMediaModeTranscoding;
		}
	}
	else
	{
		// to be done for AVC party mix mode
		mediaMode = eMediaModeTranscoding;
		if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc &&
			channelType == kIpVideoChnlType &&
			pChannel->GetDirection() == cmCapReceive)
		{
			if (m_pParty->GetTargetMode()->IsHdVswInMixMode())
				mediaMode = eMediaModeTranscodingAndVsw;
//	        const std::list <StreamDesc> streamsDescList = pChannel->GetStreams();
//	        std::list <StreamDesc>::const_iterator itr_streams;
//	        for (itr_streams=streamsDescList.begin(); itr_streams!=streamsDescList.end(); itr_streams++)
//	        {
//	        	if (itr_streams->m_isAvcToSvcVsw)
//					mediaMode = eMediaModeTranscodingAndVsw;
//	        }
		}

		if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvcVsw)
		{
			if (channelType == kIpVideoChnlType)
				mediaMode = eMediaModeVswMode;
		}
	}

	return mediaMode;
}

void CSipCntl::Rtp_FillAndSendUpdatePortOpenRtpStruct(CSipChannel* pChannel, BOOL isInternal, BYTE index)
{
	DWORD seqNum = 0;
	PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillAndSendUpdatePortOpenRtpStruct");
	TUpdatePortOpenRtpChannelReq* pStruct = new TUpdatePortOpenRtpChannelReq;
	memset(pStruct, 0, sizeof(TUpdatePortOpenRtpChannelReq));

	kChanneltype channelType = ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel());

	pStruct->bunIsRecovery      = FALSE;
	pStruct->unChannelType	    = channelType;
	pStruct->unChannelDirection = pChannel->GetDirection();
	pStruct->unCapTypeCode      = pChannel->GetAlgorithm();
	pStruct->unEncryptionType   = kUnKnownMediaType;
	memset(&(pStruct->aucSessionKey), '0', sizeOf128Key);

	pStruct->unSequenceNumber   = 0;	//EYAL???
	pStruct->unTimeStamp        = 0;	//EYAL???
	pStruct->unSyncSource       = 0;	//EYAL???

	pStruct->updateSsrcParams.unUpdatedSSRC		= 0;
	pStruct->updateSsrcParams.bReplaceSSRC		= FALSE;
	pStruct->updateSsrcParams.bDoNotChangeSsrc	= FALSE;

    pStruct->updateSsrcParams.unUpdatedCSRC=0;
    pStruct->updateSsrcParams.bReplaceCSRC=FALSE;

    pStruct->mediaMode = ConfigureMediaModeForParty(pChannel,channelType);

	if (!m_bIsMrcCall && m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvcVsw
		&& pChannel->GetDirection()==cmCapReceive)
	{
		APIU32* ssrcIds = NULL;
		int numOfSsrcIds = 0;

		if (pChannel->GetMediaType()==cmCapVideo)
		{
			m_pParty->GetTargetMode()->GetSsrcIds(cmCapVideo, cmCapReceive, ssrcIds, &numOfSsrcIds);

		  if (numOfSsrcIds)
		    {
		      pStruct->updateSsrcParams.unUpdatedSSRC = ssrcIds[0]; //m_pParty->GetSSRcIdsForAvc(0, cmCapReceive, cmCapVideo);
		      pStruct->updateSsrcParams.bReplaceSSRC=TRUE;
		    }
		}
		else if (pChannel->GetMediaType()==cmCapAudio)
		  {
		    m_pParty->GetTargetMode()->GetSsrcIds(cmCapAudio, cmCapReceive, ssrcIds, &numOfSsrcIds);

		    if (numOfSsrcIds)
		      {
			pStruct->updateSsrcParams.unUpdatedSSRC = ssrcIds[0];// m_pParty->GetSSRcIdsForAvc(0, cmCapReceive, cmCapAudio);
			pStruct->updateSsrcParams.bReplaceSSRC=TRUE;
		      }
		}

		delete[] ssrcIds;
		ssrcIds = NULL;
	}
	else if (!m_bIsMrcCall && isInternal)
    {
        // get the SSRC from the channel
        int i=0;
        const std::list <StreamDesc> streamsDescList = pChannel->GetStreams();
        std::list <StreamDesc>::const_iterator itr_streams;

        for (itr_streams=streamsDescList.begin(); itr_streams!=streamsDescList.end(); itr_streams++)
        {
            pStruct->updateSsrcParams.unUpdatedSSRC = itr_streams->m_pipeIdSsrc;
            pStruct->updateSsrcParams.bReplaceSSRC = TRUE;
            i++;
        }

        // sanity check
        if (i > 1)
        {
            pChannel->Dump("mix_mode: Something is wrong - more than one SSRC for the channel");
        }
    }

    bool bOpenArtVideoOutForMrcIvr = (m_bIsMrcCall &&
                                        (channelType == kIpVideoChnlType || channelType == kIpAudioChnlType) &&
                                        pChannel->IsDirection(cmCapTransmit) &&
                                        ::IsIvrForSVCEnabled() ) ? true : false;

    if (bOpenArtVideoOutForMrcIvr)
    {
    	const std::list <StreamDesc> streamsDescList = pChannel->GetStreams();

    	if (!streamsDescList.empty())
    	{
    	    if ((channelType == kIpVideoChnlType)||(channelType == kIpAudioChnlType))
    	    {
    	    	DWORD ivrSsrc = 0;

    	    	if(m_pParty->GetTargetMode())
    	    	{
    	    		if(channelType == kIpVideoChnlType)
    	    			ivrSsrc=m_pParty->GetTargetMode()->GetIvrSsrc(cmCapVideo);
    	    		else
    	    			ivrSsrc=m_pParty->GetTargetMode()->GetIvrSsrc(cmCapAudio);
    	    	}
    	    	else
    	    	{
    	    		PASSERT(1);
    	    	}

                pStruct->updateSsrcParams.unUpdatedSSRC = ivrSsrc;//streamsDescList.front().m_pipeIdSsrc - 1;
                pStruct->updateSsrcParams.bReplaceSSRC = TRUE;
                pStruct->updateSsrcParams.unUpdatedCSRC = IVR_CSRC;
                pStruct->updateSsrcParams.bReplaceCSRC = TRUE;
    	    }
    	 }
    }

	Rtp_FillUpdatePortOpenRtpChannelStruct(&pStruct->tUpdateRtpSpecificChannelParams, pChannel);

	if (!m_bIsMrcCall && IsChannelSupportLpr(pChannel))
	{
		lprCapCallStruct* plpCallStr = NULL;

		if (pStruct->unChannelDirection == cmCapTransmit)
		{
			SetLprOfRemoteCapsCapStruct(channelType);
			plpCallStr = m_pCall->GetLprCapStruct(1);//get lpr struct of remote and open transmit according to it
		}
		else
		{
			plpCallStr = m_pCall->GetLprCapStruct(0);
		}

		pStruct->tLprSpecificParams.bunLprEnabled = 1;
		pStruct->tLprSpecificParams.unVersionID = plpCallStr->versionID;
		pStruct->tLprSpecificParams.unMinProtectionPeriod = plpCallStr->minProtectionPeriod;
		pStruct->tLprSpecificParams.unMaxProtectionPeriod = plpCallStr->maxProtectionPeriod;
		pStruct->tLprSpecificParams.unMaxRecoverySet = plpCallStr->maxRecoverySet;
		pStruct->tLprSpecificParams.unMaxRecoveryPackets = plpCallStr->maxRecoveryPackets;
		pStruct->tLprSpecificParams.unMaxPacketSize = plpCallStr->maxPacketSize;
	}
	else
	{
	pStruct->tLprSpecificParams.bunLprEnabled = 0;
	pStruct->tLprSpecificParams.unVersionID = 0;
	pStruct->tLprSpecificParams.unMinProtectionPeriod = 0;
	pStruct->tLprSpecificParams.unMaxProtectionPeriod = 0;
	pStruct->tLprSpecificParams.unMaxRecoverySet = 0;
	pStruct->tLprSpecificParams.unMaxRecoveryPackets = 0;
	pStruct->tLprSpecificParams.unMaxPacketSize = 0;
  }

	if (pChannel->IsChannelDtlsEnabled()) //_dtls_
	{
		CDtlsCap* pDtlsCap = NULL;
		pDtlsCap  = pChannel->GetChannelDtls();
		CopySdesCapsFromClassToStruct(&pStruct->sdesCap, pDtlsCap );
		pStruct->unEncryptionType   = kAES_CTR; //BRIDGE-11023
	}
	else if (pChannel->IsChannelSdesEnabled())
	{
		CSdesCap* pSdesCap = NULL;
		pSdesCap = pChannel->GetChannelSdes();
		CopySdesCapsFromClassToStruct(&pStruct->sdesCap, pSdesCap);
		pStruct->unEncryptionType   = kAES_CTR; //BRIDGE-11023
	}
	else
	{
		pStruct->sdesCap.bIsSrtpInUse = 0;
	}

	if (m_pParty->GetTargetMode()->GetIsTipMode() && pStruct->unChannelDirection == cmCapTransmit)
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillAndSendUpdatePortOpenRtpStruct - mute tx channel");
		pChannel->Mute(TRUE);
	}

	if (!isInternal)
	{
		Rtp_FillMsftSvcParamsOnRtpStruct(pChannel, pStruct);
	}

	pStruct->bMuteStream = pChannel->IsMuted();

	pStruct->useRtcp = m_useRtcp;


	pStruct->useRtcp = TRUE;

CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	CConfParty* pConfParty = NULL;

	if (pCommConf)
	{
		pConfParty = pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());
	}


	if( MicrosoftEP_Lync_2013 == GetRemoteIdent() 	|| Microsoft_AV_MCU2013 == GetRemoteIdent() 	||
	    MicrosoftEP_R1 == GetRemoteIdent() 		|| MicrosoftEP_R2 == GetRemoteIdent() 		|| MicrosoftEP_Lync_R1 == GetRemoteIdent()||
	    MicrosoftEP_MAC == GetRemoteIdent() 	|| MicrosoftEP_MAC_Lync == GetRemoteIdent() 	||  Microsoft_AV_MCU == GetRemoteIdent()  ||
	    MicrosoftEP_Lync_CCS == GetRemoteIdent() ||
		 Microsoft_AV_MCU2013 == GetRemoteIdent() || ( pConfParty && eMsftAvmcuNone != pConfParty->GetMsftAvmcuState() ) )
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillMsftSvcParamsOnRtpStruct -lync/av-mcu 2013 client isrtcp is no");
		pStruct->useRtcp = FALSE;
	}



	// speakerIndication
	TRACEINTO << "speakerIndication - send H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ - IbmSametimeEp: " << (IsSameTimeEP() ? "yes" : "no" );
	pStruct->updateSsrcParams.bDoNotChangeSsrc = ( (IsSameTimeEP()) ? TRUE : FALSE );

	seqNum = SendMsgToMpl((BYTE*)(pStruct), sizeof(TUpdatePortOpenRtpChannelReq), H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ, isInternal, index);
	pChannel->SetSeqNumRtp(seqNum);
	PDELETE(pStruct);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::Rtp_FillMsftSvcParamsOnRtpStruct(CSipChannel* pChannel, TUpdatePortOpenRtpChannelReq* pStruct)
{
	if (m_isMs2013Active)
	{
		if (!m_bShouldMsftVideoTxStreamOn && pStruct->unChannelType == kIpVideoChnlType && pStruct->unChannelDirection == cmCapTransmit )
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillMsftSvcParamsOnRtpStruct - mute MSFT SVC tx channel");
			pChannel->Mute(TRUE);
		}

		DWORD unIndex = 1;
		if(pStruct->unCapTypeCode == eMsSvcCapCode  && pStruct->unChannelDirection == cmCapReceive )
		{
			unIndex = 1;
			if (IsMSSlaveInParty())
			{
				unIndex = GetMSSlavePartyIndex() + 1;
			}
			pStruct->updateSsrcParams.unMsFirstSyncSourceInRange = m_pLastRemoteCaps->getMsftSsrcVideoFirst(unIndex);
			pStruct->updateSsrcParams.unMsLastSyncSourceInRange = m_pLastRemoteCaps->getMsftSsrcVideoLast(unIndex);
			pStruct->updateSsrcParams.bReplaceSSRC = FALSE;
			pStruct->updateSsrcParams.unUpdatedSSRC = VSR_SOURCE_NONE;
			pStruct->updateSsrcParams.bReplaceCSRC = FALSE;
			pStruct->updateSsrcParams.unUpdatedCSRC = VSR_SOURCE_NONE;

		}
		else if(pStruct->unCapTypeCode == eMsSvcCapCode  && pStruct->unChannelDirection == cmCapTransmit )
		{
			pStruct->updateSsrcParams.unMsFirstSyncSourceInRange = m_pChosenLocalCap->getMsftSsrcVideoFirst(1);
			pStruct->updateSsrcParams.unMsLastSyncSourceInRange = m_pChosenLocalCap->getMsftSsrcVideoLast(1);
			pStruct->updateSsrcParams.bReplaceSSRC = FALSE;
			pStruct->updateSsrcParams.unUpdatedSSRC = VSR_SOURCE_NONE;
			pStruct->updateSsrcParams.bReplaceCSRC = FALSE;
			pStruct->updateSsrcParams.unUpdatedCSRC = VSR_SOURCE_NONE;
		}
		else if(pStruct->unCapTypeCode == eRtvCapCode  && pStruct->unChannelDirection == cmCapTransmit )
		{
			pStruct->updateSsrcParams.unMsFirstSyncSourceInRange = m_pChosenLocalCap->getMsftSsrcVideoFirst(1);
			pStruct->updateSsrcParams.unMsLastSyncSourceInRange = m_pChosenLocalCap->getMsftSsrcVideoLast(1);
			pStruct->updateSsrcParams.bReplaceSSRC = TRUE;
			pStruct->updateSsrcParams.unUpdatedSSRC = m_pChosenLocalCap->getMsftSsrcVideoFirst(1);
			pStruct->updateSsrcParams.bReplaceCSRC = FALSE;
			pStruct->updateSsrcParams.unUpdatedCSRC = VSR_SOURCE_NONE;
		}
		else if(pStruct->unCapTypeCode == eRtvCapCode  && pStruct->unChannelDirection == cmCapReceive )
		{
			unIndex = 1;
			if (IsMSSlaveInParty())
			{
				unIndex = GetMSSlavePartyIndex() + 1;
			}
			pStruct->updateSsrcParams.unMsFirstSyncSourceInRange = m_pLastRemoteCaps->getMsftSsrcVideoFirst(unIndex);
			pStruct->updateSsrcParams.unMsLastSyncSourceInRange = m_pLastRemoteCaps->getMsftSsrcVideoLast(unIndex);
			pStruct->updateSsrcParams.bReplaceSSRC = FALSE;
			pStruct->updateSsrcParams.unUpdatedSSRC = VSR_SOURCE_NONE;
			pStruct->updateSsrcParams.bReplaceCSRC = FALSE;
			pStruct->updateSsrcParams.unUpdatedCSRC = VSR_SOURCE_NONE;
		}
		else if(pStruct->unChannelType == kIpAudioChnlType  && pStruct->unChannelDirection == cmCapReceive )
		{
			pStruct->updateSsrcParams.unMsFirstSyncSourceInRange = m_pLastRemoteCaps->getMsftSsrcAudio();
			pStruct->updateSsrcParams.unMsLastSyncSourceInRange = m_pLastRemoteCaps->getMsftSsrcAudio();
			pStruct->updateSsrcParams.bReplaceSSRC = FALSE;
			pStruct->updateSsrcParams.unUpdatedSSRC = VSR_SOURCE_NONE;
		}
		else if(pStruct->unChannelType == kIpAudioChnlType  && pStruct->unChannelDirection == cmCapTransmit )
		{
			pStruct->updateSsrcParams.unMsFirstSyncSourceInRange = m_pChosenLocalCap->getMsftSsrcAudio();
			pStruct->updateSsrcParams.unMsLastSyncSourceInRange = m_pChosenLocalCap->getMsftSsrcAudio();
			pStruct->updateSsrcParams.bReplaceSSRC = TRUE;
			pStruct->updateSsrcParams.unUpdatedSSRC = m_pChosenLocalCap->getMsftSsrcAudio();
			pStruct->updateSsrcParams.bReplaceCSRC = FALSE;
			pStruct->updateSsrcParams.unUpdatedCSRC = VSR_SOURCE_NONE;
		}
	}
	else //not MSFT
	{
		pStruct->updateSsrcParams.unMsFirstSyncSourceInRange = VSR_SOURCE_NONE;
		pStruct->updateSsrcParams.unMsLastSyncSourceInRange = VSR_SOURCE_NONE;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::IsContent(APIU32 channelType, DWORD opcode)
{
    PTRACE2INT(eLevelInfoNormal,"CSipCntl::IsContent - channelType=", channelType);
    return (opcode == ART_CONTENT_ON_REQ || opcode == ART_CONTENT_OFF_REQ ||
            channelType == kIpContentChnlType);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::Rtp_FillUpdatePortOpenRtpChannelStruct(TUpdateRtpSpecificChannelParams* pUpdateRtpSpecificChannelParams, CSipChannel *pChannel)
{
	PASSERTMSG_AND_RETURN(!pChannel, "!pChannel");
	PASSERTMSG_AND_RETURN(!pUpdateRtpSpecificChannelParams, "!pUpdateRtpSpecificChannelParams");

	//init filed which are depends on dataType or on capEnum:
    pUpdateRtpSpecificChannelParams->bunIsH263Plus = 0;
    pUpdateRtpSpecificChannelParams->bunIsFlipIntraBit = 0;
    pUpdateRtpSpecificChannelParams->unAnnexesMask = 0;

    pUpdateRtpSpecificChannelParams->nHcMpiCif	   = -1;
    pUpdateRtpSpecificChannelParams->nHcMpiQCif   = -1;
    pUpdateRtpSpecificChannelParams->nHcMpi4Cif   = -1;
    pUpdateRtpSpecificChannelParams->nHcMpi16Cif  = -1;
    pUpdateRtpSpecificChannelParams->nHcMpiVga    = -1;
    pUpdateRtpSpecificChannelParams->nHcMpiNtsc   = -1;
    pUpdateRtpSpecificChannelParams->nHcMpiSvga   = -1;
    pUpdateRtpSpecificChannelParams->nHcMpiXga    = -1;
    pUpdateRtpSpecificChannelParams->nHcMpiSif    = -1;
    pUpdateRtpSpecificChannelParams->nHcMpiQvga   = -1;
    pUpdateRtpSpecificChannelParams->b32StreamRequiresEndOfFrameParsing = FALSE;

    pUpdateRtpSpecificChannelParams->unMaxFramesPerPacket = 0;
    pUpdateRtpSpecificChannelParams->unCustomMaxMbpsValue = 0;
    pUpdateRtpSpecificChannelParams->bunIsCCEnabled		  = NO;
	pUpdateRtpSpecificChannelParams->bunContentEnabled = 0;

	// fill Payload type fields
	// becuase of the mess of payload type, currently I'm recalculating it (the mess happened since in MGC the card allocate and send the payload type and our DB doesn't support doing it in the MCMS level)
	pUpdateRtpSpecificChannelParams->unPayloadType		= pChannel->GetPayloadType();

	if(pChannel->GetDirection() == cmCapTransmit)
		pUpdateRtpSpecificChannelParams->unDtmfPayloadType  = _UnKnown;// channel out has no DTMF payload type
	else
		pUpdateRtpSpecificChannelParams->unDtmfPayloadType  = pChannel->GetDtmfPayloadType();

	//fill general fields
	pUpdateRtpSpecificChannelParams->unBitRate		  = pChannel->GetCurrentRate();
	pUpdateRtpSpecificChannelParams->unDestMcuId	  = m_pParty->GetMcuNum();
	pUpdateRtpSpecificChannelParams->unDestTerminalId = m_pParty->GetTerminalNum();

	//fill specific fields
	channelSpecificParameters* pChannelParams = (channelSpecificParameters*)pChannel->GetData();
	cmCapDataType dataType = pChannel->GetMediaType();
	CapEnum capEnum = pChannel->GetAlgorithm();
	pUpdateRtpSpecificChannelParams->unPacketPayloadFormat = E_PACKET_PAYLOAD_FORMAT_SINGLE_UNIT;
	APIU8 profile = H264_Profile_BaseLine;

    // Adding traffic shaping to non-tip calls
    if (!GetIsTipCall()) UpdateTrafficShapingParams(*pUpdateRtpSpecificChannelParams, m_bIsMrcCall);

	if (dataType == cmCapVideo)
	{
	    CBaseVideoCap *pBaseVideoCap = (CBaseVideoCap*)CBaseCap::AllocNewCap(capEnum,(BYTE*)pChannelParams);

	    if (!pBaseVideoCap)
	    {
	        PTRACE(eLevelError, "CSipCntl::Rtp_FillUpdatePortOpenRtpChannelStruct - pBaseVideoCap is NULL!!");
	        DBGPASSERT(1119);
	        return;
	    }

		//fill bunIsH263Plus & unAnnexesAndResolutionMask
		if (capEnum == eH263CapCode)
		{
			BYTE bIsH263Plus = FALSE;

			if (bIsH263Plus == FALSE)
				bIsH263Plus = pChannel->IsChannelDynamicPayloadType();

			// Video encoder does not support H263+. For those EPs that support both H263+ and H263, we send H263.
			// For those EPs that support H263+ only, we set RTP support H263+(while the encoder is still H263).
		    if (pChannel->GetDirection() == cmCapTransmit && pChannel->GetRoleLabel() != kRolePresentation)
		    {
		    	BYTE bIsRmtRcvH263DynPTOnly = m_pLastRemoteCaps->IsH263DynamicPayloadTypeOnly(kRolePeople);

		    	if (bIsRmtRcvH263DynPTOnly)
		    	{
		    		pUpdateRtpSpecificChannelParams->bunIsH263Plus = TRUE;
		    	}
		    	else
		    	{
		    		pUpdateRtpSpecificChannelParams->bunIsH263Plus = FALSE;
		    		pUpdateRtpSpecificChannelParams->unPayloadType = _H263;
		    	}
		    }
		    else
		    {
	            pUpdateRtpSpecificChannelParams->bunIsH263Plus = bIsH263Plus;
		    }

			memcpy(&(pUpdateRtpSpecificChannelParams->unAnnexesMask),
				&(pChannelParams->p263.annexesMask),
				sizeof(pUpdateRtpSpecificChannelParams->unAnnexesMask));

			if (pChannel->GetRoleLabel() != kRolePresentation) // in content we support annex
				DBGPASSERT((DWORD)pChannelParams->p263.annexesMask.fds_bits[0]);// the annex mask should be zero in SIP

			if (pChannel->GetDirection() == cmCapTransmit)
			{
				if (GetSystemCfgFlagInt<BOOL>(m_serviceId, CFG_KEY_SIP_FLIP_INTRA_ENV))// old MC Environment bug
					pUpdateRtpSpecificChannelParams->bunIsFlipIntraBit = 1;
				else if	(GetSystemCfgFlagInt<BOOL>(m_serviceId, CFG_KEY_SIP_FLIP_INTRA_EP)
					&& (m_remoteIdent == MicrosoftEP_R1))// specific old MOC bug
				{
					pUpdateRtpSpecificChannelParams->bunIsFlipIntraBit = 1;
				}
			}
		}

		//fill mpi
		pUpdateRtpSpecificChannelParams->nHcMpiCif	 = pBaseVideoCap->GetFormatMpi(kCif);
		pUpdateRtpSpecificChannelParams->nHcMpiQCif  = pBaseVideoCap->GetFormatMpi(kQCif);
		pUpdateRtpSpecificChannelParams->nHcMpi4Cif  = pBaseVideoCap->GetFormatMpi(k4Cif);
		pUpdateRtpSpecificChannelParams->nHcMpi16Cif = pBaseVideoCap->GetFormatMpi(k16Cif);
		pUpdateRtpSpecificChannelParams->nHcMpiVga   = pBaseVideoCap->GetFormatMpi(kVGA);
		pUpdateRtpSpecificChannelParams->nHcMpiNtsc  = pBaseVideoCap->GetFormatMpi(kNTSC);
		pUpdateRtpSpecificChannelParams->nHcMpiSvga  = pBaseVideoCap->GetFormatMpi(kSVGA);
		pUpdateRtpSpecificChannelParams->nHcMpiXga   = pBaseVideoCap->GetFormatMpi(kXGA);
		pUpdateRtpSpecificChannelParams->nHcMpiSif   = pBaseVideoCap->GetFormatMpi(kSIF);
		pUpdateRtpSpecificChannelParams->nHcMpiQvga  = pBaseVideoCap->GetFormatMpi(kQVGA);

		//fill unCustomMaxMbpsValue
		if (capEnum == eH264CapCode)
		{
			APIS32 mbps = pChannelParams->p264.customMaxMbpsValue;

			if (mbps == -1)
			{
				APIU8 level = pChannelParams->p264.levelValue;
				CH264Details h264Details = level;
				mbps = h264Details.GetDefaultMbpsAsProduct();//we send the product to the card
			}
			else
				mbps = ::ConvertMaxMbpsToProduct(mbps);//we send the product to the card

			pUpdateRtpSpecificChannelParams->unCustomMaxMbpsValue = mbps;

			profile = pChannelParams->p264.profileValue;
			if ((profile == H264_Profile_High) || (profile == H264_Profile_Main))// TIP
				pUpdateRtpSpecificChannelParams->unPacketPayloadFormat = E_PACKET_PAYLOAD_FORMAT_FRAGMENTATION_UNIT;
		}

		if(NULL == pChannelParams){
			pBaseVideoCap->FreeStruct();
		}

		POBJDELETE(pBaseVideoCap);
	}

	if (dataType == cmCapAudio)
	{
		CBaseAudioCap *pBaseAudioCap = (CBaseAudioCap*)CBaseCap::AllocNewCap(capEnum,(BYTE*)pChannelParams);

	    if (pBaseAudioCap)
	    {
			pUpdateRtpSpecificChannelParams->unMaxFramesPerPacket = pBaseAudioCap->GetMaxFramePerPacket();

			if(NULL == pChannelParams){
				pBaseAudioCap->FreeStruct();
			}

			POBJDELETE(pBaseAudioCap);
	    }
	    else
	        PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillUpdatePortOpenRtpChannelStruct - pBaseAudioCap is NULL");

		if(pChannel->GetDirection() == cmCapReceive)
		{
			//if SRTP - Patch
			if(pChannel->IsChannelSdesEnabled() && pChannel->GetChannelSdes() )
			{	//If MOC R2 or Lync or MOC R1
				if((m_remoteIdent == MicrosoftEP_R2) || (m_remoteIdent == MicrosoftEP_Lync_R1)  || m_remoteIdent == MicrosoftEP_Lync_2013 ||(m_remoteIdent == MicrosoftEP_R1) || (m_remoteIdent == MicrosoftEP_MAC) || (m_remoteIdent == MicrosoftEP_MAC_Lync))
					pUpdateRtpSpecificChannelParams->bunIsFlipIntraBit = 2;
			}
		}
	}

	if (dataType == cmCapData)
	{
		if((pChannel->GetPayloadType() == _AnnexQ) || (pChannel->GetPayloadType() == _RvFecc) || (pChannel->GetPayloadType() == 0))
			pUpdateRtpSpecificChannelParams->unPayloadType = 254;// currently we can't do new H file definition.

		// eanbled disabled close caption (indication going over the FECC channel)
		BOOL IsEnabledCloseCaption = NO;
		CSysConfig* pSysConfig = CProcessBase::GetProcess()->GetSysConfig();
		pSysConfig->GetBOOLDataByKey("ENABLE_CLOSED_CAPTION", IsEnabledCloseCaption);

		if(IsEnabledCloseCaption)
			pUpdateRtpSpecificChannelParams->bunIsCCEnabled		  = 1;
	}

	if (pChannel->IsChannelType(VIDEO_CONT_OUT))
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::Rtp_FillUpdatePortOpenRtpChannelStruct, m_eContentOutState=", m_eContentOutState);

		if(m_eContentOutState == eNoChannel)
			m_eContentOutState = eSendStreamOff; // the channel is opened with StreamOff by default
		else if(m_eContentOutState == eWaitToSendStreamOn)  //After receiving party in conf.
		{
			pUpdateRtpSpecificChannelParams->bunContentEnabled = (APIU32)eStreamOn;
			m_eContentOutState = eSendStreamOn;
		}
		else if ((m_eContentOutState == eStreamOn) || (m_eContentOutState == eSendStreamOn)) /* AVAYA-1303 */
		{
			/* In case stream is on, keep channel parameters ContentEnabled at "ON" state. */
			pUpdateRtpSpecificChannelParams->bunContentEnabled = (APIU32)eStreamOn;
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::Rtp_FillUpdatePortOpenRtpChannelStruct, ContentEnabled=", pUpdateRtpSpecificChannelParams->bunContentEnabled);
		}
	}

	if (pChannel->IsChannelType(VIDEO_CONT_IN) && (m_eContentInState == eNoChannel))
		m_eContentInState = eSendStreamOff;

	if (pChannel->IsChannelType(VIDEO_CONT_IN) || pChannel->IsChannelType(VIDEO_CONT_OUT))
		pUpdateRtpSpecificChannelParams->unBitRate = m_fullContentRate;

	// TIP
	BYTE bIsTip = FALSE;
	if (((dataType == cmCapAudio) && (capEnum == eAAC_LDCapCode)) ||
		((dataType == cmCapVideo) && (capEnum == eH264CapCode) && (profile == H264_Profile_Main)) ||
		((dataType == cmCapVideo) && (capEnum == eH264CapCode) && (profile == H264_Profile_BaseLine) && m_pParty->GetTargetMode()->GetIsTipMode() ) ||
		((dataType == cmCapVideo) && (pChannel->GetRoleLabel() & kRoleContentOrPresentation)))
	{
		if (GetIsTipCall())
		{
			bIsTip = TRUE;
			pUpdateRtpSpecificChannelParams->openTipPortParams.bnTipIsEnabled 	= TRUE;
			pUpdateRtpSpecificChannelParams->openTipPortParams.eTipPosition		= m_pParty->GetTipPartyTypeAndPosition();
			if (pChannel->IsChannelType(VIDEO_CONT_IN) || pChannel->IsChannelType(VIDEO_CONT_OUT))
				pUpdateRtpSpecificChannelParams->openTipPortParams.eTipPosition = eTipVideoAux;
		}
	}

	if (!bIsTip)
	{
		pUpdateRtpSpecificChannelParams->openTipPortParams.bnTipIsEnabled 		= FALSE;
		pUpdateRtpSpecificChannelParams->openTipPortParams.eTipPosition			= eTipNone;
	}

	PTRACE2INT(eLevelInfoNormal, "CSipCntl::Rtp_FillUpdatePortOpenRtpChannelStruct, TIP position:", pUpdateRtpSpecificChannelParams->openTipPortParams.eTipPosition);
	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	CConfParty* pConfParty = NULL;

	if (pCommConf)
	{
		pConfParty = pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());
	}

	if (dataType == cmCapVideo || dataType == cmCapAudio ) //per Anat E. request
	{
		if (eMsft2013LyncClient == m_isMs2013Active)
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillUpdatePortOpenRtpChannelStruct, unMsftClient is LYNC 2013 client");
			pUpdateRtpSpecificChannelParams->unMsftClient 		= MSFT_CLIENT_LYNC2013;
		}
		else if (m_remoteIdent == MicrosoftEP_R1 || m_remoteIdent == MicrosoftEP_R2 || m_remoteIdent == MicrosoftEP_MAC)
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillUpdatePortOpenRtpChannelStruct, unMsftClient is MOC");
			pUpdateRtpSpecificChannelParams->unMsftClient 		= MSFT_CLIENT_MOC;
		}
		else if (m_remoteIdent == MicrosoftEP_Lync_R1  || m_remoteIdent == MicrosoftEP_Lync_2013 || m_remoteIdent == MicrosoftEP_MAC_Lync )
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillUpdatePortOpenRtpChannelStruct, unMsftClient is Lync");
			pUpdateRtpSpecificChannelParams->unMsftClient 		= MSFT_CLIENT_LYNC;
		}
		else if( ( pConfParty && eMsftAvmcu2013 == pConfParty->GetMsftAvmcuState() ) ||  eMsft2013AvMCU == m_isMs2013Active )  //if cccp av-mcu 2013 only then it is 2013 av -mcu -this condition needs to be before the next condition
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillUpdatePortOpenRtpChannelStruct, unMsftClient is AVMCU 2013 ");
			pUpdateRtpSpecificChannelParams->unMsftClient 		= MSFT_CLIENT_AVMCU2013;
		}
		else if (m_remoteIdent == Microsoft_AV_MCU ||  ( pConfParty && eMsftAvmcu2010 == pConfParty->GetMsftAvmcuState() ) ||  m_remoteIdent == Microsoft_AV_MCU2013 ) //av-mcu 2010 or av-mcu 20113 connecting as non cccp rtv call
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillUpdatePortOpenRtpChannelStruct, unMsftClient is AVMCU");
			pUpdateRtpSpecificChannelParams->unMsftClient 		= MSFT_CLIENT_AVMCU;
		}
		else
		{
			pUpdateRtpSpecificChannelParams->unMsftClient 		= MSFT_CLIENT_DUMMY;
		}
	}

	//LYNC2013_FEC_RED:
	pUpdateRtpSpecificChannelParams->bIsFecRedOn = FALSE;
	if (pChannel && pChannel->GetMediaType()==cmCapVideo)
		pUpdateRtpSpecificChannelParams->unFecRedPayloadType = eFECDynamicPayload;
	if (pChannel && pChannel->GetMediaType()==cmCapAudio)
		pUpdateRtpSpecificChannelParams->unFecRedPayloadType = eREDDynamicPayload;

	if(!m_bIsMrcCall && pChannel && pChannel->GetMediaType()==cmCapVideo && IsChannelSupportFec(pChannel))
	{
		TRACEINTO << "LYNC2013_FEC_RED: is FEC supported ? YES, payload:" << (DWORD)pChannel->GetFecPayloadType();

		pUpdateRtpSpecificChannelParams->bIsFecRedOn = TRUE;
		pUpdateRtpSpecificChannelParams->unFecRedPayloadType = pChannel->GetFecPayloadType(); //eFECDynamicPayload;
	}
	else
	{
		if (pChannel && pChannel->GetMediaType()==cmCapVideo)
			TRACEINTO << "LYNC2013_FEC_RED: is FEC supported ? NO";
		if(!m_bIsMrcCall && pChannel && pChannel->GetMediaType()==cmCapAudio && IsChannelSupportRed(pChannel))
		{
			TRACEINTO << "LYNC2013_FEC_RED: is RED supported ? YES";

			pUpdateRtpSpecificChannelParams->bIsFecRedOn = TRUE;
			pUpdateRtpSpecificChannelParams->unFecRedPayloadType = pChannel->GetRedPayloadType(); //eREDDynamicPayload;
		}
		else if (pChannel && pChannel->GetMediaType()==cmCapAudio)
			TRACEINTO << "LYNC2013_FEC_RED: is RED supported ? NO";
	}

}

////////////////////////////////////////////////////////////////////////////
// H323_RTP_UPDATE_CHANNEL_REQ instead of SIP_RTP_UPDATE_CHANNEL_REQ
void CSipCntl::Rtp_FillAndSendUpdateRtpChannelStruct(CSipChannel *pChannel)
{
	DWORD seqNum = 0;
	PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillAndSendUpdateRtpChannelStruct");
	TUpdateRtpChannelReq* pStruct = new TUpdateRtpChannelReq;
	memset(pStruct, 0, sizeof(TUpdateRtpChannelReq));

	pStruct->unChannelType	    = ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel());
	pStruct->unChannelDirection = pChannel->GetDirection();
    pStruct->mediaMode = ConfigureMediaModeForParty(pChannel, (kChanneltype)pStruct->unChannelType);
	Rtp_FillUpdatePortOpenRtpChannelStruct(&pStruct->tUpdateRtpSpecificChannelParams, pChannel);

	if (pChannel->IsChannelDtlsEnabled()) //_dtls_
	{
		CDtlsCap* pDtlsCap = NULL;
		pDtlsCap  = pChannel->GetChannelDtls();
		CopySdesCapsFromClassToStruct(&pStruct->sdesCap, pDtlsCap );
		pStruct->unEncryptionType   = kAES_CTR; //BRIDGE-11023
	}
	else if (pChannel->IsChannelSdesEnabled())
	{
		CSdesCap* pSdesCap = NULL;
		pSdesCap = pChannel->GetChannelSdes();
		CopySdesCapsFromClassToStruct(&pStruct->sdesCap, pSdesCap);
		pStruct->unEncryptionType   = kAES_CTR; //BRIDGE-11023
	}
	else
	{
		pStruct->sdesCap.bIsSrtpInUse = 0;
	}

	seqNum = SendMsgToMpl((BYTE*)(pStruct), sizeof(TUpdateRtpChannelReq), H323_RTP_UPDATE_CHANNEL_REQ);
	pChannel->SetSeqNumRtp(seqNum);
	PDELETE(pStruct);
}

////////////////////////////////////////////////////////////////////////////
// H323_RTP_UPDATE_CHANNEL_RATE_REQ instead of SIP_RTP_UPDATE_CHANNEL_RATE_REQ
void CSipCntl::Rtp_FillAndSendUpdateRtpChannelRateStruct(CSipChannel *pChannel)
{
	PTRACE(eLevelInfoNormal, "CSipCntl::Rtp_FillAndSendUpdateRtpChannelRateStruct");
	TUpdateRtpChannelRateReq* pStruct = new TUpdateRtpChannelRateReq;
	pStruct->unChannelType	    = ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel());
	pStruct->unChannelDirection = pChannel->GetDirection();
	pStruct->unNewChannelRate   = pChannel->GetCurrentRate();

	SendMsgToMpl((BYTE*)(pStruct), sizeof(TUpdateRtpChannelRateReq), H323_RTP_UPDATE_CHANNEL_RATE_REQ);
	PDELETE(pStruct);
}


////////////////////////////////////////////////////////////////////////////
/*									 CM				                  */
////////////////////////////////////////////////////////////////////////////
void CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStructInChannels(CSipChannel *pChannel, BYTE isUpdate)
{
	//we open incoming channel resources before there are any incoming channels so the address in NULL
	mcTransportAddress rmtAddress;
	memset(&rmtAddress, 0, sizeof(mcTransportAddress));
	APIU32 rmtRtcpPort = 0;
	CSipChannel* pChannelEx=NULL;
	int chnType=OPEN_CHANNEL_NORMAL_MODE;

	if(m_bIsMrcCall)
	{
		OpenSvcChannel(pChannel, rmtAddress, rmtRtcpPort,chnType, isUpdate);
	}
	else
	{
		Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct(pChannel, rmtAddress, rmtRtcpPort, isUpdate);

		pChannelEx = ShouldOpenMRMPAvcChannel(pChannel,chnType);

		if (pChannelEx && isUpdate==FALSE)
		{// do not send MRMP_UPDATE for internal channels
			OpenSvcChannel(pChannelEx, rmtAddress, rmtRtcpPort,chnType, isUpdate);
	}
	}
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStructOutChannels(CSipChannel *pChannel, BYTE isUpdate)
{
	eMediaLineInternalType mlineInternalType = GetMediaLineInternalType(pChannel->GetMediaType(), pChannel->GetRoleLabel());
	BYTE confIsEncrypted = FALSE;
	int chnType=OPEN_CHANNEL_NORMAL_MODE;

	if (m_pParty->GetTargetMode()->GetIsEncrypted() == Encryp_On && pChannel->IsMediaChannel())
	{
		confIsEncrypted = TRUE;
		PTRACE(eLevelInfoNormal,"Encryp_On");
	}

	APIU32 rmtRtcpPort = 0;
	//for ANAT
	int	index = -1;
	BOOL isANATContained = IsANATPresentInSDP(m_pRemoteSdp);
	if (isANATContained)  //need the condition "isUpdate=NO"?
	{
		index = GetIndexAccordingToInternalTypeAndIpVersion(mlineInternalType, m_pRemoteSdp, m_AnatSelectedIpVersion);
	}

	rmtRtcpPort = ExtractMLineRtcpPort(mlineInternalType, (const sipSdpAndHeadersSt *)m_pRemoteSdp, rmtRtcpPort, confIsEncrypted, index);
	mcTransportAddress rmtAddress = ExtractMLineMediaIp(mlineInternalType, (const sipSdpAndHeadersSt *)m_pRemoteSdp, m_dummyMediaIp, confIsEncrypted, index).transAddr;
//  rmtRtcpPort = pChannel->GetRtcpPort();
//	rmtAddress = pChannel->GetAddress();
	CSipChannel* pChannelEx=NULL;
//	memcpy(&rmtAddress, &(pChannel->GetAddress()), sizeof(mcTransportAddress));
	if(m_bIsMrcCall)
	{
		OpenSvcChannel(pChannel, rmtAddress, rmtRtcpPort,chnType, isUpdate);
	}
	else
	{
		Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct(pChannel, rmtAddress, rmtRtcpPort, isUpdate);

		pChannelEx = ShouldOpenMRMPAvcChannel(pChannel,chnType);
		if( pChannelEx && isUpdate==FALSE)
		{// do not send MRMP_UPDATE for internal channels
			OpenSvcChannel(pChannelEx, rmtAddress, rmtRtcpPort,chnType, isUpdate);
		}
	}
}

////////////////////////////////////////////////////////////////////////////
// CONFPARTY_CM_OPEN_UDP_PORT_REQ instead of SIP_CM_OPEN_UDP_PORT_REQ
// CONFPARTY_CM_UPDATE_UDP_ADDR_REQ instead of SIP_CM_UPDATE_UDP_ADDR_REQ
void CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct(CSipChannel *pChannel, mcTransportAddress &rmtAddress, APIU32 rmtRtcpPort, BYTE isUpdate)
{
	char s[50];
	DWORD seqNum = 0;

	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());

	ETipPartyTypeAndPosition tipPartyType = m_pParty->GetTipPartyTypeAndPosition();
	/* Flora comment: for MSSlave, just do the same with Tip, do not send Msg, and set the state to connected. */
	if( tipPartyType == eTipSlaveLeft || tipPartyType == eTipSlaveRigth || tipPartyType == eTipSlaveAux
		 || IsMSSlaveParty())
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct: slave party - UDP ports should not be opened ");
		pChannel->SetConnectionState(kConnected);
		pChannel->SetCmConnectionState(kConnected);
		return;
	}
	else if (GetIsTipCall() && ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel())==kIpContentChnlType)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct: Video Auxiliary - UDP ports should not be opened ");
		pChannel->SetCmConnectionState(kConnected);
		return;
	}

	sprintf(s, "dest address is 0x%x", rmtAddress.addr.v4.ip);
	PTRACE2(eLevelInfoNormal,"CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct, ", s);

	TOpenUdpPortOrUpdateUdpAddrMessageStruct localStruct;
	TOpenUdpPortOrUpdateUdpAddrMessageStruct* pStruct = &localStruct;

	memset(pStruct, 0, sizeof(TOpenUdpPortOrUpdateUdpAddrMessageStruct));

	mcReqCmOpenUdpPortOrUpdateUdpAddr* pUdpSt  = &pStruct->tCmOpenUdpPortOrUpdateUdpAddr;

	if (!pUdpSt)
	{
		DBGPASSERT_AND_RETURN(1);
	}

	pUdpSt->channelType		 = ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel());
	pUdpSt->channelDirection = pChannel->GetDirection();

	if (pCommConf)
		pUdpSt->uRtpKeepAlivePeriod = pCommConf->GetNatKAPeriod();
	else
		PASSERTMSG(1, "GetCurrentConf return NULL");

	if (m_UserAgent && strstr(m_UserAgent, "TANDBERG/81")) // BRIDGE-4550
	{
		pUdpSt->uRtpKeepAlivePeriod = 0;
		PTRACE2(eLevelError, "CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct: Setting RTP KeepAlive for MXP to 0 otherwise no media. name : ", PARTYNAME);
	}

	//fill local address
	// IpV6
	enIpVersion eIpAddrMatch = GetIpAddrMatch();

	pUdpSt->CmLocalUdpAddressIp.ipVersion = eIpAddrMatch;

	bool bIsLocalAddressIpV4 = ((pUdpSt->CmLocalUdpAddressIp.ipVersion == (APIU32)eIpVersion4) ? true : false);

	if (true == bIsLocalAddressIpV4) //v4
	{
		pUdpSt->CmLocalUdpAddressIp.addr.v4.ip = m_UdpAddressesParams.IpV4Addr.ip;
	}
	else
	{
		// --- UDP: array of addresses ---
		// First we will look for the best IpV6 address match -> Meaning we will match ScopeId's
		BYTE place = FindMatchingIpV6MediaAddressByScopeId();
		memcpy(pUdpSt->CmLocalUdpAddressIp.addr.v6.ip, m_UdpAddressesParams.IpV6AddrArray[place].ip, 16);
		pUdpSt->CmLocalUdpAddressIp.addr.v6.scopeId = m_UdpAddressesParams.IpV6AddrArray[place].scopeId;
	}

	// TIP case
	pUdpSt->bIsTipEnable = GetIsTipCall() ;

	if (pChannel->GetMediaType() == cmCapBfcp && m_pSipBfcpCtrl)
	{
		pUdpSt->CmLocalUdpAddressIp.transportType = m_pSipBfcpCtrl->GetBfcpTransportType();
		pUdpSt->connMode = m_pSipBfcpCtrl->GetBfcpConnMode();
	}
	else
	{
		pUdpSt->CmLocalUdpAddressIp.transportType = eTransportTypeUdp;
		pUdpSt->connMode = eUdp;
	}

	//fill remote address
	pUdpSt->CmRemoteUdpAddressIp.ipVersion = eIpAddrMatch;

    bool bIsRemoteAddressIpV4 = ((pUdpSt->CmRemoteUdpAddressIp.ipVersion == (APIU32)eIpVersion4) ? true : false);

    if (true == bIsRemoteAddressIpV4) //v4
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruc remote address type is Ipv4");
		pUdpSt->CmRemoteUdpAddressIp.addr.v4.ip = rmtAddress.addr.v4.ip;
	}
	else
	{
		memcpy(pUdpSt->CmRemoteUdpAddressIp.addr.v6.ip, rmtAddress.addr.v6.ip, 16);
		pUdpSt->CmRemoteUdpAddressIp.addr.v6.scopeId = rmtAddress.addr.v6.scopeId;
	}

	// send to trace (local and remote addresses)
	if (bIsLocalAddressIpV4 && bIsRemoteAddressIpV4)
	{
		TRACEINTOFUNC << "Local address type: IPv4, remote address type: IPv4";
	}

	else
	{
		TRACEINTOFUNC
			<< "Local address type: " << ( bIsLocalAddressIpV4 ? "IPv4" : "IPv6" )
			<< ", remote address type: " << ( bIsRemoteAddressIpV4 ? "IPv4" : "IPv6" );

		if (!bIsLocalAddressIpV4)
		{
			BYTE place = FindMatchingIpV6MediaAddressByScopeId();
			TRACEINTOFUNC << "Local address type: Ipv6, place: " << place;
		}

		if (!bIsRemoteAddressIpV4)
		{
			TRACEINTOFUNC << "Remote address type: Ipv6, scope: " << rmtAddress.addr.v6.scopeId;
		}
	}

	//fill fields for both local and remote addresses
	pUdpSt->CmLocalUdpAddressIp.distribution  = eDistributionUnicast;// Don't Care
	pUdpSt->CmRemoteUdpAddressIp.distribution = eDistributionUnicast;// Don't Care

	if (pChannel->GetMediaType() == cmCapBfcp && m_pSipBfcpCtrl)
		pUdpSt->CmRemoteUdpAddressIp.transportType = m_pSipBfcpCtrl->GetBfcpTransportType();
	else
		pUdpSt->CmRemoteUdpAddressIp.transportType = eTransportTypeUdp;

	pUdpSt->ice_channel_rtp_id = 0;
	pUdpSt->ice_channel_rtcp_id = 0;

	cmCapDataType dataType = pChannel->GetMediaType();
	ERoleLabel eRole = pChannel->GetRoleLabel();

	switch (dataType)
	{
		case cmCapAudio:
		{
			pUdpSt->CmLocalUdpAddressIp.port  = m_UdpAddressesParams.AudioChannelPort;
			pUdpSt->CmRemoteUdpAddressIp.port = rmtAddress.port;
			pUdpSt->LocalRtcpPort			  = m_UdpAddressesParams.AudioChannelPort + 1;
			pUdpSt->RemoteRtcpPort			  = rmtRtcpPort;

			// AN: vngfe-4438: add && m_pIceParams
			if (GetIsEnableICE() && m_pIceParams)
			{
				pUdpSt->ice_channel_rtp_id = m_pIceParams->GetAudioRtpId();
				pUdpSt->ice_channel_rtcp_id = m_pIceParams->GetAudioRtcpId();
			}

		break;
		}
		case cmCapVideo:
		{
			if (eRole == kRolePeople)
			{
				pUdpSt->CmLocalUdpAddressIp.port  = m_UdpAddressesParams.VideoChannelPort;
				pUdpSt->CmRemoteUdpAddressIp.port = rmtAddress.port;
				pUdpSt->LocalRtcpPort			  = m_UdpAddressesParams.VideoChannelPort + 1;
				pUdpSt->RemoteRtcpPort			  = rmtRtcpPort;

				// AN: vngfe-4438: add && m_pIceParams
				if (GetIsEnableICE() && m_pIceParams)
				{
					pUdpSt->ice_channel_rtp_id = m_pIceParams->GetVideoRtpId();
					pUdpSt->ice_channel_rtcp_id = m_pIceParams->GetVideoRtcpId();
				}
			}
			else
			{
				pUdpSt->CmLocalUdpAddressIp.port  = m_UdpAddressesParams.ContentChannelPort;
				pUdpSt->CmRemoteUdpAddressIp.port = rmtAddress.port;
				pUdpSt->LocalRtcpPort			  = m_UdpAddressesParams.ContentChannelPort + 1;
				pUdpSt->RemoteRtcpPort			  = rmtRtcpPort;

				// AN: vngfe-4438: add && m_pIceParams
				if (GetIsEnableICE() && m_pIceParams)
				{
					pUdpSt->ice_channel_rtp_id = m_pIceParams->GetContentRtpId();
					pUdpSt->ice_channel_rtcp_id = m_pIceParams->GetContentRtcpId();
				}
			}

			break;
		}
		case cmCapData:
		{
			pUdpSt->CmLocalUdpAddressIp.port  = m_UdpAddressesParams.FeccChannelPort;
			pUdpSt->CmRemoteUdpAddressIp.port = rmtAddress.port;
			pUdpSt->LocalRtcpPort			  = m_UdpAddressesParams.FeccChannelPort + 1;
			pUdpSt->RemoteRtcpPort			  = rmtRtcpPort;

			// AN: vngfe-4438: add && m_pIceParams
			if (GetIsEnableICE() && m_pIceParams)
			{
				pUdpSt->ice_channel_rtp_id = m_pIceParams->GetDataRtpId();
				pUdpSt->ice_channel_rtcp_id = m_pIceParams->GetDataRtcpId();
			}

			break;
		}
		case cmCapBfcp:
		{
			if (m_pSipBfcpCtrl && (m_pSipBfcpCtrl->GetBfcpConnMode()== eTcpPassive))
			{
				pUdpSt->LocalRtcpPort = BFCP_TCP_RTCP_PORT;

				if (bIsLocalAddressIpV4)	pUdpSt->CmLocalUdpAddressIp.port  = BFCP_IPV4_TCP_PORT;
				else						pUdpSt->CmLocalUdpAddressIp.port  = BFCP_IPV6_TCP_PORT;
			}
			else
			{
				pUdpSt->CmLocalUdpAddressIp.port  = m_UdpAddressesParams.BfcpChannelPort;
				pUdpSt->LocalRtcpPort			  = m_UdpAddressesParams.BfcpChannelPort + 1;
			}

			pUdpSt->CmRemoteUdpAddressIp.port = rmtAddress.port;
			pUdpSt->RemoteRtcpPort			  = rmtRtcpPort;
			pUdpSt->uRtpKeepAlivePeriod		  = 0; /* disabled */

			break;
		}
		default:
			pUdpSt->CmLocalUdpAddressIp.port  = 0;
			pUdpSt->CmRemoteUdpAddressIp.port = 0;
			pUdpSt->LocalRtcpPort			  = 0;
			pUdpSt->RemoteRtcpPort			  = 0;
			break;
	}

	if (pUdpSt->uRtpKeepAlivePeriod)
		PTRACE2INT(eLevelInfoNormal, "Setting RTP KeepAlive uRtpKeepAlivePeriod=", pUdpSt->uRtpKeepAlivePeriod);

	pChannel->SetAddress(pUdpSt->CmLocalUdpAddressIp);
	pChannel->SetRmtAddress(pUdpSt->CmRemoteUdpAddressIp);
	pChannel->SetRtcpPort(pUdpSt->LocalRtcpPort);
	pChannel->SetRtcpRmtPort(pUdpSt->RemoteRtcpPort);

	if (GetpPrecedenceSettingsDB()->IsPrecedenceEnabled())
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct dataType=", dataType);
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct Algorithm=", pChannel -> GetAlgorithm());
	}

	if (dataType == cmCapAudio)
		pUdpSt->tosValue[MEDIA_TOS_VALUE_PLACE] = m_pQos->m_bIpAudio;
	else if ((dataType == cmCapVideo) && (eRole == kRolePeople))
		pUdpSt->tosValue[MEDIA_TOS_VALUE_PLACE] = m_pQos->m_bIpVideo;
	else if ((dataType == cmCapVideo) && (eRole & kRoleContentOrPresentation) && GetpPrecedenceSettingsDB() -> IsPrecedenceEnabled())
		pUdpSt->tosValue[MEDIA_TOS_VALUE_PLACE] = m_pQos->m_bIpVideo;
	else if ((dataType == cmCapBfcp) && GetpPrecedenceSettingsDB() -> IsPrecedenceEnabled())
		pUdpSt->tosValue[MEDIA_TOS_VALUE_PLACE] = m_pQos->m_bIpSignaling;
	else if ((dataType == cmCapData) && GetpPrecedenceSettingsDB() -> IsPrecedenceEnabled())
		pUdpSt->tosValue[MEDIA_TOS_VALUE_PLACE] = m_pQos->m_bIpVideo;
	else
		pUdpSt->tosValue[MEDIA_TOS_VALUE_PLACE] = 0;

	PTRACE2INT(eLevelInfoNormal, "CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct - Setting TOS: ", pUdpSt->tosValue[MEDIA_TOS_VALUE_PLACE]);

	BOOL isRtcpQosIsEqualToRtp = NO;
	std::string key = "RTCP_QOS_IS_EQUAL_TO_RTP";
	CProcessBase::GetProcess()->GetSysConfig()->GetBOOLDataByKey(key, isRtcpQosIsEqualToRtp);

	if( isRtcpQosIsEqualToRtp )
	    pUdpSt->tosValue[RTCP_TOS_VALUE_PLACE] = pUdpSt->tosValue[MEDIA_TOS_VALUE_PLACE];
	else
	    pUdpSt->tosValue[RTCP_TOS_VALUE_PLACE] = m_pQos->m_bIpRtcp;

	pUdpSt->RtcpCnameMask = m_RtcpCnameMask;
	memset(&(pStruct->physicalPort.physical_id), 0, sizeof(PHYSICAL_RESOURCE_INFO_S));
	pStruct->physicalPort.connection_id = m_pMfaInterface->GetConnectionId();
	pStruct->physicalPort.party_id = m_pCsRsrcDesc->GetPartyRsrcId();

	//SRTP
	memset(&pStruct->tCmOpenUdpPortOrUpdateUdpAddr.sdesCap, 0, sizeof(sdesCapSt));
	if(pChannel->IsChannelSdesEnabled())
	{
		CSdesCap* pSdesCap = NULL;
		pSdesCap = pChannel->GetChannelSdes();
		if(pSdesCap && !pSdesCap->GetIsSdesUnencryptedSrtcp())
		{
			CopySdesCapsFromClassToStruct(&(pStruct->tCmOpenUdpPortOrUpdateUdpAddr.sdesCap), pSdesCap);

			// SRTCP is always SHA1-80
			pStruct->tCmOpenUdpPortOrUpdateUdpAddr.sdesCap.cryptoSuite = (APIU16) eAes_Cm_128_Hmac_Sha1_80;
		}
	}
	else
	{
		pStruct->tCmOpenUdpPortOrUpdateUdpAddr.sdesCap.bIsSrtpInUse = 0;
	}

	pStruct->tCmOpenUdpPortOrUpdateUdpAddr.capProtocolType = pChannel->GetAlgorithm();

	///////////////////////////////////////////////
	// SIP disconnection detect timer
	if (!isUpdate)
	{
		CSipCall* pCall = pChannel->GetCallPtr();

		if ((kIpAudioChnlType == pStruct->tCmOpenUdpPortOrUpdateUdpAddr.channelType
			|| kIpVideoChnlType == pStruct->tCmOpenUdpPortOrUpdateUdpAddr.channelType)
			&& (cmCapTransmit ==pStruct->tCmOpenUdpPortOrUpdateUdpAddr.channelDirection))
			//&& !GetIsTipCall()) /* bridge-6339 disable the mechnism incase of TIP call */ //BRIDGE-15677 - allow in TIP calls
		{
			pStruct->tCmOpenUdpPortOrUpdateUdpAddr.ulDetectionTimerLen = pCall->GetMediaDetectionTimer();

			if (kIpVideoChnlType == pStruct->tCmOpenUdpPortOrUpdateUdpAddr.channelType)
				pCall->SetMediaDetectioHasVideo(TRUE);
		}
		else
		{
			pStruct->tCmOpenUdpPortOrUpdateUdpAddr.ulDetectionTimerLen = 0;
		}
	}

    pStruct->tCmOpenUdpPortOrUpdateUdpAddr.uMsftType = MSFT_CLIENT_NONE_MSFT;
	CConfParty* pConfParty = NULL;

	if (pCommConf)
	{
	    pConfParty = pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());
	    if (!pConfParty)
	    {
	        PTRACE(eLevelError, "CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct - pConfParty is NULL!");
	        DBGPASSERT(1120);
		    return;
	    }
	}
	else
	{
	    PTRACE(eLevelError, "CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct - pCommConf is NULL!");
	    DBGPASSERT(1121);
	    return;
	}

    if ( pConfParty->GetMsftAvmcuState() == eMsftAvmcu2013 ||  eMsft2013AvMCU == m_isMs2013Active ) //this condition needs to be first for cccp 2013 av-mcu
    {
          PTRACE(eLevelInfoNormal, "CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct, unMsftClient is AVMCU2013");
          pStruct->tCmOpenUdpPortOrUpdateUdpAddr.uMsftType = MSFT_CLIENT_AVMCU2013;
    }
    else if (m_remoteIdent == MicrosoftEP_Lync_2013)
    {
          PTRACE(eLevelInfoNormal, "CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct, unMsftClient is MSFT_CLIENT_LYNC2013");
          pStruct->tCmOpenUdpPortOrUpdateUdpAddr.uMsftType = MSFT_CLIENT_LYNC2013;
    }
    else if (m_remoteIdent == MicrosoftEP_Lync_R1  || m_remoteIdent == MicrosoftEP_MAC_Lync)
    {
          PTRACE(eLevelInfoNormal, "CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct, unMsftClient is MSFT_CLIENT_LYNC");
          pStruct->tCmOpenUdpPortOrUpdateUdpAddr.uMsftType = MSFT_CLIENT_LYNC;
    }
    else if (m_remoteIdent == Microsoft_AV_MCU || pConfParty->GetMsftAvmcuState() == eMsftAvmcu2010 || m_remoteIdent == Microsoft_AV_MCU2013)
    {
          PTRACE(eLevelInfoNormal, "CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct, unMsftClient is MSFT_CLIENT_AVMCU");
          pStruct->tCmOpenUdpPortOrUpdateUdpAddr.uMsftType = MSFT_CLIENT_AVMCU;
    }

	if (isUpdate)
	{
		seqNum = SendMsgToMpl((BYTE*)(pStruct), sizeof(TOpenUdpPortOrUpdateUdpAddrMessageStruct), CONFPARTY_CM_UPDATE_UDP_ADDR_REQ);
	}
	else
	{
		seqNum = SendMsgToMpl((BYTE*)(pStruct), sizeof(TOpenUdpPortOrUpdateUdpAddrMessageStruct), CONFPARTY_CM_OPEN_UDP_PORT_REQ);
	}

	pChannel->SetSeqNumCm(seqNum);



}

////////////////////////////////////////////////////////////////////////////
// CONFPARTY_CM_CLOSE_UDP_PORT_REQ instead of SIP_CM_CLOSE_UDP_PORT_REQ
BYTE CSipCntl::IsMSSlaveParty()
{
	eAvMcuLinkType AvMcuLinkType = m_pParty->GetAvMcuLinkType();
	if (AvMcuLinkType == eAvMcuLinkSlaveIn || AvMcuLinkType == eAvMcuLinkSlaveOut)
	{
		return TRUE;
	}
	return FALSE;
}

BYTE CSipCntl::IsMSSlaveInParty()
{
	eAvMcuLinkType AvMcuLinkType = m_pParty->GetAvMcuLinkType();
	if (AvMcuLinkType == eAvMcuLinkSlaveIn)
	{
		return TRUE;
	}
	return FALSE;
}

DWORD CSipCntl::GetMSSlavePartyIndex()
{
	if ( IsMSSlaveParty())
	{
		return m_pParty->GetMSSlavePartyIndex();
	}

	return 0;
}


BYTE CSipCntl::Cm_FillAndSendCloseUdpPortStruct(CSipChannel *pChannel)
{
  PTRACE2INT(eLevelInfoNormal,"CSipCntl::Cm_FillAndSendCloseUdpPortStruct - ConnectionId=", m_pMfaInterface->GetConnectionId());
  DWORD seqNum = 0;


	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());

	ETipPartyTypeAndPosition tipPartyType = m_pParty->GetTipPartyTypeAndPosition();

	/* MSSlave Flora comment: we should do the same thing for MSSlave here with TipSlave, do not need to close UDP ports. */
	if( tipPartyType == eTipSlaveLeft || tipPartyType == eTipSlaveRigth || tipPartyType == eTipSlaveAux
		 || IsMSSlaveParty())
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::Cm_FillAndSendCloseUdpPortStruct: slave party - UDP ports should not be closed ");
		pChannel->SetConnectionState(kDisconnected);
		pChannel->SetCmConnectionState(kDisconnected);
		RemoveChannel(pChannel);
		return TRUE;
	}
	else if (GetIsTipCall() && ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel())==kIpContentChnlType)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct: Video Auxiliary - UDP ports should not be closed ");
		pChannel->SetCmConnectionState(kDisconnected);
		if(GetIsContentSpeaker()  == TRUE)
		{
			m_isNeedToReleaseUponHoldForTip = TRUE;
			PTRACE(eLevelInfoNormal,"CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct: hold when token is held ");
		}
		RemoveChannel(pChannel);
        m_pParty->GetCurrentMode()->SetMediaOff(cmCapVideo, cmCapTransmit, kRolePresentation);
		return TRUE;
	}
	if( ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel()) == kIpVideoChnlType )
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct: video  m_bIsVsrCtrlInitialized set to false");
		m_bIsVsrCtrlInitialized = FALSE;
		m_bShouldMsftVideoTxStreamOn = FALSE;

	}

  TCloseUdpPortMessageStruct* pStruct = new TCloseUdpPortMessageStruct;

  mcReqCmCloseUdpPort* pUdpSt = &pStruct->tCmCloseUdpPort;
  memset(pUdpSt, 0, sizeof(mcReqCmCloseUdpPort));
  pUdpSt->channelType = ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel());
  pUdpSt->channelDirection = pChannel->GetDirection();

  pUdpSt->CmLocalUdpAddressIp = pChannel->GetAddress();
  pUdpSt->LocalRtcpPort = pChannel->GetRtcpPort();

  if (pChannel->GetMediaType() == cmCapBfcp && m_pSipBfcpCtrl)
  		pUdpSt->CmRemoteUdpAddressIp.transportType = m_pSipBfcpCtrl->GetBfcpTransportType();
  	else
  		pUdpSt->CmRemoteUdpAddressIp.transportType = eTransportTypeUdp;

  enIpVersion eIpAddrMatch = eIpVersion4;
  PTRACE2INT(eLevelInfoNormal,"CSipCntl::Cm_FillAndSendCloseUdpPortStruct - m_isUpdateAnatIpType=", m_isUpdateAnatIpType);
  if (m_isUpdateAnatIpType && m_LastAnatSelectedIpVersion != enIpVersionMAX)   //added for ANAT
  	eIpAddrMatch = m_LastAnatSelectedIpVersion;
  else if (IsAnatSupported())
  	eIpAddrMatch = m_AnatSelectedIpVersion;
  else
  	eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);
  pUdpSt->CmLocalUdpAddressIp.ipVersion = eIpAddrMatch;

  memcpy(&(pUdpSt->CmRemoteUdpAddressIp), pChannel->GetRmtAddress(), sizeof(mcTransportAddress));
  pUdpSt->RemoteRtcpPort = pChannel->GetRtcpRmtPort();

  pUdpSt->ice_channel_rtp_id = 0;
  pUdpSt->ice_channel_rtcp_id = 0;

  UpdateIceChannelsIds(pUdpSt, pChannel);

  ///////////////////////////////////////////////
  // in case of downgrade to AudioOnly
  if(kIpVideoChnlType == pStruct->tCmCloseUdpPort.channelType)
  {
	  CSipCall* pCall = pChannel->GetCallPtr();
	  if(cmCapTransmit ==pStruct->tCmCloseUdpPort.channelDirection)
	  {
		   pCall->SetMediaDetectioHasVideo(FALSE);
	  }
  }

  memset(&(pStruct->physicalPort.physical_id), 0, sizeof(PHYSICAL_RESOURCE_INFO_S));
  pStruct->physicalPort.connection_id = m_pMfaInterface->GetConnectionId();

  pStruct->physicalPort.party_id = m_pCsRsrcDesc->GetPartyRsrcId();

  seqNum = SendMsgToMpl((BYTE*)(pStruct), sizeof(TCloseUdpPortMessageStruct), CONFPARTY_CM_CLOSE_UDP_PORT_REQ);
  pChannel->SetSeqNumCm(seqNum);
  PDELETE(pStruct);

  return FALSE;
}





////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateIceChannelsIds(mcReqCmCloseUdpPort* pUdpSt,CSipChannel* pChannel)
{
	pUdpSt->ice_channel_rtp_id = 0;
	pUdpSt->ice_channel_rtcp_id = 0;

	cmCapDataType dataType = pChannel->GetMediaType();
	ERoleLabel eRole = pChannel->GetRoleLabel();

	if(m_pIceParams)
	{
		switch (dataType)
		{
			case cmCapAudio:
				{
					pUdpSt->ice_channel_rtp_id = m_pIceParams->GetAudioRtpId();
					pUdpSt->ice_channel_rtcp_id = m_pIceParams->GetAudioRtcpId();
					break;
				}
			case cmCapVideo:
				{
					if (eRole == kRolePeople)
					{
						pUdpSt->ice_channel_rtp_id = m_pIceParams->GetVideoRtpId();
						pUdpSt->ice_channel_rtcp_id = m_pIceParams->GetVideoRtcpId();
					}
					else
					{
						pUdpSt->ice_channel_rtp_id = m_pIceParams->GetContentRtpId();
						pUdpSt->ice_channel_rtcp_id = m_pIceParams->GetContentRtcpId();
					}
					break;
				}
			case cmCapData:
				{
					pUdpSt->ice_channel_rtp_id = m_pIceParams->GetDataRtpId();
					pUdpSt->ice_channel_rtcp_id = m_pIceParams->GetDataRtcpId();
					break;
				}
			default:
				{
					PTRACE(eLevelInfoNormal,"CSipCntl::UpdateIceChannelsIds - Unknown Data Type!!!");
				}
		}
	}
}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateIceChannelsIds(MrmpCloseChannelRequestMessage* pStruct, CSipChannel* pChannel)
{
	pStruct->ice_channel_rtp_id = 0;
	pStruct->ice_channel_rtcp_id = 0;

	cmCapDataType dataType = pChannel->GetMediaType();
	ERoleLabel eRole = pChannel->GetRoleLabel();

	if(m_pIceParams)
	{
		switch (dataType)
		{
			case cmCapAudio:
			{
				pStruct->ice_channel_rtp_id = m_pIceParams->GetAudioRtpId();
				pStruct->ice_channel_rtcp_id = m_pIceParams->GetAudioRtcpId();
				break;
			}
			case cmCapVideo:
			{
				if (eRole == kRolePeople)
				{
					pStruct->ice_channel_rtp_id = m_pIceParams->GetVideoRtpId();
					pStruct->ice_channel_rtcp_id = m_pIceParams->GetVideoRtcpId();
				}
				else
				{
					pStruct->ice_channel_rtp_id = m_pIceParams->GetContentRtpId();
					pStruct->ice_channel_rtcp_id = m_pIceParams->GetContentRtcpId();
				}
				break;
			}
			case cmCapData:
			{
				pStruct->ice_channel_rtp_id = m_pIceParams->GetDataRtpId();
				pStruct->ice_channel_rtcp_id = m_pIceParams->GetDataRtcpId();
				break;
			}
			default:
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::UpdateIceChannelsIds - Unknown Data Type!!!");
			}
		}
	}
}
//////////////////////////////////////////////////////////
///////////////// MFA Indications ////////////////////////
//////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////
//IP_RTP_DTMF_INPUT_IND
void CSipCntl::OnRtpDtmfInd(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnRtpDtmfInd");

	TRtpDtmfRequestInd* pDtmfMsg = (TRtpDtmfRequestInd*) pParam->GetPtr(1);

	APIU8* buffer = new APIU8[2];// in the DTMF structure there is only one digit
	buffer[0] = pDtmfMsg->unDigit;
	buffer[1] = 0;

	m_pPartyApi->sendPartyDTMFInd(buffer,1, RTP_DTMF_INPUT_IND);
	PDELETEA(buffer);
}

void CSipCntl::OnRtpDtmfIndIgnore(CSegment* pParam)
{
	TRACEINTO << "state: " << m_state;
}

/////////////////////////////////////////////////////////////////////////
//IP_RTP_DIFF_PAYLOAD_TYPE_IND
void CSipCntl::OnRtpDifferentPayloadTypeInd(CSegment* pParam)
{
	TRtpDiffPayloadTypeInd* pDiffPayloadMsg = (TRtpDiffPayloadTypeInd*)pParam->GetPtr();
	CSipChannel* pChannel = NULL;

	ERoleLabel 		roleLabel;
	cmCapDataType 	mediaType;


	mediaType = ::ChannelTypeToDataType((kChanneltype)pDiffPayloadMsg->unChannelType, roleLabel);
	pChannel = m_pCall->GetChannel(true, mediaType, (cmCapDirection)pDiffPayloadMsg->unChannelDirection,roleLabel);

	if (!pChannel)
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::OnRtpDifferentPayloadTypeInd : channel wasn't found");
		DBGPASSERT(pDiffPayloadMsg->unChannelType);
		return;
	}

	CMedString cLog;
	cLog << "channel type " << pDiffPayloadMsg->unChannelType << ", channel direction " << pDiffPayloadMsg->unChannelDirection << ", Payload " << pDiffPayloadMsg->unPayloadType;
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnRtpDifferentPayloadTypeInd - ", cLog.GetString());

	m_pPartyApi->SendIpDifferentPayload(pChannel->GetMediaType(), pChannel->GetDirection(), pDiffPayloadMsg->unPayloadType, (WORD) roleLabel);

}
////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
//IP_RTP_FECC_MUTE_IND
void CSipCntl::OnRtpFeccMuteInd(CSegment* pParam)
{
	TRtpFeccMuteInd* pRtpFeccMuteIndMsg = (TRtpFeccMuteInd*)pParam->GetPtr();

	PASSERTMSG_AND_RETURN(!pRtpFeccMuteIndMsg, "!pRtpFeccMuteIndMsg");

	WORD unIsMuteOn = (WORD)(pRtpFeccMuteIndMsg->unIsMuteOn);

	TRACEINTO << "unIsMuteOn " << (int)(pRtpFeccMuteIndMsg->unIsMuteOn);

	m_pPartyApi->UpdateMuteIcon(unIsMuteOn);

}
////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
//IP_RTP_STREAM_STATUS_IND
void CSipCntl::OnRtpStreamStatusInd(CSegment* pParam)
{
	TRtpStreamStatusInd* pStreamStatusMsg = (TRtpStreamStatusInd*)pParam->GetPtr();
	CSipChannel* pChannel = NULL;

	ERoleLabel 		roleLabel;
	cmCapDataType 	mediaType;

	mediaType = ::ChannelTypeToDataType((kChanneltype)pStreamStatusMsg->unChannelType, roleLabel);
	pChannel = m_pCall->GetChannel(true, mediaType, (cmCapDirection)pStreamStatusMsg->unChannelDirection, roleLabel);

	if (!pChannel)
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::OnRtpStreamStatusInd : channel wasn't found");
		DBGPASSERT(pStreamStatusMsg->unChannelType);
		return;
	}

	BYTE bRejectChannel = FALSE;
	CMedString cLog;
	cLog << "channel type " << pStreamStatusMsg->unChannelType << ", channel direction " << pStreamStatusMsg->unChannelDirection;

	PTRACE(eLevelInfoNormal,"CSipCntl::OnRtpStreamStatusInd");
	if (pStreamStatusMsg->unStreamStatus == 0)
		PTRACE(eLevelInfoNormal,"CSipCntl::OnRtpStreamStatusInd: Stream status is fine.");
	else
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnRtpStreamStatusInd: Stream status is NOT ok on channel index .",pStreamStatusMsg->unChannelType);

		// what should I do with the 'unPayloadType' flag - report to party that should decided on the needed actions.
		if(pChannel && (pChannel->GetConnectionState() != kDisconnected || pChannel->GetConnectionState() != kDisconnecting) && pStreamStatusMsg->unPayloadType)
		{
			cLog << ", Payload " << pStreamStatusMsg->unPayloadType;
			PTRACE2(eLevelInfoNormal,"CSipCntl::OnRtpStreamStatusInd: Stream status is NOT ok on (Payload). ",cLog.GetString());
			m_pPartyApi->SendIpDifferentPayload(pChannel->GetMediaType(), pChannel->GetDirection(), pStreamStatusMsg->unPayloadType, (WORD) roleLabel);
			return;
		}
		CBaseVideoCap* pVideoData	= (CBaseVideoCap*)pChannel->GetDataAsCapClass();
		if (pChannel && pChannel->GetMediaType() == cmCapVideo && pVideoData && pChannel->GetConnectionState() == kConnected)
		{
			CSecondaryParams secParams;
			BYTE bReportOnViolation		= NO;
			BYTE bFoundLightViolation	= FALSE;
			CCapSetInfo capInfo			= pChannel->GetAlgorithm();

			// what should I do with the 'bunViolation' flag
			if(pStreamStatusMsg->unPayloadType)// protocol - secondary,
			{
				secParams.m_problemParam	= PayloadType;
				secParams.m_rmtProblemValue	= pStreamStatusMsg->unPayloadType;
				secParams.m_currProblemValue= pChannel->GetPayloadType();
				bReportOnViolation			= YES;
				cLog << "The payload type isn't ok - " << pStreamStatusMsg->unPayloadType;
				PTRACE2(eLevelInfoNormal, "CSipCntl::OnRtpStreamStatusInd: ", cLog.GetString());
			}
			else if(pStreamStatusMsg->unAnnexesAndResolutionMask)// Annexes- secondary
			{
				DWORD errorNo = pStreamStatusMsg->unAnnexesAndResolutionMask & (H263_Annexes_Number-1);// check the number of annexes
				if(errorNo)// there is an error in the annexes
				{
					secParams.m_problemParam		= Annexes;
					CH263VideoCap* pCap			= (CH263VideoCap*) CBaseCap::AllocNewCap(eH263CapCode, NULL);

					bReportOnViolation			= YES;
					cLog << "The annexes aren't ok";
					PTRACE2(eLevelInfoNormal, "CSipCntl::OnH323StreamStatusInd - ", cLog.GetString());
					if(pCap) //In case there was no other initialize
					{
						secParams.m_rmtProblemValue = pCap->GetAnnex(pStreamStatusMsg->unAnnexesAndResolutionMask);
						pCap->FreeStruct();
					}
					POBJDELETE(pCap);
				}
			}
			else if(pStreamStatusMsg->unBitRate)// Rate - special behavior (need to send re-invite with lower video rate, currently only monitoring
			{
				cLog << "Remote transmitted rate is " << pStreamStatusMsg->unBitRate << ", signaling rate is " <<  pVideoData->GetBitRate();
				PTRACE2(eLevelInfoNormal,"CSipCntl::OnRtpStreamStatusInd: ",cLog.GetString());
			}
			else if(pStreamStatusMsg->unResolution)// Resolution - monitoring only
			{
				cLog << "Remote transmitted resolution is " << pStreamStatusMsg->unResolution << ", signaling resolution is " <<  pVideoData->GetFormat();
				PTRACE2(eLevelInfoNormal,"CSipCntl::OnRtpStreamStatusInd: ",cLog.GetString());
			}
			else if(pStreamStatusMsg->unFramesPerSec)// FPS - monitoring only
			{
				cLog << "Remote transmitted FPS is " << pStreamStatusMsg->unFramesPerSec << ", signaling FPS is " <<  pVideoData->GetFormatMpi(pVideoData->GetFormat());
				PTRACE2(eLevelInfoNormal,"CSipCntl::OnRtpStreamStatusInd: ",cLog.GetString());
			}
			else if(pStreamStatusMsg->unAnnexesAndResolutionMask)// Custom - monitoring only
			{
				cLog << "Remote transmitted custom format is " << (pStreamStatusMsg->unAnnexesAndResolutionMask & 0xFFFFFFEA) << ", signaling custome format is NONE";
				PTRACE2(eLevelInfoNormal,"CSipCntl::OnRtpStreamStatusInd: ",cLog.GetString());
			}

			if (bFoundLightViolation && !bReportOnViolation)
			{
				if ( GetSystemCfgFlagInt<BOOL>(CFG_KEY_IGNORE_STREAM_VIOLATION) == FALSE)
					bReportOnViolation = YES;
				else
					PTRACE(eLevelInfoNormal, "CSipCntl::OnRtpStreamStatusInd: The flag IGNORE_STREAM_VIOLATION is on");
			}

			if (bReportOnViolation)
			{
				m_pPartyApi->SendIpStreamViolation(pStreamStatusMsg->unStreamStatus,SECONDARY_CAUSE_STREAM_VIOLATION,secParams);	//inform the H323Part
				m_strConfParamInfo << ",st-st <"
					<< secParams.m_capCode			<< ","
					<< secParams.m_resolution			<< ","
					<< secParams.m_frameRate			<< ","
					<< secParams.m_lineRate			<< ","
					<< secParams.m_problemParam		<< ","
					<< secParams.m_rmtProblemValue	<< ","
					<< secParams.m_currProblemValue	  //there is no need to add the conf type cause it is already in the string
					<< ">";
			}
		}
		else
		{
			CSmallString str;
			if (pChannel->GetMediaType() != cmCapVideo)
				str << "Channel is not video (type - " << pChannel->GetMediaType() << ")";
			else
				str << "Channel state is " << pChannel->GetConnectionState();
			PTRACE2(eLevelInfoNormal,"CSipCntl::OnRtpStreamStatusInd: ", str.GetString());
		}
		POBJDELETE(pVideoData);
	}
}

//IP_RTP_BAD_SPONTAN_IND
/* currently no need for that function, we have it in the trace.
/////////////////////////////////////////////////////////////////////
void CSipCntl::OnMfaBadSpontaneuosInd(CSegment* pParam)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnMfaBadSpontaneuosInd - Conn Id = ",m_pCsRsrcDesc->GetConnectionId());
	TRtpBadSpontaneousInd pSpontaneuos;
	DWORD  structLen = sizeof(TRtpBadSpontaneousInd);
	memset(&pSpontaneuos,0,structLen);
	pParam->Get((BYTE*)(&pSpontaneuos),structLen);

	if (pSpontaneuos.unBadSpontReason < lastBadSpontanIndReason)
	{
		CMedString str;
		str << "Channel type: " << pSpontaneuos.unChannelType
		    << "Channel direction: " << pSpontaneuos.unChannelDirection
		    << "Reason: " << g_badSpontanIndReasonStrings[pSpontaneuos.unBadSpontReason];
		PTRACE2(eLevelError,"CSipCntl::OnMfaBadSpontaneuosInd:  = ", str.GetString());

//		if()//Add the string alarm to the Fault list in the EMA, currently no need for sending the indication to the fault.
//		{
//			const char * pDesc = (const char *)(g_badSpontanIndReasonStrings[pSpontaneuos.unBadSpontReason]);
//			CHlogApi::TaskFault(FAULT_GENERAL_SUBJECT, IP_RTP_BAD_SPONTAN_IND, MAJOR_ERROR_LEVEL, pDesc, TRUE);
//		}
	}
	else
		PTRACE(eLevelError,"CSipCntl::OnMfaBadSpontaneuosInd - Unsupported BadSpontaneuosIndication");
}
*/

//////////////////////////////////////////////////////////////
void CSipCntl::OnPartyMrmpPartyMonitoringInd(CSegment* pParam)
{
    if( m_tipPartySlaveIdToMonitor != 0 )
	{
		PTRACE2INT(eLevelInfoNormal,"OLGA  CSipCntl::OnPartyMrmpPartyMonitoringInd - send the message to slave party id=", m_tipPartySlaveIdToMonitor);
		m_pParty->SendMessageFromMasterToSlaveByID( m_tipPartySlaveIdToMonitor, CONF_PARTY_MRMP_PARTY_MONITORING_IND, pParam);
		return;
	}

    PTRACE(eLevelInfoNormal,"CSipCntl::OnPartyMrmpPartyMonitoringInd");

    // continue with the regular 'PartyMonitoringInd' method
    OnPartyMonitoringInd(pParam);
}

//////////////////////////////////////////////////////////////
void CSipCntl::OnPartyMonitoringInd(CSegment* pParam)
{
    if( m_tipPartySlaveIdToMonitor != 0 )
	{
		PTRACE2INT(eLevelInfoNormal,"OLGA  CSipCntl::OnPartyMonitoringInd - send the message to slave party id=", m_tipPartySlaveIdToMonitor);
		m_pParty->SendMessageFromMasterToSlaveByID( m_tipPartySlaveIdToMonitor, IP_CM_PARTY_MONITORING_IND, pParam);
		return;
	}
	PTRACE(eLevelInfoNormal,"CSipCntl::OnPartyMonitoringInd");

	TCmPartyMonitoringInd* pPartyMonitoringMsg = (TCmPartyMonitoringInd *)pParam->GetPtr();
	CSipChannel* pChannel = NULL;


	BYTE bRejectChannel = FALSE;
	BYTE				bIsTransmit = NO;
	CapEnum				eAlgorithm	= eUnknownAlgorithemCapCode;

	CSipChannel* pSameSessionChannel	= NULL;

	TCmPartyMonitoringInd* pPartyMonitoringInd = (TCmPartyMonitoringInd *)pParam->GetPtr();


	mcTransportAddress channelAddress;
	mcTransportAddress sameSessionAddress;
	memset(&channelAddress, 0, sizeof(mcTransportAddress));
	memset(&sameSessionAddress, 0, sizeof(mcTransportAddress));

	int	 videoResulation		= kUnknownFormat;

	TRtpChannelMonitoringInd* pChanMonitoring = (TRtpChannelMonitoringInd *)pPartyMonitoringMsg->acMonitoringData;

	for (DWORD i = 0; i < pPartyMonitoringInd->unNumOfChannels ; i++) //MaxChannelsPerCall  pPartyMonitoringInd->unNumOfChannels
	{
		// all channel types has same common structure at the beginning and therefore we can use the video to take out common params (or all over channel types).
		kChanneltype channelType = (kChanneltype)pChanMonitoring->tRtpVideoChannelMonitoring.tRtpCommonChannelMonitoring.unChannelType;
		ERoleLabel eRole = kRolePeople;

		cmCapDataType eDataType = ::ChannelTypeToDataType(channelType,eRole); //debug
		cmCapDirection	unChannelDirection = (cmCapDirection)pChanMonitoring->tRtpVideoChannelMonitoring.tRtpCommonChannelMonitoring.unChannelDirection;//debug
		pChannel = m_pCall->GetChannel(true, eDataType, unChannelDirection,eRole); //debug
		/*pChannel = m_pCall->GetChannel(
							::ChannelTypeToDataType(
									(kChanneltype)channelType,eRole),
									(cmCapDirection)pChanMonitoring->tRtpVideoChannelMonitoring.tRtpCommonChannelMonitoring.unChannelDirection);
		*/
		if (pChannel && (pChannel->GetConnectionState() == kConnected) && pChanMonitoring->tRtpVideoChannelMonitoring.tRtpCommonChannelMonitoring.bunValidChannel)
		{
			EIpChannelType		eChanType	= H225;
			cmCapDataType		eType		= cmCapEmpty;
			mcTransportAddress localIp;
			mcTransportAddress remoteIp;

			memset(&localIp,0,sizeof(mcTransportAddress));
			memset(&remoteIp,0,sizeof(mcTransportAddress));


			mcTransportAddress IceLocalIp;
			mcTransportAddress IceRemoteIp;
			memset(&IceLocalIp,0,sizeof(mcTransportAddress));
			memset(&IceRemoteIp,0,sizeof(mcTransportAddress));
			BYTE IsIce = 0;
			EIceConnectionType ChosenConnectionType = kNone;

			eType		= pChannel->GetMediaType();
			bIsTransmit = (pChannel->GetDirection() == cmCapTransmit);
			eAlgorithm	= pChannel->GetAlgorithm();
			eChanType   = ::CalcChannelType(eType,bIsTransmit,eRole, eAlgorithm);

			CPrtMontrBaseParams *pPrtMonitrParams = CPrtMontrBaseParams::AllocNewClass(eChanType);
			GetLocalMediaIpAsTrAddr(localIp);

			GetRemoteMediaIpAsTrAddr(eType,eRole,remoteIp);
			localIp.port  = GetPort( eType, cmCapReceive, pChannel->GetRoleLabel());
			remoteIp.port = GetRemoteMediaPort(eType, eRole);

			OverwriteMonitoring(eChanType, remoteIp, localIp, IsIce, IceRemoteIp, IceLocalIp);

			//ICE
			if(m_IceConnectivityCheckStatus == eIceConnectedLocal || m_IceConnectivityCheckStatus == eIceConnectedRemote)
			{
				IsIce = 1;

				memset(&remoteIp,0,sizeof(mcTransportAddress));
				GetOriginalRmtIpAddress(eType,remoteIp,eRole);

				char* IceRmtIPStr = GetMediaChosenRemoteIpAddress(eDataType);
				char* IceLocalIPStr = GetMediaChosenLocalIpAddress(eDataType);

				if((IceRmtIPStr) && ::IsValidIpV4Address(IceRmtIPStr) && (IceLocalIPStr) && ::IsValidIpV4Address(IceLocalIPStr))
				{
					::stringToIpV4 (&IceRemoteIp, IceRmtIPStr);
					::stringToIpV4 (&IceLocalIp, IceLocalIPStr);
				}
				ChosenConnectionType = GetMediaChosenRemoteType(eDataType);

				PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnPartyMonitoringInd DataType: ",eDataType);


				PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnPartyMonitoringInd ChosenConnectionType :",ChosenConnectionType);


				if(!(isApiTaNull(&IceRemoteIp) || isApiTaNull(&IceLocalIp)))
				{
					IceRemoteIp.port = GetMediaChosenRemotePort(eDataType);
					IceLocalIp.port =  GetMediaChosenLocalPort(eDataType);
				}

				UpdatePartyMonitoring((TRtpCommonChannelMonitoring*)pChanMonitoring,pPrtMonitrParams,m_oldMediaBytesArr,pChannel->GetAlgorithm(),
						eChanType,pChannel->GetCardIndex(),m_pCall->GetCardIndex(),m_oldFramesArr,pChannel->GetCurrentRate(),
						(char *)pChannel->GetData(),&remoteIp,&localIp,IsIce,&IceRemoteIp,&IceLocalIp,ChosenConnectionType); //14

			}
			else
				UpdatePartyMonitoring((TRtpCommonChannelMonitoring*)pChanMonitoring,pPrtMonitrParams,m_oldMediaBytesArr,pChannel->GetAlgorithm(),
					eChanType,pChannel->GetCardIndex(),m_pCall->GetCardIndex(),m_oldFramesArr,pChannel->GetCurrentRate(),
								(char *)pChannel->GetData(),&remoteIp,&localIp,IsIce,&IceRemoteIp,&IceLocalIp); //14

			//PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnPartyMonitoringInd this is media type " ,(DWORD)eChanType);
			m_pPartyApi->IpLogicalChannelConnect(pPrtMonitrParams,(DWORD)eChanType,0);

			if ((eChanType==VIDEO_OUT) || (eChanType==VIDEO_CONT_OUT))
			{
				BYTE 	intraSyncFlag			= 0;
				DWORD	streamVideoSyncParams	= 0;
				BYTE videoBCHSyncFlag			= 0;
				WORD bchOutOfSyncCount			= 0;
				BYTE protocolSyncFlag			= 0;
				WORD protocolOutOfSyncCount		= 0;


				streamVideoSyncParams = ((TRtpVideoChannelMonitoring *)pChanMonitoring)->unStreamVideoSync;
				VideoSyncParamsParser(streamVideoSyncParams,
									intraSyncFlag, videoBCHSyncFlag, bchOutOfSyncCount,
									protocolSyncFlag, protocolOutOfSyncCount);

				m_pPartyApi->IpPartyMonitoringUpdateDB(
									(BYTE)eChanType,  intraSyncFlag,
									videoBCHSyncFlag, bchOutOfSyncCount,
									protocolSyncFlag, protocolOutOfSyncCount);
			}

			POBJDELETE(pPrtMonitrParams);
		}
		pChanMonitoring = (TRtpChannelMonitoringInd *)((BYTE *)pChanMonitoring + sizeof(TRtpVideoChannelMonitoring));
	}
}

//////////////////////////////////////////////////////////////////
//for CDR_MCCF: for REINVITE transaction
void CSipCntl::OnPartyInMiddleOfTransactionStatisticsInd(CSegment* pParam)
{
    PTRACE(eLevelInfoNormal,"CDR_MCCF: CSipCntl::OnPartyInMiddleOfTransactionStatisticsInd");

    TCmPartyInfoStatisticsInd* pPartyInfoStatisticsMsg = (TCmPartyInfoStatisticsInd *)pParam->GetPtr();
    TCmPartyInfoStatisticsInd* pPartyInfoStatisticsInd = (TCmPartyInfoStatisticsInd *)pParam->GetPtr();
    TRtpChannelMonitoringInd*  pChanMonitoring         = (TRtpChannelMonitoringInd *)pPartyInfoStatisticsMsg->acMonitoringData;
    APIU32                     numOfChannels           = pPartyInfoStatisticsInd->unNumOfChannels;

    OnPartyInfoStatisticsOrMonitoring(pChanMonitoring,numOfChannels, FALSE);

    PTRACE(eLevelInfoNormal,"CDR_MCCF: CSipCntl::OnPartyInMiddleOfTransactionStatisticsInd - m_state != IP_DISCONNECTING  => return to transaction");
    m_pPartyApi->SipPartyStatisticsInfo();
}

//////////////////////////////////////////////////////////////////
//CDR_MCCF:
void CSipCntl::OnPartyStatisticsIndStateDisconnectingTout(CSegment* pParam)
{
    PTRACE(eLevelError,"CDR_MCCF: CSipCntl::OnPartyStatisticsIndStateDisconnectingTout!");

    BYTE bMessageSent = SipCloseAllChannelsReq();
}

//////////////////////////////////////////////////////////////////
//CDR_MCCF:
void CSipCntl::OnPartyStatisticsIndAnycaseTout(CSegment* pParam)
{
    PTRACE(eLevelError,"CDR_MCCF: CSipCntl::OnPartyStatisticsIndAnycaseTout!");

    m_pPartyApi->SipPartyStatisticsInfo();
}

//////////////////////////////////////////////////////////////////
//CDR_MCCF:
void CSipCntl::OnPartyStatisticsIndStateDisconnecting(CSegment* pParam)
{
    TCmPartyInfoStatisticsInd* pPartyInfoStatisticsMsg = (TCmPartyInfoStatisticsInd *)pParam->GetPtr();
    TCmPartyInfoStatisticsInd* pPartyInfoStatisticsInd = (TCmPartyInfoStatisticsInd *)pParam->GetPtr();
    TRtpChannelMonitoringInd*  pChanMonitoring         = (TRtpChannelMonitoringInd *)pPartyInfoStatisticsMsg->acMonitoringData;
    APIU32                     numOfChannels           = pPartyInfoStatisticsInd->unNumOfChannels;

    OnPartyInfoStatisticsOrMonitoring(pChanMonitoring,numOfChannels, FALSE);

   // if ( m_pParty->GetTipPartyTypeAndPosition() != eTipMasterCenter )
   // {
    PTRACE(eLevelInfoNormal,"CDR_MCCF: CSipCntl::OnPartyStatisticsIndStateDisconnecting - m_state == IP_DISCONNECTING  => close channels");
    BYTE bMessageSent = SipCloseAllChannelsReq();
  //  }
   /* else
    {
        PTRACE(eLevelInfoNormal,"CDR_MCCF: CSipCntl::OnPartyStatisticsIndStateDisconnecting - m_state == IP_DISCONNECTING  => close channels - master(tip)");
        m_pPartyApi->SipPartyStatisticsInfo();
    }
*/
    //send to MCMS Polycom mixer
    //SendStatisticsInfoOfThisEpToMCMSpolycomMixer();

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//for CDR_MCCF:
void CSipCntl::SendStatisticsInfoOfThisEpToMCMSpolycomMixer()
{
	if (m_pIpVideoCdrChannelMonitor[0]->GetConnectionStatus() == NO &&
		m_pIpVideoCdrChannelMonitor[1]->GetConnectionStatus() == NO)
	{
		PTRACE(eLevelInfoNormal,"CDR_MCCF: CSipCntl::SendStatisticsInfoOfThisEpToMCMSpolycomMixer - m_pIpVideoCdrChannelMonitor not valid, return and don't send statistics info to MCMS polycom mixer");
		return;
	}

    CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
    CConfParty* pConfParty = NULL;

    if (pCommConf)
    {
    	pConfParty               = pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());
    	const char* strConfName  = pCommConf->GetName();
    	std::vector< COsQueue > clientRspMbxList = ::GetClientRspMbxForMCCFtwinTxList();

    	PTRACE2INT(eLevelInfoNormal,"CDR_MCCF: CSipCntl::SendStatisticsInfoOfThisEpToMCMSpolycomMixer sizeOfList:",clientRspMbxList.size());

    	DWORD       confId       = pCommConf->GetConfID();
        char        confIdString [H243_NAME_LEN];
        snprintf(confIdString,sizeof(confIdString),"%d",confId);

    	if ( pConfParty )
    	{
    		DWORD       partyId      = pConfParty->GetPartyId();
    		char        partyIdString [H243_NAME_LEN];
    		snprintf(partyIdString,sizeof(partyIdString),"%d",partyId);

    		if ( clientRspMbxList.empty() == TRUE)
    		{
    			PTRACE(eLevelInfoNormal,"CDR_MCCF: CSipCntl::SendStatisticsInfoOfThisEpToMCMSpolycomMixer - there is no MCCF open channel - don't call CMccfCdrPackageResponse");
    			return;
    		}

    		CLIENT_RSP_MBX_LIST::iterator itr = clientRspMbxList.begin();
    		COsQueue clientRspMbx = (*itr);

            for ( ; (itr != clientRspMbxList.end() && (DWORD)itr->m_id != 0xFFFFFFFF ); ++itr)
            {
            	clientRspMbx = (*itr);

            	PTRACE2INT(eLevelInfoNormal,"CDR_MCCF: CSipCntl::SendStatisticsInfoOfThisEpToMCMSpolycomMixer - call CMccfCdrPackageResponse twinId(itr->m_id):", (DWORD)itr->m_id);
                CMccfCdrPackageResponse::ResponseReportMsg( clientRspMbx , m_pIpVideoCdrChannelMonitor,
															m_pIpVideoCdrChannelDetails,/* pConfParty->GetPartyTag(),strConfName,*/confIdString,partyIdString );
            }

    	}
    	else
    		PTRACE(eLevelInfoNormal,"CDR_MCCF: CSipCntl::SendStatisticsInfoOfThisEpToMCMSpolycomMixer - pConfParty is NULL - don't call CMccfCdrPackageResponse");
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//for CDR_MCCF:
void CSipCntl::OnPartyInfoStatisticsOrMonitoring(TRtpChannelMonitoringInd* pChanMonitoring, APIU32 numOfChannels, BYTE isMonitoringIndMsg)
{
    PTRACE(eLevelInfoNormal,"CSipCntl::OnPartyInfoStatisticsOrMonitoring");

    if (isMonitoringIndMsg == FALSE)
        DeleteTimer(IP_CM_PARTY_STATISTIC_INFO_IND_TOUT);

    if( numOfChannels > MAX_SIP_CHANNELS )// it means that they are no statistics yet
    {
    	PTRACE(eLevelInfoNormal,"CSipCntl::OnPartyInfoStatisticsOrMonitoring, number of channels is 999");
    	return;
    }

    CSipChannel*       pChannel            = NULL;
    BYTE               bRejectChannel      = FALSE;
    BYTE               bIsTransmit         = NO;
    CapEnum            eAlgorithm          = eUnknownAlgorithemCapCode;
    CSipChannel*       pSameSessionChannel = NULL;
    int                videoResulation     = kUnknownFormat;
    mcTransportAddress channelAddress;
    mcTransportAddress sameSessionAddress;

    memset(&channelAddress, 0, sizeof(mcTransportAddress));
    memset(&sameSessionAddress, 0, sizeof(mcTransportAddress));

    for (APIU32 i = 0; i < numOfChannels/*pPartyMonitoringInd->unNumOfChannels*/; i++)
    {
        // all channel types has same common structure at the beginning and therefore we can use the video to take out common params (or all over channel types).
        kChanneltype channelType = (kChanneltype)pChanMonitoring->tRtpVideoChannelMonitoring.tRtpCommonChannelMonitoring.unChannelType;
        ERoleLabel eRole = kRolePeople;

        cmCapDataType eDataType = ::ChannelTypeToDataType(channelType,eRole); //debug
        cmCapDirection  unChannelDirection = (cmCapDirection)pChanMonitoring->tRtpVideoChannelMonitoring.tRtpCommonChannelMonitoring.unChannelDirection;//debug
        pChannel = m_pCall->GetChannel(true, eDataType, unChannelDirection,eRole); //debug

        if (pChannel && (pChannel->GetConnectionState() == kConnected) && pChanMonitoring->tRtpVideoChannelMonitoring.tRtpCommonChannelMonitoring.bunValidChannel)
        {
            EIpChannelType      eChanType   = H225;
            cmCapDataType       eType       = cmCapEmpty;
            mcTransportAddress localIp;
            mcTransportAddress remoteIp;

            memset(&localIp,0,sizeof(mcTransportAddress));
            memset(&remoteIp,0,sizeof(mcTransportAddress));

            mcTransportAddress IceLocalIp;
            mcTransportAddress IceRemoteIp;
            memset(&IceLocalIp,0,sizeof(mcTransportAddress));
            memset(&IceRemoteIp,0,sizeof(mcTransportAddress));
            BYTE IsIce = 0;
            EIceConnectionType ChosenConnectionType = kNone;

            eType       = pChannel->GetMediaType();
            bIsTransmit = (pChannel->GetDirection() == cmCapTransmit);
            eAlgorithm  = pChannel->GetAlgorithm();
            eChanType   = ::CalcChannelType(eType,bIsTransmit,eRole, eAlgorithm);

            CPrtMontrBaseParams *pPrtMonitrParams = CPrtMontrBaseParams::AllocNewClass(eChanType);
            GetLocalMediaIpAsTrAddr(localIp);

            GetRemoteMediaIpAsTrAddr(eType,eRole,remoteIp);
            localIp.port  = GetPort( eType, cmCapReceive, pChannel->GetRoleLabel());
            remoteIp.port = GetRemoteMediaPort(eType, eRole);

			OverwriteMonitoring(eChanType, remoteIp, localIp, IsIce, IceRemoteIp, IceLocalIp);

			//ICE
            if(m_IceConnectivityCheckStatus == eIceConnectedLocal || m_IceConnectivityCheckStatus == eIceConnectedRemote)
            {
                IsIce = 1;

                memset(&remoteIp,0,sizeof(mcTransportAddress));
                GetOriginalRmtIpAddress(eType,remoteIp,eRole);

                char* IceRmtIPStr = GetMediaChosenRemoteIpAddress(eDataType);
                char* IceLocalIPStr = GetMediaChosenLocalIpAddress(eDataType);

                if((IceRmtIPStr) && ::IsValidIpV4Address(IceRmtIPStr) && (IceLocalIPStr) && ::IsValidIpV4Address(IceLocalIPStr))
                {
                    ::stringToIpV4 (&IceRemoteIp, IceRmtIPStr);
                    ::stringToIpV4 (&IceLocalIp, IceLocalIPStr);
                }
                ChosenConnectionType = GetMediaChosenRemoteType(eDataType);

                PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnPartyInfoStatisticsOrMonitoring DataType: ",eDataType);
                PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnPartyInfoStatisticsOrMonitoring ChosenConnectionType :",ChosenConnectionType);

                if(!(isApiTaNull(&IceRemoteIp) || isApiTaNull(&IceLocalIp)))
                {
                    IceRemoteIp.port = GetMediaChosenRemotePort(eDataType);
                    IceLocalIp.port =  GetMediaChosenLocalPort(eDataType);
                }

                UpdatePartyMonitoring((TRtpCommonChannelMonitoring*)pChanMonitoring,pPrtMonitrParams,m_oldMediaBytesArr,pChannel->GetAlgorithm(),
                        eChanType,pChannel->GetCardIndex(),m_pCall->GetCardIndex(),m_oldFramesArr,pChannel->GetCurrentRate(),
                        (char *)pChannel->GetData(),&remoteIp,&localIp,IsIce,&IceRemoteIp,&IceLocalIp,ChosenConnectionType); //14

            }
            else
                UpdatePartyMonitoring((TRtpCommonChannelMonitoring*)pChanMonitoring,pPrtMonitrParams,m_oldMediaBytesArr,pChannel->GetAlgorithm(),
                        eChanType,pChannel->GetCardIndex(),m_pCall->GetCardIndex(),m_oldFramesArr,pChannel->GetCurrentRate(),
                        (char *)pChannel->GetData(),&remoteIp,&localIp,IsIce,&IceRemoteIp,&IceLocalIp); //14

            //PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnPartyMonitoringInd this is media type " ,(DWORD)eChanType);
            if (isMonitoringIndMsg == TRUE)
            {
                m_pPartyApi->IpLogicalChannelConnect(pPrtMonitrParams,(DWORD)eChanType,0);

                if ((eChanType==VIDEO_OUT) || (eChanType==VIDEO_CONT_OUT))
                {
                    BYTE    intraSyncFlag           = 0;
                    DWORD   streamVideoSyncParams   = 0;
                    BYTE videoBCHSyncFlag           = 0;
                    WORD bchOutOfSyncCount          = 0;
                    BYTE protocolSyncFlag           = 0;
                    WORD protocolOutOfSyncCount     = 0;

                    streamVideoSyncParams = ((TRtpVideoChannelMonitoring *)pChanMonitoring)->unStreamVideoSync;
                    VideoSyncParamsParser(streamVideoSyncParams,
                            intraSyncFlag, videoBCHSyncFlag, bchOutOfSyncCount,
                            protocolSyncFlag, protocolOutOfSyncCount);

                    m_pPartyApi->IpPartyMonitoringUpdateDB(
                            (BYTE)eChanType,  intraSyncFlag,
                            videoBCHSyncFlag, bchOutOfSyncCount,
                            protocolSyncFlag, protocolOutOfSyncCount);

                }
            }
            else //for CDR_MCCF
            {
                PTRACE(eLevelInfoNormal,"CDR_MCCF: CSipCntl::OnPartyInfoStatisticsOrMonitoring - set channel details for CDR_MCCF feature");
                UpdateChannelStatisticsInfoIfNeeded((TRtpCommonChannelMonitoring*)pChanMonitoring,(CPrtMontrBaseParams*)pPrtMonitrParams);
            }

            POBJDELETE(pPrtMonitrParams);
        }
        pChanMonitoring = (TRtpChannelMonitoringInd *)((BYTE *)pChanMonitoring + sizeof(TRtpVideoChannelMonitoring));
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//CDR_MCCF:
void CSipCntl::UpdateChannelStatisticsInfoIfNeeded(TRtpCommonChannelMonitoring* pChanMonitoring ,CPrtMontrBaseParams* pPrtMonitrParams)
{
     if (!pPrtMonitrParams)
        return;

      PTRACE(eLevelInfoNormal, "CDR_MCCF: CSipCntl::UpdateChannelStatisticsInfoIfNeeded ");
      EIpChannelType     channelType      = (EIpChannelType)pPrtMonitrParams->GetChannelType();
      BYTE               connectionStatus = (BYTE)pPrtMonitrParams->GetConnectionStatus();
      DWORD              acualRate        = pPrtMonitrParams->GetBitRate();  //rate clculatin is not valid for statistic info as it is not current rate-igonre it -this will not be passed to DMA.

      mcTransportAddress partyAddr;
      memset(&partyAddr, 0, sizeof(mcTransportAddress));
      memcpy(&partyAddr, pPrtMonitrParams->GetPartyAddr(), sizeof(mcTransportAddress));

      WORD               partyPort = pPrtMonitrParams->GetPartyPort();

      mcTransportAddress mcuAddr;
      memset(&mcuAddr, 0, sizeof(mcTransportAddress));
      memcpy(&mcuAddr, pPrtMonitrParams->GetMcuAddr(), sizeof(mcTransportAddress));

      WORD               mcuPort           = pPrtMonitrParams->GetMcuPort();
      WORD               frameRate         = pPrtMonitrParams->GetFrameRate();
      int                resolution        = pPrtMonitrParams->GetResolution();
      BYTE               IsIce             = pPrtMonitrParams->GetIsIce();
      EIceConnectionType IceConnectionType = pPrtMonitrParams->GetIceConnectionType();

      mcTransportAddress IcePartyAddr;
      memset(&IcePartyAddr, 0, sizeof(mcTransportAddress));

      mcTransportAddress IceMcuAddr;
      memset(&IceMcuAddr, 0, sizeof(mcTransportAddress));

      if (pPrtMonitrParams->GetIcePartyAddr() && pPrtMonitrParams->GetIceMcuAddr())
      {
        memcpy(&IcePartyAddr, pPrtMonitrParams->GetIcePartyAddr(), sizeof(mcTransportAddress));
        memcpy(&IceMcuAddr, pPrtMonitrParams->GetIceMcuAddr(), sizeof(mcTransportAddress));
      }

      if (channelType < IP_CHANNEL_TYPES_NUMBER)
      {
          int channelPos =0;
          if(channelType == VIDEO_OUT)
              channelPos = 0;
          else if(channelType == VIDEO_CONT_OUT)
              channelPos =1;
          else
          {
              PTRACE2INT(eLevelError,"CDR_MCCF: CSipCntl::UpdateChannelStatisticsInfoIfNeeded - got statistics on channel different than video out or content out ",channelType);
              DBGPASSERT(YES);
              return;
          }
		  if(m_pIpVideoCdrChannelMonitor[channelPos])
		  {

		  	TRACEINTO<<"DRAGON"<<" channel pos="<<channelPos<<" connection="<<m_pIpVideoCdrChannelMonitor[channelPos]->GetConnectionStatus()<<" num="<<pChanMonitoring->unMediaBytes;

		  }
          if (m_pIpVideoCdrChannelMonitor[channelPos] && m_pIpVideoCdrChannelMonitor[channelPos]->GetConnectionStatus() == NO && pChanMonitoring->unMediaBytes > 0) //meaning this is the first time we got statistics on this channel so we save it without compare
          {
              PTRACE2INT(eLevelInfoNormal, "CDR_MCCF: CSipCntl::UpdateChannelStatisticsInfoIfNeeded - first time to get info on channel save as is ",channelPos);
              m_pIpVideoCdrChannelMonitor[channelPos]->CopyClass(*pPrtMonitrParams);
              if (m_pIpVideoCdrChannelDetails[channelPos])
                  SetIpVideoChannelDetails(channelType, connectionStatus, acualRate, &partyAddr, &mcuAddr, IsIce, &IcePartyAddr, &IceMcuAddr, IceConnectionType, 0xFFFFFFFF, 0xFFFFFFFF, frameRate, resolution);
          }
          else if(m_pIpVideoCdrChannelMonitor[channelPos] && pChanMonitoring->unMediaBytes > 0)
          {
              PTRACE2INT(eLevelInfoNormal, "CDR_MCCF: CSipCntl::UpdateChannelStatisticsInfoIfNeeded - not the first time to get info on channel so we compare params ",channelPos);
              CompareChannelStatisticsWithCurrentDbStatisticsAndUpdate(pPrtMonitrParams);
          }
          else
              PTRACE2INT(eLevelError, "CDR_MCCF: CSipCntl::UpdateChannelStatisticsInfoIfNeeded - m_pIpVideoCdrChannelMonitor[channelPos] is NULL ",channelPos);

          CMedString msg;
          msg << "end! channelPos:" << channelPos << " channelType:" << channelType <<
                        " m_pIpVideoCdrChannelMonitor[channelPos]->GetJitterPeak() :" << m_pIpVideoCdrChannelMonitor[channelPos]->GetJitterPeak();


          msg<< " m_pIpVideoCdrChannelMonitor[channelPos]->GetNumOfPackets() :" << m_pIpVideoCdrChannelMonitor[channelPos]->GetNumOfPackets();


          msg<<  " m_pIpVideoCdrChannelMonitor[channelPos]->GetPacketLoss() :" << m_pIpVideoCdrChannelMonitor[channelPos]->GetPacketLoss();
          msg<<  " m_pIpVideoCdrChannelMonitor[channelPos]->GetMaxResolution() :" << m_pIpVideoCdrChannelMonitor[channelPos]->GetMaxResolution();
          msg<<  " m_pIpVideoCdrChannelMonitor[channelPos]->GetMinResolution() :" << m_pIpVideoCdrChannelMonitor[channelPos]->GetMinResolution();
          msg<<  " m_pIpVideoCdrChannelMonitor[channelPos]->GetMaxFrameRate() :" << m_pIpVideoCdrChannelMonitor[channelPos]->GetMaxFrameRate();
          msg<<  " m_pIpVideoCdrChannelMonitor[channelPos]->GetMinFrameRate() :" << m_pIpVideoCdrChannelMonitor[channelPos]->GetMinFrameRate();
          msg<<  " ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolutionHeight() : " << ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolutionHeight() <<
                 " ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolutionWidth() : " << ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolutionWidth();
          msg<<  " ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolutionHeight() :" << ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolutionHeight() <<
                 " ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolutionWidth() :" <<  ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolutionWidth();


          PTRACE2(eLevelError,"CDR_MCCF: CSipCntl::UpdateChannelStatisticsInfoIfNeeded last : ", msg.GetString());



      }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CDR_MCCF:
void CSipCntl::SetIpVideoChannelDetails(EIpChannelType channelType, BYTE connectionStatus,
                                     DWORD actualRate, mcTransportAddress* partyAddr, mcTransportAddress* mcuAddr, BYTE IsIce,
                                     mcTransportAddress* IcePartyAddr, mcTransportAddress* IceMcuAddr, EIceConnectionType IceConnectionType,
                                     DWORD packetsCounterIn, DWORD packetsCounterUse, WORD frameRate, int videoResolution)
{
  if (channelType < IP_CHANNEL_TYPES_NUMBER)
  {
      int channelPos =0;
      if(channelType == VIDEO_OUT)
            channelPos = 0;
      else if(channelType == VIDEO_CONT_OUT)
            channelPos =1;
      else
     {
         PTRACE2INT(eLevelError,"CDR_MCCF: CSipCntl::SetIpVideoChannelDetails - got statistics on channel different than video out or content out ",channelType);
         DBGPASSERT(YES);
         return;
     }

    PTRACE2INT(eLevelInfoNormal,"CDR_MCCF: CSipCntl::SetIpVideoChannelDetails -channelPos ",channelPos);
    if (m_pIpVideoCdrChannelDetails[channelPos])
    {
      if (channelType != m_pIpVideoCdrChannelDetails[channelPos]->GetChannelType())
          m_pIpVideoCdrChannelDetails[channelPos]->SetChannelType(channelType);

      if (connectionStatus != 0xFF)
          m_pIpVideoCdrChannelDetails[channelPos]->SetConnectionStatus(connectionStatus);

      if (actualRate != 0xFFFFFFFF)
          m_pIpVideoCdrChannelDetails[channelPos]->SetActualRate(actualRate);

      if (::isApiTaNull(partyAddr) != TRUE || partyAddr->port != 0xFFFF)
          m_pIpVideoCdrChannelDetails[channelPos]->SetPartyAddrPort(partyAddr);

      if (::isApiTaNull(mcuAddr) != TRUE || mcuAddr->port != 0xFFFF)
          m_pIpVideoCdrChannelDetails[channelPos]->SetMcuAddrPort(mcuAddr);

      if (packetsCounterIn != 0xFFFFFFFF)
          m_pIpVideoCdrChannelDetails[channelPos]->SetPacketsCounterIn(packetsCounterIn);

      if (packetsCounterUse != 0xFFFFFFFF)
          m_pIpVideoCdrChannelDetails[channelPos]->SetPacketsCounterUse(packetsCounterUse);

      if (frameRate != 0xFFFF)
          m_pIpVideoCdrChannelDetails[channelPos]->SetFrameRate(frameRate);

      if (videoResolution != 0xFFFF)
      {
          m_pIpVideoCdrChannelDetails[channelPos]->SetVideoResolution(videoResolution);
      }

      m_pIpVideoCdrChannelDetails[channelPos]->SetIsIce(IsIce);

      if (::isApiTaNull(IcePartyAddr) != TRUE || IcePartyAddr->port != 0xFFFF)
          m_pIpVideoCdrChannelDetails[channelPos]->SetIcePartyAddrPort(IcePartyAddr);

      if (::isApiTaNull(IceMcuAddr) != TRUE || IceMcuAddr->port != 0xFFFF)
          m_pIpVideoCdrChannelDetails[channelPos]->SetIceMcuAddrPort(IceMcuAddr);

      if (IceConnectionType)
          m_pIpVideoCdrChannelDetails[channelPos]->SetIceConnectionType(IceConnectionType);
    }
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CDR_MCCF:
void CSipCntl::CompareChannelStatisticsWithCurrentDbStatisticsAndUpdate(CPrtMontrBaseParams* pPrtMonitrParams)
{
    PTRACE(eLevelInfoNormal, "CDR_MCCF: CSipCntl::CompareChannelStatisticsWithCurrentDbStatisticsAndUpdate channelType:");
    EIpChannelType     channelType      = (EIpChannelType)pPrtMonitrParams->GetChannelType();

    CMedString msg;

     if (channelType < IP_CHANNEL_TYPES_NUMBER)
      {
          int channelPos =0;
          if(channelType == VIDEO_OUT)
                channelPos = 0;
          else if(channelType == VIDEO_CONT_OUT)
                channelPos =1;
          else
         {
             PTRACE2INT(eLevelError,"CDR_MCCF: CSipCntl::SetIpVideoChannelDetails - got statistics on channel different than video out or content out ",channelType);
             DBGPASSERT(YES);
             return;
         }

        msg << " channelPos:" << channelPos << " channelType:" << channelType <<
               " m_pIpVideoCdrChannelMonitor[channelPos]->GetJitterPeak() before:" << m_pIpVideoCdrChannelMonitor[channelPos]->GetJitterPeak() <<
               " pPrtMonitrParams->GetJitterPeak():" << pPrtMonitrParams->GetJitterPeak();

          DWORD jitterPeak = max(m_pIpVideoCdrChannelMonitor[channelPos]->GetJitterPeak(),pPrtMonitrParams->GetJitterPeak() );
          ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->SetJitterPeak(jitterPeak);

        msg << " m_pIpVideoCdrChannelMonitor[channelPos]->GetJitterPeak() after:" << m_pIpVideoCdrChannelMonitor[channelPos]->GetJitterPeak() <<
               " jitterPeak:" << jitterPeak <<
               " m_pIpVideoCdrChannelMonitor[channelPos]->GetNumOfPackets() before:" << m_pIpVideoCdrChannelMonitor[channelPos]->GetNumOfPackets() <<
               " pPrtMonitrParams->GetNumOfPackets():" << pPrtMonitrParams->GetNumOfPackets();

          DWORD numofPackets = m_pIpVideoCdrChannelMonitor[channelPos]->GetNumOfPackets() + pPrtMonitrParams->GetNumOfPackets();
                  ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->SetNumOfPackets(numofPackets);

        msg << " numofPackets:" << numofPackets <<
               " m_pIpVideoCdrChannelMonitor[channelPos]->GetNumOfPackets() after:" << m_pIpVideoCdrChannelMonitor[channelPos]->GetNumOfPackets() <<
               " m_pIpVideoCdrChannelMonitor[channelPos]->GetPacketLoss() before:" << m_pIpVideoCdrChannelMonitor[channelPos]->GetPacketLoss() <<
               " pPrtMonitrParams->GetPacketLoss():" << pPrtMonitrParams->GetPacketLoss();


          DWORD numofPacketsLost = m_pIpVideoCdrChannelMonitor[channelPos]->GetPacketLoss() + pPrtMonitrParams->GetPacketLoss();
                                ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->SetPacketLoss(numofPacketsLost);

        msg << " numofPacketsLost:" << numofPacketsLost <<
               " m_pIpVideoCdrChannelMonitor[channelPos]->GetPacketLoss() after:" << m_pIpVideoCdrChannelMonitor[channelPos]->GetPacketLoss() <<
               " roundedUpmaxResolutionLast - m_pIpVideoCdrChannelMonitor[channelPos]->GetMaxResolution():" << m_pIpVideoCdrChannelMonitor[channelPos]->GetMaxResolution() <<
               " roundedUpmaxResolutionNew - pPrtMonitrParams->GetMaxResolution():" << pPrtMonitrParams->GetMaxResolution();

        //start check for max resolution
          DWORD roundedUpmaxResolutionLast = m_pIpVideoCdrChannelMonitor[channelPos]->GetMaxResolution();
          if(roundedUpmaxResolutionLast == (DWORD)kUnknownFormat)
              roundedUpmaxResolutionLast = CCapSetInfo::GetResolutionFormat(((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolutionWidth(), ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolutionHeight());

          EOrderedFormat eReportedResolutionMaxLast = CCapSetInfo::ConvertFormatToOrderedFormat((EFormat)roundedUpmaxResolutionLast);

          DWORD roundedUpmaxResolutionNew = pPrtMonitrParams->GetMaxResolution();
          if(roundedUpmaxResolutionNew == (DWORD)kUnknownFormat)
              roundedUpmaxResolutionNew = CCapSetInfo::GetResolutionFormat(((CAdvanceVideo*)pPrtMonitrParams)->GetMaxResolutionWidth(), ((CAdvanceVideo*)pPrtMonitrParams)->GetMaxResolutionHeight());

          EOrderedFormat eReportedResolutionMaxNew = CCapSetInfo::ConvertFormatToOrderedFormat((EFormat)roundedUpmaxResolutionNew);

          DWORD maxFrameRateLast = ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxFrameRate();
          DWORD maxFrameRateNew = ((CPrtMontrGlobalParams*)pPrtMonitrParams)->GetMaxFrameRate();

        msg << " maxFrameRateLast:" << maxFrameRateLast << " maxFrameRateNew:" << maxFrameRateNew;

          if(eReportedResolutionMaxNew > eReportedResolutionMaxLast || ( eReportedResolutionMaxNew == eReportedResolutionMaxLast && maxFrameRateNew > maxFrameRateLast) )
          {
              PTRACE(eLevelInfoNormal, "CDR_MCCF: CSipCntl::CompareChannelStatisticsWithCurrentDbStatisticsAndUpdate new max resolution is bigger save new info");
              ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->SetMaxFrameRate(maxFrameRateNew);
              ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->SetMaxResolution(pPrtMonitrParams->GetMaxResolution());
              ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->SetMaxResolutionWidth( ((CAdvanceVideo*)pPrtMonitrParams)->GetMaxResolutionWidth());
              ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->SetMaxResolutionHeight( ((CAdvanceVideo*)pPrtMonitrParams)->GetMaxResolutionHeight());
          }

        msg << " ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxFrameRate() after:" << ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxFrameRate() <<
               " ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolution() after:" << ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolution() <<
               " ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolutionHeight() after:" << ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolutionHeight() <<
               " ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolutionWidth() after:" << ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMaxResolutionWidth();

          //start check for min resolution
          DWORD roundedUpminResolutionLast = m_pIpVideoCdrChannelMonitor[channelPos]->GetMinResolution();
          if(roundedUpminResolutionLast == (DWORD)kUnknownFormat)
              roundedUpminResolutionLast = CCapSetInfo::GetResolutionFormat(((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolutionWidth(), ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolutionHeight());

          EOrderedFormat eReportedResolutionMinLast = CCapSetInfo::ConvertFormatToOrderedFormat((EFormat)roundedUpminResolutionLast);

          DWORD roundedUpminResolutionNew = pPrtMonitrParams->GetMinResolution();
          if(roundedUpminResolutionNew == (DWORD)kUnknownFormat)
              roundedUpminResolutionNew = CCapSetInfo::GetResolutionFormat(((CAdvanceVideo*)pPrtMonitrParams)->GetMinResolutionWidth(), ((CAdvanceVideo*)pPrtMonitrParams)->GetMinResolutionHeight());

        msg << " roundedUpminResolutionLast - m_pIpVideoCdrChannelMonitor[channelPos]->GetMinResolution():" << m_pIpVideoCdrChannelMonitor[channelPos]->GetMinResolution() <<
               " roundedUpminResolutionNew - pPrtMonitrParams->GetMinResolution():" << pPrtMonitrParams->GetMinResolution();

          EOrderedFormat eReportedResolutionMinNew = CCapSetInfo::ConvertFormatToOrderedFormat((EFormat)roundedUpminResolutionNew);

          DWORD minFrameRateLast = ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinFrameRate();
          DWORD minFrameRateNew = ((CPrtMontrGlobalParams*)pPrtMonitrParams)->GetMinFrameRate();

          if(eReportedResolutionMinNew < eReportedResolutionMinLast || ( eReportedResolutionMinNew == eReportedResolutionMinLast && minFrameRateNew < minFrameRateLast) )
          {
              PTRACE(eLevelInfoNormal, "CDR_MCCF: CSipCntl::CompareChannelStatisticsWithCurrentDbStatisticsAndUpdate new min resolution is lower save new info");
              ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->SetMinFrameRate(minFrameRateNew);
              ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->SetMinResolution(pPrtMonitrParams->GetMinResolution());
              ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->SetMinResolutionWidth( ((CAdvanceVideo*)pPrtMonitrParams)->GetMinResolutionWidth());
              ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->SetMinResolutionHeight( ((CAdvanceVideo*)pPrtMonitrParams)->GetMinResolutionHeight());
          }

        msg << " minFrameRateLast - ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinFrameRate():" << ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinFrameRate() <<
               " minFrameRateNew - ((CPrtMontrGlobalParams*)pPrtMonitrParams)->GetMinFrameRate():" << ((CPrtMontrGlobalParams*)pPrtMonitrParams)->GetMinFrameRate() <<
               " ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinFrameRate() after:" << ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinFrameRate() <<
               " ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolution() after:" << ((CPrtMontrGlobalParams*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolution() <<
               " ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolutionHeight() after:" << ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolutionHeight() <<
               " ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolutionWidth() after:" <<  ((CAdvanceVideo*)m_pIpVideoCdrChannelMonitor[channelPos])->GetMinResolutionWidth();


        PTRACE2(eLevelError,"CDR_MCCF: CSipCntl::CompareChannelStatisticsWithCurrentDbStatisticsAndUpdate: ", msg.GetString());

      }

}


//////////////////////////////////////////////////////////////
// IP_CM_RTCP_MS_SVC_PLI_IND - indicated of RTCP flow control message
void CSipCntl::OnCmRtcpMsSvcPliInd(CSegment* pParam)
{
DBGPASSERT_AND_RETURN(!pParam);

	TCmRtcpMsSvcPLIMsg	msSvcPLIMsg;
    memset(&msSvcPLIMsg,0,sizeof(TCmRtcpMsSvcPLIMsg));
    pParam->Get( (BYTE*)&msSvcPLIMsg, sizeof(TCmRtcpMsSvcPLIMsg));
    TCmRtcpMsSvcPLIInfo& pliInfo = msSvcPLIMsg.cmRtcpMsSvcPLI;

    CMedString log;
    log << "MSI[" << pliInfo.mediaSourceSSRC << "], SSRC[" << pliInfo.senderSSRC << "], requestID[" << pliInfo.requestId << "]";

    bool to_all = true;
    APIU8* pSfr = &(pliInfo.SFR0);
    for (int i = 0; i < 8; ++i)
    {
    	log << "SFR" << i << "[" << *(pSfr + i) << "] ";
       	if(*(pSfr + i) != 0xFF){
       			if(GetRemoteIdent() == Microsoft_AV_MCU2013){
       				to_all = false;
       			}
        	}
    }

    PTRACE2(eLevelInfoNormal,"CSipCntl::OnCmRtcpMsSvcPliInd - ",log.GetString());

    // build encoders mask to slave controller to use
    WORD encoders_mask = 0;
    if(to_all){
    	encoders_mask = 0xFF;
    }else{

        pSfr = &(pliInfo.SFR0);
        unsigned char current_bit_mask = 0;
    	DWORD current_prID = 0;
    	EVideoResolutionType requestedRes = eAuto_Res;

        for (int i = 0; i < 8; ++i)
        {
        	unsigned char current_sfr_byte = *(pSfr + i);
            for (int j = 0; j < 8; ++j)
            {
            	// by microsoft MSDN, prId set lsb = 0 to msb = 7
            	current_bit_mask = (0x01<<j);
            	if(current_sfr_byte & current_bit_mask){
            		current_prID = i*8+j;
            		requestedRes = GetResolutionTypeByPrId(current_prID);
            		switch(requestedRes){
            		case eCIF_Res:{
            			encoders_mask |= 0x01;
            			break;
            		}
            		case eSD_Res:{
            			encoders_mask |= 0x02;
            			break;
            		}
            		case eHD720_Res:{
            			encoders_mask |= 0x04;
            			break;
            		}
            		default:{
            			break;
            		}
            		}
            	}
            }
        }
    }

    CSipChannel* pChannel = m_pCall->GetChannel(true, cmCapVideo, cmCapTransmit,kRolePeople);
    if (pChannel != NULL && pChannel->GetConnectionState() == kConnected)
    {
    	if(to_all){
    		PTRACE(eLevelInfoNormal,"CSipCntl::OnCmRtcpMsSvcPliInd Outgoing channel, Ask VB/CB for new intra.");
    		BYTE bIsGradualIntra = FALSE;
    		CSegment*  seg = new CSegment;
    		*seg << (WORD)Fast_Update << (WORD)kRolePeople << (WORD)1 << bIsGradualIntra;// Remote report on Intra

    		m_pPartyApi->IpRmtH230(seg); // forward task to party manager
    		POBJDELETE(seg);
    	}else{
    		PTRACE(eLevelInfoNormal,"CSipCntl::OnCmRtcpMsSvcPliInd Outgoing channel, Ask intra from slave encodes");
    		BYTE bIsGradualIntra = FALSE;
    		CSegment*  seg = new CSegment;
    		*seg << encoders_mask << (WORD)Fast_Update << (WORD)kRolePeople << (WORD)1 << bIsGradualIntra;// Remote report on Intra

    		m_pPartyApi->IpRmtSpecificStreamsFastUpdateReq(seg);
    		POBJDELETE(seg);

    	}
    }
}

//////////////////////////////////////////////////////
// IP_CM_RTCP_DSH_IND - indicated of RTCP flow control message
void CSipCntl::OnCmRtcpAvMcuDshInd(CSegment* pParam)
{
	PASSERT_AND_RETURN(!pParam);
	PASSERT_AND_RETURN(!m_pParty);

	TCmRtcpDshMsg msDshMsg;
	pParam->Get((BYTE*)&msDshMsg, sizeof(msDshMsg));
	TCmRtcpDshInfo& dshInfo = msDshMsg.cmRtcpDsh;

	TRACEINTO << "PartyId:" << m_pParty->GetPartyRsrcID() << ", DominantSpeakerMsi:" << dshInfo.dominantSpeakerMsi;

	EventPackage::ApiLync::Instance().AddDSH(m_pParty->GetPartyRsrcID(), (LyncMsi*)dshInfo.DSHEntry, ARRAYSIZE(dshInfo.DSHEntry));
}

//////////////////////////////////////////////////////////////
// IP_CM_RTCP_RTPFB_IND - indicated of RTCP flow control message
void CSipCntl::OnCmRtcpRtpFBInd(CSegment* pParam)
{
	TCmRtcpRTPFB 		dataStruct;
	CMedString 			cLog;
	APIU32				rate;
	ERoleLabel 			eRole;

	//Ignore LPR & Flow Control indications for AVC call in MixAvcSvcVsw conference
	if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvcVsw && !m_bIsMrcCall) {
		PTRACE(eLevelInfoNormal,"CSipCntl::OnCmRtcpRtpFBInd: ignore LPR & Flow Control indications for AVC eMixAvcSvcVsw");
		return;
	}

    memset(&dataStruct,0,sizeof(TCmRtcpRTPFB));
    pParam->Get( (BYTE*)&dataStruct, sizeof(TCmRtcpRTPFB)); /* fetch data struct sent by the emb.*/

    eRole = dataStruct.tCmRtcpRTPFBInfo.uMediaType == kIpVideoChnlType ?  kRolePeople : kRolePresentation;

    /* calculate the rate by the mantissa and exp params */
    TmmbrParamsToRate(dataStruct.tCmRtcpRTPFBInfo.MxTBRMantissa, dataStruct.tCmRtcpRTPFBInfo.MxTBRExp, &rate);

    cLog << "Received RTCP TMMBR Flow control from CardManager Rate:" << rate << " uMediaType=" << dataStruct.tCmRtcpRTPFBInfo.uMediaType << " role = " << eRole;
    PTRACE2(eLevelInfoNormal,"CSipCntl::OnCmRtcpRtpFBInd: ",cLog.GetString());

    /*update the video/content rate according to the flow control */
    m_pPartyApi->UpdatePartyVideoBitRate(rate/100, cmCapTransmit, eRole);

}


//////////////////////////////////////////////////////////////
// IP_CM_RTCP_MSG_IND.. Indicates on RTCP RR Packet loss
void CSipCntl::OnCmRtcpMsgInd(CSegment* pParam)
{
	// Retrieve data from segment received
	TCmRtcpMsg dataStruct;
    memset(&dataStruct,0,sizeof(TCmRtcpMsg));
    pParam->Get( (BYTE*)&dataStruct, sizeof(TCmRtcpMsg));
    kChanneltype channelType = (kChanneltype)((dataStruct.tCmRtcpMsgInfo).uMediaType);
    cmCapDirection channelDirection = cmCapTransmit;
    eRtcpMsgType msgType = (eRtcpMsgType)((dataStruct.tCmRtcpMsgInfo).uMsgType);

    APIU32 sequenceNumber = dataStruct.tCmRtcpMsgInfo.uSeqNumber;

	DWORD tipPackLossInterval = 3;
	BOOL  bTipSendIntraForPLI = YES;
	CSysConfig* sysConfig = NULL;
	CProcessBase *pProcess = CProcessBase::GetProcess();
	if(pProcess)
		sysConfig =	pProcess->GetSysConfig();
	if(sysConfig)
	{
		sysConfig->GetDWORDDataByKey(CFG_KEY_TIP_PACKET_LOSS_SEND_INTRA_INTERVAL_SEC, tipPackLossInterval);
		sysConfig->GetBOOLDataByKey(CFG_KEY_TIP_SEND_INTRA_FOR_PLI, bTipSendIntraForPLI);  // the default value is "NO"
	}

    ETipVideoPosition tipPosition = eTipVideoPosLast;
    BYTE bIsGradualIntra = FALSE;

    CMedString cLog;
    cLog << "channel type " << channelType << ", channel direction " << channelDirection << ", message type " << msgType;

    if (GetIsTipCall())
	{
		CSipChannel* pChannel = m_pCall->GetChannel(true,cmCapVideo, cmCapReceive,kRolePeople);
		BYTE isBlockSendIntra = FALSE;

		if(pChannel && (pChannel->IsMuted() == TRUE || m_bIsOnHold || m_bIsResuming))
			isBlockSendIntra = TRUE;
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnCmRtcpMsgInd: isBlockSendIntra ",isBlockSendIntra);
	    if ( m_pParty->GetTargetMode()->IsTipNegotiated() == FALSE ||  isBlockSendIntra )
	    {
	        PTRACE(eLevelInfoNormal,"CSipCntl::OnCmRtcpMsgInd: not sending intra req because TipNegotiation is Active (for example:still creating slaves)");
	        return;
	    }
    	if (!(msgType == RTCP_TIP_IDR || msgType == RTCP_TIP_GDR || msgType == RTCP_TIP_PKT_LOSS || msgType ==  RTCP_INTRA_RTV))
    		DBGPASSERT(msgType+100);
		if (msgType == RTCP_TIP_GDR || msgType == RTCP_TIP_PKT_LOSS)
			bIsGradualIntra = TRUE;  // TODO: Need to change the parameter name and meaning.
    	tipPosition = (ETipVideoPosition)((dataStruct.tCmRtcpMsgInfo).uTipPosition);
 		cLog << ", Tip Position from EP:" << tipPosition;

 		// swap positions (just in case of NACK)
 		if (msgType == RTCP_TIP_PKT_LOSS)
 		{
			if (tipPosition == eTipVideoPosLeft)
			{
				tipPosition = eTipVideoPosRight;
				m_nLeftToRightNacks++;
			}
			else if (tipPosition == eTipVideoPosRight)
			{
				tipPosition = eTipVideoPosLeft;
				m_nRightToLeftNacks++;
			}
			else
			{
				m_nCenterNacks++;
			}
 		}

 		cLog << ", Tip Position to Encoder:" << tipPosition;
 		cLog << ", seq. number:" << sequenceNumber;
	}

    PTRACE2(eLevelInfoNormal,"CSipCntl::OnCmRtcpMsgInd: ",cLog.GetString());

    if (GetIsTipCall())
	{
		cLog.Clear();

		cLog << "Counter: id:" << m_pParty->GetPartyId() <<", NACK!!! - center:" << m_nCenterNacks << ", left:" << m_nLeftToRightNacks << ", right:" << m_nRightToLeftNacks << ", total:" << (m_nCenterNacks + m_nLeftToRightNacks + m_nRightToLeftNacks);
		cLog << ", RTP self intra req conuter:" << m_nRtpSelfIntraReq;

		PTRACE2(eLevelInfoNormal,"CSipCntl::OnCmRtcpMsgInd: ",cLog.GetString());
	}

    CSipComMode* pCurrentMode = new CSipComMode;
    pCurrentMode->Create(*m_pCall);
    BYTE bIsLprEnabled = pCurrentMode->GetIsLpr();
//    POBJDELETE(pCurrentMode);

    if (channelDirection != cmCapTransmit)
    {
       PTRACE(eLevelInfoNormal,"CSipCntl::OnCmRtcpMsgInd - not transmit channel. ignore RTCP RR for non transmit channels");
    }
   else if ((channelType != kIpVideoChnlType) && (channelType != kIpContentChnlType))
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnCmRtcpMsgInd - not video or content channel");
}
else if (  (msgType == RTCP_INTRA_RTV) && (m_remoteIdent == MicrosoftEP_R1 || m_remoteIdent == MicrosoftEP_R2 ||m_remoteIdent == MicrosoftEP_Lync_R1  || m_remoteIdent == MicrosoftEP_Lync_2013 || m_remoteIdent == MicrosoftEP_MAC || m_remoteIdent == MicrosoftEP_MAC_Lync ) )
	{//For RTV only??? from MOC only???
	 	CapEnum capTarget;
	  	if(channelType == kIpVideoChnlType)
	   	{
	   		capTarget = (CapEnum)pCurrentMode->GetMediaType(cmCapVideo, cmCapTransmit);
    		if(capTarget == eRtvCapCode)
   	   		SendH230FastUpdateToParty(channelType, cmCapTransmit);
    	}
    }
	else if ((msgType == RTCP_FIR) || (msgType == RTCP_PLI && !GetIsTipCall()) || (msgType == RTCP_PLI && GetIsTipCall() && bTipSendIntraForPLI) || (msgType == RTCP_WEBRTC_FIR)) // BRIDGE-4459
	{
		PTRACE2(eLevelInfoNormal,"CSipCntl::OnCmRtcpMsgInd : Video Fast Update case with FIR, Name - ", PARTYNAME);
		if((!m_bIsMrcCall) && m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvcVsw)
		{
			unsigned int 		   unChannelHandle=1000;
			unsigned int   	   unSequenseNumber=200;
			unsigned int 	   	   nNumberOfSyncSources=1;
			APIUBOOL	   bIsGdr=FALSE;
			unsigned int		   syncSources = 0;

			const std::list <StreamDesc> streamsDescList = m_pParty->GetTargetMode()->GetStreamsListForMediaMode(cmCapVideo,cmCapTransmit, kRolePeople);
			std::list <StreamDesc>::const_iterator itr_streams;
			itr_streams = streamsDescList.begin();
			if(itr_streams!=streamsDescList.end())
			{
				syncSources=itr_streams->m_pipeIdSsrc;
				TRACEINTOFUNC<<"#@@@! CSipCntl::OnCmRtcpMsgInd syncSources="<<syncSources;
			}

//				syncSources[0]=3000;
			CSegment* pParam2 = new CSegment;
			*pParam2<<unChannelHandle;
			*pParam2<<unSequenseNumber;
			*pParam2<<nNumberOfSyncSources;
			*pParam2<<bIsGdr;
//				*pParam2<<&syncSources;
			*pParam2<<syncSources;
			m_pPartyApi->HandleMrmpRtcpFirInd(pParam2);

		}
		else
		{
			if(GetIsTipCall() && (tipPosition == eTipVideoPosCenter || tipPosition == eTipVideoPosLeft || tipPosition == eTipVideoPosRight))
				SendH230FastUpdateToParty(channelType, cmCapTransmit, TRUE, tipPosition);
			else
				SendH230FastUpdateToParty(channelType, cmCapTransmit);
		}
	}
	else if ((msgType != RTCP_INTRA_RTV && !GetIsTipCall()) ||
			 (msgType != RTCP_INTRA_RTV && GetIsTipCall() && tipPackLossInterval != 0)) // BRIDGE-4459 (tipPackLossInterval )
	{
		// should request intra from video bridge
		SendH230FastUpdateToParty(channelType, channelDirection, bIsGradualIntra, tipPosition);

		if (msgType == RTCP_TIP_IDR || msgType == RTCP_TIP_GDR || msgType == RTCP_TIP_PKT_LOSS) // tiptmp check
		{
			CSipChannel* pChannel = m_pCall->GetChannel(true, cmCapVideo, channelDirection, kRoleContentOrPresentation);

			if (pChannel && GetSystemCfgFlagInt<BOOL>(CFG_KEY_INITIATE_TIP_CONTENT_INTRA) == YES)
			{
				PTRACE(eLevelError,"INITIATE_TIP_CONTENT_INTRA = YES");
				SendH230FastUpdateToParty(kIpContentChnlType, channelDirection); // tiptmp check
			}
		}
	}

	POBJDELETE(pCurrentMode);
}


/////////////////////////////////////////////////////////////////
void CSipCntl::UpdateSeeingMcuTerminalNum(WORD mcuNum, WORD terminalNum, PartyRsrcID partyId)
{
	m_speakerMcuNum		= mcuNum;
	m_speakerTermNum	= terminalNum;
	m_speakerPartyId	= partyId;

	//in RMX2000C when SEND_VIN received from conf it means that the token request
	//is from PCM and we should let RTP know that they should actualy move the camera
	m_isCameraControl = 1;

    TRACEINTO << "CSipCntl::UpdateSeeingMcuTerminalNum "
                  << "- McuNum"       	<< mcuNum
                  << ", TermNum:"         << terminalNum
                  << ", PartyId:"  		<< partyId
                  << ", isCameraControl: "<< (m_isCameraControl ? "yes" : "no");
}
/////////////////////////////////////////////////////////////////
void CSipCntl::OnRtpFeccTokenInd(CSegment *pParam)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnRtpFeccTokenInd - ",m_pMfaInterface->GetConnectionId());

	TRtpFeccTokenRequestInd *pFeccToken = new TRtpFeccTokenRequestInd;
	DWORD  structLen = sizeof(TRtpFeccTokenRequestInd);
	memset(pFeccToken, 0, structLen);
	pParam->Get((BYTE*)pFeccToken, structLen);

	CSipChannel *pChannel = GetChannel(cmCapData, cmCapReceive);
	if (pChannel)
	{
		/* In cop the FECC feature is only through PCM - there is not always
		 * a valid speaker when an fecc token ind received
		if (m_speakerMcuNum	== 0 && m_speakerTermNum == 0 && m_speakerPartyId == 0)
		{
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnRtpFeccTokenInd - Sending reject - No VIN ",m_pMfaInterface->GetConnectionId());
			OnPartyFeccTokenReq(kTokenReject);
		}
		else
		*/
			m_pPartyApi->OnIpDataTokenMsg(pFeccToken->unTokenOpcode,LSD_6400,pFeccToken->unIsCameraControl);
	}
	else
		PTRACE(eLevelError,"CSipCntl::OnRtpFeccTokenInd - Data channel wasn't found");

	PDELETE(pFeccToken);
}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnRtpFeccKeyInd(CSegment *pParam)
{
//	if (!m_pParty->GetIsLeader())
//	{
//		CSmallString cstr;
//		cstr << "party: " << PARTYNAME << "received fecc key but it is not the leader!!!";
//		PASSERTMSG(1,cstr.GetString());
//		return;
//	}


	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnRtpFeccKeyInd - ",m_pMfaInterface->GetConnectionId());

	TRtpFeccTokenRequestInd *pFeccToken = new TRtpFeccTokenRequestInd;
	DWORD  structLen = sizeof(TRtpFeccTokenRequestInd);
	memset(pFeccToken, 0, structLen);
	pParam->Get((BYTE*)pFeccToken, structLen);

	CSipChannel *pChannel = GetChannel(cmCapData, cmCapReceive);
	if (pChannel)
	{
		m_pPartyApi->OnIpFeccKeyMsg(pFeccToken->unTokenOpcode);
	}
	else
		PTRACE(eLevelError,"CSipCntl::OnRtpFeccKeyInd - Data channel wasn't found");

	PDELETE(pFeccToken);
}
////////////////////////////////////////////////////////////////////////////
//H323_RTP_FECC_TOKEN_RESPONSE_REQ
void CSipCntl::OnPartyFeccTokenReq(feccTokenEnum eFeccTokenOpcode, WORD isCameraControl)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnPartyFeccTokenReq - ",GetHWInterface(H323_RTP_FECC_TOKEN_RESPONSE_REQ,FALSE)->GetConnectionId());
	TFeccTokenResponseReq *pStruct = new TFeccTokenResponseReq;

	CSipChannel *pChannel = GetChannel(cmCapData, cmCapReceive);

	if (pChannel && (pChannel->GetConnectionState() == kConnected))
	{
		pStruct->unResponse							= (APIU32)eFeccTokenOpcode;
		pStruct->unDestMcuId						= m_speakerMcuNum;
		pStruct->unDestTerminalId					= m_speakerTermNum;
		pStruct->tDestTerminalPhysicalRtp.party_id	= (APIU32)m_speakerPartyId;

		CRsrcDesc *pRsrcDesc = ::GetpConfPartyRoutingTable()->GetPartyRsrcDesc(m_speakerPartyId, eLogical_rtp);
		if(IsValidPObjectPtr(pRsrcDesc))
		{
			ConnectionID connId = pRsrcDesc->GetConnectionId();
			pStruct->tDestTerminalPhysicalRtp.connection_id	= (APIU32)connId;
		}

		pStruct->unIsCameraControl	= isCameraControl;

		SendMsgToMpl((BYTE*)(pStruct), sizeof(TFeccTokenResponseReq), H323_RTP_FECC_TOKEN_RESPONSE_REQ);

		m_isCameraControl = 0;
	}
	else
	{
		PTRACE(eLevelError,"CSipCntl::OnPartyFeccTokenReq: Incoming fecc channel wasn't found");
	}

	PDELETE(pStruct);
}

/////////////////////////////////////////////////////////////////
void CSipCntl::OnMfaAckConnecting(CSegment* pParam)
{
	TRACEINTO<<"!@# started";
	ACK_IND_S* pAckIndStruct = new ACK_IND_S;
	CSipChannel* pChannel = NULL;
	CMedString cLog;
	ConnectionID connectionId = DEFAULT_CONNECTION_ID;
	GetMfaAckAndIdentifyChannel(pParam, pAckIndStruct, &pChannel, cLog, connectionId);

	OnMfaAckConnectingWithParams(pAckIndStruct, pChannel, cLog, connectionId);
}

/////////////////////////////////////////////////////////////////
void CSipCntl::OnMfaAckConnectingWithParams(ACK_IND_S* pAckIndStruct, CSipChannel* pChannel, CMedString &cLog, ConnectionID connectionId)

{
	BYTE confType;
	BYTE bChannelsConnected = TRUE;
	BYTE bRejectChannel = FALSE;
	CMedString cMainLog;
	BYTE bSendToParty = TRUE;

	EnterFunctionAndOpcode(cMainLog, "OnMfaAckConnectingWithParams", pAckIndStruct->ack_base.ack_opcode);
//    PTRACE(eLevelInfoNormal, cMainLog.GetString());

	if ((pAckIndStruct->ack_base.ack_opcode == ART_CONTENT_ON_REQ) || (pAckIndStruct->ack_base.ack_opcode == ART_CONTENT_OFF_REQ))
	{
		HandleContentOnOffAck(pAckIndStruct);
		POBJDELETE(pAckIndStruct);
		return;
	}
	else if ((pAckIndStruct->ack_base.ack_opcode == TB_MSG_OPEN_PORT_REQ) || (pAckIndStruct->ack_base.ack_opcode == TB_MSG_CLOSE_PORT_REQ))
	{
		HandleInternalArtAck(pAckIndStruct, connectionId);
		POBJDELETE(pAckIndStruct);
		return;
	}
	else if (pAckIndStruct->ack_base.ack_opcode == ART_EVACUATE_REQ)
	{
		HandleRtpEvacuateAck(pAckIndStruct);
		POBJDELETE(pAckIndStruct);
		return;
	}
	else if (pAckIndStruct->ack_base.ack_opcode == ART_UPDATE_RELAY_PARAMS_REQ)
	{
		HandleArtUpdateWithSsrcAck(pAckIndStruct);
		POBJDELETE(pAckIndStruct);
		return;
	}
	else if (pAckIndStruct->ack_base.ack_opcode == IP_MSG_UPDATE_ON_TIP_CALL_REQ || pAckIndStruct->ack_base.ack_opcode == IP_MSG_CLOSE_TIP_CALL_REQ)
	{
		HandleMuxTipAck(pAckIndStruct);
		POBJDELETE(pAckIndStruct);
		return;
	}
	else if (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_STREAM_IS_MUST_REQ)
	{
		TRACEINTO << "got ack from mrmp on CONF_PARTY_MRMP_STREAM_IS_MUST_REQ";
		POBJDELETE(pAckIndStruct);
		m_pPartyApi->MrmpStreamIsMustAck();
		return;
	}
	if (IsVsrInitMessage(pAckIndStruct->ack_base.ack_opcode))
	{
		m_pVsrControl->InitializeAcked();
		return;
	}

	if (!pChannel || (pAckIndStruct->ack_base.ack_opcode == H323_RTP_PARTY_MONITORING_REQ) || (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_PARTY_MONITORING_REQ))

	{
		HandleMfaAckChannelNotFound(cLog, "OnMfaAckConnectingWithParams", pAckIndStruct);
		POBJDELETE(pAckIndStruct);
		return;
	}

	bRejectChannel = HandleMfaAckStatus(cMainLog, pAckIndStruct->ack_base.status, pAckIndStruct->ack_base.ack_opcode, pChannel);
	if (pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_CHANNEL_REQ/* && 0*/)
	{
		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
			if (kUpdating == pChannel->GetRtpConnectionState())
			{
				pChannel->SetRtpConnectionState(kConnected);
				if ((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
				{
					pChannel->SetConnectionState(kConnected);
				}
				if (m_bIsMrcCall && !m_pCall->IsInternalChannel(pChannel) && pChannel->GetMediaType() == cmCapVideo && pChannel->GetDirection() == cmCapReceive)
				{
					TRACEINTO << "dynMixedPosAck ART external channel updated: " << ::GetTypeStr(pChannel->GetMediaType()) << " " << ::GetDirectionStr(pChannel->GetDirection());
				}
			}
			else
			{
				cMainLog << "Not in Updating state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}
		}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ)
	{
		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
			if ((kConnecting == pChannel->GetRtpConnectionState()) || (kUpdating == pChannel->GetRtpConnectionState()))	// because of the RTP indication we can receive also in updating state.
			{
				pChannel->SetRtpConnectionState(kConnected);

				if ((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
				{
					if (m_pCall->IsInternalChannel(pChannel))
					{
						TRACEINTO << "dynMixedPosAck internal art channel connected: " << ::GetTypeStr(pChannel->GetMediaType()) << " " << ::GetDirectionStr(pChannel->GetDirection());
					}

					pChannel->SetConnectionState(kConnected);
				}
			}
			else
			{
				cMainLog << "Not in CONNECTING state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}

			BYTE bMsgSent = HandleContentStreamStateForRtpAck(pChannel);

			if (bMsgSent)
				bSendToParty = FALSE;
		}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_OPEN_UDP_PORT_REQ)
	{
		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
			if (kConnecting == pChannel->GetCmConnectionState())
			{
				pChannel->SetCmConnectionState(kConnected);

				if ((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
				{
					TRACEINTO << "art channel connected: " << ::GetTypeStr(pChannel->GetMediaType()) << " " << ::GetDirectionStr(pChannel->GetDirection());
					pChannel->SetConnectionState(kConnected);
					cMainLog << "Set channel to connected state ";

					if (pChannel->GetMediaType() == cmCapBfcp && pChannel->GetDirection() == cmCapTransmit && m_pSipBfcpCtrl && m_pSipBfcpCtrl->GetBfcpTransportType() == eTransportTypeUdp)
					{
						m_pSipBfcpCtrl->SendHelloKeepAlive();
					}
				}
			}
			else
			{
				cMainLog << "Not in Connecting state , channel state - " << pChannel->GetCmConnectionState() << ", ";
			}
		}
		else
		{	// channel was not opened, since its is UDP close it and remove

			cMainLog << "Close channel ";
			pChannel->SetConnectionState(kDisconnected);
			pChannel->SetCmConnectionState(kDisconnected);
			RemoveChannel(pChannel);
		}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_OPEN_CHANNEL_REQ)
	{
		PTRACE(eLevelInfoNormal, "!!CSipCntl::OnMfaAckConnectingWithParams CONF_PARTY_MRMP_OPEN_CHANNEL_REQ");

		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
			TRACEINTOFUNC << "STATUS_OK, state of CmConnection: " << pChannel->GetCmConnectionState();

			if (1/*kConnecting == pChannel->GetCmConnectionState()*/) // eyaln_channel
			{
				//nissim
				if (m_pCall->IsInternalChannel(pChannel))
				{
					TRACEINTO << "dynMixedPosAck mrmp internal channel connected: " << ::GetTypeStr(pChannel->GetMediaType()) << " " << ::GetDirectionStr(pChannel->GetDirection());
				}

				if (pChannel->GetMediaType() == cmCapVideo && pChannel->GetRoleLabel() == kRolePeople)
				{
					if (pChannel->GetDirection() == cmCapReceive)
					{
						TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] video receive) " << pAckIndStruct->channelHandle;
					}
					else
					{
						TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] video transmit) " << pAckIndStruct->channelHandle;
					}
				}

				if (pChannel->GetMediaType() == cmCapVideo && pChannel->GetRoleLabel() == kRoleContent)
				{
					if (pChannel->GetDirection() == cmCapReceive)
					{
						TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] video content receive) " << pAckIndStruct->channelHandle;
					}
					else
					{
						TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] video content transmit) " << pAckIndStruct->channelHandle;
					}
				}

				if (pChannel->GetMediaType() == cmCapAudio)
				{
					if (pChannel->GetDirection() == cmCapReceive)
					{
						TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] audio receive) " << pAckIndStruct->channelHandle;
					}
					else
					{
						TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] audio transmit) " << pAckIndStruct->channelHandle;
					}
				}

				if (pChannel->GetMediaType() == cmCapData)
				{
					if (pChannel->GetDirection() == cmCapReceive)
					{
						TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] cmCapData receive) " << pAckIndStruct->channelHandle;
					}
					else
					{
						TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] cmCapData transmit) " << pAckIndStruct->channelHandle;
					}
				}

				pChannel->SetCmConnectionState(kConnected);
				pChannel->SetConnectionState(kConnected); /*  new code !!! */
			}
			else
			{
				cMainLog << "Not in Connecting state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}
		}
		else
		{ // channel was not opened, since its is UDP close it and remove

			PTRACE(eLevelInfoNormal, "!!CSipCntl::OnMfaAckConnectingWithParams close channel");
			cMainLog << "Close channel ";
			pChannel->SetConnectionState(kDisconnected);
			pChannel->SetCmConnectionState(kDisconnected);
			RemoveChannel(pChannel);
		}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_UPDATE_CHANNEL_REQ)
	{
		TRACEINTO << "CONF_PARTY_MRMP_UPDATE_CHANNEL_REQ";

		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
			TRACEINTOFUNC << "STATUS_OK, state of CmConnection: " << pChannel->GetCmConnectionState();
			pChannel->SetCmConnectionState(kConnected);
			pChannel->SetConnectionState(kConnected);
		}
		else
		{ // channel was not updated, since its is UDP close it and remove
			TRACEINTO << "Close channel";
			pChannel->SetConnectionState(kDisconnected);
			pChannel->SetCmConnectionState(kDisconnected);
			RemoveChannel(pChannel);
		}
	}
	//below code can be used in channel closing
	else if ((pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ) || (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ))
	{
		TRACEINTO << "Set channel state disconnected";
		pChannel->SetConnectionState(kDisconnected);
		pChannel->SetCmConnectionState(kDisconnected);

		RemoveChannel(pChannel);
	}

	else if ((pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_ON_REQ) || (pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_OFF_REQ))
	{ // currently do nothing. we don't wait to mute/un-mute indication
	}
	else if (pAckIndStruct->ack_base.ack_opcode == IP_CM_DTLS_CLOSE_REQ)
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckConnectingWithParams - ACK on DTLS close request, status:", pAckIndStruct->ack_base.status);
		pChannel->SetDtlsConnectionState(kDisconnected);
	}

	if ((pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ || pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_CHANNEL_REQ) && (pChannel->GetDiffPayloadState() == kDiffPayload_UpdateSent))
	{
		pChannel->SetDiffPayloadState(kDiffPayload_NotNeeded);
		bSendToParty = FALSE;
	}

	cMainLog << cLog.GetString();
	PTRACE2(eLevelInfoNormal, "", cMainLog.GetString());
	confType = m_pParty->GetTargetMode()->GetConfType();
	bChannelsConnected = m_pCall->AreAllOpenChannelsConnectionState(kConnected, m_bIsMrcCall, confType);

	if ((pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_ON_REQ) || (pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_OFF_REQ))
	{ // do nothing until this message will be debug and intigarte with the RTP.
	}
	else if (bRejectChannel)
	{
		//disconnect the call
		// set all channels to be connected in order to disconnect them (they won't disconnect in state "connecting")
		m_pCall->SetChannelsConnectingState(kConnected, MAX_SIP_CHANNELS, NULL);

		DWORD MipErrorNumber = GetMipErrorNumber(pAckIndStruct, pChannel);
		int hwType = (int) (MipErrorNumber / 10000);

		TRACEINTO << "ReqNum:" << ((hwType == 2 /*RTP*/) ? pChannel->GetSeqNumRtp() : pChannel->GetSeqNumCm()) << ", MipOpcode:" << MipErrorNumber << " - Channel was rejected";

		m_pPartyApi->SipPartyCallFailed(SIP_CARD_REJECTED_CHANNELS, MipErrorNumber);		//
	}
	else if (bChannelsConnected)
	{
		CSipComMode* pCurrentMode = new CSipComMode;
		pCurrentMode->Create(*m_pCall);
		pCurrentMode->CopyStaticAttributes(*(m_pParty->GetTargetMode())); // copy necessary data members like ConfType from preffered mode to best mode.
		if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc)
		{
			pCurrentMode->SetStreamsListForMediaMode(m_pParty->GetTargetMode()->GetStreamsListForMediaMode(cmCapVideo, cmCapReceive, kRolePeople), cmCapVideo, cmCapReceive, kRolePeople);
		}

		if ( (pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ) ||
			 (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ) )
		{
			PTRACE2(eLevelInfoNormal, "CSipCntl::OnMfaAckConnectingWithParams, there are no more channels in disconnecting state - ", PARTYNAME);
			m_pPartyApi->SipPartyChannelsDisconnected(pCurrentMode);
		}
		else if (pAckIndStruct->ack_base.ack_opcode == IP_CM_DTLS_CLOSE_REQ)
		{
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckConnectingWithParams - all dtls chans not in disconnecting state:", m_pCall->IsOnlyOneDtlsChannelDisconnectionState(kDisconnecting));
			PTRACE2INT(eLevelError, "SipCntl::OnMfaAckConnectingWithParams, is dtls for video receive enable in current mode:", pCurrentMode->IsDtlsChannelEnabled(cmCapVideo, cmCapReceive, kRolePeople));
			PTRACE2INT(eLevelError, "SipCntl::OnMfaAckConnectingWithParams, is dtls for video transmit enable in current mode:", pCurrentMode->IsDtlsChannelEnabled(cmCapVideo, cmCapTransmit, kRolePeople));

			CLargeString str;

			str << " mediaType: " << pChannel->GetMediaType() << ", direction: " << pChannel->GetDirection() << ", dtls state: " << pChannel->GetDtlsConnectionState() << ", channel state: " << pChannel->GetConnectionState() << ", is channel dtls enable: " << pChannel->IsChannelDtlsEnabled();

			PTRACE2(eLevelError, "CSipCntl::OnMfaAckDisconnecting :", str.GetString());

			if (m_pCall->AreAllDtlsChannelsNotInConnectionState(kDisconnecting))
			{
				PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckDisconnecting - all relevant DTLS channels are closed. go to transaction to close SIP channels");
				m_pPartyApi->SipPartyDtlsChannelsDisconnected(pCurrentMode);
			}
		}
		else
		{
			if (pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ || pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_CHANNEL_REQ || pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_OPEN_UDP_PORT_REQ || pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_OPEN_CHANNEL_REQ || pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_UPDATE_CHANNEL_REQ)
			{
				if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc)
				{
					if (m_bIsMrcCall)
					{
						TRACEINTO << "dynMixedPosAck All open channels are in connected state - SVC EP";
					}
					else
					{
						TRACEINTO << "dynMixedPosAck All open channels are in connected state - AVC EP";
					}
				}
				else
					PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckConnectingWithParams, All open channels are in connected state");

				if (bSendToParty)
				{
					m_pPartyApi->SipPartyChannelsConnected(pCurrentMode);
					
					TRACEINTO << "m_isMs2013Active:" << m_isMs2013Active << ", IsMSSlaveParty:" << (DWORD)IsMSSlaveParty();
					
					if (m_isMs2013Active && IsMSSlaveParty())
					{
						PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckConnectingWithParams - IsMSSlaveParty - m_state=IP_CONNECTED");
						m_state = IP_CONNECTED;
					}
				}
				else
					PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckConnectingWithParams, Not sent to Party.");
			   }
		}

		POBJDELETE(pCurrentMode);
	}
	else
	{
		// currently we do nothing just wait on timer to the process of MFA response for the open channels.
	}

	POBJDELETE(pAckIndStruct);
}


/////////////////////////////////////////////////////////////////
void CSipCntl::OnMfaAckConnected(CSegment* pParam)
{
	BYTE confType;
	ACK_IND_S* pAckIndStruct = new ACK_IND_S;
	CSipChannel* pChannel = NULL;
	BYTE bChannelsConnected			= TRUE;
	BYTE bAllChannelsAreClosed = FALSE;
	BYTE bRejectChannel 	= FALSE;
	CMedString cLog;
	CMedString cMainLog;
	BYTE bSendToParty				= TRUE;
	ConnectionID connectionId = DEFAULT_CONNECTION_ID;

	GetMfaAckAndIdentifyChannel(pParam, pAckIndStruct, &pChannel, cLog, connectionId);
	EnterFunctionAndOpcode(cMainLog, "OnMfaAckConnected", pAckIndStruct->ack_base.ack_opcode);

	if (IsVsrInitMessage(pAckIndStruct->ack_base.ack_opcode))
	{
		m_pVsrControl -> InitializeAcked();
		return;
	}
	else if ((pAckIndStruct->ack_base.ack_opcode == ART_CONTENT_ON_REQ) || (pAckIndStruct->ack_base.ack_opcode == ART_CONTENT_OFF_REQ))
	{
		HandleContentOnOffAck(pAckIndStruct);
        POBJDELETE(pAckIndStruct);
		return;
	}
    else if ((pAckIndStruct->ack_base.ack_opcode == TB_MSG_OPEN_PORT_REQ) || (pAckIndStruct->ack_base.ack_opcode == TB_MSG_CLOSE_PORT_REQ))
    {
        HandleInternalArtAck(pAckIndStruct, connectionId);
        POBJDELETE(pAckIndStruct);
        return;
    }
	else if(pAckIndStruct->ack_base.ack_opcode == ACTIVATE_PACKET_LOSS_REQ)
	{
		if ( pAckIndStruct->ack_base.status != STATUS_OK )
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected, status failed on ACTIVATE_PACKET_LOSS_REQ!!");
			DBGPASSERT(ACTIVATE_PACKET_LOSS_REQ);
	        POBJDELETE(pAckIndStruct);
			return;
		}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == ART_EVACUATE_REQ)
	{
		HandleRtpEvacuateAck(pAckIndStruct);
                POBJDELETE(pAckIndStruct);
		return;
	}
    else if (pAckIndStruct->ack_base.ack_opcode == ART_UPDATE_RELAY_PARAMS_REQ)
    {
        HandleArtUpdateWithSsrcAck(pAckIndStruct);
        POBJDELETE(pAckIndStruct);
        return;
    }
  else if ( pAckIndStruct->ack_base.ack_opcode == IP_MSG_UPDATE_ON_TIP_CALL_REQ || pAckIndStruct->ack_base.ack_opcode == IP_MSG_CLOSE_TIP_CALL_REQ )
  {
      HandleMuxTipAck(pAckIndStruct);
      POBJDELETE(pAckIndStruct);
      return;
  }
  else if (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_STREAM_IS_MUST_REQ)
  {
  	TRACEINTO<<"got ack from mrmp on CONF_PARTY_MRMP_STREAM_IS_MUST_REQ";
  	POBJDELETE(pAckIndStruct);
	m_pPartyApi->MrmpStreamIsMustAck();
  	return;
  }

	if ( !pChannel ||
		 (pAckIndStruct->ack_base.ack_opcode == H323_RTP_PARTY_MONITORING_REQ) ||
		 (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_PARTY_MONITORING_REQ) )
	{
		PTRACE(eLevelError,"CSipCntl::OnMfaAckConnected 3-channel not found");
		HandleMfaAckChannelNotFound(cLog, "OnMfaAckConnected", pAckIndStruct);
		POBJDELETE(pAckIndStruct);
		return;
	}

	bRejectChannel = HandleMfaAckStatus(cMainLog, pAckIndStruct->ack_base.status,pAckIndStruct->ack_base.ack_opcode, pChannel);

	//below code can be used in channel closing
	if ( pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_CHANNEL_REQ)
	{
		if ( pAckIndStruct->ack_base.status == STATUS_OK )
		{
			if (kUpdating == pChannel->GetRtpConnectionState())
			{
				pChannel->SetRtpConnectionState(kConnected);
				if((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
				{
					pChannel->SetConnectionState(kConnected);
				}
				if(m_bIsMrcCall && !m_pCall->IsInternalChannel(pChannel) && pChannel->GetMediaType()==cmCapVideo   && pChannel->GetDirection()==cmCapReceive )
				{
				  TRACEINTO<<"!@#  dynMixedPosAck ART external channel updated: "<<::GetTypeStr(pChannel->GetMediaType())<<" "<<::GetDirectionStr(pChannel->GetDirection());
				}
			}
			else
			{
				cMainLog << "Not in Updating state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}
		}
	}
	else if ( pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ)
	{
	    if ( pAckIndStruct->ack_base.status == STATUS_OK )
		{
		    if (kConnecting == pChannel->GetRtpConnectionState() || kUpdating == pChannel->GetRtpConnectionState())
			{
		    	if(m_pCall->IsInternalChannel(pChannel))
		    	{
		    		TRACEINTO<<"!@# dynMixedPosAck internal art channel connected: "<<::GetTypeStr(pChannel->GetMediaType())<<" "<<::GetDirectionStr(pChannel->GetDirection());
		    	}
		    	pChannel->SetRtpConnectionState(kConnected);
		    	if((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
		    	{
					pChannel->SetConnectionState(kConnected);
		    	}
			}
			else
			{
				cMainLog << "Not in CONNECTING state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}
			BYTE bMsgSent = HandleContentStreamStateForRtpAck(pChannel);
			if (bMsgSent)
				bSendToParty = FALSE;
		}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_UPDATE_CHANNEL_REQ)
	{
		if ( pAckIndStruct->ack_base.status == STATUS_OK )
		{
			if (kConnecting == pChannel->GetRtpConnectionState() || kUpdating == pChannel->GetRtpConnectionState())
			{
				pChannel->SetRtpConnectionState(kConnected);
				pChannel->SetConnectionState(kConnected);
			}
			else if (m_pCall->IsInternalChannel(pChannel) && kConnecting == pChannel->GetCmConnectionState())
            {
                pChannel->SetCmConnectionState(kConnected);
				pChannel->SetConnectionState(kConnected);
			}
			else
			{
				cMainLog << "Not in Updating state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}
//			BYTE bMsgSent = HandleContentStreamStateForRtpAck(pChannel);
//			if (bMsgSent)
//				bSendToParty = FALSE;
		}
	}
	else if ( pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_OPEN_UDP_PORT_REQ/* && 0*/ )
	{
		if ( pAckIndStruct->ack_base.status == STATUS_OK )
		{
			if (kConnecting == pChannel->GetCmConnectionState())
			{
				pChannel->SetCmConnectionState(kConnected);
				if((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
				{
					pChannel->SetConnectionState(kConnected);

					// VNGR-26807
					if(pChannel->GetMediaType() == cmCapBfcp && pChannel->GetDirection() == cmCapTransmit && m_pSipBfcpCtrl && m_pSipBfcpCtrl->GetBfcpTransportType() == eTransportTypeUdp)
					{
						m_pSipBfcpCtrl->SendHelloKeepAlive();
					}
				}
			}
			else
			{
				cMainLog << "Not in Connecting state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}
		}
		else
		{// channel was not opened, since its is UDP close it and remove
			pChannel->SetConnectionState(kDisconnected);
			pChannel->SetCmConnectionState(kDisconnected);
			RemoveChannel(pChannel);
		}
	}

	else if ( pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_OPEN_CHANNEL_REQ )
    {
        PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected CONF_PARTY_MRMP_OPEN_CHANNEL_REQ");
        if ( pAckIndStruct->ack_base.status == STATUS_OK )
        {
            TRACEINTOFUNC << "STATUS_OK, state of CmConnection: " << pChannel->GetCmConnectionState();

            if (1/*kConnecting == pChannel->GetCmConnectionState()*/) // eyaln_channel
            {
                //nissim

		 if(m_pCall->IsInternalChannel(pChannel))
		 {
		     TRACEINTO<<"!@#  dynMixedPosAck mrmp internal channel connected: "<<::GetTypeStr(pChannel->GetMediaType())<<" "<<::GetDirectionStr(pChannel->GetDirection());
		}
                if(pChannel->GetMediaType()==cmCapVideo && pChannel->GetRoleLabel()==kRolePeople)
                {
                    if(pChannel->GetDirection()==cmCapReceive)
                    {
                        TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] video receive) " << pAckIndStruct->channelHandle;
                    }
                    else
                    {
                        TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] video transmit) " << pAckIndStruct->channelHandle;
                    }
                }

                if(pChannel->GetMediaType()==cmCapVideo && pChannel->GetRoleLabel()==kRoleContent)
                {
                    if(pChannel->GetDirection()==cmCapReceive)
                    {
                        TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] video content receive) " << pAckIndStruct->channelHandle;
                    }
                    else
                    {
                        TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] video content transmit) " << pAckIndStruct->channelHandle;
                    }
                }

                if(pChannel->GetMediaType()==cmCapAudio)
                {
                    if(pChannel->GetDirection()==cmCapReceive)
                    {
                        TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] audio receive) " << pAckIndStruct->channelHandle;
                    }
                    else
                    {
                        TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] audio transmit) " << pAckIndStruct->channelHandle;
                    }
                }
                if(pChannel->GetMediaType()==cmCapData)
                {
                    if(pChannel->GetDirection()==cmCapReceive)
                    {
                        TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] cmCapData receive) " << pAckIndStruct->channelHandle;
                    }
                    else
                    {
                        TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] cmCapData transmit) " << pAckIndStruct->channelHandle;
                    }
                }

//                if(pAckIndStruct->channelHandle != INVALID_CHANNEL_HANDLE)
//                {
//                    pChannel->SetChannelHandle(pAckIndStruct->channelHandle);
//                }

                pChannel->SetCmConnectionState(kConnected);
                pChannel->SetConnectionState(kConnected); /*  new code !!! */
            }
            else
            {
                cMainLog << "Not in Connecting state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
            }
        }
        else
        {// channel was not opened, since its is UDP close it and remove

            PTRACE(eLevelInfoNormal, "!!CSipCntl::OnMfaAckConnectingWithParams close channel");
            cMainLog << "Close channel ";
            pChannel->SetConnectionState(kDisconnected);
            pChannel->SetCmConnectionState(kDisconnected);
            RemoveChannel(pChannel);
        }
    }

	else if ( (pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ) ||
			  (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ) )
	{
		if (((pChannel->GetMediaType() == cmCapBfcp) &&
			((pChannel->GetDirection() == cmCapReceive) || (pChannel->GetDirection() == cmCapTransmit))))
		{
			if (m_bfcpChannelsAckCounter > 0)
				m_bfcpChannelsAckCounter--;
		}

		pChannel->SetConnectionState(kDisconnected);
		pChannel->SetCmConnectionState(kDisconnected);

		RemoveChannel(pChannel);

		bAllChannelsAreClosed	= !m_pCall->IsAtLeastOneChannelConnectionState(kDisconnecting);// I think it should be removed
	}
	else if ((pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_ON_REQ) || (pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_OFF_REQ))
	{// currently do nothing. we don't wait to mute/un-mute indication
	}
	else if (pAckIndStruct->ack_base.ack_opcode == H323_RTP_LPR_MODE_CHANGE_REQ) // LPR
	{
		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
			TRACEINTO << "CSipCntl::OnMfaAck : SIP_RTP_LPR_MODE_CHANGE_REQ - status is ok -  Media Type = " << pAckIndStruct->media_type <<
											", Direction = " << pAckIndStruct->media_direction << ", ConnId = " << GetHWInterface(H323_RTP_LPR_MODE_CHANGE_REQ,FALSE)->GetConnectionId();
			if (IsValidTimer(LPRTOUT))
					DeleteTimer(LPRTOUT);

			// if m_LprModeTimeout == 0 No timer is needed since the LPR is permanent
			if (m_LprModeTimeout != 0)
				StartTimer(LPRTOUT,  m_LprModeTimeout*SECOND);
			else
			{
			    DWORD lprDefaultTimeOut = GetSystemCfgFlagInt<DWORD>("LPR_ACTIVITY_MAX_DURATION_IN_SECONDS");
			    if (lprDefaultTimeOut)
			        StartTimer(LPRTOUT,  lprDefaultTimeOut*SECOND);
			 }
			//else
              //  StartTimer(LPRTOUT,  3*SECOND);

		 }
		else
		{
			TRACEINTO << "CSipCntl::OnMfaAck : SIP_RTP_LPR_MODE_CHANGE_REQ - status is NOT ok -  Media Type = " << pAckIndStruct->media_type <<
											", Direction = " << pAckIndStruct->media_direction << ", ConnId = " << GetHWInterface(H323_RTP_LPR_MODE_CHANGE_REQ,FALSE)->GetConnectionId();
			DBGPASSERT(GetHWInterface(H323_RTP_LPR_MODE_CHANGE_REQ,FALSE)->GetConnectionId());
		}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == H323_RTP_LPR_MODE_RESET_REQ) // LPR
	{
		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
			TRACEINTO << "CSipCntl::OnMfaAck : SIP_RTP_LPR_MODE_RESET_REQ - status is ok -  Media Type = " << pAckIndStruct->media_type <<
										", Direction = " << pAckIndStruct->media_direction << ", ConnId = " << GetHWInterface(H323_RTP_LPR_MODE_RESET_REQ,FALSE)->GetConnectionId();

			MfaSIPLprAck();
		}
		else
		{
			TRACEINTO << "CSipCntl::OnMfaAck : SIP_RTP_LPR_MODE_RESET_REQ - status is NOT ok -  Media Type = " << pAckIndStruct->media_type <<
										", Direction = " << pAckIndStruct->media_direction << ", ConnId = " << GetHWInterface(H323_RTP_LPR_MODE_RESET_REQ,FALSE)->GetConnectionId();
			DBGPASSERT(GetHWInterface(H323_RTP_LPR_MODE_RESET_REQ,FALSE)->GetConnectionId());
		}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == IP_CM_DTLS_CLOSE_REQ)
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected - ACK on DTLS close request, status:", pAckIndStruct->ack_base.status);
		pChannel->SetDtlsConnectionState(kDisconnected);
	}

	if ((pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ || pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_CHANNEL_REQ)
		&& (pChannel->GetDiffPayloadState() == kDiffPayload_UpdateSent))
	{
		pChannel->SetDiffPayloadState(kDiffPayload_NotNeeded);
		bSendToParty = FALSE;
	}
	cMainLog << cLog.GetString();
	PTRACE2(eLevelInfoNormal, "", cMainLog.GetString());
	confType=m_pParty->GetTargetMode()->GetConfType();
	bChannelsConnected		= m_pCall->AreAllOpenChannelsConnectionState(kConnected,m_bIsMrcCall,confType);

	if ((pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_ON_REQ) || (pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_OFF_REQ))
	{// do nothing until this message will be debug and intigarte with the RTP.
	}
	else if (pAckIndStruct->ack_base.ack_opcode == IP_CM_RTCP_VIDEO_PREFERENCE_REQ)
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected, Video preference Do nothing!!");
	}
	else if(bRejectChannel)
	{
		//disconnect the call
		// set all channels to be connected in order to disconnect them (they won't disconnect in state "connecting")
		PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected, Channel was rejected");
		m_pCall->SetChannelsConnectingState(kConnected,MAX_SIP_CHANNELS,NULL);
		DWORD MipErrorNumber = GetMipErrorNumber(pAckIndStruct,pChannel);
		int hwType =  (int)(MipErrorNumber / 10000);
		if(hwType == 2 /*RTP */)
		{
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected, Channel was rejected the req num is: ", pChannel->GetSeqNumRtp());
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected, Channel was rejected the mcu internal problem opcode is: ", MipErrorNumber);
		}
		else
		{
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected, Channel was rejected the req num is: ", pChannel->GetSeqNumCm());
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected, Channel was rejected the mcu internal problem opcode is: ", MipErrorNumber);

		}
		m_pPartyApi->SipPartyCallFailed(SIP_CARD_REJECTED_CHANNELS,MipErrorNumber);//
	}
	else if (bChannelsConnected)
	{
		PTRACE2INT(eLevelError,"CSipCntl::OnMfaAckConnected CONFPARTY_CM_CLOSE_UDP_PORT_REQ bChannelsConnected  -",bChannelsConnected);
		CSipComMode* pCurrentMode = new CSipComMode;
		pCurrentMode->Create(*m_pCall);
		pCurrentMode->CopyStaticAttributes(*(m_pParty->GetTargetMode()));
		if ( (pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ) ||
			 (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ) )
		{
			PTRACE2(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected, there are no more channels in disconnecting state - ", PARTYNAME);
			m_pPartyApi->SipPartyChannelsDisconnected(pCurrentMode);
		}
		else if (pAckIndStruct->ack_base.ack_opcode == IP_CM_DTLS_CLOSE_REQ)
		{
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected - all dtls chans not in disconnecting state:", m_pCall->AreAllDtlsChannelsNotInConnectionState(kDisconnecting));

			PTRACE2INT(eLevelError, "SipCntl::OnMfaAckConnected, is dtls for video receive enable in current mode:", pCurrentMode->IsDtlsChannelEnabled(cmCapVideo ,cmCapReceive,kRolePeople));
			PTRACE2INT(eLevelError, "SipCntl::OnMfaAckConnected, is dtls for video transmit enable in current mode:", pCurrentMode->IsDtlsChannelEnabled(cmCapVideo ,cmCapTransmit,kRolePeople));

			CLargeString str;

			str << " mediaType: " << pChannel->GetMediaType()
				<< ", direction: " << pChannel->GetDirection()
				<< ", dtls state: " << pChannel->GetDtlsConnectionState()
				<< ", channel state: " << pChannel->GetConnectionState()
				<< ", is channel dtls enable:	" << pChannel->IsChannelDtlsEnabled();

			PTRACE2(eLevelError,"CSipCntl::OnMfaAckConnected :",str.GetString());

			if (m_pCall->AreAllDtlsChannelsNotInConnectionState(kDisconnecting))
			{
				PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected - all relevant DTLS channels are closed. go to transaction to close SIP channels");
				m_pPartyApi->SipPartyDtlsChannelsDisconnected(pCurrentMode);
			}
		}
		else
		{
			if(pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ ||
			   pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_CHANNEL_REQ ||
			   pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_OPEN_UDP_PORT_REQ ||
			   pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_OPEN_CHANNEL_REQ ||
               pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_UPDATE_CHANNEL_REQ)
			{
				PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected, All open channels are in connected state");
				if( m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc )
				{
				   if(m_bIsMrcCall)
				   {
				       TRACEINTO<<"dynMixedPosAck All open channels are in connected state - SVC EP";
				   }
				   else
				   {
				     TRACEINTO<<"dynMixedPosAck All open channels are in connected state - AVC EP";
				   }
				}
				if (bSendToParty)
				{
					m_pPartyApi->SipPartyChannelsConnected(pCurrentMode/*,pChannel->GetChannelHandle()*/);
				}
				else
					PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected, Not sent to Party.");
			}
		}
		POBJDELETE(pCurrentMode);
	}
	else if (bAllChannelsAreClosed)
	{
		CSipComMode* pCurrentMode = new CSipComMode;
		pCurrentMode->Create(*m_pCall);
		pCurrentMode->CopyStaticAttributes(*(m_pParty->GetTargetMode())); // copy necessary data members like ConfType from preffered mode to best mode.

		if ( (pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ) ||
			 (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ) )
		{
			PTRACE2(eLevelInfoNormal, "CSipCntl::OnMfaAckConnected, there are no more channels in disconnecting state - ", PARTYNAME);
			m_pPartyApi->SipPartyChannelsDisconnected(pCurrentMode);
		}
		POBJDELETE(pCurrentMode);
	}

	if ((pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ) &&
		(m_bfcpChannelsAckCounter == 0 && m_bBfcpReconnect == TRUE))
	{
		m_bBfcpReconnect = FALSE;
		m_pPartyApi->BfcpEndReestablishConnection();
	}

	POBJDELETE(pAckIndStruct);
}


/////////////////////////////////////////////////////////////////
void CSipCntl::OnMfaAckChangeMode(CSegment* pParam)
{
	TRACEINTO << "!@# started";
	BYTE confType;
	ACK_IND_S* pAckIndStruct = new ACK_IND_S;
	CSipChannel* pChannel = NULL;
	BYTE bAllChannelsAreClosed = FALSE;
	BYTE bRejectChannel 	= FALSE;
	CMedString cLog;
	CMedString cMainLog;
	BYTE bSendToParty		= TRUE;
	ConnectionID connectionId = DEFAULT_CONNECTION_ID;

	GetMfaAckAndIdentifyChannel(pParam, pAckIndStruct, &pChannel, cLog, connectionId);
	EnterFunctionAndOpcode(cMainLog, "OnMfaAckChangeMode", pAckIndStruct->ack_base.ack_opcode);

	if (IsVsrInitMessage(pAckIndStruct->ack_base.ack_opcode))
	{
		m_pVsrControl -> InitializeAcked();
		return;
	}
	else if ((pAckIndStruct->ack_base.ack_opcode == ART_CONTENT_ON_REQ) || (pAckIndStruct->ack_base.ack_opcode == ART_CONTENT_OFF_REQ))
	{
		HandleContentOnOffAck(pAckIndStruct);
		POBJDELETE(pAckIndStruct);
		return;
	}
    else if ((pAckIndStruct->ack_base.ack_opcode == TB_MSG_OPEN_PORT_REQ) || (pAckIndStruct->ack_base.ack_opcode == TB_MSG_CLOSE_PORT_REQ))
    {
        HandleInternalArtAck(pAckIndStruct, connectionId);
        POBJDELETE(pAckIndStruct);
        return;
    }
	else if (pAckIndStruct->ack_base.ack_opcode == ART_EVACUATE_REQ)
	{
		HandleRtpEvacuateAck(pAckIndStruct);
		POBJDELETE(pAckIndStruct);
		return;
	}
    else if (pAckIndStruct->ack_base.ack_opcode == ART_UPDATE_RELAY_PARAMS_REQ)
    {
        HandleArtUpdateWithSsrcAck(pAckIndStruct);
        POBJDELETE(pAckIndStruct);
        return;
    }
	else if ( pAckIndStruct->ack_base.ack_opcode == IP_MSG_UPDATE_ON_TIP_CALL_REQ || pAckIndStruct->ack_base.ack_opcode == IP_MSG_CLOSE_TIP_CALL_REQ )
	{
		HandleMuxTipAck(pAckIndStruct);
		POBJDELETE(pAckIndStruct);
		return;
	}
	else if (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_STREAM_IS_MUST_REQ)
	{
		TRACEINTO<<"got ack from mrmp on CONF_PARTY_MRMP_STREAM_IS_MUST_REQ";
		POBJDELETE(pAckIndStruct);
		m_pPartyApi->MrmpStreamIsMustAck();
		return;
	}

	if ( !pChannel ||
		 (pAckIndStruct->ack_base.ack_opcode == H323_RTP_PARTY_MONITORING_REQ) ||
		 (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_PARTY_MONITORING_REQ) )
	{
		HandleMfaAckChannelNotFound(cLog, "OnMfaAckChangeMode", pAckIndStruct);
		POBJDELETE(pAckIndStruct);
		return;
	}

	bRejectChannel = HandleMfaAckStatus(cMainLog, pAckIndStruct->ack_base.status,pAckIndStruct->ack_base.ack_opcode, pChannel);

	if (pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_CHANNEL_REQ)
	{
		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
			if (kUpdating == pChannel->GetRtpConnectionState())
			{
				pChannel->SetRtpConnectionState(kConnected);

				if (kConnected == pChannel->GetCmConnectionState())
				{
					pChannel->SetConnectionState(kConnected);
				}

				TRACEINTO << "!@# 001";

				if (m_bIsMrcCall && !m_pCall->IsInternalChannel(pChannel) &&
					pChannel->GetMediaType()==cmCapVideo && pChannel->GetDirection()==cmCapReceive )
				{
					TRACEINTO << "!@#  dynMixedPosAck ART external channel updated: " <<
						::GetTypeStr(pChannel->GetMediaType()) << " " << ::GetDirectionStr(pChannel->GetDirection());
				}
			}
			else
			{
				cMainLog << "Not in Updating state , channel RtpConnectionState - " <<
					ConnectionStateToString(pChannel->GetRtpConnectionState()) << ", ";
			}
		}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ)
	{
		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
		    if (kConnecting == pChannel->GetRtpConnectionState() || kUpdating == pChannel->GetRtpConnectionState())
			{
				pChannel->SetRtpConnectionState(kConnected);

				if ((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
				{
					if (m_pCall->IsInternalChannel(pChannel))
					{
						TRACEINTO << "!@# dynMixedPosAck internal art channel connected: "
							<< ::GetTypeStr(pChannel->GetMediaType()) << " " << ::GetDirectionStr(pChannel->GetDirection());
					}

					pChannel->SetConnectionState(kConnected);
				}
			}
			else
			{
				cMainLog << "Not in Updating state , channel RtpConnectionState - "
					<< ConnectionStateToString(pChannel->GetRtpConnectionState()) << ", ";
			}

			BYTE bMsgSent = HandleContentStreamStateForRtpAck(pChannel);

			if (bMsgSent)
			{
				TRACEINTO<<"!@# message will not be sent";
				bSendToParty = FALSE;
			}
		}
	}
	else if( pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_OPEN_CHANNEL_REQ )
	{
		PTRACE(eLevelInfoNormal, "!!CSipCntl::OnMfaAckChangeMode CONF_PARTY_MRMP_OPEN_CHANNEL_REQ");
		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
			TRACEINTO<<"mrmp channel connected: "<<::GetTypeStr(pChannel->GetMediaType())<<" "<<::GetDirectionStr(pChannel->GetDirection());
			TRACEINTOFUNC << "STATUS_OK, state of CmConnection: " << pChannel->GetCmConnectionState();

			if (1/*kConnecting == pChannel->GetCmConnectionState()*/) // eyaln_channel
			{
				//nissim
				if(m_pCall->IsInternalChannel(pChannel))
				{
					TRACEINTO<<"!@#  dynMixedPosAck mrmp internal channel connected: "<<::GetTypeStr(pChannel->GetMediaType())<<" "<<::GetDirectionStr(pChannel->GetDirection());
				}

                if(pChannel->GetMediaType()==cmCapVideo && pChannel->GetRoleLabel()==kRolePeople)
                {
                    if(pChannel->GetDirection()==cmCapReceive)
                    {
                    	TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] video receive) " << pAckIndStruct->channelHandle;
                    }
                    else
                    {
                    	TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] video transmit) " << pAckIndStruct->channelHandle;
                    }
                }

                if(pChannel->GetMediaType()==cmCapVideo && pChannel->GetRoleLabel()==kRoleContent)
                {
                    if(pChannel->GetDirection()==cmCapReceive)
                    {
                    	TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] video content receive) " << pAckIndStruct->channelHandle;
                    }
                    else
                    {
                    	TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] video content transmit) " << pAckIndStruct->channelHandle;
                    }
                }

				if(pChannel->GetMediaType()==cmCapAudio)
                {
                    if(pChannel->GetDirection()==cmCapReceive)
                    {
                    	TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] audio receive) " << pAckIndStruct->channelHandle;
                    }
                    else
                    {
                    	TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] audio transmit) " << pAckIndStruct->channelHandle;
                    }
                }

                if(pChannel->GetMediaType()==cmCapData)
                {
                    if(pChannel->GetDirection()==cmCapReceive)
                    {
                    	TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[0] cmCapData receive) " << pAckIndStruct->channelHandle;
                    }
                    else
                    {
                    	TRACEINTOFUNC << "Setting to connected state.\nSetting channel handle to (channelHandle[1] cmCapData transmit) " << pAckIndStruct->channelHandle;
                    }
                }

				pChannel->SetCmConnectionState(kConnected);
				pChannel->SetConnectionState(kConnected); /*  new code !!! */
			}
			else
			{
				cMainLog << "Not in Connecting state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}
		}
		else
		{// channel was not opened, since its is UDP close it and remove
			PTRACE(eLevelInfoNormal, "!!CSipCntl::OnMfaAckChangeMode close channel");
			cMainLog << "Close channel ";
			pChannel->SetConnectionState(kDisconnected);
			pChannel->SetCmConnectionState(kDisconnected);
			RemoveChannel(pChannel);
		}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_UPDATE_CHANNEL_REQ)
	{
		if ( pAckIndStruct->ack_base.status == STATUS_OK )
		{
			if (pChannel->GetConnectionState() == kUpdating || kConnecting == pChannel->GetRtpConnectionState() || kUpdating == pChannel->GetRtpConnectionState())
			{
				pChannel->SetRtpConnectionState(kConnected);
				pChannel->SetConnectionState(kConnected);
			}
			else
			{
				cMainLog << "Not in Updating state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}
		}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_OPEN_UDP_PORT_REQ)
	{
			if (pAckIndStruct->ack_base.status == STATUS_OK)
			{
				if (kConnecting == pChannel->GetCmConnectionState())
				{
					pChannel->SetCmConnectionState(kConnected);

					if((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
					{
						pChannel->SetConnectionState(kConnected);
					}
				}
				else
				{
					cMainLog << "Not in Connecting state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
				}
			}
			else
			{// channel was not opened, since its is UDP close it and remove
				pChannel->SetConnectionState(kDisconnected);
				pChannel->SetCmConnectionState(kDisconnected);
				RemoveChannel(pChannel);
			}
	}
	//below code can be used in channel update
	else if (pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_UPDATE_UDP_ADDR_REQ)
	{
		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
			if (kUpdating == pChannel->GetCmConnectionState())
			{
				pChannel->SetCmConnectionState(kConnected);

				if((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
				{
					pChannel->SetConnectionState(kConnected);
				}
			}
			else
			{
				cMainLog << "Not in Updating state , channel state - " << pChannel->GetCmConnectionState() << ", ";
			}
		}
		else
		{// channel was not opened, since its is UDP close it and remove
			pChannel->SetConnectionState(kDisconnected);
			pChannel->SetCmConnectionState(kDisconnected);
			RemoveChannel(pChannel);
		}
	}
	//below code can be used in channel closing
	else if ( (pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ) ||
			  (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ) )
	{
		if (((pChannel->GetMediaType() == cmCapBfcp) &&
			((pChannel->GetDirection() == cmCapReceive) || (pChannel->GetDirection() == cmCapTransmit))))
		{
			if (m_bfcpChannelsAckCounter > 0)
				m_bfcpChannelsAckCounter--;
		}

		pChannel->SetConnectionState(kDisconnected);
		pChannel->SetCmConnectionState(kDisconnected);

		RemoveChannel(pChannel);
	}
	else if ((pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_ON_REQ) || (pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_OFF_REQ))
	{
	}
	else if (pAckIndStruct->ack_base.ack_opcode == IP_CM_DTLS_CLOSE_REQ)
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckChangeMode - ACK on DTLS close request, status:", pAckIndStruct->ack_base.status);
		pChannel->SetDtlsConnectionState(kDisconnected);


		CLargeString str;

		str << " mediaType: " << pChannel->GetMediaType()
			<< ", direction: " << pChannel->GetDirection()
			<< ", dtls state: " << pChannel->GetDtlsConnectionState()
			<< ", channel state: " << pChannel->GetConnectionState()
			<< ", is channel dtls enable:	" << pChannel->IsChannelDtlsEnabled();

		PTRACE2(eLevelError,"CSipCntl::OnMfaAckChangeMode :",str.GetString());
	}

	if ((pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ || pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_CHANNEL_REQ)
		&& (pChannel->GetDiffPayloadState() == kDiffPayload_UpdateSent) /*&& m_pParty->GetActiveTransactionType()!=kSipTransUpgradeSvcOnlyToMixReq*/)
	{
		pChannel->SetDiffPayloadState(kDiffPayload_NotNeeded);
		TRACEINTO<<"!@# message will not be sent";

		bSendToParty = FALSE;
	}

	cMainLog << cLog.GetString();
	PTRACE2(eLevelInfoNormal, "", cMainLog.GetString());

	BYTE bChannelsConnected = TRUE;
	confType=m_pParty->GetTargetMode()->GetConfType();
	bChannelsConnected = m_pCall->AreAllOpenChannelsConnectionState(kConnected,m_bIsMrcCall,confType);

	if (pAckIndStruct->ack_base.ack_opcode == IP_CM_DTLS_CLOSE_REQ)
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckChangeMode - ACK on DTLS close request, bChannelsConnected:", bChannelsConnected);

	if ((pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_ON_REQ) || (pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_OFF_REQ))
	{// do nothing until this message will be debug and intigarte with the RTP.
	}
	else if (bRejectChannel)
	{
		//disconnect the call
		// set all channels to be connected in order to disconnect them (they won't disconnect in state "connecting")
		PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckChangeMode, Channel was rejected");
		m_pCall->SetChannelsConnectingState(kConnected,MAX_SIP_CHANNELS,NULL);
		DWORD MipErrorNumber = GetMipErrorNumber(pAckIndStruct,pChannel);
		int hwType =  (int)(MipErrorNumber / 10000);
		if(hwType == 2 /*RTP*/)
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckChangeMode, Channel was rejected the req num is: ", pChannel->GetSeqNumRtp());
		else
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckChangeMode, Channel was rejected the req num is: ", pChannel->GetSeqNumCm());
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckChangeMode, Channel was rejected the mcu internal problem opcode is: ", MipErrorNumber);
		m_pPartyApi->SipPartyCallFailed(SIP_CARD_REJECTED_CHANNELS,MipErrorNumber);//
	}
	else if (bChannelsConnected)
	{
		TRACEINTO << "m_state= " << m_state << " m_bChangeModeWithinTransaction= " << (int)m_bChangeModeWithinTransaction;

		m_state = (m_bChangeModeWithinTransaction == YES) ? IP_CONNECTING : IP_CONNECTED;
		m_bChangeModeWithinTransaction= NO;

		TRACEINTO << "m_state= " << m_state << " m_bChangeModeWithinTransaction= " << (int)m_bChangeModeWithinTransaction;

		PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckChangeMode, All channels are connected");
		CSipComMode* pCurrentMode = new CSipComMode;

		pCurrentMode->Create(*m_pCall);
		pCurrentMode->CopyStaticAttributes(*(m_pParty->GetTargetMode())); // copy necessary data members like ConfType from preffered mode to best mode.

		if (bSendToParty)
			m_pPartyApi->SipPartyChannelsUpdated(pCurrentMode);
		else
			PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckChangeMode, Not sent to Party.");

		if (pAckIndStruct->ack_base.ack_opcode == IP_CM_DTLS_CLOSE_REQ)
		{
			PTRACE2INT(eLevelError, "SipCntl::OnMfaAckChangeMode, is dtls for video receive enable in current mode:", pCurrentMode->IsDtlsChannelEnabled(cmCapVideo ,cmCapReceive,kRolePeople));
			PTRACE2INT(eLevelError, "SipCntl::OnMfaAckChangeMode, is dtls for video transmit enable in current mode:", pCurrentMode->IsDtlsChannelEnabled(cmCapVideo ,cmCapTransmit,kRolePeople));
		}

		POBJDELETE(pCurrentMode);
		if (IsValidTimer(PARTYCHANGEMODETOUT))
				DeleteTimer(PARTYCHANGEMODETOUT);
	}
	else
	{
		// currently we do nothing just wait on timer to the process of MFA response for the open channels.
	}

	if ((pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ) &&
		(m_bfcpChannelsAckCounter == 0 && m_bBfcpReconnect == TRUE))
	{
		m_bBfcpReconnect = FALSE;
		m_pPartyApi->BfcpEndReestablishConnection();
	}

	POBJDELETE(pAckIndStruct);
}


/////////////////////////////////////////////////////////////////
void CSipCntl::OnMfaAckDisconnecting(CSegment* pParam)
{
	ACK_IND_S* pAckIndStruct = new ACK_IND_S;
	BYTE confType;
	CSipChannel* pChannel = NULL;
	BYTE bAllChannelsAreClosed = FALSE;
	BYTE bRejectChannel 	= FALSE;
	CMedString cLog;
	CMedString cMainLog;
	ConnectionID connectionId = DEFAULT_CONNECTION_ID;

	GetMfaAckAndIdentifyChannel(pParam, pAckIndStruct, &pChannel, cLog, connectionId);
	EnterFunctionAndOpcode(cMainLog, "OnMfaAckDisconnecting", pAckIndStruct->ack_base.ack_opcode);

	if ((pAckIndStruct->ack_base.ack_opcode == ART_CONTENT_ON_REQ) || (pAckIndStruct->ack_base.ack_opcode == ART_CONTENT_OFF_REQ))
	{
		HandleContentOnOffAck(pAckIndStruct);
        POBJDELETE(pAckIndStruct);
		return;
	}
	else if ((pAckIndStruct->ack_base.ack_opcode == TB_MSG_OPEN_PORT_REQ) || (pAckIndStruct->ack_base.ack_opcode == TB_MSG_CLOSE_PORT_REQ))
    {
        HandleInternalArtAck(pAckIndStruct, connectionId);
        POBJDELETE(pAckIndStruct);
        return;
    }
	else if (pAckIndStruct->ack_base.ack_opcode == ART_EVACUATE_REQ)
	{
		HandleRtpEvacuateAck(pAckIndStruct);
        POBJDELETE(pAckIndStruct);
		return;
	}

	if ( // temp temp temp - to be removed after the fix of the ACK is added
		 /*(pAckIndStruct->ack_base.ack_opcode != CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ) &&*/

	( !pChannel ||
	  (pAckIndStruct->ack_base.ack_opcode == H323_RTP_PARTY_MONITORING_REQ)) ||
	  (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_PARTY_MONITORING_REQ) )
	{
		PTRACE2(eLevelInfoNormal, cMainLog.GetString(), pChannel?" ---- pChannel exists":" ---- pChannel NULL");

		HandleMfaAckChannelNotFound(cLog, "OnMfaAckDisconnecting", pAckIndStruct);
		POBJDELETE(pAckIndStruct);
		return;
	}

	bRejectChannel = HandleMfaAckStatus(cMainLog, pAckIndStruct->ack_base.status,pAckIndStruct->ack_base.ack_opcode, pChannel);



	//below code can be used in channel closing
	if ( pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ ||
		 pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ )
	{
		if (pChannel)
		{
			pChannel->SetConnectionState(kDisconnected);
			pChannel->SetCmConnectionState(kDisconnected);

			RemoveChannel(pChannel);
		}
	}

	// if we initiate the disconnecting of the call while there was still channels in openning state
	else if ( pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ/* && 0*/ )
	{
		if ( pAckIndStruct->ack_base.status == STATUS_OK )
		{
			if (kConnecting == pChannel->GetRtpConnectionState() || kUpdating == pChannel->GetRtpConnectionState())
			{
				pChannel->SetRtpConnectionState(kConnected);
				if((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
				{
					pChannel->SetConnectionState(kConnected);
				}
			}
			else
			{
				cMainLog << "Not in CONNECTING state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}
		}
	}

	else if ( pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_OPEN_UDP_PORT_REQ/* && 0*/ )
	{
		if ( pAckIndStruct->ack_base.status == STATUS_OK )
		{
			if (kConnecting == pChannel->GetCmConnectionState())
			{
				pChannel->SetCmConnectionState(kConnected);
				if((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
				{
					pChannel->SetConnectionState(kConnected);
				}
			}
			else
			{
				cMainLog << "Not in Connecting state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}
		}
		else
		{// channel was not opened, since its is UDP close it and remove
			if (pChannel)
			{
			pChannel->SetConnectionState(kDisconnected);
			pChannel->SetCmConnectionState(kDisconnected);
			RemoveChannel(pChannel);
			}
		}
	}

	else if ( pAckIndStruct->ack_base.ack_opcode == H323_RTP_UPDATE_CHANNEL_REQ/* && 0*/ )
	{
		if ( pAckIndStruct->ack_base.status == STATUS_OK )
		{
			if (kUpdating == pChannel->GetRtpConnectionState())
			{
				pChannel->SetRtpConnectionState(kConnected);
				if((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
				{
					pChannel->SetConnectionState(kConnected);
				}
			}
			else
			{
				cMainLog << "Not in Updating state , channel state - " << pChannel->GetRtpConnectionState() << ", ";
			}
		}
	}

	//below code can be used in channel update
	else if (pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_UPDATE_UDP_ADDR_REQ)
	{
		if (pAckIndStruct->ack_base.status == STATUS_OK)
		{
			if ( kUpdating == pChannel->GetCmConnectionState() )
			{
				pChannel->SetCmConnectionState(kConnected);
				if((kConnected == pChannel->GetRtpConnectionState()) && (kConnected == pChannel->GetCmConnectionState()))
				{
					pChannel->SetConnectionState(kConnected);
				}
			}
			else
			{
				cMainLog << "Not in Updating state , channel state - " << pChannel->GetCmConnectionState() << ", ";
			}
		}
		else
		{// channel was not opened, since its is UDP close it and remove
			if (pChannel)
			{
			pChannel->SetConnectionState(kDisconnected);
			pChannel->SetCmConnectionState(kDisconnected);
			RemoveChannel(pChannel);
		}
	}
	}
	else if (pAckIndStruct->ack_base.ack_opcode == IP_CM_DTLS_CLOSE_REQ)
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckDisconnecting - ACK on DTLS close request, status:", pAckIndStruct->ack_base.status);
		pChannel->SetDtlsConnectionState(kDisconnected);

		CLargeString str;

		str << " mediaType: " << pChannel->GetMediaType()
			<< ", direction: " << pChannel->GetDirection()
			<< ", dtls state: " << pChannel->GetDtlsConnectionState()
			<< ", channel state: " << pChannel->GetConnectionState()
			<< ", is channel dtls enable:	" << pChannel->IsChannelDtlsEnabled();

		PTRACE2(eLevelError,"CSipCntl::OnMfaAckDisconnecting :",str.GetString());
	}

	cMainLog << cLog.GetString();
	PTRACE2(eLevelInfoNormal, "", cMainLog.GetString());
	confType=m_pParty->GetTargetMode()->GetConfType();
	if ((pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_ON_REQ) || (pAckIndStruct->ack_base.ack_opcode == H323_RTP_STREAM_OFF_REQ))
	{// do nothing until this message will be debug and intigarte with the RTP.
	}
	else if ( (pAckIndStruct->ack_base.ack_opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ) ||
			  (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ) )
	{
		if (m_pCall->GetNumOfChannels() == 0 && m_pCall->GetNumOfChannelsEx()==0)
			OnAllChannelsAreClosed();
	}
	else if (pAckIndStruct->ack_base.ack_opcode == IP_CM_DTLS_CLOSE_REQ)
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnMfaAckDisconnecting - ACK on DTLS close request, status:", pAckIndStruct->ack_base.status);

		if (m_pCall->AreAllDtlsChannelsConnectionState(kDisconnected))
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::OnMfaAckDisconnecting - all DTLS channels are closed. now close SIP channels");
			SipCloseAllChannelsReq();
		}
	}
	else if ( m_bIsMrcCall && (m_pCall->IsAtLeastOneChannelConnectionState(kConnecting)==NO && m_pCall->AreAllOpenChannelsConnectionState(kDisconnecting,m_bIsMrcCall,confType)==NO))
		SipCloseAllChannelsReq();
    //---HOMOLOGATION SIP_CC_TE_CR_V_002 ------------------------------------------//
    else if(m_pCall->IsAtLeastOneChannelConnectionState(kConnected)==YES)
    {
        PTRACE(eLevelError,"CSipCntl::OnMfaAckDisconnecting: channels connected");
        SipCloseAllChannelsReq();
    }
    //-----------------------------------------------------------------------------//

	POBJDELETE(pAckIndStruct);
}
/////////////////////////////////////////////////////////////////
BYTE CSipCntl::HandleContentStreamStateForRtpAck(CSipChannel* pChannel)
{
	BYTE bMsgSent = FALSE;

	if (pChannel->IsChannelType(VIDEO_CONT_OUT))
	{
	    if(m_eContentOutState == eSendStreamOff)
			m_eContentOutState = eStreamOff;
		else if(m_eContentOutState == eSendStreamOn)
		{
			m_eContentOutState = eStreamOn;
			m_pPartyApi->MfaUpdatedPresentationOutStream();
			bMsgSent = TRUE;
		}
	}
	if (pChannel->IsChannelType(VIDEO_CONT_IN) && (m_eContentInState == eSendStreamOff))
		m_eContentInState = eStreamOff;

	return bMsgSent;
}
/////////////////////////////////////////////////////////////////
void CSipCntl::RemoveChannel(CSipChannel* pChannel)
{
	/* VNGR-25563 - In case we change the content protocol (example 264->263, we dont want to change the contentState to "eNoChannel")
	if (pChannel->IsChannelType(VIDEO_CONT_OUT))
		m_eContentOutState = eNoChannel;
	if (pChannel->IsChannelType(VIDEO_CONT_IN))
		m_eContentInState = eNoChannel;
	 */
	m_pCall->RemoveChannel(pChannel);
}
//////////////////////////////////////////////////////////////////////////////
//////////////// Useable function for connecting with MFA (CM/RTP) ///////////
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////
void CSipCntl::OnMfaReqToutDisconnecting(CSegment* pParam)
{
	PTRACE2(eLevelError, "CSipCntl::OnMfaReqToutDisconnecting, MFA request with no response, Name - ", PARTYNAME);

	// print the request IDs of the timed out request
	std::list<DWORD>::iterator it;
	for (it = m_MfaReqIds.begin(); it != m_MfaReqIds.end(); ++it)
	    TRACEINTO << "!!!!!! MFA request with no response Req:" << *it;

	// apparently, we had problem on channel closing procedure -> informs party control.
	// party suppose to kill all ports on deallocate resources step.
	m_pPartyApi->SetFaultyResourcesToPartyControlLevel(STATUS_FAIL);
	TRACEINTO<<"!@# calling OnAllChannelsAreClosed";
	OnAllChannelsAreClosed();
}


/////////////////////////////////////////////////////////////////
void CSipCntl::OnMfaReqToutAnycase(CSegment* pParam)
{
	PTRACE2(eLevelError, "CSipCntl::OnMfaReqToutAnycase, MFA request with no response, Name - ", PARTYNAME);
    // print the request IDs of the timed out request
    std::list<DWORD>::iterator it;
    for (it = m_MfaReqIds.begin(); it != m_MfaReqIds.end(); ++it)
        TRACEINTO << "!!!!!! MFA request with no response Req:" << *it;

	CCommConf* pComConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	if(m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvc || (pComConf && pComConf->GetConfMediaType() == eMixAvcSvc ) )
	{
	  TRACEINTO<<"!@# dynMixedErr MFA request with no response";
	}
	//disconnect the call
	// set all channels to be connected in order to disconnect them (they won't disconnect in state "connecting")
	m_pCall->SetChannelsConnectingState(kConnected,MAX_SIP_CHANNELS,NULL);
	m_pPartyApi->SetFaultyResourcesToPartyControlLevel(STATUS_FAIL);
	m_pPartyApi->SipPartyCallFailed(SIP_INTERNAL_MCU_PROBLEM);//


}
/////////////////////////////////////////////////////////////////
void CSipCntl::GetMfaAckAndIdentifyChannel(CSegment* pParam, ACK_IND_S* pAckIndStruct, CSipChannel** pChannel, CObjString &cLog, ConnectionID &connectionId)
{
	*pParam >> pAckIndStruct->ack_base.ack_opcode
			>> pAckIndStruct->ack_base.ack_seq_num
			>> pAckIndStruct->ack_base.status
			>> pAckIndStruct->ack_base.reason
			>> pAckIndStruct->media_type
			>> pAckIndStruct->media_direction
			>> pAckIndStruct->channelHandle
			>> connectionId;

	if (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_OPEN_CHANNEL_REQ)
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::GetMfaAckAndIdentifyChannel ack_opcode=CONF_PARTY_MRMP_OPEN_CHANNEL_REQ pAckIndStruct->channelHandle=", pAckIndStruct->channelHandle);
	}
	else if (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_UPDATE_CHANNEL_REQ)
	{
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::GetMfaAckAndIdentifyChannel ack_opcode=CONF_PARTY_MRMP_UPDATE_CHANNEL_REQ pAckIndStruct->channelHandle=", pAckIndStruct->channelHandle);
	}

	ERoleLabel eRole;
	cmCapDirection channelDirection = (cmCapDirection)pAckIndStruct->media_direction;
	kChanneltype channelType = (kChanneltype)pAckIndStruct->media_type;
	kChanneltype channelTypeInAck = channelType;

	TRACEINTO << "mix_mode: ConnectionId = " << connectionId
		<< " pAckIndStruct->ack_base.ack_opcode: " << pAckIndStruct->ack_base.ack_opcode
		<< " pAckIndStruct->ack_base.ack_seq_num:" << pAckIndStruct->ack_base.ack_seq_num
		<< " channelType: " << ChanneltypeToString(channelType)
		<< " channelDirection: " << CapDirectionToString(channelDirection);

	cLog << "channel type ";
	::GetChannelTypeName(pAckIndStruct->media_type,cLog);
	cLog << ", channel direction ";
	::GetChannelDirectionName((cmCapDirection)pAckIndStruct->media_direction,cLog);

	if (channelType==kAvcToSvcChnlType)
	{
		channelType=kSvcAvcChnlType;
	}

	if(channelDirection == 0 && pAckIndStruct->ack_base.ack_opcode == H323_RTP_FECC_TOKEN_RESPONSE_REQ)  // RTP send this opcode ack without direction
		channelDirection = cmCapReceive;

	if(channelType == kEmptyChnlType && pAckIndStruct->ack_base.ack_opcode == H323_RTP_FECC_TOKEN_RESPONSE_REQ)  // RTP send this opcode ack without channel type
		channelType = kIpFeccChnlType;

	if (!m_bIsMrcCall && m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvcVsw
		&& ((pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_OPEN_CHANNEL_REQ)
		|| (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ)))
	{
		channelType = kAvcVSWChnType; /*  kAvcVSWChnType need to change APICOM for a new channel type  */
	}

	if (channelType != channelTypeInAck)
	{
		TRACEINTO << "!@# channelType is changed to " << ChanneltypeToString(channelType);
	}

	cmCapDataType mediaType = ::ChannelTypeToDataType(channelType, eRole);

	if (((channelType==kSvcAvcChnlType && IsMrmpOpcode(pAckIndStruct->ack_base.ack_opcode))
		|| channelType==kAvcVSWChnType || channelType==kAvcToSacChnlType) && !m_bIsMrcCall) /* kAvcVSWChnType need to change APICOM for a new channel type  */
	{
		*pChannel = m_pCall->GetChannel(false, mediaType, channelDirection, eRole);

		if(*pChannel==NULL)
		{
			TRACEINTO<<"!@# 2 channel not found";
		}
	}
	else if (IsInternalArtConnId(connectionId) && !m_bIsMrcCall)
    {// these are channels from avcToSvcTranslator ARTs
        *pChannel = m_pCall->GetChannel(false, mediaType, channelDirection, eRole, connectionId);

		if(*pChannel==NULL)
		{
			TRACEINTO<<"!@# 2 channel not found";
		}
    }
	else
	{
	    *pChannel = m_pCall->GetChannel(true, mediaType, channelDirection, eRole);
	}

	if(*pChannel && (pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_OPEN_CHANNEL_REQ
		|| pAckIndStruct->ack_base.ack_opcode == CONF_PARTY_MRMP_UPDATE_CHANNEL_REQ)) // softmcu - svc call
	{
		(*pChannel)->SetChannelHandle(pAckIndStruct->channelHandle);
	}

	ReduceReqCounter(pAckIndStruct);
}

/////////////////////////////////////////////////////////////////
void CSipCntl::EnterFunctionAndOpcode(CObjString &cMainLog, const char* pString, DWORD opcode)
{
	static const CProcessBase * process = CProcessBase::GetProcess();
	const std::string &str = process->GetOpcodeAsString(opcode);
	const char* OpcodeStr = str.c_str();
	cMainLog << "CSipCntl::" << pString << " " << OpcodeStr << " ";
}

/////////////////////////////////////////////////////////////////
BYTE CSipCntl::HandleMfaAckStatus(CObjString &cMainLog, DWORD status, DWORD opcode, CSipChannel* pChannel)
{
	if (status == STATUS_OK
		)
	{
		cMainLog << "status is OK - \n";
	}
	else
	{
		if(CONFPARTY_CM_MUX_ON_AVMCU_CALL_REQ == opcode)
		{

			TRACEINTO << "CSipCntl::HandleMfaAckStatus: CONFPARTY_CM_MUX_ON_AVMCU_CALL_REQ -ack   ";
		}
		if (opcode == CONFPARTY_CM_CLOSE_UDP_PORT_REQ && pChannel->GetMediaType() == cmCapBfcp && pChannel->GetDirection() == cmCapReceive &&
		   m_pSipBfcpCtrl && (m_pSipBfcpCtrl->GetBfcpConnMode() == eTcpActive || m_pSipBfcpCtrl->GetBfcpConnMode() == eTcpPassive) &&
		   (m_pCall->GetChannel(true, cmCapBfcp, cmCapTransmit) == NULL || !m_pParty->GetBfcpConnected()))
		{
			TRACEINTO << "CSipCntl::HandleMfaAckStatus: skip the error for bfcp receive channel in tcp connection mode opcode=" << opcode;
		}
		else if ( opcode == ART_CONTENT_ON_REQ || opcode == ART_CONTENT_OFF_REQ ||
		     opcode == ART_EVACUATE_REQ || opcode == H323_RTP_LPR_MODE_CHANGE_REQ ||
		     opcode == H323_RTP_LPR_MODE_RESET_REQ || opcode == H323_RTP_FECC_TOKEN_RESPONSE_REQ )
		{
			TRACEINTO << "CSipCntl::HandleMfaAckStatus: Do not send faulty rsrc to pc level - Opcode = " << opcode;
		    DBGPASSERT(status);
		}
		else
		{
			DBGPASSERT(status);
			static const CProcessBase * process = CProcessBase::GetProcess();
			const std::string &str = process->GetOpcodeAsString(opcode);
			TRACEINTO << "CSipCntl::HandleMfaAckStatus: " << str.c_str() << ", status is NOT ok: "<< status << ", ConnId = " << GetHWInterface(opcode,FALSE)->GetConnectionId();

			m_pPartyApi->SetFaultyResourcesToPartyControlLevel(STATUS_FAIL);

			return (!STATUS_OK);
		}
	}

    return STATUS_OK;
}

/////////////////////////////////////////////////////////////////
void CSipCntl::HandleMfaAckChannelNotFound(CObjString &cLog, const char* pString, ACK_IND_S* pAckIndStruct)
{
//	if(pAckIndStruct->ack_base.ack_opcode != H323_RTP_PARTY_MONITORING_REQ
//		&& pAckIndStruct->ack_base.ack_opcode != H323_RTP_UPDATE_MT_PAIR_REQ
//		&& pAckIndStruct->ack_base.ack_opcode != IP_RTP_SET_FECC_PARTY_TYPE )
//
//	{
//		BYTE isChanNotFound = 1;
//		CMedString str;
//		cLog << ", opcode " << pAckIndStruct->ack_base.ack_opcode;
//		str << "CSipCntl::" << pString << ": channel wasn't found " << cLog.GetString();
//		PTRACE2(eLevelInfoNormal, "", str.GetString());
//		DBGPASSERT(pAckIndStruct->media_type);
//		m_pCall->SetChannelsConnectingState(kConnected,MAX_SIP_CHANNELS,NULL);
//		DWORD MipErrorNumber = GetMipErrorNumber(pAckIndStruct,NULL,isChanNotFound);
//		m_pPartyApi->SipPartyCallFailed(SIP_CARD_REJECTED_CHANNELS,MipErrorNumber);//
//	}
}
/////////////////////////////////////////////////////////////////
void CSipCntl::TranslateAckToMipErrorNumber(MipHardWareConn& mipHwConn, MipMedia& mipMedia, MipDirection& mipDirect,
									   MipTimerStatus& mipTimerStat, MipAction& mipAction, ACK_IND_S* pAckIndStruct, CSipChannel* pChannel
									   ,BYTE isChanNotFound)
{
	CLargeString cstr;
	CLargeString responsibilityStr;

	DWORD faultOpcode =0;

	cstr << "Party:" << m_pCsInterface->GetPartyRsrcId() << " Conf:" << m_pCsInterface->GetConfRsrcId();
	CProcessBase *pProcess = CProcessBase::GetProcess();
	DWORD opcode = 0;

	if (pAckIndStruct)
	{
		opcode = pAckIndStruct->ack_base.ack_opcode;
		faultOpcode = ACK_FAILED;
		cstr << " receives Failure Status for opcode: ";

		switch(pAckIndStruct->ack_base.ack_opcode)
		{
			case CONFPARTY_CM_OPEN_UDP_PORT_REQ:
			{
				mipHwConn = eMipUdp;
				mipAction = eMipOpen;
				break;
			}
			case CONFPARTY_CM_CLOSE_UDP_PORT_REQ:
			{
				mipHwConn = eMipUdp;
				mipAction = eMipClose;
				break;
			}
			case H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ:
			{
				mipHwConn = eMipRtp;
				if (pChannel)
				{
					if (kUpdating == pChannel->GetRtpConnectionState())
						mipAction = eMipUpdate;
					else
						mipAction = eMipOpen;
				}
				else
					mipAction = eMipOpen;
				break;
			}
			case H323_RTP_UPDATE_CHANNEL_REQ:
			{
				mipHwConn = eMipRtp;
				mipAction = eMipUpdate;
				break;
			}
			case CONFPARTY_CM_UPDATE_UDP_ADDR_REQ:
			{
				mipHwConn = eMipUdp;
				mipAction = eMipUpdate;
				break;
			}
			default:
			{
				mipHwConn = eMipNoneHw;
				mipAction = eMipNoAction;
			}
		}

		mipMedia = (MipMedia)pAckIndStruct->media_type;
		mipDirect = (MipDirection)pAckIndStruct->media_direction;
		if (isChanNotFound)
			mipTimerStat = eMipChanNotFound;
		else
			mipTimerStat = eMipStatusFail;

		cstr << " Req:";
		if (pChannel != NULL)
		{
			if (mipHwConn == eMipRtp)
				cstr << pChannel->GetSeqNumRtp();
			else
				cstr << pChannel->GetSeqNumCm();

		}
		else
			cstr << "channel not found ?";

		responsibilityStr << "( Responsibility: embedded )";
	}
	else
	{
		faultOpcode=ACK_NOT_RECEIVED;

		CSipChannel* pCurChannel = NULL;
		for (int i = 0; i < m_pCall->GetNumOfChannels(); i++)
		{
			pCurChannel = m_pCall->GetChannel(i, true);
			if(pCurChannel)
			{
				if (pCurChannel->GetRtpConnectionState() == kUpdating)
				{
					opcode = H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ;
					mipHwConn = eMipRtp;
					switch (pCurChannel->GetMediaType())
					{
						case cmCapAudio:
						{
							mipMedia = eMipAudio;
							break;
						}
						case cmCapVideo:
						{
							mipMedia = eMipVideo;
							break;
						}
						case cmCapData:
						{
							mipMedia = eMipFecc;
							break;
						}
						default:
							mipMedia = eMipNoneMedia;
					}
					mipDirect = (MipDirection)pCurChannel->GetDirection();
					mipTimerStat = eMipTimer;
					mipAction = eMipUpdate;
				}
			}
		}
		if (opcode)
		{
			cstr << " Did not receive ACK for opcode: ";
			responsibilityStr << "( Responsibility: embedded )";
		}
		else
		{
			cstr << " Unknown timer! ";
			responsibilityStr << "( Responsibility: SipParty )";
		}
	}

	if (opcode)
	{
		if (opcode == H323_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ)
			cstr << "SIP_RTP_UPDATE_PORT_OPEN_CHANNEL_REQ:";
		else
			cstr << pProcess->GetOpcodeAsString(opcode);
	}

	cstr << " Req:";
	if (pChannel != NULL)
	{
		if (mipHwConn == eMipRtp)
			cstr << pChannel->GetSeqNumRtp();
		else
			cstr << pChannel->GetSeqNumCm();
	}
	else
	{
		cstr << "?";
	}

	cstr << responsibilityStr;
	DumpMcuInternalDetailed(cstr,faultOpcode);

}
/////////////////////////////////////////////////////////////////
DWORD CSipCntl::GetMipErrorNumber(ACK_IND_S* pAckIndStruct, CSipChannel* pChannel, BYTE isChanNotFound)
{
	MipHardWareConn mipHwConn;
	MipMedia		mipMedia;
	MipDirection	mipDirect;
	MipTimerStatus	mipTimerStat;
	MipAction		mipAction;
	TranslateAckToMipErrorNumber(mipHwConn, mipMedia, mipDirect, mipTimerStat, mipAction, pAckIndStruct,pChannel,isChanNotFound);
	DWORD MipErrorNumber = ::CalculateMcuInternalProblemErrorNumber((BYTE)mipHwConn, (BYTE)mipMedia, (BYTE)mipDirect,
															(BYTE)mipTimerStat, (BYTE)mipAction);

	return 	MipErrorNumber;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
enIpVersion CSipCntl::CheckForMatchBetweenPartyAndUdp(enIpVersion eIpVer,eIpType eipType) const
{
	enIpVersion ipMatch = eIpVersion4;

	if ( eIpVer == eIpVersion6 && (eipType == eIpType_IpV6 || eipType == eIpType_Both))
	{
		ipMatch = eIpVersion6;
	}

	return ipMatch;

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
enIpVersion CSipCntl::GetIpAddrMatch() const
{
	enIpVersion eIpAddrMatch;
	if (IsAnatSupported())   //added for ANAT
		eIpAddrMatch = m_AnatSelectedIpVersion;
	else if (m_state == IP_CHANGEMODE)
		eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetSipLocalMediaType(),m_UdpAddressesParams.IpType);
	else
		eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);

	return eIpAddrMatch;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::FindMatchingIpV6MediaAddressByScopeId()
{
	BYTE place = 0;
	enScopeId eNetSetupMediaScopeId = m_pNetSetup->GetPerferedIpV6ScopeAddr();
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::FindMatchingIpV6MediaAddressByScopeId preffered scope id is : ", eNetSetupMediaScopeId);
	for (int i = 0;i < NUM_OF_IPV6_ADDRESSES; i++)
	{
		//PTRACE2INT(eLevelInfoNormal, "CSipCntl::FindMatchingIpV6MediaAddressByScopeId scopeId : ", (DWORD)m_UdpAddressesParams.IpV6AddrArray[i].scopeId);
		if (eNetSetupMediaScopeId == (enScopeId)m_UdpAddressesParams.IpV6AddrArray[i].scopeId)
		{
			place = i;
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::FindMatchingIpV6MediaAddressByScopeId place is  : ", place);
			break;
		}
	}

	return place;

}

//////////////////////////////////////////////////////////////////////
void CSipCntl::SendStartDnsTimer(DWORD serviceId)
{
	CSegment* pSeg = new CSegment;
	*pSeg << serviceId;
	StartTimer(DNS_POLLING_TIMER, DefaultOfDnsInterval * SECOND, pSeg);
}

//////////////////////////////////////////////////////////////////////////////////
void CSipCntl::ResolveDomainReq(DWORD serviceId, const char* pProxyAddress)
{
	PTRACE2(eLevelInfoNormal, "CSipCntl::ResolveDomainReq, resolving name =", pProxyAddress);
	CSegment*  pRetParam = new CSegment;
	*pRetParam << serviceId
			   << pProxyAddress
			   << (WORD)eProcessConfParty;

 	CProcessBase * process = CProcessBase::GetProcess();
	if (!process)
	{
		PASSERT(101);
	}

    CManagerApi api(eProcessDNSAgent);
    const StateMachineDescriptor stateMachine = GetStateMachineDescriptor();

    STATUS res = api.SendMsg(pRetParam,DNS_RESOLVE_DOMAIN_REQ,&m_pParty->GetRcvMbx(),&stateMachine);

	PASSERT( res );
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnDnsPollingTimeout(CSegment* pParam)
{
	WORD serviceId;
	*pParam >> serviceId;

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnDnsPollingTimeout. Service Id = ", serviceId);
	CIpServiceListManager* pIpServiceListManager = ::GetIpServiceListMngr();
	CConfIpParameters* pServiceParams = pIpServiceListManager->FindIpService(serviceId);
	if (pServiceParams == NULL)
	{
		PASSERTMSG(m_pCsRsrcDesc->GetConnectionId(), "CSipCntl::OnDnsPollingTimeout - IP Service does not exist!!!");
		m_pPartyApi->SipPartyDnsResAck(STATUS_FAIL);
		return;
	}
	if (pServiceParams->GetNumOfDnsWaiting())
	{
		char* pProxyAddress = new char[MaxLengthOfSingleUrl + 1]; AUTO_DELETE_ARRAY(pProxyAddress);
		memset(pProxyAddress,0,MaxLengthOfSingleUrl + 1);
		GetOutboundSipProxy(pProxyAddress);
		if (pProxyAddress[0] != '\0') //send request to DNS
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::OnDnsPollingTimeout. No Ip for Proxy. Wait for DNS answer.");
			ResolveDomainReq(serviceId, pProxyAddress);
		}

	}
	else
		PTRACE2INT(eLevelError,"CSipCntl::OnDnsPollingTimeout. Service isn't waiting to DNS resolve. Service Id = ", serviceId);

}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnDNSResolveInd(CSegment* pParam)
{
	WORD  serviceId = 0;
	ipAddressStruct proxyAddr[TOTAL_NUM_OF_IP_ADDRESSES];
	char hostName[H243_NAME_LEN] = {0};

	*pParam >> serviceId
			>> hostName;

	// Media IP mismatch
	memset(&proxyAddr, 0, (sizeof(ipAddressStruct)*TOTAL_NUM_OF_IP_ADDRESSES));
	// get only fist ip address
	pParam->Get((BYTE*)&proxyAddr, (sizeof(ipAddressStruct)*TOTAL_NUM_OF_IP_ADDRESSES));

	CIpAddressPtr proxyIp = CIpAddress::CreateIpAddress(proxyAddr[0]);

	PTRACE2INT(eLevelError,"CSipCntl::OnDNSResolveInd - Service Id = ", serviceId);
	if (proxyIp.get())
		PTRACE2(eLevelInfoNormal,"CSipCntl::OnDNSResolveInd - Proxy address %s \n",proxyIp->ToString(1));

	DeleteTimer(DNS_POLLING_TIMER);

	BYTE bIsError = FALSE;

	if (proxyIp.get())
	{
		CIpServiceListManager* pIpServiceListManager = ::GetIpServiceListMngr();
		CConfIpParameters* pServiceParams = pIpServiceListManager->FindIpService(serviceId);
		if (pServiceParams == NULL)
		{
			PASSERTMSG(m_pCsRsrcDesc->GetConnectionId(), "CSipCntl::OnDnsPollingTimeout - IP Service does not exist!!!");
			return;
		}
		if (pServiceParams->GetNumOfDnsWaiting() == 0)
		{
			PTRACE2INT(eLevelError, "CSipCntl::OnDNSResolveInd, Card isn't in waiting phase. Service Id = ", serviceId);
			return;
		}

		BYTE bIsParamsOk = TRUE;
		char* pProxyAddress = new char[MaxLengthOfSingleUrl+1];
		memset(pProxyAddress,0,MaxLengthOfSingleUrl+1);

		GetOutboundSipProxy(pProxyAddress);

		bIsParamsOk = !strncmp(pProxyAddress, hostName, MaxLengthOfSingleUrl);

		if (bIsParamsOk)
		{
			pServiceParams->DecreaseNumOfDnsWaiting();
			pServiceParams->SetProxyIpFromDns(&(proxyAddr[0]));
			if (proxyAddr[0].ipVersion == eIpVersion6)
			{
				// In this case we need to find out what is the perfered scopeId we want to open the media towards the EP
				// We will take thee scope Id from the Proxy Ip!
/*				ALLOCBUFFER(mediaAddr,IPV6_ADDRESS_LEN);
				memset(mediaAddr,'\0',IPV6_ADDRESS_LEN);
				mcTransportAddress proxyTrAddr;
				memset(&proxyTrAddr,0,sizeof(mcTransportAddress));
				proxyTrAddr.ipVersion = eIpVersion6;
				memcpy(&(proxyTrAddr.addr), &(proxyAddr[0].addr), sizeof(ipAddressIf));
				::ipToString(proxyTrAddr,mediaAddr,1);*/
				enScopeId ePerferedIpV6ScopeAddr;
				ePerferedIpV6ScopeAddr = (enScopeId)proxyAddr[0].addr.v6.scopeId;//::getScopeId(mediaAddr);
				m_pNetSetup->SetPerferedIpV6ScopeAddr(ePerferedIpV6ScopeAddr);
				PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnDNSResolveInd, . ipv6 preffered scope id is  = ", ePerferedIpV6ScopeAddr);
//				DEALLOCBUFFER(mediaAddr);
			}
			m_pNetSetup->SetIpDnsProxyAddressArray(proxyAddr);

			if (pServiceParams->GetNumOfDnsWaiting() == 0)
			{
				m_pPartyApi->SipPartyDnsResAck(STATUS_OK);
			}
			else
				PTRACE(eLevelInfoNormal,"CSipCntl::OnDNSResolveInd - Params are not ready in order to continue flow.");

		}
		else
		{
			PTRACE2INT(eLevelError, "CSipCntl::OnDNSResolveInd, Problem with service or host name. Service Id = ", serviceId);
			bIsError = TRUE;
		}
		delete [] pProxyAddress;
	}

	else
	{
		PTRACE2INT(eLevelError, "CSipCntl::OnDNSResolveInd, Resolution result: Proxy Ip = 0, Not sending invite request. Service Id = ", serviceId);
		bIsError = TRUE;
	}

	if (bIsError)
	{
		DBGPASSERT(STATUS_FAIL);
		m_pPartyApi->SipPartyDnsResAck(STATUS_FAIL);
	}

}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::MakeDnsQuary()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::MakeDnsQuary.");

	CIpServiceListManager* pIpServiceListManager = ::GetIpServiceListMngr();
	CConfIpParameters* pServiceParams = pIpServiceListManager->FindIpService(m_serviceId);
	if (pServiceParams == NULL)
	{
		PASSERTMSG(m_pCsRsrcDesc->GetConnectionId(), "CSipCntl::MakeDnsQuary - IP Service does not exist!!!");
		return ;
	}

	DWORD bOn = pServiceParams->GetSipProxyStatus();
	BYTE		bDialDirect	= 0;

	DWORD bIsUseOutBoundProxy = STATUS_OK;
	// IpV6
	const mcTransportAddress* pDestTaAddr = m_pNetSetup->GetTaDestPartyAddr();
	if (::isApiTaNull(pDestTaAddr) == FALSE)
		bDialDirect = 1;

	if (!bDialDirect)
	{
		// if the service status is On and its not direct IP call (IP address valid or URI with IP address)
		// we try to get the outbound proxy.
		char pProxyAddress[MaxLengthOfSingleUrl + 1] = {0};

		if(bOn != eServerStatusOff && bDialDirect == NO)
		{
			GetOutboundSipProxy(pProxyAddress);

			if (pProxyAddress[0] == '\0')
				bIsUseOutBoundProxy = STATUS_FAIL;
		}
		if(bIsUseOutBoundProxy != STATUS_OK)
		{
			DBGPASSERT(STATUS_FAIL);
			m_pPartyApi->SipPartyDnsResAck(STATUS_FAIL);
		}
		/* ///////////////////////DNS ///////////////////////////// */
		if (pProxyAddress[0] != '\0' )  //send request to DNS
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::MakeDnsQuary. No Ip for Proxy. Wait for DNS answer.");
			PTRACE2(eLevelInfoNormal,"CSipCntl::MakeDnsQuary - Proxy name = %s \n",pProxyAddress);
			pServiceParams->SetNumOfDnsWaiting(1);
			ResolveDomainReq(m_serviceId, pProxyAddress);
		}
		else
		{
			PTRACE(eLevelError,"CSipCntl::MakeDnsQuary. No Ip and no name for Proxy!!");
		}

		if ((pServiceParams->GetNumOfDnsWaiting()!= 0))
		{
			SendStartDnsTimer(m_serviceId);
		}
	}
	else
		m_pPartyApi->SipPartyDnsResAck(STATUS_OK);
}

/////////////////////////////////////////////////////////////////////////////
//void CSipCntl::OnAllChannelsAreClosedInChangeMedia()
//{
//	PTRACE2(eLevelInfoNormal,"CSipCntl::OnAllChannelsAreClosedInChangeMedia. ",PARTYNAME);
//	// Now we will look for the correct Ip address type and re-open all the UDP ports with the correct IP if exists
//	// If it does'nt exist we will disconnect the call.
//	enIpVersion eIpDesiredVer = (m_pNetSetup->GetSipLocalMediaType() == eIpVersion4) ? eIpVersion6 :eIpVersion4 ;
//	ipAddressStruct* pNewIpMediaVersion = m_pNetSetup->GetIpDnsProxyAddress(eIpDesiredVer);
//	if (pNewIpMediaVersion == NULL)
//	{
//		// No matching Ip type (V4/V6) - Disconnect the party
//		OnAllChannelsAreClosed();
//		return;
//	}
//
//	m_pNetSetup->SetSipLocalMediaType(eIpDesiredVer);
//
//	EIpChannelType chanArr[MAX_SIP_MEDIA_TYPES] = {AUDIO_IN,VIDEO_IN};// temporary initializing.
//	int numOfChannels = m_pCall->SetChannelsConnectingState(kConnecting, MAX_SIP_MEDIA_TYPES, chanArr,kDisconnected);
//	if ( numOfChannels > 0 )
//	{
//		if ( ReOpenMediaChannels(kConnecting) > 0 )
//		{
//			PTRACE(eLevelError,"CSipCntl::OnAllChannelsAreClosedInChangeMedia:ReOpening media");
//		}
//		else
//		{
//			DBGPASSERT(YES);
//			PTRACE(eLevelError,"CSipCntl::OnAllChannelsAreClosedInChangeMedia: No requests to open media");
//		}
//	}
//	else
//	{
//		DBGPASSERT(YES);
//		PTRACE(eLevelError,"CSipCntl::OnAllChannelsAreClosedInChangeMedia: No Channels");
//	}
//}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::HandleMediaIpAddrVersionMismatch(BYTE isNeedToResetCallIndex )
{
	PTRACE(eLevelInfoNormal, "CSipCntl::HandleMediaIpAddrVersionMismatch");
	// 1. Update the call index flag (New or same session)
	m_isNeedToResetCallIndex = isNeedToResetCallIndex;
	// 2. Send a closing to this transaction
	m_state = IP_DISCONNECTING;
	SipInviteAckReq(NO);
	// 3. Changing the SipControl state
	m_state = IP_CHANGEMODE;
	// 4. Closing all open UDP ports
	BYTE bMessageSent = SipCloseAllChannelsReq();
}

/////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::checkForMediaIpVersionMismatch(const sipSdpAndHeadersSt* pSdpAndHeaders)
{
	enIpVersion eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);

	if(GetIsIceCall() && m_pIceParams)
	{
		TRACEINTO << "ICE call - match";
		return 0;
	} else
	{
		if (ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.ipVersion == (DWORD)eIpAddrMatch)
			return 0; // match
		else
			return 1; // no match
	}
}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::handleSwitchedMediaNewSession()
{
	PTRACE2(eLevelInfoNormal, "CSipCntl::handleSwitchedMediaNewSession - Party Name ",PARTYNAME);
	m_state = IP_CONNECTING;
	SipInviteReq(NULL,0,1);
}
/////////////////////////////////////////////////////////////////////////
int CSipCntl::ReOpenMediaChannels(EConnectionState iChannelsInState )
{
	int iNumOfChannels = 0;
	int iNumOfSentChannels = 0;
	CSipChannel* pChannel = NULL;

	PTRACE(eLevelInfoNormal, "CSipCntl::ReOpenMediaChannels");
	iNumOfChannels = m_pCall->GetNumOfChannels();

	for(int i = 0; i < iNumOfChannels; i++)
	{
		pChannel = m_pCall->GetChannel(i, true);

		if ( (NULL != pChannel) &&
					((iChannelsInState == -1) || (pChannel->GetConnectionState() == iChannelsInState)) )
		{
			if(pChannel->IsDirection(cmCapReceive))
				Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStructInChannels(pChannel, NO);
			else
			{
				DBGPASSERT((DWORD)cmCapTransmit);
				PTRACE(eLevelInfoNormal, "CSipCntl::ReOpenMediaChannels - Can only be for incoming channel");
			}
			iNumOfSentChannels++;
		}
	}
	return iNumOfSentChannels;
}
/////////////////////////////////////////////////////////////////
void CSipCntl::OnPartyInfoUnionInd(CSegment* pParam)
{
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	APIS8 videoLabel[32];

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;
	mcIndInfo* pMcIndInfo = (mcIndInfo *)pParam->GetPtr(1);
	switch (pMcIndInfo->subOpcode)
	{
		case VideoFastUpdate:
		case VideoFastUpdateV2StreamId:
		case VideoFastUpdate_v2:
		{
			PTRACE2(eLevelInfoNormal,"CSipCntl::OnPartyInfoUnionInd : Video Fast Update case, Name - ", PARTYNAME);
			if((!m_bIsMrcCall) && m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvcVsw)
			{
				unsigned int 		   unChannelHandle=1000;
				unsigned int   	   unSequenseNumber=200;
				unsigned int 	   	   nNumberOfSyncSources=1;
				APIUBOOL	   bIsGdr=FALSE;
				unsigned int		   syncSources = 0;

				const std::list <StreamDesc> streamsDescList = m_pParty->GetTargetMode()->GetStreamsListForMediaMode(cmCapVideo,cmCapTransmit, kRolePeople);
				std::list <StreamDesc>::const_iterator itr_streams;
				itr_streams = streamsDescList.begin();
				if(itr_streams!=streamsDescList.end())
				{
					syncSources=itr_streams->m_pipeIdSsrc;
					TRACEINTOFUNC<<"#@@@! CSipCntl::OnPartyInfoUnionInd syncSources="<<syncSources;
				}

//				syncSources[0]=3000;
				CSegment* pParam2 = new CSegment;
				*pParam2<<unChannelHandle;
				*pParam2<<unSequenseNumber;
				*pParam2<<nNumberOfSyncSources;
				*pParam2<<bIsGdr;
//				*pParam2<<&syncSources;
				*pParam2<<syncSources;
				m_pPartyApi->HandleMrmpRtcpFirInd(pParam2);

			}
			else
			{
				//enVideoType eVideoType = mainType;
				sprintf(videoLabel, "%s", "");
				if (pMcIndInfo->subOpcode == VideoFastUpdate_v2 ||
					pMcIndInfo->subOpcode == VideoFastUpdateV2StreamId)
				{
					mcIndVideoFastUpdateV2 *pVideoFastUpdateV2Ind;
					pVideoFastUpdateV2Ind = (mcIndVideoFastUpdateV2*)(&(pMcIndInfo->buff));
					//enVideoType eVideoType = (enVideoType)pVideoFastUpdateV2Ind->videoType;
					memcpy(videoLabel, pVideoFastUpdateV2Ind->label, 32);
				}

				if (pMcIndInfo->subOpcode == VideoFastUpdateV2StreamId)
					m_eMediaStreamAttrType = eMediaStreamId;
				else if (pMcIndInfo->subOpcode == VideoFastUpdate_v2)
					m_eMediaStreamAttrType = eMediaStream;

				CSegment *pParam = new CSegment;
				//*pParam << (DWORD)eVideoType;
				pParam->Put((BYTE*)videoLabel, 32);
				DispatchEvent(SIP_CS_SIG_VIDEO_FAST_UPDATE_IND, pParam);
				POBJDELETE(pParam);
			}
			break;
		}
		case FlowControl:
		{
			PTRACE2(eLevelInfoNormal,"CSipCntl::OnPartyInfoUnionInd : Flow control case, Name - ", PARTYNAME);
			m_remoteIdent = PolycomEp;
			mcIndFlowControl *sFlowControlInd;
			sFlowControlInd = (mcIndFlowControl*)(&(pMcIndInfo->buff));
			OnChangeRateInd(sFlowControlInd->label , sFlowControlInd->mediaDirection,sFlowControlInd->rate * 10);
			break;

		}
		case LprChangeMode:
		{
			mcIndSipLPRModeChange *sLprModeChangelInd;
			sLprModeChangelInd = (mcIndSipLPRModeChange*)(&(pMcIndInfo->buff));
			OnSipLprChangeModeInd(sLprModeChangelInd, pMcIndInfo->dTxnId );
			// TBD

			break;
		}
		//LyncCCS
		case CcsPluginConfPwd:
		{
			mcIndConfPwdInfo *sConfPwdInfo = NULL;
			sConfPwdInfo =  (mcIndConfPwdInfo*)(&(pMcIndInfo->buff));
			OnSipPartyAuthInfoInd(sConfPwdInfo, pMcIndInfo->dTxnId);
			break;
		}
		//eFeatureRssDialin
		case SrsIndication:
		{
			mcIndSrsIndicaton  *pstRssCmdStatus = NULL;
			pstRssCmdStatus = (mcIndSrsIndicaton *)(&(pMcIndInfo->buff));
			OnSipPartySrsStatusInd(pstRssCmdStatus);
			break;
		}
		//eFeatureRssDialin
		case SrsVideoLayout :
		{
			mcIndSrsVideolayout  *pstRssLayoutCmd = NULL;
			pstRssLayoutCmd = (mcIndSrsVideolayout *)(&(pMcIndInfo->buff));
			OnSipPartySrsLayoutInd(pstRssLayoutCmd);
			break;
		}
		default:
		{
			PTRACE2(eLevelInfoNormal,"CSipCntl::OnPartyInfoUnionInd : Unknown Info union indication, Name - ", PARTYNAME);
			PASSERT_AND_RETURN(pMcIndInfo->subOpcode + 1000);
		}
	}
}

/////////////////////////////////////////////////////////////////
void CSipCntl::OnPartyInfoRespInd(CSegment* pParam)
{
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnPartyInfoRespInd :Party name - ", PARTYNAME);

	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;

	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;
	mcIndInfoResp* pMcIndInfoResp = (mcIndInfoResp *)pParam->GetPtr(1);

	if (pMcIndInfoResp->subOpcode == PlcmIvrService) {

		CSipHeaderList * pHeaders = new CSipHeaderList(pMcIndInfoResp->sipHeaders);
	    const CSipHeader* pPlcmDiagnosticsHdr = pHeaders->GetNextHeader(kPlcmDiagnostics);

		DWORD sts=eStsOk;

	    if (pPlcmDiagnosticsHdr && pPlcmDiagnosticsHdr->GetHeaderStr()) {

	    	char diagnostics[64];
	    	memset(diagnostics, 0, sizeof(diagnostics));

	    	pPlcmDiagnosticsHdr->GetHeaderStrLower(diagnostics, sizeof(diagnostics) - 1);

	    	if (strstr(diagnostics, "retry"))
	    		sts = eStsRetry;
	    	else if (strstr(diagnostics, "reject"))
	    		sts = eStsReject;
	    }

		m_pParty->SipConfNIDConfirmationInd(sts);

		POBJDELETE(pHeaders);
	}
}

//////////////////////////////////////////////////////////
void CSipCntl::UpdatePayloadTypeInRecieveMediasWhenAnswering()
{
	//incase we are the answering side in an invite ro re-invite trans we want to change payload type into remote payload type
	//Notice: this function is based on the assumption that the the response cap set is fully found in the remote capset and no other caps is added!!!
	PTRACE(eLevelInfoNormal,"CSipCntl::UpdatePayloadTypeInRecieveMediasWhenAnswering");
	UpdatePayloadTypeInRecieveChannelsAccordingToRemoteCaps();
}

//////////////////////////////////////////////////////////
void CSipCntl::OnChangeRateInd(APIS8 *label , APIU32 mediaDirection, APIU32 rate)
{
	//Ignore LPR & Flow Control indications for AVC call in MixAvcSvcVsw conference
	if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvcVsw && !m_bIsMrcCall) {
			PTRACE(eLevelInfoNormal,"CSipCntl::OnChangeRateInd: Ignore LPR & Flow Control for AVC eMixAvcSvcVsw");
			return;
	}

	ERoleLabel eRole = kRolePeople;

	PTRACE2(eLevelInfoNormal,"CSipCntl::OnChangeRateInd received label=",label);
	if( ( strncmp(label, "", MAX_LABEL_LENGTH) == 0) || ( strncmp(label, "0", MAX_LABEL_LENGTH) == 0) || ( strncmp(label, GetLocalStreamLabel(kRolePeople), MAX_LABEL_LENGTH) == 0) )
	    eRole = kRolePeople;
	else if (strncmp(label, GetLocalStreamLabel(kRolePresentation), MAX_LABEL_LENGTH) == 0)
		eRole = kRolePresentation;
	else
	{
		eRole = kRolePeople; // default
		DBGPASSERT(1);
	}

	/*verify that the video rate is legal - minimum rate is MIN_VIDEO_RATE */
	if (rate < MIN_VIDEO_RATE)
	{
		PTRACE2INT(eLevelError, "CSipCntl::OnChangeRateInd Illegal rate", rate);
	}
	else
	{
		TRACEINTOFUNC << "label:             " <<  label
					  << "\nmedia direction: " << mediaDirection
					  << "\nrate:            " << rate;

		if ( ((eRole == kRolePeople /*main-people*/) || (eRole == kRolePresentation /*main-people*/)) &&
			 ((mediaDirection == kSendRecv) || (mediaDirection == kSendOnly)))
		{
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnChangeRateInd: eRole ", eRole);
			m_pPartyApi->UpdatePartyVideoBitRate(rate, cmCapTransmit, eRole);
		}
	}


}

//////////////////////////////////////////////////////////
//this function updated the rate of people caps in both m_pCall and local caps
void CSipCntl::ChangeLocalCapsAndMpCallPeopleRate(DWORD newVidRate, ERoleLabel eRole)
{
	TRACEINTOFUNC << "newVidRate: " << newVidRate << ", eRole: " << eRole;
	m_pCall->SetChannelRate(newVidRate,cmCapVideo,cmCapReceive,eRole);
	m_pChosenLocalCap ->SetVideoRateInallCaps(newVidRate,eRole);
	//CLargeString str;
	//m_pChosenLocalCap ->DumpToString(str);
	//PTRACE2(eLevelInfoNormal,"CSipCntl::ChangeLocalCapsAndMpCallPeopleRate :  ",str.GetString());

}

//////////////////////////////////////////////////////////
void  CSipCntl::SetAlternativeTransportType(const char* strAltToAddr)
{
	char *start, *strTmp;
	char strAddrTmp[IP_STRING_LEN];

	strncpy(strAddrTmp, strAltToAddr, sizeof(strAddrTmp) - 1);
	strAddrTmp[sizeof(strAddrTmp) - 1] = 0;
	start = strstr(strAddrTmp, "transport=");
	if( start )	//if maddr exist in the message
	{
	    start += strlen("transport=");
	    strTmp = start;
	    while( *strTmp != ';' )
	        strTmp++;

	    *strTmp = '\0';
	    if( (strstr(start, "udp") !=NULL) ||  (strstr(start, "UDP") !=NULL))
	       m_transportType = eTransportTypeUdp;
	    else if( (strstr(start, "tcp") !=NULL) ||  (strstr(start, "TCP") !=NULL))
	       m_transportType = eTransportTypeTcp;
	    else if( (strstr(start, "tls") !=NULL) ||  (strstr(start, "TLS") !=NULL))
	       m_transportType = eTransportTypeTls;
	}
}
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendStartPartyPreviewReqToCM(DWORD RemoteIPAddress,WORD VideoPort,cmCapDirection Direction,CapEnum capEnum)
{
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::SendStartPartyPreviewReqToCM - ",GetHWInterface(IP_CM_START_PREVIEW_CHANNEL,FALSE)->GetConnectionId());
	mcReqCmStartPreviewChannel* pStruct = new mcReqCmStartPreviewChannel;
	memset(pStruct,0,sizeof(mcReqCmStartPreviewChannel));

	//Remote ip
	pStruct->remotePreviewAddress.ipVersion = eIpVersion4;
	pStruct->remotePreviewAddress.port = VideoPort;
	pStruct->remotePreviewAddress.distribution = eDistributionUnicast;
	pStruct->remotePreviewAddress.transportType = eTransportTypeUdp;
	pStruct->remotePreviewAddress.addr.v4.ip = RemoteIPAddress;

	pStruct->channelType = (APIU32)kIpVideoChnlType;
	pStruct->channelDirection =(APIU32)Direction;

	if(capEnum == eH261CapCode)
		pStruct->payloadType = H261previewStreamPT;
	if(capEnum == eH263CapCode)
	{
		CSipChannel* pChannel = NULL;
		pChannel = GetChannel(cmCapVideo,Direction);
		if(CPObject::IsValidPObjectPtr(pChannel))
		{
			if(pChannel->IsChannelDynamicPayloadType())
				pStruct->payloadType = H263PLUSpreviewStreamPT;
			else
				pStruct->payloadType = H263previewStreamPT;
		}
	}
	if(capEnum == eH264CapCode)
		pStruct->payloadType = H264previewStreamPT;

	SendMsgToMpl((BYTE*)(pStruct), sizeof(mcReqCmStartPreviewChannel), IP_CM_START_PREVIEW_CHANNEL);
	PDELETE(pStruct);

}
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendStopPartyPreviewReqToCM(cmCapDirection Direction)
{
	PTRACE2INT(eLevelInfoNormal, "CH323Cntl::SendStopPartyPreviewReqToCM - ",GetHWInterface(IP_CM_STOP_PREVIEW_CHANNEL,FALSE)->GetConnectionId());

	mcReqCmCloseUdpPort *pStruct = new mcReqCmCloseUdpPort;
	memset(pStruct,0,sizeof(mcReqCmCloseUdpPort));

	pStruct->channelType = (APIU32)kIpVideoChnlType;
	pStruct->channelDirection =(APIU32)Direction;

	SendMsgToMpl((BYTE*)(pStruct), sizeof(mcReqCmCloseUdpPort), IP_CM_STOP_PREVIEW_CHANNEL);
	PDELETE(pStruct);

}

///////////////////////////////////////////////////////////////////////////////
//recieve LPR message from remote EP.
void CSipCntl::OnSipLprChangeModeInd(mcIndSipLPRModeChange* sLprModeChangelInd , APIU32 dTxId)
{
	DWORD  indLen    = sizeof(mcReqInfoResp);// + 1000; //+1000
	BYTE  pReqArray[indLen];
	memset(pReqArray,0,indLen);
	mcReqInfoResp* mcReq = (mcReqInfoResp*)pReqArray;
	mcReq->dTxnId = dTxId;
	mcReq->subOpcode = LprChangeMode;
	enSipCodes sipAnswer= SipCodesOk;
	//m_isLprModeOn = YES;

	BOOL isSipLprEnabled = FALSE;
	CSysConfig* pSysConfig = CProcessBase::GetProcess()->GetSysConfig();
	pSysConfig->GetBOOLDataByKey("ENABLE_SIP_LPR", isSipLprEnabled);

	//Ignore LPR & Flow Control indications for AVC call in MixAvcSvcVsw conference
	if (isSipLprEnabled == TRUE)
	{
		if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvcVsw && !m_bIsMrcCall) {
			isSipLprEnabled = FALSE;
			PTRACE(eLevelInfoNormal,"CSipCntl::OnSipLprChangeModeInd: Ignore LPR & Flow Control indications for AVC eMixAvcSvcVsw");
		}
	}

	if(isSipLprEnabled == FALSE)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::OnSipLprChangeModeInd: - LPR is disabled");
		sipAnswer = SipCodesNotAcceptable;
		mcReq->status = (APIS32)sipAnswer;
		m_isLprModeOn = NO;
		SendSIPMsgToCS(SIP_CS_SIG_INFO_RESP_REQ, pReqArray, indLen);
		return;
	}

	if ((m_pParty) && (m_pParty->GetCurrentMode()) &&
		((m_pParty->GetCurrentMode()->GetConfType() == kVideoSwitch) || (m_pParty->GetCurrentMode()->GetConfType() == kVSW_Fixed)))
	{
		// VSW:
		BOOL bEnableFlowControlVSW = GetSystemCfgFlagInt<BOOL>(CFG_KEY_SUPPORT_VSW_FLOW_CONTROL);
		if(!bEnableFlowControlVSW)
		{
			PTRACE(eLevelError,"CSipCntl::OnSipLprChangeModeInd: SUPPORT_VSW_FLOW_CONTROL is false");
			sipAnswer = SipCodesNotAcceptable;
			mcReq->status = (APIS32)sipAnswer;
			m_isLprModeOn = NO;
			SendSIPMsgToCS(SIP_CS_SIG_INFO_RESP_REQ, pReqArray, indLen);
			return;
		}
	}

	//DWORD congestionCeiling = sLprModeChangelInd->congestionCeiling*10;
	DWORD congestionCeiling = sLprModeChangelInd->congestionCeiling; // congestionCeiling in x100 bps, sLprModeChangelInd->congestionCeiling in 100bps or kbps
	APIU32 lprVersion = 0;
	if(m_pLastRemoteCaps){
		CLprCap* lprCap = m_pLastRemoteCaps->GetLprCap(); AUTO_DELETE(lprCap);
		if(lprCap){
			lprVersion = lprCap->GetLprVersionID();
		}
	}

	if(1 == lprVersion)  congestionCeiling *= 10;
	TRACEINTO << "CSipCntl::OnSipLprChangeModeInd - LPR version: " << lprVersion << "m_state:" << m_state << "\n";


	DWORD newTotalVideoRate = 0;
	LPRParams *pLprParam 	= NULL;

	if (m_state == IP_CONNECTED)
	{
		//if this LPR request is to reset lpr mode meaning go back to old val
		if (sLprModeChangelInd->lossProtection == 0 && sLprModeChangelInd->mtbf == 0)
		{
			DWORD currentRate = 0;
			if (m_LastRateBeforeLpr < 640) //less than 64k
				currentRate = min( m_pCall->GetCallRate(cmCapTransmit), m_pNetSetup->GetMaxRate() / 100 );
			else
				currentRate = m_LastRateBeforeLpr;

			if ( currentRate <= congestionCeiling)
				newTotalVideoRate = currentRate;
			else
				newTotalVideoRate = congestionCeiling;

			TRACEINTO << "1. newTotalVideoRate = " << newTotalVideoRate << "\n";
		}
		else
		{
			pLprParam = ::lookupLprParams(sLprModeChangelInd->lossProtection, ( (sLprModeChangelInd->mtbf) *100),
				        0, (min(m_pCall->GetCallRate(cmCapTransmit)/10, m_pNetSetup->GetMaxRate() / 1000)));
			if (pLprParam == NULL)
			{
				sipAnswer = SipCodesNotAcceptable;
				mcReq->status = (APIS32)sipAnswer;
				m_isLprModeOn = NO;
				SendSIPMsgToCS(SIP_CS_SIG_INFO_RESP_REQ, pReqArray, indLen);
				PASSERTMSG(1, "CSipCntl::OnSipLprChangeModeInd - pLprParam == NULL - Not valid!!");
                TRACEINTO << "pLprParam == NULL, party id = " << (m_pParty ?  m_pParty->GetPartyId() : 0);
				return;
			}

			newTotalVideoRate = (((congestionCeiling)*(pLprParam->numData + pLprParam->numRecovery))/((pLprParam->numData + (2*pLprParam->numRecovery))));// -activeContentRate;
			TRACEINTO << "2. newTotalVideoRate = " << newTotalVideoRate << "\n";

			if (newTotalVideoRate > congestionCeiling)
			{
				sipAnswer = SipCodesNotAcceptable;
				mcReq->status = (APIS32)sipAnswer;
				m_isLprModeOn = NO;
				SendSIPMsgToCS(SIP_CS_SIG_INFO_RESP_REQ, pReqArray, indLen);
				PASSERTMSG_AND_RETURN((newTotalVideoRate),"CSipCntl::OnSipLprChangeModeInd - Combined rate bigger then congestionCeiling");
			}
		}
		if (m_pParty && m_pParty->GetCurrentMode() && (( m_pParty->GetCurrentMode()->GetConfType() == kVideoSwitch) || (m_pParty->GetCurrentMode()->GetConfType() == kVSW_Fixed)))
		{
			if ( newTotalVideoRate < (VSW_FLOW_CONTROL_RATE_THRESHOLD *  min( m_pCall->GetCallRate(cmCapTransmit), m_pNetSetup->GetMaxRate() / 100)))
			{
				PTRACE(eLevelError,"CSipCntl::OnSipLprChangeModeInd: LPR rate lower than threshold in vsw conf!!! ");
				m_isLprModeOn = NO;
				return;
			}
		}
		// Currently the Total allowed video rate is the congestionCeiling
		//m_pParty->GetTargetMode()->SetTotalVideoRate(newPeopleRate);
		//m_pParty->GetCurrentMode()->SetTotalVideoRate(newPeopleRate);
		// Sending new rates to video and content bridges
		//m_isLprModeOn = YES;
		// Merge V6 <--> V7_4.6 need to add new parameter totalVideoBitRate
		// temp - for compilation to pass:
		//CIpComMode *pCurrMode		= m_pParty ? m_pParty->GetCurrentMode(), NULL;
		//CIpComMode *pTargetMode		= m_pParty ? m_pParty->GetTargetMode(), NULL;

		DWORD currentContentRate = 0;
		DWORD newPeopleRate 	 = 0;

		if(m_pParty && m_pParty->GetIsActiveContent())
			currentContentRate = m_pCall->GetChannelRate(cmCapVideo, cmCapReceive, kRolePresentation);
		if ( MicrosoftEP_Lync_CCS == GetRemoteIdent())
		{
			PTRACE(eLevelError,"CSipCntl::OnSipLprChangeModeInd: For CCS Plug-in, Use the VideoRate directly!!! ");
			newPeopleRate = newTotalVideoRate;
			if ( newPeopleRate < 640 )
			{
				PTRACE(eLevelError,"CSipCntl::OnSipLprChangeModeInd: ACHIVED LOWER TRESHOLD OF 64K LIVE VIDEO - WE MAKE PEOPLE RATE 64K FOR THIS LPR/DBA REQUEST!!! ");
				newPeopleRate = 640;
			}
		}
		else
		{
			newPeopleRate = newTotalVideoRate - currentContentRate;

			// Adding a Threshold of 64k including content - Below that - We will disregard the LPR/DBA requests from the EP
			DWORD minPeopleRate = 640;
			if ((newTotalVideoRate < currentContentRate + minPeopleRate) || (newTotalVideoRate <= currentContentRate))
			{
				PTRACE(eLevelError,"CSipCntl::OnSipLprChangeModeInd: ACHIVED LOWER TRESHOLD OF 64K LIVE VIDEO - WE MAKE PEOPLE RATE 64K FOR THIS LPR/DBA REQUEST!!! ");
				newPeopleRate = minPeopleRate;
				newTotalVideoRate = newPeopleRate + currentContentRate; // VNGFE-6950
			}
		}

		TRACEINTO << "new people rate=" << newPeopleRate << ", currentContentRate:" << currentContentRate << ", new Total rate=" << newTotalVideoRate;
		m_pPartyApi->UpdatePeopleLprRate(newPeopleRate, cmCapTransmit, sLprModeChangelInd->lossProtection,
				sLprModeChangelInd->mtbf,congestionCeiling/10 ,sLprModeChangelInd->fill , sLprModeChangelInd->modeTimeout,newTotalVideoRate, FALSE, currentContentRate/*because there is no contnet in sip people video rate=full video rate*/);
	}
	else
	{
//		sipAnswer = SipCodesNotAcceptable;
	    sipAnswer = SipCodesOk;
		mcReq->status = (APIS32)sipAnswer;
		m_isLprModeOn = NO;
		PTRACE(eLevelInfoNormal,"CSipCntl::OnSipLprChangeModeInd - ignore Lpr request when not in connected state.");
		SendSIPMsgToCS(SIP_CS_SIG_INFO_RESP_REQ, pReqArray, indLen);
		return;

	}
	sipAnswer = SipCodesOk;
	mcReq->status = (APIS32)sipAnswer;

	SendSIPMsgToCS(SIP_CS_SIG_INFO_RESP_REQ, pReqArray, indLen);
}

////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateDbLprSyncStatus(BYTE isSynced, BYTE isLocal)
{
	//PTRACE2INT(eLevelInfoNormal,"CSipCntl::UpdateDbLprSyncStatus: Name - ",m_pCsRsrcDesc->GetConnectionId());
	DWORD  par = 0;
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::UpdateDbLprSyncStatus: param - ",par);

  PTRACE(eLevelInfoNormal, "CSipCntl::UpdateDbLprSyncStatus - ignoring LPR state in video indication on layout due to SRS requirements");
  //=========================================================
  // Checking if video quality indication should be updated
  // This is disabled due to SRS requirements
  //=========================================================
  //const	BYTE lprActive = !isSynced;
  //BYTE*	pLastLprActive;
  //if (isLocal)
  //{
  //	pLastLprActive = &m_outboundLprActive;
  //}
  //else
  //{
  //	pLastLprActive = &m_inboundLprActive;
  //}
  //if (lprActive != *pLastLprActive)
  //{
  //	*pLastLprActive = lprActive;
  //	PropagatePacketLostStatus(m_cmInboundPacketLossStatus, m_cmOutboundPacketLossStatus, m_inboundLprActive, m_outboundLprActive);
  //}
	//=========================================================

	if (isLocal)
		par = LOCALLPRVID;
	else
		par = REMOTELPRVID;

	par <<= 16;
	if (isSynced)
		par |= 1;

	m_pPartyApi->UpdateLprDB(LPR_SYNC,par,1);


}
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendLprReqToMfa(WORD status, DWORD lossProtection, DWORD mtbf, DWORD newPeopleRate, DWORD fill, DWORD modeTimeout, BYTE isReset)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendLprReqToMfa - Conn Id = ",m_pCsRsrcDesc->GetConnectionId());
	if (status)
	{
		PASSERTMSG(status, "CSipCntl::SendLprReqToMfa - Status fail");
		return;
	}
	DWORD congestionCeiling = 0;
/*	if (isReset)
	{
		DWORD activeContentRate = m_pCurrentModeH323->GetMediaBitRate(cmCapVideo, cmCapReceive, kRoleContentOrPresentation);
		congestionCeiling = newPeopleRate + activeContentRate;
	}
	else*/
	congestionCeiling = newPeopleRate;

	TLprModeChangeReq *pStruct = new TLprModeChangeReq;

	PTRACE(eLevelInfoNormal,"CSipCntl::SendLprReqToMfa - for video");

	pStruct->unChannelType			= (APIU32)kIpVideoChnlType;
	if (GetRemoteIdent()== MicrosoftEP_Lync_CCS)
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendLprReqToMfa - Set ContentType for CCS.",m_pCsRsrcDesc->GetConnectionId());
		pStruct->unChannelType			= (APIU32)kIpContentChnlType;
	}

	pStruct->unChannelDirection		= (APIU32)cmCapTransmit;
	pStruct->usLossProtection		= lossProtection;
	pStruct->unMTBF					= mtbf;
	pStruct->unCongestionCeiling	= congestionCeiling;
	pStruct->usFill					= fill;
	pStruct->usModeTimeout			= modeTimeout;
	pStruct->usAlignment			= 0;

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendLprReqToMfa - Set ChannelType = ",pStruct->unChannelType);
	BYTE isSync = 0;
	BYTE isLocal = 1;
	if (isReset)//USE H323_RTP_LPR_MODE_RESET_REQ INSTEAD OF SIP_RTP_LPR_MODE_RESET_REQ
	{
		isSync =1;
		UpdateDbLprSyncStatus(isSync,isLocal);
		SendMsgToMpl((BYTE*)(pStruct), sizeof(TLprModeChangeReq), H323_RTP_LPR_MODE_RESET_REQ);
	}
	else
    {
        isSync = 0;
        if (lossProtection == 0 && mtbf == 0)
            isSync = 1;
        UpdateDbLprSyncStatus(isSync,isLocal);
		SendMsgToMpl((BYTE*)(pStruct), sizeof(TLprModeChangeReq), H323_RTP_LPR_MODE_CHANGE_REQ);
    }

	// send LPR request for content
	PTRACE(eLevelInfoNormal,"CSipCntl::SendLprReqToMfa - for content");
	pStruct->unChannelType = (APIU32)kIpContentChnlType;

	if (isReset)//USE H323_RTP_LPR_MODE_RESET_REQ INSTEAD OF SIP_RTP_LPR_MODE_RESET_REQ
	{
		isSync =1;
		UpdateDbLprSyncStatus(isSync,isLocal);
		SendMsgToMpl((BYTE*)(pStruct), sizeof(TLprModeChangeReq), H323_RTP_LPR_MODE_RESET_REQ);
	}
	else
	{
		isSync = 0;
		if (lossProtection == 0 && mtbf == 0)
			isSync = 1;
		UpdateDbLprSyncStatus(isSync,isLocal);
		SendMsgToMpl((BYTE*)(pStruct), sizeof(TLprModeChangeReq), H323_RTP_LPR_MODE_CHANGE_REQ);
	}

	PDELETE(pStruct);

	// Remember the modeTimeout for the starting of the timer when receiving the ack
	m_LprModeTimeout = modeTimeout;
}
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSIPLprTout(CSegment* pParam)
{
    CancelLpr();

}
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::CancelLpr()
{
    if (!m_isLprModeOn)
    {
        PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSIPLprTout - LPR Not active! Conn Id = ",m_pCsRsrcDesc->GetConnectionId());
        return;
    }
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSIPLprTout - Conn Id = ",m_pCsRsrcDesc->GetConnectionId());

	DWORD newPeopleRate = 0;
	newPeopleRate = m_LastRateBeforeLpr;
	TRACEINTO << "CSipCntl::OnSIPLprTout - newPeopleRate = " << newPeopleRate << "\n";
	SendLprReqToMfa(statOK , 0, 0, newPeopleRate, 0, 0, 1);
	BYTE isSync = 1;
	BYTE isLocal = 1;
	UpdateDbLprSyncStatus(isSync,isLocal);
	m_isLprModeOn = 0;
    if (m_pParty->GetTargetMode()->GetConfType() == kCop)
        SendInfoFlowControlReq(mainType, cmCapReceive , newPeopleRate);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::MfaSIPLprAck()
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::MfaSIPLprAck - Conn Id = ",m_pCsRsrcDesc->GetConnectionId());

	DWORD newPeopleRate = 0;
	newPeopleRate = m_LastRateBeforeLpr;
	TRACEINTO << "CSipCntl::MfaSIPLprAck - newPeopleRate = " << newPeopleRate << "\n";

	if ((m_pParty->GetTargetMode()->GetConfType() == kVideoSwitch) || (m_pParty->GetTargetMode()->GetConfType() == kVSW_Fixed))
	{
		// VSW:
		BOOL bEnableFlowControlVSW = GetSystemCfgFlagInt<BOOL>(CFG_KEY_SUPPORT_VSW_FLOW_CONTROL);
		if(!bEnableFlowControlVSW)
		{
			PTRACE(eLevelError,"CSipCntl::MfaSIPLprAck: SUPPORT_VSW_FLOW_CONTROL is false");
			return;
		}
	}
	// Sending new rates to video  bridge
	m_pPartyApi->UpdatePartyVideoBitRate(newPeopleRate, cmCapTransmit, kRolePeople);
}
///////////////////////////////////////////////////////////////////////////
void CSipCntl::OnRtpLprChangeModeInd(CSegment* pParam)
{
	APIU32							unChannelType;				//Video/Audio/Content/FECC
	APIU32							unChannelDirection;
	APIU16							usLossProtection;
	APIU32							unMTBF;
	APIU32							unCongestionCeiling;
	APIU16							usFill;
	APIU16							usModeTimeout;
	APIU16							usAlignment;
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnRtpLprChangeModeInd - CS Connection ID = ", m_pCsRsrcDesc->GetConnectionId());
	// Passing the LPR ind from the rtp to the EP
	TLprModeChangeInd *pLprModeChange = new TLprModeChangeInd;
	DWORD  structLen = sizeof(TLprModeChangeInd);
	memset(pLprModeChange, 0, structLen);
	pParam->Get((BYTE*)pLprModeChange, structLen);

	unChannelType = pLprModeChange->unChannelType;
    unChannelDirection = pLprModeChange->unChannelDirection;
    BOOL isVideo = 0;

	//BYTE bAllChannelsConnected    = AreAllChannelsConnected();
	//CSipChannel* pChannel= m_pCall->GetChannel(VIDEO_IN);

    CSipChannel* pChannel;
    EConnectionState connectionstate = kUnknown;

    if (cmCapReceive == unChannelDirection && (kIpContentChnlType == unChannelType || kIpVideoChnlType == unChannelType))
    {
    	isVideo = (kIpVideoChnlType == unChannelType) ? 1 : 0;
    	if (isVideo)
    		pChannel = m_pCall->GetChannel(VIDEO_IN);
    	else
    		pChannel = m_pCall->GetChannel(VIDEO_CONT_IN);

    	if (pChannel)
    		connectionstate = pChannel->GetConnectionState();

    	if (connectionstate == kConnected)
    	{
    		SendInfoLprReq(pLprModeChange->usLossProtection,pLprModeChange->unMTBF,pLprModeChange->unCongestionCeiling,pLprModeChange->usFill,pLprModeChange->usModeTimeout);

    		BYTE isSync = 0;
    		BYTE isLocal = 0;
    		if (pLprModeChange->usLossProtection == 0 && pLprModeChange->unMTBF == 0)
    			isSync = 1;
    		UpdateDbLprSyncStatus(isSync,isLocal);

    		if (IsValidTimer(LOCALLPRTOUT))
    			DeleteTimer(LOCALLPRTOUT);

    		if (pLprModeChange->usModeTimeout != 0)
    			StartTimer(LOCALLPRTOUT,pLprModeChange->usModeTimeout);
    	}
		else
			PASSERTMSG(m_pCsRsrcDesc->GetConnectionId(), "CSipCntl::OnRtpLprChangeModeInd - video or content in channel not in connected state !!!");
	}
	else
		PTRACE(eLevelError,"CSipCntl::OnRtpLprChangeModeInd: channel type received was not video or content Or direction was wrong! ");

	PDELETE(pLprModeChange);
}
/////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnRtpLprTout(CSegment* pParam)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnRtpLprTout: Name - ",m_pCsRsrcDesc->GetConnectionId());
	BYTE isSync = 1;
	BYTE isLocal = 0;
	UpdateDbLprSyncStatus(isSync,isLocal);
}

//////////////////////////////////////////////
BYTE CSipCntl::IsChannelSupportLpr(CSipChannel* pChannel)
{
	if (m_pChosenLocalCap ->GetIsLpr() && m_pParty->GetTargetMode()->GetIsLpr() && pChannel->GetMediaType() == cmCapVideo && m_pCall->IsInternalChannel(pChannel)==false)
	{
		if (pChannel->GetDirection() == cmCapTransmit && m_pLastRemoteCaps->GetIsLpr())
		{
			pChannel->SetIsSupportLpr(TRUE);

			return TRUE;
		}

		if (pChannel->GetDirection() == cmCapReceive &&
			(!m_pLastRemoteCaps->GetNumOfCapSets() || m_pLastRemoteCaps->GetIsLpr()))
		{
			pChannel->SetIsSupportLpr(TRUE);

			return TRUE;
		}
	}

	pChannel->SetIsSupportLpr(FALSE);

	return FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//LYNC2013_FEC_RED:
BYTE CSipCntl::IsChannelSupportFec(CSipChannel* pChannel)
{
	//if (m_pMaxLocalCaps && m_pMaxLocalCaps->GetIsFec())
	//	TRACEINTO<<"LYNC2013_FEC_RED: MaxLocalCaps supports FEC";
	//else
	//	TRACEINTO<<"LYNC2013_FEC_RED: MaxLocalCaps NOT!!! supports FEC";
	
	if(/*m_pMaxLocalCaps && m_pMaxLocalCaps->GetIsFec() &&*/    //in case of ms slaves - slave has no local caps.
	   m_pParty && m_pParty->GetTargetMode()->GetIsFec() &&
	   pChannel && pChannel->GetMediaType() == cmCapVideo &&
	   m_pCall && m_pCall->IsInternalChannel(pChannel)==false)
	{
		payload_en payloadToSet = _UnKnown;
		if (pChannel && pChannel->GetDirection() == cmCapTransmit && m_pLastRemoteCaps && m_pLastRemoteCaps->GetIsFec())
		{
			//transmit payload type is determined according to remote caps:
			payloadToSet = m_pLastRemoteCaps->GetPayloadTypeByDynamicPreference(eFECCapCode, H264_Profile_None, pChannel->GetRoleLabel());
			//TRACEINTO<<"LYNC2013_FEC_RED: setting: PayloadType of remote (transmit case):"<<(int)payloadToSet;
			if (::IsDynamicPayloadType(payloadToSet)) //if remote supports dynamic, check local support
			{
				payload_en localPayload = /*m_pChosenLocalCap*/ m_pMaxLocalCaps->GetPayloadTypeByDynamicPreference(eFECCapCode, H264_Profile_None, pChannel->GetRoleLabel());
				if (::IsValidPayloadType(localPayload) && !::IsDynamicPayloadType(localPayload))	//if local doesn't support dynamic, we need to use the static
				{
					//TRACEINTO<<"LYNC2013_FEC_RED: setting: localPayload will be set:"<<(int)localPayload;
					payloadToSet = localPayload;
				}
			}
			pChannel->SetFecPayloadType(payloadToSet);

			return TRUE;
		}
		if(pChannel && pChannel->GetDirection() == cmCapReceive &&
		   m_pLastRemoteCaps && (!m_pLastRemoteCaps->GetNumOfCapSets() || m_pLastRemoteCaps->GetIsFec() ))
		{
			//receive payload type is determined according to local caps:
			payloadToSet = /*m_pChosenLocalCap*/ m_pMaxLocalCaps->GetPayloadTypeByDynamicPreference(eFECCapCode, H264_Profile_None, pChannel->GetRoleLabel());
			//TRACEINTO<<"LYNC2013_FEC_RED: setting: PayloadType of local (receive case):"<<(int)payloadToSet;
			if (::IsDynamicPayloadType(payloadToSet)) //if local supports dynamic, check remote support
			{
				payload_en remotePayload = m_pLastRemoteCaps->GetPayloadTypeByDynamicPreference(eFECCapCode, H264_Profile_None, pChannel->GetRoleLabel());
				if (::IsValidPayloadType(remotePayload) && !::IsDynamicPayloadType(remotePayload))	//if remote doesn't support dynamic, we need to use the static
				{
					//TRACEINTO<<"LYNC2013_FEC_RED: setting: remotePayload will be set:"<<(int)remotePayload;
					payloadToSet = remotePayload;
				}
			}
			pChannel->SetFecPayloadType(payloadToSet);
			return TRUE;
		}
	}

	return FALSE;
}
////////////////////////////////////////////////////////////////////////////////
//LYNC2013_FEC_RED:
BYTE CSipCntl::IsChannelSupportRed(CSipChannel* pChannel)
{
	if(m_pChosenLocalCap && m_pChosenLocalCap->GetIsRed() &&
	   m_pParty && m_pParty->GetTargetMode()->GetIsRed() &&
	   pChannel && pChannel->GetMediaType() == cmCapAudio &&
	   m_pCall && m_pCall->IsInternalChannel(pChannel)==false)
	{
		payload_en payloadToSet = _UnKnown;
		if (pChannel && pChannel->GetDirection() == cmCapTransmit && m_pLastRemoteCaps && m_pLastRemoteCaps->GetIsRed())
		{
			//transmit payload type is determined according to remote caps:
			payloadToSet = m_pLastRemoteCaps->GetPayloadTypeByDynamicPreference(eREDCapCode, H264_Profile_None, pChannel->GetRoleLabel());
			//TRACEINTO<<"LYNC2013_FEC_RED: $#@ setting: PayloadType of remote (transmit case):"<<(int)payloadToSet;
			if (::IsDynamicPayloadType(payloadToSet)) //if remote supports dynamic, check local support
			{
				payload_en localPayload = m_pChosenLocalCap->GetPayloadTypeByDynamicPreference(eREDCapCode, H264_Profile_None, pChannel->GetRoleLabel());
				if (::IsValidPayloadType(localPayload) && !::IsDynamicPayloadType(localPayload))	//if local doesn't support dynamic, we need to use the static
				{
					//TRACEINTO<<"LYNC2013_FEC_RED: $#@ setting: localPayload will be set:"<<(int)localPayload;
					payloadToSet = localPayload;
				}
			}
			pChannel->SetRedPayloadType(payloadToSet);

			return TRUE;
		}
		if(pChannel && pChannel->GetDirection() == cmCapReceive &&
		   m_pLastRemoteCaps && (!m_pLastRemoteCaps->GetNumOfCapSets() || m_pLastRemoteCaps->GetIsRed() ))
		{
			//receive payload type is determined according to local caps:
			payloadToSet = m_pChosenLocalCap->GetPayloadTypeByDynamicPreference(eREDCapCode, H264_Profile_None, pChannel->GetRoleLabel());
			//TRACEINTO<<"LYNC2013_FEC_RED: $#@ setting: PayloadType of local (receive case):"<<(int)payloadToSet;
			if (::IsDynamicPayloadType(payloadToSet)) //if local supports dynamic, check remote support
			{
				payload_en remotePayload = m_pLastRemoteCaps->GetPayloadTypeByDynamicPreference(eREDCapCode, H264_Profile_None, pChannel->GetRoleLabel());
				if (::IsValidPayloadType(remotePayload) && !::IsDynamicPayloadType(remotePayload))	//if remote doesn't support dynamic, we need to use the static
				{
					//TRACEINTO<<"LYNC2013_FEC_RED: $#@ setting: remotePayload will be set:"<<(int)remotePayload;
					payloadToSet = remotePayload;
				}
			}
			pChannel->SetRedPayloadType(payloadToSet);
			return TRUE;
		}
	}

	return FALSE;
}
/////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetCopVideoTxModes(CCopVideoTxModes* pCopVideoModes)
{
	POBJDELETE(m_pCopVideoModes);
	m_pCopVideoModes = new CCopVideoTxModes(*pCopVideoModes);
	m_pCopVideoModes->Dump("CSipCntl::SetCopVideoTxModes", eLevelInfoNormal);
}
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateRtpOnLeaderStatus(BYTE isLeader)
{
	FECC_PARTY_TYPE_S* pStruct = new FECC_PARTY_TYPE_S;
	memset(pStruct,0,sizeof(FECC_PARTY_TYPE_S));

	if (isLeader)
	{
		pStruct->uFeccPartyType = eFeccPartyTypeChairperson;
	}
	else if (m_pParty->GetTargetMode()->GetConfType() == kCop)
	{
		pStruct->uFeccPartyType = eFeccPartyTypeNone;
	}
	else  // CP / VSW
	{
		pStruct->uFeccPartyType = eFeccPartyTypeRegular;
	}

	SendMsgToMpl((BYTE*)(pStruct), sizeof(FECC_PARTY_TYPE_S), IP_RTP_SET_FECC_PARTY_TYPE);
	PDELETE(pStruct);
}
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetLocalVideoCapsExactlyAccordingToScm(CIpComMode* pScm)
{
	if (m_pChosenLocalCap )
		m_pChosenLocalCap ->SetVideoCapsExactlyAccordingToScm(pScm);
	else
		DBGPASSERT(YES);
	m_bDeclareVideoFromScmOnly = TRUE;

	//CLargeString str;
	//m_pChosenLocalCap->DumpToString(str);
	//PTRACE2(eLevelInfoNormal,"CSipCntl::SetLocalVideoCapsExactlyAccordingToScm m_pChosenLocalCap:",str.GetString());


}
//////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetRemoteTypeOnNetSetup(eVideoPartyType RemoteVideoPartyType)
{
	m_pNetSetup->SetRemoteVideoPartyType(RemoteVideoPartyType);
}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendUpdateChannelForDiffPayloadIfNeeded(CSipComMode* pTargetMode)
{
	cmCapDataType mediaType;
	ERoleLabel eRole;
	TRACEINTO<<"!@# ";
	for (int i = 0 ; i < MAX_SIP_MEDIA_TYPES; i++)
	{
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);
		CSipChannel* pCurChannel = NULL;
		pCurChannel	= m_pCall->GetChannel(true, mediaType, cmCapReceive,eRole);
		if (pCurChannel && pCurChannel->GetDiffPayloadState() == kDiffPayload_NeedToSendUpdate)
		{
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendUpdateChannelForDiffPayloadIfNeeded : media type ",i);
			EIpChannelType chanArr = ::CalcChannelType(mediaType, FALSE, eRole);
			SipUpdateChannelReq(pTargetMode, chanArr, kChannelParams, YES, YES);
		}
	}
}
////////////////////////////////////////////////////////////
void  CSipCntl::BuildRepresentableSiteName(char* siteName)
{
	char *end, *start;
	char siteNameTmp[MAX_SITE_NAME_ARR_SIZE];
	memset(siteNameTmp,'\0',MAX_SITE_NAME_ARR_SIZE);

	TRACEINTO << "siteName: " << siteName;

	if(IsOmitDomainFromPartyName())
	{
		GetSipUsernameFromUrl(siteNameTmp, siteName, MAX_SITE_NAME_ARR_SIZE);
		strncpy(siteName, siteNameTmp, MAX_SITE_NAME_ARR_SIZE);
	}
	else
	{
		strncpy(siteNameTmp, siteName, sizeof(siteNameTmp) - 1);
		siteNameTmp[sizeof(siteNameTmp) - 1] = 0;
	}

	end = strstr(siteNameTmp, ";");
	if( end )	//if ';' exist in the name
	{
	    *end = '\0';
	    start = strstr(siteNameTmp, ":");
	    if( start )
	    {
	       start++; //we don't need ":"
	       strncpy(siteName, start, MAX_SITE_NAME_ARR_SIZE);
	    }
	    else
	       strncpy(siteName, siteNameTmp, MAX_SITE_NAME_ARR_SIZE);

		siteName[MAX_SITE_NAME_ARR_SIZE - 1] = '\0';
	}

	RemoveOpeningAndEndingInvertedCommas(siteName);
}

////////////////////////////////////////////////////////////
void  CSipCntl::RemoveOpeningAndEndingInvertedCommas(char* siteName)
{
       char *start;
       char siteNameTmp[MAX_SITE_NAME_ARR_SIZE];

       strncpy(siteNameTmp, siteName, sizeof(siteNameTmp) - 1);
       siteNameTmp[sizeof(siteNameTmp) - 1] = 0;

       // look for first '"'
       start = strchr(siteNameTmp, '"');
       if(start)
       {
          start++; //we don't need '"'
          strncpy(siteName, start, MAX_SITE_NAME_ARR_SIZE);
       }
       else
       {
          strncpy(siteName, siteNameTmp, MAX_SITE_NAME_ARR_SIZE);
       }

       siteName[MAX_SITE_NAME_ARR_SIZE -1] = '\0';

       // look for last '"'
       char* last = strrchr(siteName, '"');
       if (last)
       {
             *last = '\0';
       }

       siteName[MAX_SITE_NAME_ARR_SIZE - 1] = '\0';
}


////////////////////////////////////////////////////////////
BOOL  CSipCntl::GetDisplayNameFromIdentity(char* siteName)
{
	char *end, *start;
	char siteNameTmp[MAX_SITE_NAME_ARR_SIZE];
	BOOL result = FALSE;

	strncpy(siteNameTmp, siteName, sizeof(siteNameTmp) - 1);
	siteNameTmp[sizeof(siteNameTmp) - 1] = 0;
	start = strstr(siteNameTmp, "\"");
	if( start )	//if '\"' exist in the identity
	{
	    start++; //we don't need "\""
	    end = strstr(start, "\"");
	    if( end )
	    	*end = '\0';
	    if( start )
	       strncpy(siteName, start, MAX_SITE_NAME_ARR_SIZE);
	    result = TRUE;
	}
	return result;
}


//SDES
/////////////////////////////////////////////////////////////////////////
void CSipCntl::SetLocalSdesKeysAndTagByRemote(int sdesTag, char *pSdesKeySymmetric, CIpComMode *targetMode, CIpComMode *targetModeMax, cmCapDataType eMediaType, ERoleLabel eRole)
{
	// Get remote tag and set it to local params
	char sdesKey[MAX_BASE64_KEY_SALT_LEN];
	char *pSdesKey = &sdesKey[0];

	BOOL fDisableDefaults = FALSE;
	memset(sdesKey, 0, sizeof(sdesKey));

	if (pSdesKeySymmetric && pSdesKeySymmetric[0] != '\0') {
		memcpy(sdesKey, pSdesKeySymmetric, sizeof(sdesKey));
			fDisableDefaults = TRUE;
	}
	else
		CreateBase64MasterSaltKey(&pSdesKey);

	m_pPartialLocalCaps ->UpdateSdesTag(eMediaType, (APIU32)sdesTag, eRole);
	m_pFullLocalCaps->UpdateSdesTag(eMediaType ,(APIU32)sdesTag, eRole);
	m_pMaxLocalCaps ->UpdateSdesTag(eMediaType, (APIU32)sdesTag, eRole);

	m_pPartialLocalCaps->UpdateSdesMasterSaltBase64Key(eMediaType, pSdesKey, fDisableDefaults, eRole);
	m_pFullLocalCaps->UpdateSdesMasterSaltBase64Key(eMediaType, pSdesKey, fDisableDefaults, eRole);
	m_pMaxLocalCaps->UpdateSdesMasterSaltBase64Key(eMediaType, pSdesKey, fDisableDefaults, eRole);

	if (fDisableDefaults) {
		targetMode->SetSdesMkiDefaultParams(eMediaType, cmCapTransmit, eRole, FALSE);
		targetMode->SetSdesLifeTimeDefaultParams(eMediaType, cmCapTransmit, eRole, FALSE);
		targetModeMax->SetSdesMkiDefaultParams(eMediaType, cmCapTransmit, eRole, FALSE);
		targetModeMax->SetSdesLifeTimeDefaultParams(eMediaType, cmCapTransmit, eRole, FALSE);
	}

	switch (eMediaType) {
		case cmCapAudio:
			targetMode->UpdateXmitSdesAudioTag((APIU32)sdesTag);
			targetModeMax->UpdateXmitSdesAudioTag((APIU32)sdesTag);
			targetMode->UpdateXmitSdesAudioMasterSaltBase64Key(pSdesKey);
			targetModeMax->UpdateXmitSdesAudioMasterSaltBase64Key(pSdesKey);
			break;

		case cmCapVideo:
			if (eRole == kRolePresentation) {
				targetMode->UpdateXmitSdesContentTag((APIU32)sdesTag);
				targetModeMax->UpdateXmitSdesContentTag((APIU32)sdesTag);
				targetMode->UpdateXmitSdesContentMasterSaltBase64Key(pSdesKey);
				targetModeMax->UpdateXmitSdesContentMasterSaltBase64Key(pSdesKey);
			}
			else {
				targetMode->UpdateXmitSdesVideoTag((APIU32)sdesTag);
				targetModeMax->UpdateXmitSdesVideoTag((APIU32)sdesTag);
				targetMode->UpdateXmitSdesVideoMasterSaltBase64Key(pSdesKey);
				targetModeMax->UpdateXmitSdesVideoMasterSaltBase64Key(pSdesKey);
			}
			break;

		case cmCapData:
			targetMode->UpdateXmitSdesDataTag((APIU32)sdesTag);
			targetModeMax->UpdateXmitSdesDataTag((APIU32)sdesTag);
			targetMode->UpdateXmitSdesDataMasterSaltBase64Key(pSdesKey);
			targetModeMax->UpdateXmitSdesDataMasterSaltBase64Key(pSdesKey);
			break;

		default:
			break;
	}
}

/////////////////////////////////////////////////////////////////////////
void CSipCntl::SetLocalSdesKeysAndTagByHost(CIpComMode *targetMode, CIpComMode *targetModeMax, cmCapDataType eMediaType, ERoleLabel eRole)
{
	char sdesKey[MAX_BASE64_KEY_SALT_LEN];
	char *pSdesKey = &sdesKey[0];

	memset(&sdesKey, 0, sizeof(sdesKey));

	CreateBase64MasterSaltKey(&pSdesKey);

	m_pPartialLocalCaps->UpdateSdesMasterSaltBase64Key(eMediaType, pSdesKey, FALSE, eRole);
	m_pFullLocalCaps->UpdateSdesMasterSaltBase64Key(eMediaType, pSdesKey, FALSE, eRole);
	m_pMaxLocalCaps->UpdateSdesMasterSaltBase64Key(eMediaType, pSdesKey, FALSE, eRole);
	m_pChosenLocalCap->UpdateSdesMasterSaltBase64Key(eMediaType, pSdesKey, FALSE, eRole);

	switch (eMediaType) {
		case cmCapAudio:
			targetMode->UpdateXmitSdesAudioMasterSaltBase64Key(pSdesKey);
			targetModeMax->UpdateXmitSdesAudioMasterSaltBase64Key(pSdesKey);
			break;

		case cmCapVideo:
			if (eRole == kRolePresentation) {
				targetMode->UpdateXmitSdesContentMasterSaltBase64Key(pSdesKey);
				targetModeMax->UpdateXmitSdesContentMasterSaltBase64Key(pSdesKey);
			}
			else {
				targetMode->UpdateXmitSdesVideoMasterSaltBase64Key(pSdesKey);
				targetModeMax->UpdateXmitSdesVideoMasterSaltBase64Key(pSdesKey);
			}
			break;

		case cmCapData:
			targetMode->UpdateXmitSdesDataMasterSaltBase64Key(pSdesKey);
			targetModeMax->UpdateXmitSdesDataMasterSaltBase64Key(pSdesKey);
			break;

		default:
			break;
	}
}

/////////////////////////////////////////////////////////////////////////
void CSipCntl::SetLocalSdesKeysAndTag(CIpComMode *targetMode, CIpComMode *targetModeMax)
{
	if(targetMode->GetIsEncrypted() == Encryp_Off)
		return;

	BYTE bIsInviteInitiator = IsInviteInitiator();

	//Handle symmetric keys for MFW and exit
	if(bIsInviteInitiator == NO &&
		CProcessBase::GetProcess()->GetProductType()==eProductTypeSoftMCUMfw &&
		IsSameTimeEP() && m_pLastRemoteCaps) {

		int sdesTagSymmetric = -1;
		sdesTagSymmetric = m_pLastRemoteCaps->GetSdesTag(cmCapAudio, targetMode->GetIsTipMode(), kRolePeople);

		if (sdesTagSymmetric != -1) {
			PTRACE(eLevelInfoNormal,"SetLocalSdesKeysAndTag:  use symmetric keys for Sametime-Softphone 8.5.2");
			char sdesKeySymmetric[MAX_BASE64_KEY_SALT_LEN];
			memset(sdesKeySymmetric, 0, sizeof(sdesKeySymmetric));
			m_pLastRemoteCaps->GetSdesMasterSaltBase64Key(cmCapAudio, &sdesKeySymmetric[0], sizeof(sdesKeySymmetric), kRolePeople);
			SetLocalSdesKeysAndTagByRemote(sdesTagSymmetric, &sdesKeySymmetric[0], targetMode, targetModeMax, cmCapAudio, kRolePeople);
			SetLocalSdesKeysAndTagByRemote(sdesTagSymmetric, &sdesKeySymmetric[0], targetMode, targetModeMax, cmCapVideo, kRolePeople);
			SetLocalSdesKeysAndTagByRemote(sdesTagSymmetric, &sdesKeySymmetric[0], targetMode, targetModeMax, cmCapData, kRolePeople);
			SetLocalSdesKeysAndTagByRemote(sdesTagSymmetric, &sdesKeySymmetric[0], targetMode, targetModeMax, cmCapVideo, kRolePresentation);
			return;
		}
		else
			PTRACE(eLevelInfoNormal,"SetLocalSdesKeysAndTag:  sdesTagSymmetric not found for Sametime-Softphone 8.5.2");
	}


	if(bIsInviteInitiator == YES) {
		SetLocalSdesKeysAndTagByHost(targetMode, targetModeMax, cmCapAudio, kRolePeople);
		SetLocalSdesKeysAndTagByHost(targetMode, targetModeMax, cmCapVideo, kRolePeople);
		SetLocalSdesKeysAndTagByHost(targetMode, targetModeMax, cmCapData, kRolePeople);
		SetLocalSdesKeysAndTagByHost(targetMode, targetModeMax, cmCapVideo, kRolePresentation);
		}

		int sdesTag = -1;

		//Audio
		sdesTag = m_pLastRemoteCaps->GetSdesTag(cmCapAudio, targetMode->GetIsTipMode(), kRolePeople);
		if (sdesTag != -1)
		SetLocalSdesKeysAndTagByRemote(sdesTag, NULL, targetMode, targetModeMax, cmCapAudio, kRolePeople);
		else
			SetLocalSdesKeysAndTagByHost(targetMode, targetModeMax, cmCapAudio, kRolePeople);

		//Video
		sdesTag = m_pLastRemoteCaps->GetSdesTag(cmCapVideo, targetMode->GetIsTipMode(), kRolePeople);
		if (sdesTag != -1)
		SetLocalSdesKeysAndTagByRemote(sdesTag, NULL, targetMode, targetModeMax, cmCapVideo, kRolePeople);
		else
			SetLocalSdesKeysAndTagByHost(targetMode, targetModeMax, cmCapVideo, kRolePeople);

		//Data
		sdesTag = m_pLastRemoteCaps->GetSdesTag(cmCapData, targetMode->GetIsTipMode(), kRolePeople);
		if (sdesTag != -1)
		SetLocalSdesKeysAndTagByRemote(sdesTag, NULL, targetMode, targetModeMax, cmCapData, kRolePeople);
		else
			SetLocalSdesKeysAndTagByHost(targetMode, targetModeMax, cmCapData, kRolePeople);

		//Content
		sdesTag = m_pLastRemoteCaps->GetSdesTag(cmCapVideo, targetMode->GetIsTipMode(), kRolePresentation);
		if (sdesTag != -1)
		SetLocalSdesKeysAndTagByRemote(sdesTag, NULL, targetMode, targetModeMax, cmCapVideo, kRolePresentation);
		else
			SetLocalSdesKeysAndTagByHost(targetMode, targetModeMax, cmCapVideo, kRolePresentation);
}

/*
/////////////////////////////////////////////////////////////////////////
void CSipCntl::SetLocalSdesKeysAndTag(CIpComMode *targetMode, CIpComMode *targetModeMax)
{
	if(targetMode->GetIsEncrypted() == Encryp_Off)
		return;

	BYTE bIsInviteInitiator = IsInviteInitiator();

	if(bIsInviteInitiator == YES) {
		**APIU32 audioSdesTag = 1;
		APIU32 videoSdesTag = 1;
		APIU32 dataSdesTag = 1;
		APIU32 contentSdesTag = 1;
		m_pPartialLocalCaps ->UpdateSdesTag(cmCapAudio, audioSdesTag);
		m_pFullLocalCaps->UpdateSdesTag(cmCapAudio, audioSdesTag);
		m_pMaxLocalCaps ->UpdateSdesTag(cmCapAudio, audioSdesTag);
		targetMode->UpdateXmitSdesAudioTag(audioSdesTag);
		targetModeMax->UpdateXmitSdesAudioTag(audioSdesTag);
		m_pPartialLocalCaps ->UpdateSdesTag(cmCapVideo, videoSdesTag);
		m_pFullLocalCaps->UpdateSdesTag(cmCapVideo, videoSdesTag);
		m_pMaxLocalCaps ->UpdateSdesTag(cmCapVideo, videoSdesTag);
		targetMode->UpdateXmitSdesVideoTag(videoSdesTag);
		targetModeMax->UpdateXmitSdesVideoTag(videoSdesTag);
		m_pPartialLocalCaps ->UpdateSdesTag(cmCapData, dataSdesTag);
		m_pFullLocalCaps->UpdateSdesTag(cmCapData, dataSdesTag);
		m_pMaxLocalCaps ->UpdateSdesTag(cmCapData, dataSdesTag);
		targetMode->UpdateXmitSdesDataTag(dataSdesTag);
		targetModeMax->UpdateXmitSdesDataTag(dataSdesTag);
		m_pPartialLocalCaps->UpdateSdesTag(cmCapVideo, contentSdesTag,kRolePresentation);
		m_pFullLocalCaps->UpdateSdesTag(cmCapVideo, contentSdesTag,kRolePresentation);
		m_pMaxLocalCaps->UpdateSdesTag(cmCapVideo, contentSdesTag,kRolePresentation);
		targetMode->UpdateXmitSdesContentTag(contentSdesTag);
		targetModeMax->UpdateXmitSdesContentTag(contentSdesTag);

	} else {
		int tmpAudioSdesTag = 0;
		int tmpVideoSdesTag = 0;
		int tmpDataSdesTag = 0;
		int tmpContentSdesTag = 0;
		// Get remote tag and set it to local params
		if(m_pLastRemoteCaps) {
			tmpAudioSdesTag = m_pLastRemoteCaps->GetSdesTag(cmCapAudio, targetMode->GetIsTipMode());
			if(tmpAudioSdesTag != -1) {
				m_pPartialLocalCaps ->UpdateSdesTag(cmCapAudio,(APIU32)tmpAudioSdesTag);
				m_pFullLocalCaps->UpdateSdesTag(cmCapAudio,(APIU32)tmpAudioSdesTag);
				m_pMaxLocalCaps ->UpdateSdesTag(cmCapAudio,(APIU32)tmpAudioSdesTag);
				targetMode->UpdateXmitSdesAudioTag((APIU32)tmpAudioSdesTag);
				targetModeMax->UpdateXmitSdesAudioTag((APIU32)tmpAudioSdesTag);
			}

			tmpVideoSdesTag = m_pLastRemoteCaps->GetSdesTag(cmCapVideo, targetMode->GetIsTipMode());
			if(tmpVideoSdesTag != -1) {
				m_pPartialLocalCaps ->UpdateSdesTag(cmCapVideo,(APIU32)tmpVideoSdesTag);
				m_pFullLocalCaps->UpdateSdesTag(cmCapVideo,(APIU32)tmpVideoSdesTag);
				m_pMaxLocalCaps ->UpdateSdesTag(cmCapVideo,(APIU32)tmpVideoSdesTag);
				targetMode->UpdateXmitSdesVideoTag((APIU32)tmpVideoSdesTag);
				targetModeMax->UpdateXmitSdesVideoTag((APIU32)tmpVideoSdesTag);
			}

			tmpDataSdesTag = m_pLastRemoteCaps->GetSdesTag(cmCapData, targetMode->GetIsTipMode());
			if(tmpDataSdesTag != -1) {
				m_pPartialLocalCaps ->UpdateSdesTag(cmCapData,(APIU32)tmpDataSdesTag);
				m_pFullLocalCaps->UpdateSdesTag(cmCapData,(APIU32)tmpDataSdesTag);
				m_pMaxLocalCaps ->UpdateSdesTag(cmCapData,(APIU32)tmpDataSdesTag);
				targetMode->UpdateXmitSdesDataTag((APIU32)tmpDataSdesTag);
				targetModeMax->UpdateXmitSdesDataTag((APIU32)tmpDataSdesTag);
			}

			tmpContentSdesTag = m_pLastRemoteCaps->GetSdesTag(cmCapVideo,targetMode->GetIsTipMode(), kRolePresentation);
			if(tmpContentSdesTag != -1) {
				m_pPartialLocalCaps->UpdateSdesTag(cmCapVideo,(APIU32)tmpContentSdesTag,kRolePresentation);
				m_pFullLocalCaps->UpdateSdesTag(cmCapVideo,(APIU32)tmpContentSdesTag,kRolePresentation);
				m_pMaxLocalCaps->UpdateSdesTag(cmCapVideo,(APIU32)tmpContentSdesTag,kRolePresentation);
				targetMode->UpdateXmitSdesContentTag((APIU32)tmpContentSdesTag);
				targetModeMax->UpdateXmitSdesContentTag((APIU32)tmpContentSdesTag);
			}
		}
	}
	char audioBase64SdesKey[MAX_BASE64_KEY_SALT_LEN];
	char videoBase64SdesKey[MAX_BASE64_KEY_SALT_LEN];
	char dataBase64SdesKey[MAX_BASE64_KEY_SALT_LEN];
	char contentBase64SdesKey[MAX_BASE64_KEY_SALT_LEN];

	memset(audioBase64SdesKey,0,MAX_BASE64_KEY_SALT_LEN);
	memset(videoBase64SdesKey,0,MAX_BASE64_KEY_SALT_LEN);
	memset(dataBase64SdesKey,0,MAX_BASE64_KEY_SALT_LEN);
	memset(contentBase64SdesKey,0,MAX_BASE64_KEY_SALT_LEN);

	char *pAudioBase64SdesKey = &audioBase64SdesKey[0];
	char *pVideoBase64SdesKey = &videoBase64SdesKey[0];
	char *pDataBase64SdesKey = &dataBase64SdesKey[0];
	char *pContentBase64SdesKey = &contentBase64SdesKey[0];

	CreateBase64MasterSaltKey(&pAudioBase64SdesKey);
	CreateBase64MasterSaltKey(&pVideoBase64SdesKey);
	CreateBase64MasterSaltKey(&pDataBase64SdesKey);
	CreateBase64MasterSaltKey(&pContentBase64SdesKey);

	m_pPartialLocalCaps ->UpdateSdesMasterSaltBase64Key(cmCapAudio, pAudioBase64SdesKey);
	m_pFullLocalCaps->UpdateSdesMasterSaltBase64Key(cmCapAudio, pAudioBase64SdesKey);
	m_pMaxLocalCaps ->UpdateSdesMasterSaltBase64Key(cmCapAudio, pAudioBase64SdesKey);
	targetMode->UpdateXmitSdesAudioMasterSaltBase64Key(pAudioBase64SdesKey);
	targetModeMax->UpdateXmitSdesAudioMasterSaltBase64Key(pAudioBase64SdesKey);
	m_pPartialLocalCaps ->UpdateSdesMasterSaltBase64Key(cmCapVideo, pVideoBase64SdesKey);
	m_pFullLocalCaps->UpdateSdesMasterSaltBase64Key(cmCapVideo, pVideoBase64SdesKey);
	m_pMaxLocalCaps ->UpdateSdesMasterSaltBase64Key(cmCapVideo, pVideoBase64SdesKey);
	targetMode->UpdateXmitSdesVideoMasterSaltBase64Key(pVideoBase64SdesKey);
	targetModeMax->UpdateXmitSdesVideoMasterSaltBase64Key(pVideoBase64SdesKey);
	m_pPartialLocalCaps ->UpdateSdesMasterSaltBase64Key(cmCapData, pDataBase64SdesKey);
	m_pFullLocalCaps->UpdateSdesMasterSaltBase64Key(cmCapData, pDataBase64SdesKey);
	m_pMaxLocalCaps ->UpdateSdesMasterSaltBase64Key(cmCapData, pDataBase64SdesKey);
	targetMode->UpdateXmitSdesDataMasterSaltBase64Key(pDataBase64SdesKey);
	targetModeMax->UpdateXmitSdesDataMasterSaltBase64Key(pDataBase64SdesKey);
	m_pPartialLocalCaps->UpdateSdesMasterSaltBase64Key(cmCapVideo, pContentBase64SdesKey,kRolePresentation);
	m_pFullLocalCaps->UpdateSdesMasterSaltBase64Key(cmCapVideo, pContentBase64SdesKey,kRolePresentation);
	m_pMaxLocalCaps->UpdateSdesMasterSaltBase64Key(cmCapVideo, pContentBase64SdesKey,kRolePresentation);
	targetMode->UpdateXmitSdesContentMasterSaltBase64Key(pContentBase64SdesKey);
	targetModeMax->UpdateXmitSdesContentMasterSaltBase64Key(pContentBase64SdesKey);
}
*/

/////////////////////////////////////////////////////////////////////////
//void CSipCntl::UpdateLocalSdesTag(cmCapDataType dataType, APIU32 tag, CIpComMode *targetMode, ERoleLabel eRole)
//{
//	m_pChosenLocalCap->UpdateSdesTag(dataType,tag, eRole);
//
//	switch(dataType)
//	{
//		case cmCapAudio:
//			targetMode->UpdateRxSdesAudioTag(tag);
//			break;
//		case cmCapVideo:
//			if (eRole==kRolePeople)
//				targetMode->UpdateRxSdesVideoTag(tag);
//			else
//				targetMode->UpdateRxSdesContentTag(tag);
//			break;
//		case cmCapData:
//			targetMode->UpdateRxSdesDataTag(tag);
//			break;
//		default:
//			break;
//	}
//
//}

/////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateLocalCapsSdesTag(CSipComMode *pTargetMode)
{
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for (int i = 0 ; i < MAX_SIP_MEDIA_TYPES; i++)
	{
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);

		if (mediaType == cmCapBfcp)
			continue;

		CSdesCap *pSdesCap = pTargetMode->GetSipSdes(mediaType,cmCapReceive,eRole);
		if(pSdesCap)
		{
			APIU32 tag = (APIU32)pSdesCap->GetSdesTag();
			m_pChosenLocalCap ->UpdateSdesTag(mediaType,tag,eRole);
		}
	}
}
//////////////////////////////////////////
void CSipCntl::SetIsMs2013(enMsft2013ActivationState isMs2013)
{
	m_isMs2013Active = isMs2013;
}

//////////////////////////////////////////////////////////
void  CSipCntl::SetIsEnableICE(BYTE flag)
{
	m_IsEnableICE = flag;
}
//////////////////////////////////////////////////////////
BYTE CSipCntl::GetIsEnableICE() const
{
	return m_IsEnableICE;
}
//////////////////////////////////////////////////////////
void CSipCntl::SipIceMakeOffer(DWORD Opcode,CSipChanDifArr*	pIceDifArr,BOOL IsChangeNeeded)
{
    PTRACE2(eLevelInfoNormal,"CSipCntl::SipIceMakeOffer Name - ", PARTYNAME);
    DWORD seqNum = 0;
    ICE_GENERAL_REQ_S* pStruct = new ICE_GENERAL_REQ_S;
	memset(pStruct,0,sizeof(ICE_GENERAL_REQ_S));

	BuildCandidateList(pStruct,pIceDifArr);

	pStruct->isModifyChannels = IsChangeNeeded;
    pStruct->ice_session_index = m_Ice_Session_Index;
    pStruct->max_video_rate = (m_pChosenLocalCap->GetVideoRate())/10;
	pStruct->sdp_size = 0; //No SDP yet - ICE stack will build it

	//We active this flag when we send req to ICE stack.
	m_bIsSentICEStackReq = TRUE;

    seqNum = SendMsgToMpl((BYTE*)(pStruct), sizeof(ICE_GENERAL_REQ_S), Opcode);
}
//////////////////////////////////////////////////////////
void  CSipCntl::OnMfaICEOfferInd(CSegment* pParam)
{
    PTRACE2(eLevelInfoNormal,"CSipCntl::OnMfaICEOfferInd Name - ", PARTYNAME);
    DWORD Status = HandleIceIndication(pParam, true);

	m_pPartyApi->UpdatePartyOnMakeOfferInd(Status);
}

//////////////////////////////////////////////////////////
void  CSipCntl::OnMfaICEModifyOfferInd(CSegment* pParam)
{
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnMfaICEModifyOfferInd Name - ", PARTYNAME);

	DWORD Status = STATUS_FAIL;
	if(m_IsEnableICE)
	{
		if(pParam && CPObject::IsValidPObjectPtr(pParam))
			Status = HandleIceIndication(pParam, false);
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::OnMfaICEModifyOfferInd - Invalid params ");
			SetIsEnableICE(FALSE);
		}
		m_pPartyApi->UpdatePartyOnModifyOfferInd(Status);
	}
}

//////////////////////////////////////////////////////////
void  CSipCntl::OnMfaICEModifyAnswerInd(CSegment* pParam)
{

	PTRACE2(eLevelInfoNormal,"CSipCntl::OnMfaICEModifyAnswerInd Name - ", PARTYNAME);

		DWORD Status = STATUS_FAIL;
		if(m_IsEnableICE)
		{
			if(pParam && CPObject::IsValidPObjectPtr(pParam))
				Status = HandleIceIndication(pParam, false);
			else
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::OnMfaICEModifyAnswerInd - Invalid params ");
				SetIsEnableICE(FALSE);
			}
			m_pPartyApi->UpdatePartyOnModifyAnswerInd(Status, m_AllocatedBandwidth);
		}
}
//////////////////////////////////////////////////////////////
void  CSipCntl::OnMfaICEBandwidthEventInd(CSegment* pParam)
{
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnMfaICEBandwidthEventInd Name - ", PARTYNAME);

		//DWORD Status = STATUS_FAIL;
		if(m_IsEnableICE)
		{
			if(pParam && CPObject::IsValidPObjectPtr(pParam))
			{
				//Status = HandleIceIndication(pParam);
				DWORD sdpSize = 0;
				DWORD status = STATUS_OK;
				int allocatedRateVideo = -1;
				int allocatedRateAudio = -1;

				ICE_GENERAL_IND_S* pAnswerStruct = (ICE_GENERAL_IND_S*) pParam->GetPtr(1);

				status = pAnswerStruct->status;
				if(status == STATUS_OK)
				{
					allocatedRateVideo = pAnswerStruct->allocatedBandwidth;
					allocatedRateAudio = pAnswerStruct->audioAllocatedBandwidth;
					HandleNewIceAllocatedBandwidth(allocatedRateVideo, allocatedRateAudio);
				}

				PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnMfaICEBandwidthEventInd - m_pLastRemoteCaps->GetVideoRate ",m_pLastRemoteCaps->GetVideoRate());
				PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnMfaICEBandwidthEventInd - allocatedRateVideo ",allocatedRateVideo);

				m_pPartyApi->SipBandwidthReInviteNeeded();
			}
			else
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::OnMfaICEBandwidthEventInd - Invalid params ");
			}
		}
}

//////////////////////////////////////////////////////////
WORD  CSipCntl::SendRemoteICESdp(DWORD opcode,CSipChanDifArr* pIceChannelDifArr,BOOL IsChangeNeeded,BYTE IsSecondary,BOOL IsEncryptedCall)
{
	PTRACE2(eLevelInfoNormal,"CSipCntl::SendRemoteICESdp Name - ", PARTYNAME);
	DWORD seqNum = 0;
	WORD Status = STATUS_OK;

	//Build ICE sdp
	char* RemoteICESdp = new char[m_pRemoteSdp->lenOfDynamicSection];
	PASSERT_AND_RETURN_VALUE(NULL == RemoteICESdp, STATUS_FAIL);
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendRemoteICESdp - lenOfDynamicSection: ",m_pRemoteSdp->lenOfDynamicSection);
	memset(RemoteICESdp,'\0',m_pRemoteSdp->lenOfDynamicSection);

	//  BRIDGE_10346 -
	//  We have decided to rely on the check with the targetMode and not with the conf setup
	//	if you have any issue with it please consult yossi g.

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendRemoteICESdp - IsEncryptedCall: ",IsEncryptedCall);
	COstrStream ostr;
	BOOL IsFoundICE = m_pLastRemoteCaps->SetICEsdp(m_pRemoteSdp, ostr, pIceChannelDifArr, opcode,
													IsSecondary, m_serviceId, IsEncryptedCall);


	strncpy(RemoteICESdp,ostr.str().c_str(),ostr.str().length());
	RemoteICESdp[m_pRemoteSdp->lenOfDynamicSection - 1] = '\0';
	DWORD MaxsdpSize = strlen(RemoteICESdp);
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendRemoteICESdp - MaxsdpSize: ",MaxsdpSize);
    PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendRemoteICESdp - ostr.str().length(): ",ostr.str().length());
	PTRACE2(eLevelInfoNormal,"Remote ICE Sdp: \n",ostr.str().c_str());

	if(IsFoundICE)
	{
		//	Build Struct ICE_GENERAL_REQ_S
		ICE_GENERAL_REQ_S* pStruct = (ICE_GENERAL_REQ_S*)new BYTE[sizeof(ICE_GENERAL_REQ_S) + MaxsdpSize];
		memset(pStruct,0,(sizeof(ICE_GENERAL_REQ_S) + MaxsdpSize));

		BuildCandidateList(pStruct,pIceChannelDifArr);

		pStruct->isModifyChannels = IsChangeNeeded;
		pStruct->ice_session_index = m_Ice_Session_Index;
		pStruct->sdp_size = MaxsdpSize;

		pStruct->max_audio_rate = (CalculateAudioRate((m_pNetSetup->GetMaxRate())))/1000;
		int ms_cac_min_audio_threshold_rate = GetSystemCfgFlagInt<DWORD>(CFG_KEY_MS_CAC_AUDIO_MIN_BR);
		pStruct->max_audio_rate = max(pStruct->max_audio_rate, ms_cac_min_audio_threshold_rate);

		pStruct->max_video_rate = m_pNetSetup->GetMaxRate() / 1000;

	    PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendRemoteICESdp - pStruct->max_video_rate: ",pStruct->max_video_rate);
	    PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendRemoteICESdp - pStruct->max_audio_rate: ",pStruct->max_audio_rate);

		if(RemoteICESdp)
		{
			strncpy(((char*) pStruct->sdp),RemoteICESdp,MaxsdpSize);
			pStruct->sdp[MaxsdpSize - 1] = 0;
		}

		if (opcode == ICE_MAKE_ANSWER_REQ)
		{
			m_bIsIceHasSessionIndex = FALSE;
		}

		PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendRemoteICESdp - Total Size: ",sizeof(ICE_GENERAL_REQ_S) + MaxsdpSize);
		seqNum = SendMsgToMpl((BYTE*)(pStruct), sizeof(ICE_GENERAL_REQ_S) + MaxsdpSize, opcode);

		//We active this flag when we send req to ICE stack.
		m_bIsSentICEStackReq = TRUE;

		PDELETEA(pStruct);

	}
	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SendRemoteICESdp - No ICE in SDP from Remote");
		SetIsEnableICE(FALSE);
		Status = STATUS_FAIL;
	}

	PDELETEA(RemoteICESdp);

	return Status;
}

//////////////////////////////////////////////////////////
void CSipCntl::BuildCandidateList(ICE_GENERAL_REQ_S* pStruct,CSipChanDifArr* pIceChannelDifArr)
{
	//Initialize
	int j=0;
	int i=0;
	CSipChanDif* pIceChanDif = NULL;

	for(i=0;i<NumOfMediaTypes-1;i++)
	{
		pStruct->candidate_list[i].channelType = kEmptyChnlType;
		pStruct->candidate_list[i].channelOperation = iceInvalidChannel;

		for(j=0;j<MaxIcePorts;j++)
		{
			pStruct->candidate_list[i].rtp_port[j]= 0;
			pStruct->candidate_list[i].rtcp_port[j] = 0;
		}
	}
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for (i = 0 ; i < NumOfMediaTypes-1; i++)
	{
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);

		pIceChanDif = pIceChannelDifArr->GetChanDif(mediaType,cmCapTransmit,eRole);

		if ( pIceChanDif && (pIceChanDif->IsAddChannel()) )
		{
			pStruct->candidate_list[i].channelOperation = iceOpenChannel;
		}
		else if  (pIceChanDif && (pIceChanDif->IsRemoveChannel()) )
			{
				//BRIDGE-11137
				if(CProcessBase::GetProcess()->GetProductType()==eProductTypeSoftMCUMfw && IsSameTimeEP())
					pStruct->candidate_list[i].channelOperation = iceCloseChannel;
			}
			else
				pStruct->candidate_list[i].channelOperation = iceInvalidChannel;
	}
	int channelIndex=0;

	//Audio
	if(m_UdpAddressesParams.AudioChannelPort && pStruct->candidate_list[channelIndex].channelOperation != iceInvalidChannel)
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::BuildCandidateList AudioPort - ", m_UdpAddressesParams.AudioChannelPort);
		pStruct->candidate_list[channelIndex].channelType = kIpAudioChnlType;
		pStruct->candidate_list[channelIndex].rtp_port[0] = m_UdpAddressesParams.AudioChannelPort;
		pStruct->candidate_list[channelIndex].rtcp_port[0] = m_UdpAddressesParams.AudioChannelPort+1;
		pStruct->candidate_list[channelIndex].rtp_port[1] = m_UdpAddressesParams.AudioChannelAdditionalPorts;
		pStruct->candidate_list[channelIndex].rtcp_port[1] = m_UdpAddressesParams.AudioChannelAdditionalPorts+1;
		channelIndex++;
	}

	if(m_UdpAddressesParams.VideoChannelPort && pStruct->candidate_list[channelIndex].channelOperation != iceInvalidChannel)
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::BuildCandidateList VideoPort - ", m_UdpAddressesParams.VideoChannelPort);
		pStruct->candidate_list[channelIndex].channelType = kIpVideoChnlType;
		pStruct->candidate_list[channelIndex].rtp_port[0] = m_UdpAddressesParams.VideoChannelPort;
		pStruct->candidate_list[channelIndex].rtcp_port[0] = m_UdpAddressesParams.VideoChannelPort+1;
		pStruct->candidate_list[channelIndex].rtp_port[1] = m_UdpAddressesParams.VideoChannelAdditionalPorts;
		pStruct->candidate_list[channelIndex].rtcp_port[1] = m_UdpAddressesParams.VideoChannelAdditionalPorts+1;
		channelIndex++;
	}
	if(m_UdpAddressesParams.FeccChannelPort && pStruct->candidate_list[channelIndex].channelOperation != iceInvalidChannel)
	{
		CSysConfig* pSysConfig = CProcessBase::GetProcess()->GetSysConfig();
		BOOL bSipEnableFecc = TRUE;
		pSysConfig->GetBOOLDataByKey("SIP_ENABLE_FECC", bSipEnableFecc);
		if(bSipEnableFecc)
		{
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::BuildCandidateList FECCPort - ", m_UdpAddressesParams.FeccChannelPort);
			pStruct->candidate_list[channelIndex].channelType = kIpFeccChnlType;
			pStruct->candidate_list[channelIndex].rtp_port[0] = m_UdpAddressesParams.FeccChannelPort;
			pStruct->candidate_list[channelIndex].rtcp_port[0] = m_UdpAddressesParams.FeccChannelPort+1;
			pStruct->candidate_list[channelIndex].rtp_port[1] = m_UdpAddressesParams.FeccChannelAdditionalPorts;
			pStruct->candidate_list[channelIndex].rtcp_port[1] = m_UdpAddressesParams.FeccChannelAdditionalPorts+1;
			channelIndex++;
		}
	}
/*
	if(m_UdpAddressesParams.ContentChannelPort)
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::BuildCandidateList ContentPort - ", m_UdpAddressesParams.ContentChannelPort);
		pStruct->candidate_list[channelIndex].channelType = kIpContentChnlType;
		pStruct->candidate_list[channelIndex].rtp_port[0] = m_UdpAddressesParams.ContentChannelPort;
		pStruct->candidate_list[channelIndex].rtcp_port[0] = m_UdpAddressesParams.ContentChannelPort+1;
		pStruct->candidate_list[channelIndex].rtp_port[1] = m_UdpAddressesParams.ContentChannelPort;
		pStruct->candidate_list[channelIndex].rtcp_port[1] = m_UdpAddressesParams.ContentChannelPort+1;

	}
*/
}
//////////////////////////////////////////////////////////
//Check the Sdp we receive from the ice stack.

DWORD  CSipCntl::HandleIceIndication(CSegment* pParam, bool is_ms_ordering/*=false*/)
{
	PTRACE2(eLevelInfoNormal,"CSipCntl::HandleIceIndication Name - ", PARTYNAME);
	DWORD sdpSize = 0;
	DWORD status = STATUS_OK;
	int allocatedRateVideo = -1;
	int allocatedRateAudio = -1;

	ICE_GENERAL_IND_S* pAnswerStruct = (ICE_GENERAL_IND_S*) pParam->GetPtr(1);

	status = pAnswerStruct->status;
	if(status == STATUS_OK)
	{
		sdpSize = pAnswerStruct->sdp_size;
		allocatedRateVideo = pAnswerStruct->allocatedBandwidth;
		allocatedRateAudio = pAnswerStruct->audioAllocatedBandwidth;

		if( sdpSize )
		{
			//VNFR-22823 - check if SDP is ICE compatible
			if (!isSdpICECompatible(pAnswerStruct->sdp,sdpSize)) {

				PTRACE(eLevelInfoNormal,"CSipCntl::HandleIceIndication - SDP is not ICE compatible fallback to non-ice!!");
				m_IsEnableICE = FALSE;
				return STATUS_FAIL;
			} else
				PTRACE(eLevelInfoNormal,"CSipCntl::HandleIceIndication - SDP is ICE compatible, continue !!");

			// AN: vngfe-4438: add if
			if (m_pIceParams)
				POBJDELETE (m_pIceParams);

			m_pIceParams = new CIceParams;

			SetIceParams(pAnswerStruct);

			m_Ice_Session_Index = pAnswerStruct->ice_session_index;

			m_pChosenLocalCap ->CleanIceCapSets();

			m_pChosenLocalCap ->BuildLocalIceSdp(pAnswerStruct->sdp, sdpSize, m_pIceParams);

			m_pIceParams->Dump("SetIceParams");

			//Incase the ip is 0.0.0.0 ->will close ice.
			if(IsIpNull((m_pIceParams->GetIceMediaIp(eGeneralSession))->addr.v4) || IsIpNull((m_pIceParams->GetIceMediaIp(eGeneralSession))->addr.v6))
			{
				TRACEINTO << "ip is 0.0.0.0";
				m_IsEnableICE = FALSE;
				status = STATUS_FAIL;
			}

			std::string sKey;
			std::string sCacEnable;
			sKey = "CAC_ENABLE";
	        CSysConfig *sysConfig = CProcessBase::GetProcess()->GetSysConfig();
			sysConfig->GetDataByKey(sKey, sCacEnable);
			if( strcmp("NO", sCacEnable.c_str()) != 0 )
			{
				//only when CAC is enabled
				HandleNewIceAllocatedBandwidth(allocatedRateVideo, allocatedRateAudio);
			}
			else
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::HandleIceIndication - CAC disabled");
			}
		}
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::HandleIceIndication - Failed - No SDP!!");
			m_IsEnableICE = FALSE;
			status = STATUS_FAIL;
		}

	}
	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::HandleIceIndication - Failed - Status FAIL!!");
		m_IsEnableICE = FALSE;
	}

	return status;

}


//////////////////////////////////////////////////////////
void  CSipCntl::HandleNewIceAllocatedBandwidth(int allocatedRateVideo, int allocatedRateAudio)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::HandleNewIceAllocatedBandwidth, allocatedRateVideo=",allocatedRateVideo);
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::HandleNewIceAllocatedBandwidth, allocatedRateAudio=",allocatedRateAudio);

	int ms_cac_min_video_threshold_rate = GetSystemCfgFlagInt<DWORD>(CFG_KEY_MS_CAC_VIDEO_MIN_BR);
	int ms_cac_min_audio_threshold_rate = GetSystemCfgFlagInt<DWORD>(CFG_KEY_MS_CAC_AUDIO_MIN_BR);

	//if audio=0 & video =0, it means there is no CAC, we require minimum for audio
	if ((allocatedRateVideo >= 0 && allocatedRateVideo < ms_cac_min_video_threshold_rate) &&
		((allocatedRateAudio > 0) && (allocatedRateAudio < ms_cac_min_audio_threshold_rate)))
	{
		//disconnect
		CSmallString str;
		str << "allocatedRateVideo is "<< allocatedRateVideo << "minimum threshold is " << ms_cac_min_video_threshold_rate;
		str << "allocatedRateAudio is "<< allocatedRateAudio << "minimum threshold is " << ms_cac_min_audio_threshold_rate;

		PTRACE2(eLevelInfoNormal,"CSipCntl::HandleNewIceAllocatedBandwidth: starting InsufficientBandwidth flow as: ", str.GetString());
		m_pPartyApi->ICEInsufficientBandwidthEvent();
	}
	else if( allocatedRateVideo > 0 )
	{
		m_AllocatedBandwidth = allocatedRateVideo*10;
        CConfPartyProcess* pConfPartyProcess = (CConfPartyProcess*)CConfPartyProcess::GetProcess();
        if( pConfPartyProcess->m_IsEnableBWPolicyCheck == TRUE )
        	BandwidthAllocationStatus(m_pChosenLocalCap->GetVideoRate()/10, m_AllocatedBandwidth/10 );

        if(allocatedRateVideo < ms_cac_min_video_threshold_rate)
        {
			//set as audio call
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::HandleNewIceAllocatedBandwidth: setting call as audio only as allocatedRateVideo is below minimum threshold=",ms_cac_min_video_threshold_rate);
        }
        else
		{
        	if (m_pChosenLocalCap->GetMaxVideoBitRate(cmCapReceive) > (unsigned int)m_AllocatedBandwidth)
        	{
            	if ((m_pParty->GetTargetMode()->GetConfType() == kCp)) {
            		m_pChosenLocalCap->SetVideoRateInallCaps(m_AllocatedBandwidth);
            	}
    			if(m_pMaxLocalCaps && (m_pParty->GetTargetMode()->GetConfType() == kCp)) {
    				m_pMaxLocalCaps->SetVideoRateInallCaps(m_AllocatedBandwidth);
    			}
    			int dVideoRate = m_pLastRemoteCaps->GetVideoRate();
    			if( m_AllocatedBandwidth < dVideoRate )
    				m_pLastRemoteCaps->SetVideoRateInallCaps(m_AllocatedBandwidth);
        	}

//    		PTRACE2INT(eLevelInfoNormal,"CSipCntl::HandleNewIceAllocatedBandwidth: Shmulik allocatedRateVideo: ",allocatedRateVideo);
        	DWORD vidBitRate = m_pParty->GetTargetMode()->GetVideoBitRate(cmCapTransmit,kRolePeople);
        	CapEnum algorithm = (CapEnum)(m_pParty->GetTargetMode()->GetMediaType(cmCapVideo, cmCapTransmit));
        	if(vidBitRate > ((DWORD)m_AllocatedBandwidth) || algorithm != eMsSvcCapCode ) //for now chges are only for ms svc on cac- which needed to be redesigned!
        		m_pPartyApi->UpdatePartyVideoBitRate(m_AllocatedBandwidth, cmCapTransmit, kRolePeople);

		}
	}
}

//////////////////////////////////////////////////////////
// void  CSipCntl::GetLocalPortsFromSdp(char* sdp,DWORD sdpSize)
// {
// 	PTRACE2(eLevelInfoNormal,"CSipCntl::GetLocalPortsFromSdp Name - ", PARTYNAME);

// 	char *pStrPointer = NULL;
// 	char *TmpPtr = NULL;
// 	int length = 0;
// 	char* pStrTail = NULL;
// 	DWORD strSize = 0;

// 	ICESessionsTypes IceSessionsTypes = eGeneralSession;

// 	PTRACE2INT(eLevelInfoNormal,"CSipCntl::GetLocalPortsFromSdp sdpSize = ", sdpSize);

// 	if(sdpSize && m_pIceParams)
// 	{
// 		char* pSdpString = new char[sdpSize+1];
// 		strncpy(pSdpString,sdp,sdpSize);
// 		pSdpString[sdpSize] = '\0';

// 		pStrPointer = pSdpString;

// 		while(strSize < sdpSize)
// 		{
// 			length = 0;

// 			pStrTail = strstr(pStrPointer,"\r\n");

// 			if(pStrTail)
// 			{
// 				length = pStrTail - pStrPointer;

// 				if(length)
// 				{

// 					char* pOneLineString = new char[length+1];
// 					strncpy(pOneLineString,pStrPointer,length);
// 					pOneLineString[length] = '\0';


// 					CMedString* str = new CMedString;
// 					*str <<  "pOneLineString - " << pOneLineString << "length - " <<length;
// 					PTRACE2(eLevelInfoNormal,"CSipCntl::GetLocalPortsFromSdp - ",str->GetString());

// 					// Audio Mline
// 					if(strstr(pOneLineString, "m=audio"))
// 					{
// 						IceSessionsTypes = eAudioSession;
// 						m_pIceParams->SetAudioRtpPort(GetRtpPortNumber(pOneLineString));
// 						}
// 					//Video Mline
// 					else if(strstr(pOneLineString, "m=video"))
// 					{
// 						IceSessionsTypes = eVideoSession;
// 						m_pIceParams->SetVideoRtpPort(GetRtpPortNumber(pOneLineString));
// 					}
// 					//Data Mline
// 					else if(strstr(pOneLineString, "m=application"))
// 					{
// 						IceSessionsTypes = eDataSession;
// 						m_pIceParams->SetDataRtpPort(GetRtpPortNumber(pOneLineString));
// 					}
// 					else if(strstr(pOneLineString, "a=rtcp"))
// 					{
// 						if(IceSessionsTypes == eAudioSession )
// 							m_pIceParams->SetAudioRtcpPort(FindRtcpPortNumber(pOneLineString));
// 						if(IceSessionsTypes == eVideoSession )
// 							m_pIceParams->SetVideoRtcpPort(FindRtcpPortNumber(pOneLineString));
// 						if(IceSessionsTypes == eDataSession )
// 							m_pIceParams->SetDataRtcpPort(FindRtcpPortNumber(pOneLineString));
// 					}

// 					strSize	= strSize + length+2; //+2 for /r/n
// 					//PTRACE2INT(eLevelInfoNormal,"CSipCntl::GetLocalPortsFromSdp strSize = ",strSize );

// 					TmpPtr = strstr(pStrPointer,"\r\n");
// 					pStrPointer = TmpPtr+2;
// 					POBJDELETE(str);
// 					PDELETEA(pOneLineString);
// 				}
// 			}
// 			else
// 				break;

// 		}

// 		PDELETEA(pSdpString);
// 	}

// }
//////////////////////////////////////////////////////////
void CSipCntl::OnMfaICEProcessAnswerInd(CSegment* pParam)
{
    PTRACE2(eLevelInfoNormal,"CSipCntl::OnMfaICEProcessAnswerIndName , Name:", PARTYNAME);

    DWORD status = STATUS_OK;

    ICE_GENERAL_IND_S* pAnswerStruct = (ICE_GENERAL_IND_S*) pParam->GetPtr(1);

    status = pAnswerStruct->status;
    if(status != STATUS_OK)
    {
    	SetIsEnableICE(FALSE);
    	PTRACE2(eLevelInfoNormal,"CSipCntl::OnMfaICEProcessAnswerIndName Status Fail, Name:", PARTYNAME);
    }

    m_pPartyApi->UpdatePartyOnProcessAnswerInd(status);

}
//////////////////////////////////////////////////////////
void CSipCntl::OnMfaICEReinviteDataInd(CSegment* pParam)
{
    PTRACE2(eLevelInfoNormal,"CSipCntl::OnMfaICEReinviteDataInd Name -- ", PARTYNAME);
    DWORD Status = HandleIceIndication(pParam, false);

	m_pPartyApi->UpdatePartyOnReinviteDataInd(Status);
}
//////////////////////////////////////////////////////////
void  CSipCntl::OnMfaICEAnswerInd(CSegment* pParam)
{
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnMfaICEAnswerInd Name - ", PARTYNAME);

	DWORD Status = STATUS_FAIL;

	if(m_IsEnableICE)
	{
		m_bIsIceHasSessionIndex = TRUE;

		if(pParam && CPObject::IsValidPObjectPtr(pParam))
			Status = HandleIceIndication(pParam, true);
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::OnMfaICEAnswerInd - Invalid params ");
			SetIsEnableICE(FALSE);
		}

		if (m_bNeedToCancelIceSession)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::OnMfaICEAnswerInd - late canceling of ICE session");

			m_bNeedToCancelIceSession = FALSE;

			DispatchEvent(SIP_CS_SIG_CANCEL_IND, m_cancelIndParams);
			return;
		}

		m_pPartyApi->UpdatePartyOnMakeAnswerInd(Status, m_AllocatedBandwidth);
	}

}

//////////////////////////////////////////////////////////
void  CSipCntl::SetIceParams(const ICE_GENERAL_IND_S* pStruct)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SetIceParams !");

	// AN: vngfe-4438: add if
	if (m_pIceParams)
	{
		m_pIceParams->SetSessionIndex(pStruct->ice_session_index);

		m_pIceParams->SetAudioRtpId(pStruct->ice_channels_id.ice_audio_rtp_id);
		m_pIceParams->SetAudioRtcpId(pStruct->ice_channels_id.ice_audio_rtcp_id);

		m_pIceParams->SetVideoRtpId(pStruct->ice_channels_id.ice_video_rtp_id);
		m_pIceParams->SetVideoRtcpId(pStruct->ice_channels_id.ice_video_rtcp_id);

		m_pIceParams->SetDataRtpId(pStruct->ice_channels_id.ice_data_rtp_id);
		m_pIceParams->SetDataRtcpId(pStruct->ice_channels_id.ice_data_rtcp_id);

		m_pIceParams->SetContentRtpId(pStruct->ice_channels_id.ice_content_rtp_id);
		m_pIceParams->SetContentRtcpId(pStruct->ice_channels_id.ice_content_rtcp_id);
	}

}

//////////////////////////////////////////////////////////
void  CSipCntl::CloseIceSession()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::CloseIceSession !");

	if (m_Ice_Session_Index == 0)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::CloseIceSession - session index is 0 !");
		return;
	}

	if (m_bIsIceSessionIsInClosingState == TRUE)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::CloseIceSession - session is in middle of closing !");
		return;
	}

	DWORD seqNum = 0;

	ICE_GENERAL_REQ_S* pStruct = new ICE_GENERAL_REQ_S;
	memset(pStruct,0,sizeof(ICE_GENERAL_REQ_S));

	pStruct->ice_session_index = m_Ice_Session_Index;
	pStruct->sdp_size = 0;

	CSipChanDifArr* pIceChannelDifArr = new CSipChanDifArr;
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for (int i = 0 ; i < MAX_SIP_MEDIA_TYPES; i++)
	{
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);

		if (mediaType == cmCapBfcp)
			continue;

		CSipChanDif* pChanDif		= NULL;
		pChanDif = pIceChannelDifArr->GetChanDif(mediaType,cmCapTransmit,eRole);

		// AN vngfe-4438: need to check if this condition is good
		// should fix close fecc channel although it wasn't opened
		if (pChanDif && (pChanDif->IsAddChannel()))
		{
			PTRACE(eLevelInfoNormal, "CSipCntl::CloseIceSession, AN debug - if ICE call doesn't disconnect good need to check here!!!");
			pChanDif->SetRemoveChannel(YES);
			pChanDif->SetAddChannel(NO);
		}
	}

	BuildCandidateList(pStruct,pIceChannelDifArr);

	seqNum = SendMsgToMpl((BYTE*)(pStruct), sizeof(ICE_GENERAL_REQ_S), ICE_CLOSE_SESSION_REQ);

	// AN: vngfe-4438 - it was TRUE
	m_IsEnableICE = FALSE;

	m_bIsIceSessionIsInClosingState = TRUE;
	m_IceConnectivityCheckStatus 			= eIceNotConnected;
	m_pParty->SetIceCheckCompleteState(FALSE);
	for(int i=0;i<NumOfMediaTypes-1;i++)
		memset(&m_chosenCandidates[i],0,sizeof(chosenCandidatesSt));

	PDELETE(pStruct);
	POBJDELETE(pIceChannelDifArr);

}
//////////////////////////////////////////////////////////
void  CSipCntl::OnMfaICECloseSessionIndDisconnecting(CSegment* pParam)
{
	BYTE bMessageSent = NO;

	BYTE bIsCloseInitiator = m_pCall->IsCloseInitiator();

	ICE_GENERAL_IND_S* pAnswerStruct = (ICE_GENERAL_IND_S*) pParam->GetPtr(1);
	if(pAnswerStruct->status == STATUS_OK )
    {
        PTRACE(eLevelInfoNormal,"CSipCntl::OnMfaICECloseSessionIndDisconnecting  - Status OK!!!");
        m_Ice_Session_Index = 0;

        ContinueToEndCloseChannels();
    }
    else
    {
        PTRACE(eLevelInfoNormal,"CSipCntl::OnMfaICECloseSessionIndDisconnecting  - Status Failed!!!");
        DBGPASSERT(1);
		//Error handling------> should we call CSipCntl::HandleMfaAckStatus??? TBD
    }

	// AN: vngfe-4438: add if
	if (m_pIceParams)
		POBJDELETE (m_pIceParams);

    SetIsEnableICE(FALSE);
    m_bIsSentICEStackReq = FALSE;

    m_bIsIceSessionIsInClosingState = FALSE;
}
//////////////////////////////////////////////////////////
void  CSipCntl::OnMfaICECloseSessionInd(CSegment* pParam)
{
	ICE_GENERAL_IND_S* pAnswerStruct = (ICE_GENERAL_IND_S*) pParam->GetPtr(1);

    if(pAnswerStruct->status == STATUS_OK)
    {
        PTRACE(eLevelInfoNormal,"CSipCntl::OnMfaICECloseSessionInd  - Status OK!!!");
        m_Ice_Session_Index = 0;
   }
    else
    {
        PTRACE(eLevelInfoNormal,"CSipCntl::OnMfaICECloseSessionInd  - Status FAIL!!!");
        DBGPASSERT(1);
    }

    m_bIsIceSessionIsInClosingState = FALSE;

    // AN: vngfe-4438: add if
    if (m_pIceParams)
    	POBJDELETE (m_pIceParams);

    SetIsEnableICE(FALSE);

    m_pPartyApi->UpdatePartyOnCloseIceSession(pAnswerStruct->status);
}
//////////////////////////////////////////////////////////
void CSipCntl::OnMfaICEErrInd(CSegment* pParam)
{
	DWORD Status = 0;

	ICE_GENERAL_IND_S* pAnswerStruct = (ICE_GENERAL_IND_S*) pParam->GetPtr(1);

	Status = pAnswerStruct->status;

	CSmallString pStr;
	::GetICEErrorAsString(Status,pStr);

	PTRACE2(eLevelInfoNormal,"CSipCntl::OnMfaICEErrInd ! - Ice Error: ",pStr.GetString());
	PASSERT(Status);

}
//////////////////////////////////////////////////////////
void CSipCntl::OnMfaICEConnectivityCheckComplete (CSegment* pParam)
{
    PTRACE (eLevelInfoNormal, "CSipCntl::OnMfaICEConnectivityCheckComplete");
    m_pPartyApi->UpdateTransIceConnectivityCheckComplete (pParam);
    m_pPartyApi->UpdatePartyIceConnectivityCheckComplete (pParam);
}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::CompleteDataFromOtherCapUsingUserAgent(CSipCaps* remoteCaps)
{
	BOOL bEnableFreeVideoResources = GetSystemCfgFlagInt<BOOL>(CFG_KEY_SIP_FREE_VIDEO_RESOURCES);
	if (bEnableFreeVideoResources)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::CompleteDataFromOtherCapUsingUserAgent using m_pMaxLocalCaps");
		remoteCaps->CompleteDataFromOtherCap(*m_pMaxLocalCaps );
	}
	else
	{
		remoteCaps->CompleteDataFromOtherCap(*m_pChosenLocalCap );
	}
	if(IsRemoteMicrosoft())
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::CompleteDataFromOtherCapUsingUserAgent removing 4cif ");
		remoteCaps->Reomve4cifFromCaps();
		remoteCaps->SetMpiFormatInCaps(kCif,1);

		CCapSetInfo capInfoG7231 (eG7231CapCode);
        remoteCaps->RemoveCapSet(capInfoG7231);
        PTRACE(eLevelInfoNormal,"CSipCntl::CompleteDataFromOtherCapUsingUserAgent for LYNC remove G7231 because this audio codec doesn't work!");

		//on single core open audio codec according to flag (VNGFE-4961)
		//check if it's single core : 640X480@15fps
		bool is_single_core = false;
		RTVVideoModeDetails rtvVidModeDetails;
		DWORD BitRate = 0;
		remoteCaps->GetRtvCap(rtvVidModeDetails,BitRate);
		if (640 == rtvVidModeDetails.Width && 480 == rtvVidModeDetails.Height && 15 == rtvVidModeDetails.FR)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::CompleteDataFromOtherCapUsingUserAgent remote ms client has single core ");
			is_single_core = true;
		}

		remoteCaps->RemoveAudioCapsAccordingToRtvFlag(is_single_core);
		CSuperLargeString msgPM3;
		remoteCaps->DumpToString(msgPM3);
		PTRACE2(eLevelInfoNormal,"CSipCntl::CompleteDataFromOtherCapUsingUserAgent - noa to remove remoteCaps first:",msgPM3.GetString());
		if(m_isMs2013Active && remoteCaps->getMsftRxVideoBwLimitation() != 0 && remoteCaps->getMsftRxVideoBwLimitation() != 0xFFFFFFFF )
		{
			//noa dbg tmp start here

			PTRACE(eLevelInfoNormal,"CSipCntl::CompleteDataFromOtherCapUsingUserAgent 2013 ");
			if(bEnableFreeVideoResources)
				remoteCaps->Complete2013DataFromOtherCapForMsSvc(*m_pMaxLocalCaps,remoteCaps->getMsftRxVideoBwLimitation() );
			else
				remoteCaps->Complete2013DataFromOtherCapForMsSvc(*m_pChosenLocalCap,remoteCaps->getMsftRxVideoBwLimitation() );

			CSuperLargeString msgPM4;
			remoteCaps->DumpToString(msgPM4);
			PTRACE2(eLevelInfoNormal,"CSipCntl::CompleteDataFromOtherCapUsingUserAgent - noa to remove remoteCaps:",msgPM4.GetString());

		}
	}
}

//////////////////////////////////////////////////////////////////////
EPendingTransType CSipCntl::IsPendingTrns()
{
	if(m_SavedTrans != NULL && m_PendTransType != eNoPendTrans)
		return m_PendTransType;
	else
		return eNoPendTrans;
}
//////////////////////////////////////////////////////////////////////
void CSipCntl::RemovePendingReInviteTrns()
{
	if(m_SavedTrans != NULL && m_PendTransType == etransReinvite)
	{
		POBJDELETE(m_SavedTrans);
		m_PendTransType = eNoPendTrans;
	}
}


////////////////////////////////////////////////////////////////////////
void CSipCntl::SetChosenCandidates(chosenCandidatesSt Candidates,cmCapDataType eType)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetChosenCandidates eType:",eType);
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for(int i=0;i<NumOfMediaTypes-1;i++)
	{
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);
		if(mediaType == eType)
		{
			//local cand
			memset(m_chosenCandidates[i].local_candidate.type,'\0',CandidateTypeLen);
			strncpy(m_chosenCandidates[i].local_candidate.type,Candidates.remote_candidate.type,CandidateTypeLen-1);

			TRACEINTOFUNC << "remote_candidate.type: " << Candidates.remote_candidate.type
						  << "\nlocal_candidate.type: " << Candidates.local_candidate.type;

			m_chosenCandidates[i].local_candidate.port = Candidates.local_candidate.port;
			m_chosenCandidates[i].local_candidate.mediaType = Candidates.local_candidate.mediaType;

			memset(m_chosenCandidates[i].local_candidate.ip,'\0',CandidateIpLen);
			strncpy(m_chosenCandidates[i].local_candidate.ip,Candidates.local_candidate.ip,CandidateIpLen-1);

			//remote cand
			memset(m_chosenCandidates[i].remote_candidate.type,'\0',CandidateTypeLen);
			strncpy(m_chosenCandidates[i].remote_candidate.type,Candidates.remote_candidate.type,CandidateTypeLen-1);

			TRACEINTOFUNC << "m_remote_candidate.type: " << m_chosenCandidates[i].remote_candidate.type
						  << "\nm_local_candidate.type: " << m_chosenCandidates[i].local_candidate.type;


			m_chosenCandidates[i].remote_candidate.port = Candidates.remote_candidate.port;
			m_chosenCandidates[i].remote_candidate.mediaType = Candidates.remote_candidate.mediaType;
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetChosenCandidates -m_chosenCandidates[i].remote_candidate.mediaType: ",m_chosenCandidates[i].remote_candidate.mediaType);

			memset(m_chosenCandidates[i].remote_candidate.ip,'\0',CandidateIpLen);
			strncpy(m_chosenCandidates[i].remote_candidate.ip,Candidates.remote_candidate.ip,CandidateIpLen-1);
		}
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////
char* CSipCntl::GetMediaChosenRemoteIpAddress(cmCapDataType eType)
{
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for(int i=0;i<NumOfMediaTypes-1;i++)
	{
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);
		if(mediaType == eType)
		{
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::GetMediaChosenRemoteIpAddress - eType: ",eType);
			return m_chosenCandidates[i].remote_candidate.ip;
		}
	}
	return NULL;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::GetMediaChosenRemotePort(cmCapDataType eType)
{
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for(int i=0;i<NumOfMediaTypes-1;i++)
	{
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);
		if(mediaType == eType)
			return m_chosenCandidates[i].remote_candidate.port;
	}
	return 0;

}
////////////////////////////////////////////////////////////////////////////////////////////////////
EIceConnectionType CSipCntl::GetMediaChosenRemoteType(cmCapDataType eType)
{

	EIceConnectionType eConnectionType = kNone;
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for(int i=0;i<NumOfMediaTypes-1;i++)
	{
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);
		if(mediaType == eType)
		{
			int len = strlen(m_chosenCandidates[i].remote_candidate.type);
				if(strncmp(m_chosenCandidates[i].remote_candidate.type,"local",len)==0)
					eConnectionType = kLocal;
				else if(strncmp(m_chosenCandidates[i].remote_candidate.type,"relay",len)==0)
					eConnectionType = kRelay;
				else if(strncmp(m_chosenCandidates[i].remote_candidate.type,"firewall",len)==0)
					eConnectionType = kFirewall;

			PTRACE2INT(eLevelInfoNormal,"CSipCntl::GetMediaChosenRemoteType - ConnectionType: ",eConnectionType);
		}
	}


	return eConnectionType;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
char* CSipCntl::GetMediaChosenLocalIpAddress(cmCapDataType eType)
{
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for(int i=0;i<NumOfMediaTypes-1;i++)
	{
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);
		if(mediaType == eType)
		{
			return m_chosenCandidates[i].local_candidate.ip;
		}
	}
	return NULL;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::GetMediaChosenLocalPort(cmCapDataType eType)
{
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for(int i=0;i<NumOfMediaTypes-1;i++)
	{
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);
		if(mediaType == eType)
			return m_chosenCandidates[i].local_candidate.port;
	}
	return 0;

}
////////////////////////////////////////////////////////////////////////////////////////////////////
EIceConnectionType CSipCntl::GetChannelChosenLocalType(cmCapDataType eType)
{
	EIceConnectionType eConnectionType = kNone;
	cmCapDataType mediaType;
	ERoleLabel eRole;
	for(int i=0;i<NumOfMediaTypes-1;i++)
	{
		GetMediaDataTypeAndRole(globalMediaArr[i], mediaType, eRole);
		if(mediaType == eType)
		{
			int len = strlen(m_chosenCandidates[i].local_candidate.type);
			if(strncmp(m_chosenCandidates[i].local_candidate.type,"local",len)==0)
				eConnectionType = kLocal;
			else if(strncmp(m_chosenCandidates[i].local_candidate.type,"relay",len)==0)
				eConnectionType = kRelay;
			else if(strncmp(m_chosenCandidates[i].local_candidate.type,"firewall",len)==0)
				eConnectionType = kFirewall;
		}
	}
	return eConnectionType;
}

//////////////////////////////////////////////////////////
void CSipCntl::GetOriginalRmtIpAddress(cmCapDataType eMediaType, mcTransportAddress& remoteIp, ERoleLabel eRole)
{
	mcTransportAddress* TmpIp = NULL;

	if(eMediaType == cmCapAudio)
		TmpIp = m_pLastRemoteCaps->GetHostAudioIpAddr();
	if((eMediaType == cmCapVideo) && (eRole == kRolePeople))
		TmpIp = m_pLastRemoteCaps->GetHostVideoIpAddr();
	if(eMediaType == cmCapData)
		TmpIp = m_pLastRemoteCaps->GetHostDataIpAddr();

	PASSERTMSG_AND_RETURN(!TmpIp, "CSipCntl::GetOriginalRmtIpAddress - Failed, 'TmpIp' is NULL");
	memcpy(&remoteIp,TmpIp,sizeof(mcTransportAddress));
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnSipRtpSelfVideoUpdatePicReq(CSegment* pParam) // Intra request From RTP to encoder
{ // This indication takes care of RTP indications - Pass to the ENCODER.

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipRtpSelfVideoUpdatePicReq - Conn Id = ",m_pCsRsrcDesc->GetConnectionId());

	APIU32 status = 0;
	ERoleLabel eRole = kRolePeople;
	BYTE bIsGradualIntra = FALSE;
	*pParam >> status;

	if (status == STATUS_FAIL) {

		CSipChannel* pChannel = m_pCall->GetChannel(true, cmCapVideo,cmCapTransmit);

		if (pChannel)
		{
			if (pChannel->GetMediaType() == cmCapVideo)
			{
				if(pChannel->GetConnectionState() == kConnected)
				{
					m_nRtpSelfIntraReq++;

					eRole = pChannel->GetRoleLabel();
					PTRACE(eLevelInfoNormal,"CSipCntl::OnSipRtpSelfVideoUpdatePicReq Outgoing channel, Ask VB for new intra");
					CSegment*  seg = new CSegment;
					*seg << (WORD)Fast_Update << (WORD)eRole << (WORD)1 << bIsGradualIntra;// Remote report on Intra

					m_pPartyApi->IpRmtH230(seg); // forward task to party manager
					POBJDELETE(seg);
				}
				else
					PTRACE(eLevelInfoNormal,"CCSipCntl::OnSipRtpSelfVideoUpdatePicReq, Channel is not in connected state.");
			}
		}
		else
		{
			PTRACE(eLevelError,"CSipCntl::OnSipRtpSelfVideoUpdatePicReq: No video out channel found");
		}
	} else
		PTRACE(eLevelError,"CSipCntl::OnSipRtpSelfVideoUpdatePicReq: status is OK, no need to send Fast_Update");

}// OnSipRtpSelfVideoUpdatePicReq

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetToAndFromTagsForRmtSdp(sipSdpAndHeadersSt& sdpAndHeaders)
{
	BYTE* pStart = NULL;
	sipMessageHeaders* pHeaders = NULL;

	if(m_bIsReInviteTransaction)
		return;

	if (sdpAndHeaders.sipHeadersLength)
		pHeaders = (sipMessageHeaders *)((BYTE *)(sdpAndHeaders.capsAndHeaders) + sdpAndHeaders.sipHeadersOffset);

	if(pHeaders && m_pParty)
	{
	  CSipHeaderList headerList(*pHeaders);
	  const CSipHeader* sipFromHeader = headerList.GetNextHeader(kFromTag);
	  const char* strFromTag = (sipFromHeader!=NULL)?sipFromHeader->GetHeaderStr():"";
	  const CSipHeader* sipToHeader = headerList.GetNextHeader(kToTag);
	  const char* strToTag 	 = (sipToHeader!=NULL)?sipToHeader->GetHeaderStr():"";

	  const  CSipHeader* sipCallIdHeader = headerList.GetNextHeader(kCallId);
	  const char* strCallId = (sipCallIdHeader!=NULL)?sipCallIdHeader->GetHeaderStr():"";
	  if(sipCallIdHeader==NULL)
		  TRACEINTO <<"CCSipCntl::SetToAndFromTagsForRmtSdp, dial out correlation sipCallIdHeader==NULL" ;
	  CCommConf* pCommConf 	= ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	  if (pCommConf)
	  {
	    CConfParty* pConfParty 	= pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());
		if( pConfParty )
		{

			pConfParty->SetToTag(strToTag);
			pConfParty->SetFromTag(strFromTag);
			TRACEINTO <<"CCSipCntl::SetToAndFromTagsForRmtSdp, dial out correlation strCallId= " << strCallId;
			//Send Info to CDR for SIP dial out
			if(strcmp(strCallId,"") != 0)
			{
				pConfParty->SetCorrelationId(std::string(strCallId));
				pCommConf->PartyCorrelationDataToCDR(pConfParty->GetName(), m_pParty->GetMonitorPartyId(), pConfParty->GetCorrelationId());
				TRACEINTO <<"CCSipCntl::SetToAndFromTagsForRmtSdp, dial out correlation = " << pConfParty->GetCorrelationId();
				CStructTm curTime;
				PASSERT(SystemGetTime(curTime));
				PlcmCdrEventCallStartExtendedHelper cdrEventCallStartExtendedHelper;
				cdrEventCallStartExtendedHelper.SetNewIsdnUndefinedParty_BasicAndContinue(*pConfParty, SIP_INTERFACE_TYPE, *pCommConf);
				pCommConf->SendCdrEvendToCdrManager((ApiBaseObjectPtr)&cdrEventCallStartExtendedHelper.GetCdrObject(), false, cdrEventCallStartExtendedHelper.GetCdrObject().m_partyDetails.m_id);

				//send event to cdr only here because only here we get the correlationID
				PlcmCdrEventConfUserDataUpdate ConfUserDataUpdateEvent;
				ConfUserDataUpdateEvent.m_userDefinedInformation.m_contactInfoList.m_contactInfo = pConfParty->GetUserDefinedInfo(0);
				ConfUserDataUpdateEvent.m_userDefinedInformation.m_contactInfoList.m_contactInfo2 = pConfParty->GetUserDefinedInfo(1);
				ConfUserDataUpdateEvent.m_userDefinedInformation.m_contactInfoList.m_contactInfo3 = pConfParty->GetUserDefinedInfo(2);
				ConfUserDataUpdateEvent.m_userDefinedInformation.m_contactInfoList.m_contactInfo4 = pConfParty->GetUserDefinedInfo(3);
				ConfUserDataUpdateEvent.m_userDefinedInformation.m_vip = false;
				pCommConf->SendCdrEvendToCdrManager((ApiBaseObjectPtr)&ConfUserDataUpdateEvent, false, pConfParty->GetPartyId());
			}
			char str[512];
			snprintf(str,512,"CSipCntl::SetToAndFromTagsForRmtSdp: FromTag: %s , ToTag: %s , callId: %s",strFromTag, strToTag, strCallId);
			PTRACE(eLevelError,str);

		}
	  }
	}
}
////////////////////////////////////////////////////////////////////
BOOL CSipCntl::EvaluateEncryptionForTypeNotSupported(const CCommConf* pCommConf, BYTE &fEncryption)
{
	const CCommConf* pEncryptionCommConf = NULL;

	if (pCommConf)
		pEncryptionCommConf = pCommConf;
	else if (m_pParty)
		pEncryptionCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());

	if (!pEncryptionCommConf) {
	    PTRACE(eLevelError,"CSipCntl::EvaluateEncryptionForTypeNotSupported failed");
	    return FALSE;
	}

	fEncryption = pEncryptionCommConf->GetIsEncryption();

	return TRUE;
}
////////////////////////////////////////////////////////////////////
void CSipCntl::SetMediaLinesInternalTypeNotSupported(BYTE fEncryption, sipMediaLineSt *pMediaLine1, sipMediaLineSt *pMediaLine2, BOOL &fFirstVideo, BOOL &fCleanLast, BOOL &fContinue)
{
	fFirstVideo = FALSE;
	fCleanLast = FALSE;
	fContinue = FALSE;
	BOOL fSetAudio = pMediaLine1->type == eMediaLineTypeAudio && pMediaLine2->type == eMediaLineTypeAudio;
	BOOL fSetVideo = pMediaLine1->type == eMediaLineTypeVideo && pMediaLine2->type == eMediaLineTypeVideo;
	BOOL fSetApplication = pMediaLine1->type == eMediaLineTypeApplication && pMediaLine2->type == eMediaLineTypeApplication;

	if (fSetAudio || fSetVideo || fSetApplication) {

		//Evaluate AvpSavp
		BOOL fAvpSavp = pMediaLine1->subType == eMediaLineSubTypeRtpAvp && pMediaLine2->subType == eMediaLineSubTypeRtpSavp;
		BOOL fSavpAvp = pMediaLine1->subType == eMediaLineSubTypeRtpSavp && pMediaLine2->subType == eMediaLineSubTypeRtpAvp;

		//Set TypeNotSupported
		if (fEncryption && fAvpSavp)
		{
			#ifdef LOGS_FOR_EXTRA_DEBUG
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SetMediaLinesInternalTypeNotSupported : Not Supported fEncryption && fAvpSavp",0);
			#endif

			fFirstVideo = (pMediaLine2->type == eMediaLineTypeVideo && pMediaLine1->internalType == kMediaLineInternalTypeVideo) ? TRUE : FALSE;
			pMediaLine1->internalType = kMediaLineInternalTypeNotSupported;
			fCleanLast = TRUE;
		}
		else if (fEncryption && fSavpAvp)
		{
			#ifdef LOGS_FOR_EXTRA_DEBUG
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SetMediaLinesInternalTypeNotSupported : Not Supported fEncryption && fSavpAvp",0);
			#endif

			pMediaLine2->internalType = kMediaLineInternalTypeNotSupported;
			fCleanLast = TRUE;
			fContinue = TRUE;
		}
		else if (!fEncryption && fAvpSavp)
		{
			#ifdef LOGS_FOR_EXTRA_DEBUG
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SetMediaLinesInternalTypeNotSupported : Not Supported !fEncryption && fAvpSavp",0);
			#endif

			pMediaLine2->internalType = kMediaLineInternalTypeNotSupported;
			fCleanLast = TRUE;
			fContinue = TRUE;
		}
		else if (!fEncryption && fSavpAvp)
		{
			#ifdef LOGS_FOR_EXTRA_DEBUG
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::SetMediaLinesInternalTypeNotSupported : Not Supported !fEncryption && fSavpAvp",0);
			#endif

			fFirstVideo = (pMediaLine2->type == eMediaLineTypeVideo && pMediaLine1->internalType == kMediaLineInternalTypeVideo) ? TRUE : FALSE;
			pMediaLine1->internalType = kMediaLineInternalTypeNotSupported;
			fCleanLast = TRUE;
		}
	}
}
////////////////////////////////////////////////////////////////////
void CSipCntl::SetMediaLinesInternalTypeForRmtSdp(sipSdpAndHeadersSt &sdp, const CCommConf* pCommConf) //modified for ANAT
{
	BYTE fEncryption = FALSE;
	BOOL fEvalNotSupported = EvaluateEncryptionForTypeNotSupported(pCommConf, fEncryption);
	BOOL	isANATContained = IsANATPresentInSDP((sipSdpAndHeadersSt*)&sdp); //added for ANAT

	if (sdp.sipMediaLinesLength)
	{
		if (!isANATContained)
		{
			const sipMediaLinesEntrySt* pMediaLinesEntry = (const sipMediaLinesEntrySt*) &sdp.capsAndHeaders[sdp.sipMediaLinesOffset];
			int mediaLinePos = 0;

			sipMediaLineSt *pLastMediaLine = NULL;
			sipMediaLineSt *pFirstVideoMediaLine = NULL;
			sipMediaLineSt *pContentVideoMediaLine = NULL;
			BOOL           isBFCP = FALSE;

			for (unsigned int j = 0; j < pMediaLinesEntry->numberOfMediaLines; j++)
			{
				sipMediaLineSt *pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
				eMediaLineType mediaLineType = (eMediaLineType)pMediaLine->type;

				mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;

				if( eMsft2013AvMCU != m_isMs2013Active )
				{
				if (fEvalNotSupported) 
					{
						BOOL fFirstVideo = FALSE;
						BOOL fCleanLast = FALSE;
						BOOL fContinue = FALSE;
						if (pLastMediaLine) {
							SetMediaLinesInternalTypeNotSupported(fEncryption, pLastMediaLine, pMediaLine, fFirstVideo, fCleanLast, fContinue);
							if (fFirstVideo)
								pFirstVideoMediaLine = NULL;
							if (fCleanLast)
								pLastMediaLine = NULL;
							else
								pLastMediaLine = pMediaLine;
							if (fContinue)
								continue;
						}
						else
							pLastMediaLine = pMediaLine;
					}
				}

				switch (mediaLineType)
				{
					case eMediaLineTypeAudio:
						pMediaLine->internalType = kMediaLineInternalTypeAudio;
						PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdp eMediaLineTypeAudio media line #", j);
						break;
					case eMediaLineTypeVideo:
						PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdp handling kMediaLineInternalTypeVideo media line #", j);
						if (pFirstVideoMediaLine == NULL) // it is the first video m line
						{
							pMediaLine->internalType = kMediaLineInternalTypeVideo;
							pFirstVideoMediaLine = pMediaLine;
							PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdp kMediaLineInternalTypeVideo media line #", j);
						}
					else // it is not the first m line
						{
						if(strstr(pMediaLine->label, "main-video"))//  added for Lync2013 avmcu
						{
							pMediaLine->internalType = kMediaLineInternalTypeVideo;
							PTRACE2INT(eLevelInfoNormal,"dbg CSipCntl::SetMediaLinesInternalTypeForRmtSdp kMediaLineInternalTypeVideo label = \"main-video\" media line #", j);
						}   else if(strstr(pMediaLine->label, "panoramic-video") )
						{
							pMediaLine->internalType = kMediaLineInternalTypeNotSupported;
							PTRACE2INT(eLevelInfoNormal,"dbg CSipCntl::SetMediaLinesInternalTypeForRmtSdp kMediaLineInternalTypeVideo label = \"panoramic-video\" media line #", j);
						} else if( m_isMs2013Active && eMsft2013AvMCU != m_isMs2013Active)
						{
							pMediaLine->internalType = kMediaLineInternalTypeNotSupported;
							PTRACE2INT(eLevelInfoNormal,"dbg CSipCntl::SetMediaLinesInternalTypeForRmtSdp kMediaLineInternalTypeVideo kMediaLineInternalTypeNotSupported media line #", j);
						} else //set video/content:
						{
							pMediaLine->internalType = kMediaLineInternalTypeContent;
							pContentVideoMediaLine = pMediaLine;

							eMediaLineContent contentType1 = (eMediaLineContent)pFirstVideoMediaLine->content;
							eMediaLineContent contentType2 = (eMediaLineContent)pMediaLine->content;


							if ((contentType1 >= eMediaLineContentSlides) && (contentType1 <= eMediaLineContentMain)
							 && (contentType2 >= eMediaLineContentSlides) && (contentType2 <= eMediaLineContentMain))
							{
								if (contentType1 < contentType2)
								{
									pFirstVideoMediaLine->internalType = kMediaLineInternalTypeContent;
									pMediaLine->internalType = kMediaLineInternalTypeVideo;
									PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdp kMediaLineInternalTypeVideo m-line #", j);
									pContentVideoMediaLine = pFirstVideoMediaLine;
								}
							}
							else if (contentType1 != eMediaLineContentNull)       //content attribute may be null for VNGR-24998
							{//Anna - content type (test against last sent SDP)
								eMediaLineInternalType localMediaLineType = ::GetMediaLineInternalType(m_pLocalSdp, j);

								if(localMediaLineType != kMediaLineInternalTypeContent)
								{
									pMediaLine->internalType = kMediaLineInternalTypeVideo;
									pContentVideoMediaLine = NULL; // no need to check BFCP
									PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdp kMediaLineInternalTypeVideo m-line #", j);
								}
							}
						}
						}
						break;
					case eMediaLineTypeApplication:

						if ((pMediaLine->subType == eMediaLineSubTypeTcpBfcp) || (pMediaLine->subType == eMediaLineSubTypeTcpTlsBfcp) || (pMediaLine->subType == eMediaLineSubTypeUdpBfcp))
						{
							pMediaLine->internalType = kMediaLineInternalTypeBfcp;
							isBFCP = TRUE;
							PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdp bfcp sub type:", pMediaLine->subType);
						}
						else
							pMediaLine->internalType = kMediaLineInternalTypeFecc;
						break;
					case eMediaLineTypeNotSupported:
						pMediaLine->internalType = kMediaLineInternalTypeNotSupported;
						break;
					default:
						DBGPASSERT(mediaLineType+100);
				}
			}

			//YossiG VNGR-25678/25688 fix for PanoramicCamera both lines are video
			// and the trans is without BFCP, the second m=video would be ingnored later
			// until we would support such SDP
			if ( (!isBFCP) && (pContentVideoMediaLine != NULL))
			{
				pContentVideoMediaLine->internalType = kMediaLineInternalTypeVideo;
				PTRACE(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdp no BFCP set pContentVideoMediaLine kMedSaLineInternalTypeVideo");
			}
		}
		else
			SetMediaLinesInternalTypeForRmtSdpForAnat(sdp); //added for ANAT
	}
	else
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdp: Media lines size is zero. Length of dynamic section: ", sdp.lenOfDynamicSection);
}
////////////////////////////////////////////////////////////////////
void CSipCntl::SetCapsRolesForRmtSdp(sipSdpAndHeadersSt &sdp, eMediaLineInternalType mlineIntType, ERoleLabel eRole)  //modified for ANAT
{
	sipMediaLineSt *pMediaLine = NULL;

	//added for ANAT
	int numberOfMLine = 0;
	BOOL isANATContained = IsANATPresentInSDP((sipSdpAndHeadersSt*)&sdp);
	pMediaLine = GetMediaLine(sdp, mlineIntType);

	while (pMediaLine)
	{
		numberOfMLine++;

		const capBuffer* pCapBuffer = (capBuffer*) &pMediaLine->caps[0];
		const BYTE*	pTemp = (const BYTE*)pCapBuffer;

		for (unsigned int i = 0 ; i < pMediaLine->numberOfCaps; i++)
		{
			((ctCapStruct*)pCapBuffer->dataCap)->roleLabel = eRole;
			pTemp += sizeof(capBufferBase) + pCapBuffer->capLength;
			pCapBuffer = (capBuffer*)pTemp;
		}

		//PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetCapsRolesForRmtSdp media line's role for anat ", eRole); //ANAT for debug

		if (numberOfMLine >= MAX_GROUP_ANAT_MEMBER_NUM )
			break;

		if (isANATContained) //added for ANAT
		{
			pMediaLine = GetMediaLine(sdp, mlineIntType, 1);
		} else if(eMsft2013AvMCU == m_isMs2013Active)
		{
			pMediaLine = GetMediaLine(sdp, mlineIntType, numberOfMLine);
		} else
			break;
	}
}
////////////////////////////////////////////////////////////////////
void CSipCntl::OrderMediaLinesWithPanoramic(sipSdpAndHeadersSt &sdp)
{
	sipMediaLinesEntrySt* pMediaLinesEntry = (sdp.sipMediaLinesLength) ? (sipMediaLinesEntrySt*)&sdp.capsAndHeaders[sdp.sipMediaLinesOffset] : NULL;

	if (pMediaLinesEntry && pMediaLinesEntry->lenOfDynamicSection && m_pRemoteSdp && m_pRemoteSdp->sipMediaLinesLength)
	{
		sipMediaLinesEntrySt* pRemoteMediaLinesEntry = (sipMediaLinesEntrySt*)&m_pRemoteSdp->capsAndHeaders[m_pRemoteSdp->sipMediaLinesOffset];
		unsigned int numOfMlines = pMediaLinesEntry->numberOfMediaLines;
		unsigned int remoteNumOfMlines = 0;
		if (pRemoteMediaLinesEntry)
			remoteNumOfMlines = pRemoteMediaLinesEntry->numberOfMediaLines;
		DWORD maxMediaLinesNumber = max(numOfMlines, remoteNumOfMlines);
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OrderMediaLinesWithPanoramic : numOfMlines=", numOfMlines);
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::OrderMediaLinesWithPanoramic : remoteNumOfMlines=", remoteNumOfMlines);
		if (numOfMlines > 0 )
		{
			eMediaLineInternalType givenMediaLines[maxMediaLinesNumber];
			eMediaLineInternalType remoteMediaLines[maxMediaLinesNumber];
			for (unsigned int i = 0; i < maxMediaLinesNumber; i++)
			{
				givenMediaLines[i] = ::GetMediaLineInternalType(&sdp, i);
				remoteMediaLines[i] = ::GetMediaLineInternalType(m_pRemoteSdp, i);
				//PTRACE2INT(eLevelInfoNormal, "CSipCntl::OrderMediaLines : givenMediaLines[i]=", givenMediaLines[i]);
				//PTRACE2INT(eLevelInfoNormal, "CSipCntl::OrderMediaLines : remoteMediaLines[i]=", remoteMediaLines[i]);
			}

			BYTE* pNewMediaLinesBuffer = new BYTE[pMediaLinesEntry->lenOfDynamicSection];

			unsigned int destPos = 0;
			unsigned int newIndex = 0;
			unsigned int notSupportedMediaCounter = 0;

			unsigned int videoMediaCounter = 0;
			// copy mlines that exist in the remoteMediaLines array:
			for (unsigned int i = 0; i < maxMediaLinesNumber; i++)
			{
				sipMediaLineSt* pCurrentMediaLine = NULL;

				if (remoteMediaLines[i] == kMediaLineInternalTypeNotSupported) {
					pCurrentMediaLine = GetMediaLine(sdp, remoteMediaLines[i], notSupportedMediaCounter);
					notSupportedMediaCounter++;
				}else if(remoteMediaLines[i] == kMediaLineInternalTypeVideo)
				{
					pCurrentMediaLine = GetMediaLine(sdp, remoteMediaLines[i], videoMediaCounter);
					videoMediaCounter ++;
				}
				else
					pCurrentMediaLine = GetMediaLine(sdp, remoteMediaLines[i]);
				//PTRACE2INT(eLevelInfoNormal, "CSipCntl::OrderMediaLinesWithPanoramic : i=", i);
				if (pCurrentMediaLine && (givenMediaLines[pCurrentMediaLine->index] != kMediaLineInternalTypeNone))
				{
					// should enter here for each mline
					//PTRACE2INT(eLevelInfoNormal, "CSipCntl::OrderMediaLinesWithPanoramic : givenMediaLines[pCurrentMediaLine->index]=", givenMediaLines[pCurrentMediaLine->index]);
					unsigned int copySize = sizeof(sipMediaLineBaseSt) + pCurrentMediaLine->lenOfDynamicSection;
					memcpy(&pNewMediaLinesBuffer[destPos], pCurrentMediaLine, copySize);
					((sipMediaLineSt*)&pNewMediaLinesBuffer[destPos])->index = newIndex;
					destPos += copySize;
					newIndex++;
					givenMediaLines[pCurrentMediaLine->index] = kMediaLineInternalTypeNone; // mark it as copied.
				}
			}
			// copy mlines that still were not copied:
			for (unsigned int i = 0; i < numOfMlines; i++)
			{
				if (givenMediaLines[i] != kMediaLineInternalTypeNone)
				{
					sipMediaLineSt* pCurrentMediaLine = GetMediaLine(sdp, givenMediaLines[i]);
					if (pCurrentMediaLine)
					{
						unsigned int copySize = sizeof(sipMediaLineBaseSt) + pCurrentMediaLine->lenOfDynamicSection;
						memcpy(&pNewMediaLinesBuffer[destPos], pCurrentMediaLine, copySize);
						((sipMediaLineSt*)&pNewMediaLinesBuffer[destPos])->index = newIndex;
						destPos += copySize;
						newIndex++;
					}
				}
			}

			//PTRACE2INT(eLevelInfoNormal, "CSipCntl::OrderMediaLinesWithPanoramic : destPos = ", destPos);
			//PTRACE2INT(eLevelInfoNormal, "CSipCntl::OrderMediaLinesWithPanoramic : pMediaLinesEntry->lenOfDynamicSection =", pMediaLinesEntry->lenOfDynamicSection);

			if (destPos == pMediaLinesEntry->lenOfDynamicSection) // destination position should be equal to lenOfDynamicSection
				memcpy(pMediaLinesEntry->mediaLines, pNewMediaLinesBuffer, pMediaLinesEntry->lenOfDynamicSection); // copy the new order to the original structure.
			else
				DBGPASSERT(YES);

			delete[] pNewMediaLinesBuffer;
		}
	}
}

////////////////////////////////////////////////////////////////////
void CSipCntl::OrderMediaLinesByPlcmRequireTags(sipSdpAndHeadersSt &sdp)
{
	sipMediaLinesEntrySt* pMediaLinesEntry = (sdp.sipMediaLinesLength) ? (sipMediaLinesEntrySt*)&sdp.capsAndHeaders[sdp.sipMediaLinesOffset] : NULL;

	if (pMediaLinesEntry && pMediaLinesEntry->lenOfDynamicSection)
	{

		unsigned int numOfMlines = pMediaLinesEntry->numberOfMediaLines;

		if (numOfMlines > 0 )
		{
			eMediaLineInternalType givenMediaLines[numOfMlines];
			eMediaLineInternalType remoteMediaLines[numOfMlines];
			for (unsigned int i = 0; i < numOfMlines; i++)
			{
				givenMediaLines[i] = ::GetMediaLineInternalType(&sdp, i);
			}

			BYTE* pNewMediaLinesBuffer = new BYTE[pMediaLinesEntry->lenOfDynamicSection];

			unsigned int destPos = 0;
			unsigned int newIndex = 0;
			unsigned int notSupportedMediaCounter = 0;
			// copy mlines that exist in the remoteMediaLines array:
			for (unsigned int i = 0; i < numOfMlines; i++)
			{
				sipMediaLineSt* pCurrentMediaLine = NULL;


				pCurrentMediaLine = GetMediaLine(sdp, GetPlcmReqMaskMlineAtIndex(i));

				if (pCurrentMediaLine && (givenMediaLines[pCurrentMediaLine->index] != kMediaLineInternalTypeNone))
				{
					unsigned int copySize = sizeof(sipMediaLineBaseSt) + pCurrentMediaLine->lenOfDynamicSection;
					memcpy(&pNewMediaLinesBuffer[destPos], pCurrentMediaLine, copySize);
					((sipMediaLineSt*)&pNewMediaLinesBuffer[destPos])->index = newIndex;
					destPos += copySize;
					newIndex++;
					givenMediaLines[pCurrentMediaLine->index] = kMediaLineInternalTypeNone; // mark it as copied.
				}
			}
			// copy mlines that still were not copied:
			for (unsigned int i = 0; i < numOfMlines; i++)
			{
				if (givenMediaLines[i] != kMediaLineInternalTypeNone)
				{
					sipMediaLineSt* pCurrentMediaLine = GetMediaLine(sdp, givenMediaLines[i]);
					if (pCurrentMediaLine)
					{
						unsigned int copySize = sizeof(sipMediaLineBaseSt) + pCurrentMediaLine->lenOfDynamicSection;
						memcpy(&pNewMediaLinesBuffer[destPos], pCurrentMediaLine, copySize);
						((sipMediaLineSt*)&pNewMediaLinesBuffer[destPos])->index = newIndex;
						destPos += copySize;
						newIndex++;
					}
				}
			}

			if (destPos == pMediaLinesEntry->lenOfDynamicSection) // destination position should be equal to lenOfDynamicSection
				memcpy(pMediaLinesEntry->mediaLines, pNewMediaLinesBuffer, pMediaLinesEntry->lenOfDynamicSection); // copy the new order to the original structure.
			else
				DBGPASSERT(YES);

			delete[] pNewMediaLinesBuffer;
		}
	}
}

////////////////////////////////////////////////////////////////////
void CSipCntl::OrderMediaLines(sipSdpAndHeadersSt &sdp)
{
	sipMediaLinesEntrySt* pMediaLinesEntry = (sdp.sipMediaLinesLength) ? (sipMediaLinesEntrySt*)&sdp.capsAndHeaders[sdp.sipMediaLinesOffset] : NULL;

	if (pMediaLinesEntry && pMediaLinesEntry->lenOfDynamicSection && m_pRemoteSdp && m_pRemoteSdp->sipMediaLinesLength)
	{
		sipMediaLinesEntrySt* pRemoteMediaLinesEntry = (sipMediaLinesEntrySt*)&m_pRemoteSdp->capsAndHeaders[m_pRemoteSdp->sipMediaLinesOffset];
		unsigned int numOfMlines = pMediaLinesEntry->numberOfMediaLines;
		unsigned int remoteNumOfMlines = 0;
		if (pRemoteMediaLinesEntry)
			remoteNumOfMlines = pRemoteMediaLinesEntry->numberOfMediaLines;
		PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : remoteNumOfMlines = ", remoteNumOfMlines);
		PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : numOfMlines = ", numOfMlines);
		DWORD maxMediaLinesNumber = max(numOfMlines, remoteNumOfMlines);

		if (numOfMlines > 0 )
		{
			eMediaLineInternalType givenMediaLines[maxMediaLinesNumber];
			eMediaLineInternalType remoteMediaLines[maxMediaLinesNumber];
			for (unsigned int i = 0; i < maxMediaLinesNumber; i++)
			{
				givenMediaLines[i] = ::GetMediaLineInternalType(&sdp, i);
				remoteMediaLines[i] = ::GetMediaLineInternalType(m_pRemoteSdp, i);
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : givenMediaLines[i] = ", givenMediaLines[i]);
				PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : remoteMediaLines[i] = ", remoteMediaLines[i]);
			}

			BYTE* pNewMediaLinesBuffer = new BYTE[pMediaLinesEntry->lenOfDynamicSection];

			unsigned int destPos = 0;
			unsigned int newIndex = 0;
			unsigned int notSupportedMediaCounter = 0;
			// copy mlines that exist in the remoteMediaLines array:
			for (unsigned int i = 0; i < maxMediaLinesNumber; i++)
			{
				sipMediaLineSt* pCurrentMediaLine = NULL;

				#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : Value of i = ", i);
				#endif

				if (remoteMediaLines[i] == kMediaLineInternalTypeNotSupported)
				{
					#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : Not Supported remoteMediaLines[i] = ", remoteMediaLines[i]);
					#endif
					pCurrentMediaLine = GetMediaLine(sdp, remoteMediaLines[i], notSupportedMediaCounter);
					notSupportedMediaCounter++;
				}
				else
				{
					pCurrentMediaLine = GetMediaLine(sdp, remoteMediaLines[i]);

					#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : Supported remoteMediaLines[i] = ", remoteMediaLines[i]);
					#endif
				}

				if (pCurrentMediaLine && (givenMediaLines[pCurrentMediaLine->index] != kMediaLineInternalTypeNone))
				{
					#ifdef LOGS_FOR_EXTRA_DEBUG
					PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : Copy pCurrentMediaLine->index = ", pCurrentMediaLine->index);
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : Copy givenMediaLines[ pCurrentMediaLine->index] = ", givenMediaLines[pCurrentMediaLine->index]);
					#endif

					unsigned int copySize = sizeof(sipMediaLineBaseSt) + pCurrentMediaLine->lenOfDynamicSection;
					memcpy(&pNewMediaLinesBuffer[destPos], pCurrentMediaLine, copySize);
					((sipMediaLineSt*)&pNewMediaLinesBuffer[destPos])->index = newIndex;

					#ifdef LOGS_FOR_EXTRA_DEBUG
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : Copy pCurrentMediaLine->index = ", pCurrentMediaLine->index);
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : Copy givenMediaLines[pCurrentMediaLine->index] = ", givenMediaLines[pCurrentMediaLine->index]);
						PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : New Intex", newIndex);
					#endif

					destPos += copySize;
					newIndex++;
					givenMediaLines[pCurrentMediaLine->index] = kMediaLineInternalTypeNone; // mark it as copied.
				}
			}
			// copy mlines that still were not copied:
			for (unsigned int i = 0; i < numOfMlines; i++)
			{
				if (givenMediaLines[i] != kMediaLineInternalTypeNone)
				{
					sipMediaLineSt* pCurrentMediaLine = GetMediaLine(sdp, givenMediaLines[i]);
					if (pCurrentMediaLine)
					{

						#ifdef LOGS_FOR_EXTRA_DEBUG
							PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : Special Copy Media Line = ", i);
						#endif

						unsigned int copySize = sizeof(sipMediaLineBaseSt) + pCurrentMediaLine->lenOfDynamicSection;
						memcpy(&pNewMediaLinesBuffer[destPos], pCurrentMediaLine, copySize);
						((sipMediaLineSt*)&pNewMediaLinesBuffer[destPos])->index = newIndex;
						destPos += copySize;
						newIndex++;
					}
					else
					{
						#ifdef LOGS_FOR_EXTRA_DEBUG
							PTRACE2INT(eLevelInfoNormal, "dbg CSipCntl::OrderMediaLines : Could not get Media line for = ", i);
						#endif
					}
				}
			}

			if (destPos == pMediaLinesEntry->lenOfDynamicSection) // destination position should be equal to lenOfDynamicSection
				memcpy(pMediaLinesEntry->mediaLines, pNewMediaLinesBuffer, pMediaLinesEntry->lenOfDynamicSection); // copy the new order to the original structure.
			else
				DBGPASSERT(YES);

			delete[] pNewMediaLinesBuffer;
		}
	}
}
////////////////////////////////////////////////////////////////////
//  should be changed to return exact copied size
void CSipCntl::AddNotSupportedMediaLines(int numberOfNotSupported, sipMediaLinesEntrySt* pMediaLinesEntry) const
{
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::AddNotSupportedMediaLines : numberOfNotSupported=", numberOfNotSupported);
	sipMediaLineSt *pMediaLine = NULL;
	unsigned int mediaLinePos = 0;
	int curIndex = 0;

	// Go the the last local m-line:
	for (unsigned int i = 0; i < pMediaLinesEntry->numberOfMediaLines; i++)
	{
		pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
		mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;
	}

	for (int i=0;i<numberOfNotSupported;i++)
	{
		sipMediaLineSt* pNewMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
		sipMediaLineSt* pRemoteMediaLine = GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeNotSupported, i);
		if (pRemoteMediaLine)
		{
			unsigned int copySize = sizeof(sipMediaLineBaseSt) + pRemoteMediaLine->lenOfDynamicSection;
			memcpy((void*)pNewMediaLine, (void*)pRemoteMediaLine, copySize);
			pNewMediaLine->index = pMediaLinesEntry->numberOfMediaLines;
			pNewMediaLine->mediaIp.transAddr.port = 0;

			pMediaLinesEntry->numberOfMediaLines ++;
			pMediaLinesEntry->lenOfDynamicSection += copySize;
			mediaLinePos += copySize;
		}
		else
			DBGPASSERT(YES);
	}
	return;
}
////////////////////////////////////////////////////////////////////
//  should be changed to return exact copied size
void CSipCntl::AddPanoramicMediaLines(int numberOfVideoMLines, sipMediaLinesEntrySt* pMediaLinesEntry) const
{
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::AddPanoramicMediaLines : numberOfVideoMLines=", numberOfVideoMLines);

	sipMediaLineSt *pMediaLine = NULL;
	sipMediaLineSt *pLocalVideoMediaLine = NULL;
	unsigned int mediaLinePos = 0;
	int curIndex = 0;
	// Go the the last local m-line:
	for (unsigned int i = 0; i < pMediaLinesEntry->numberOfMediaLines; i++)
	{
		pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
		mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;

		if(!pLocalVideoMediaLine && pMediaLine->internalType == kMediaLineInternalTypeVideo)
			pLocalVideoMediaLine = pMediaLine;
	}

	for (int i=0;i<numberOfVideoMLines;i++)
	{
		sipMediaLineSt* pNewMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
		sipMediaLineSt* pRemoteMediaLine = GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeVideo, i);
		if (pLocalVideoMediaLine && pRemoteMediaLine && IsPanoramicVideoMediaLine(pRemoteMediaLine))
		{

			unsigned int copySize = sizeof(sipMediaLineBaseSt) + pLocalVideoMediaLine->lenOfDynamicSection;
			memcpy((void*)pNewMediaLine, (void*)pLocalVideoMediaLine, copySize);

			pNewMediaLine->index = pMediaLinesEntry->numberOfMediaLines;
			pNewMediaLine->mediaIp.transAddr.port = 0;
			memset(pNewMediaLine->label, '\0', MAX_LABEL_LENGTH);
			strncpy(pNewMediaLine->label, "panoramic-video", MAX_LABEL_LENGTH);


			pMediaLinesEntry->numberOfMediaLines ++;
			pMediaLinesEntry->lenOfDynamicSection += copySize;
			mediaLinePos += copySize;
		}
		else if(! pRemoteMediaLine)
			DBGPASSERT(YES);
		else if(! pLocalVideoMediaLine)
			DBGPASSERT(YES);

	}
	return;
}
//////////////////////////////////////////////////////////////////
void CSipCntl::OnCmBfcpTcpTransportInd(CSegment *pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnCmBfcpTcpTransportInd");

	mcIndBfcpTransport msg;
	memset(&msg, 0, sizeof(mcIndBfcpTransport));
	pParam->Get((BYTE*)&msg, sizeof(mcIndBfcpTransport));
	DWORD status = msg.status;

	if (status == bfcp_msg_status_connected)
	{
		m_pParty->SetBfcpConnected(TRUE);
	}
	else
	{
		m_pParty->SetBfcpConnected(FALSE);
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnCmBfcpTcpTransportInd IS NOT CONNECTED status = ",status);
		m_pPartyApi->BfcpStartReestablishConnection();
	}
}

////////////////////////////////////////////////////////////////////////////
void  CSipCntl::SendBfcpMessageReq(DWORD opcode, BYTE mcuId, BYTE terminalId)
{
	if (IsValidPObjectPtr(m_pSipBfcpCtrl))
	{
		CSegment*  pSeg = new CSegment;
		*pSeg << (DWORD) opcode;
		*pSeg << (BYTE) mcuId;
		*pSeg << (BYTE) terminalId;

		m_pSipBfcpCtrl->DispatchEvent(IP_CM_BFCP_MESSAGE_REQ, pSeg);

		POBJDELETE(pSeg);
	}

	// in case that remote closed bfcp connection and sent goodbye we response with goodbye ack
	if (opcode == CONTENT_ROLE_BFCP_GOODBYE_ACK)
	{
		SipCloseChannelReq(BFCP_IN);
		SipCloseChannelReq(BFCP_OUT);
	}

	//m_pSipBfcpCtrl->SendBfcpMessageReq(opcode, mcuId, terminalId);

//        BFCPH239Translator translator;
//	if (statusOK != InitializeTranslatorDefaults(&translator, atoi(BFCP_FLOOR_ID_PPC), kBFCPPriorityNormal,
//                                                 mcuId, terminalId, kBFCPFloorCtrlServer))
//		return;
//
//	BFCPFloorInfoT  pBFCPmsg;
//	memset(&pBFCPmsg,0,sizeof(BFCPFloorInfoT));
//	UInt32 pMsgLen;
//	UInt8 pOutBinaryBFCPMsg[256];
//	memset(pOutBinaryBFCPMsg,0,256);
//	CMedString str;
//
//	if( opcode == CONTENT_ROLE_BFCP_HELLO )
//	   CreateBFCPHello (&translator, pOutBinaryBFCPMsg, &pMsgLen );
//	else if (opcode == CONTENT_ROLE_BFCP_HELLO_ACK )
//	   CreateBFCPHelloAck(&translator, pOutBinaryBFCPMsg, &pMsgLen );
//
//	else
//	{
//	   SipReqToBFCP (&translator, opcode, &pBFCPmsg, m_lastFloorRequestID++);
//
//	   str << "\nTransactionType = " ;
//	   ::GetBFCPTransactionType(pBFCPmsg.transactionType, str);
//	   str << "\n";
//	   str << "FloorId         = " << pBFCPmsg.floorID << "\n";
//	   str << "conferenceID    = " << pBFCPmsg.conferenceID << "\n" ;
//	   str << "userID          = " << pBFCPmsg.userID << "\n" ;
//	   str << "transactionID   = " << pBFCPmsg.transactionID << "\n" ;
//	   str << "floorRequestID  = " << pBFCPmsg.floorRequestID << "\n" ;
//	   str << "floorStatus     = " << pBFCPmsg.floorStatus << "\n" ;
//	   str << "priority        = " << pBFCPmsg.priority << "\n" ;
//	   PTRACE2(eLevelInfoNormal, "CSipCntl::SendBfcpMessageReq- ", str.GetString());
//
//	   str.Clear();
//
//	   EncodeBFCPMsg (&translator, &pBFCPmsg, &pMsgLen, pOutBinaryBFCPMsg);
//	}
//	char s[16];
//	for(int i=0; i<(int)pMsgLen || i<56; i++)
//	{
//	   sprintf(s, "0x%x", pOutBinaryBFCPMsg[i]);
//	   str << s << " ";
//	}
//
//	str << "\n Message length is " << pMsgLen;
//	PTRACE2(eLevelInfoNormal, "CSipCntl::SendBfcpMessageReq- encoded message ", str.GetString());
//
//	size_t size = sizeof(mcReqBfcpMessage) + pMsgLen;
//        mcReqBfcpMessage *reqBFCPMsg = (mcReqBfcpMessage*)new BYTE[size]; ;
//
//	reqBFCPMsg->status = STATUS_OK;
//	reqBFCPMsg->length = pMsgLen;
//	memcpy( &reqBFCPMsg->buffer[0],  pOutBinaryBFCPMsg, pMsgLen);
//	SendSIPMsgToCS(SIP_CS_BFCP_MESSAGE_REQ, reqBFCPMsg, size);
//	PDELETEA(reqBFCPMsg);
}

////////////////////////////////////////////////////////////////////
char* CSipCntl::GetRemoteStreamLabel(ERoleLabel eRole) const
{
	char* pRetLabel = NULL;
	if (m_pRemoteSdp)
	{
		sipMediaLineSt *pMediaLine = NULL;

		//add for ANAT
		if (m_AnatSelectedIpVersion != enIpVersionMAX)
		{
			if (eRole == kRolePeople)
				pMediaLine = GetMLineAccordingToInternalTypeAndIpVersion(kMediaLineInternalTypeVideo, m_pRemoteSdp, m_AnatSelectedIpVersion);
			else
				pMediaLine = GetMLineAccordingToInternalTypeAndIpVersion(kMediaLineInternalTypeContent, m_pRemoteSdp, m_AnatSelectedIpVersion);
		}
		else
		{
			if (eRole == kRolePeople)
				pMediaLine = ::GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeVideo);
			else
				pMediaLine = ::GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeContent);
		}

		if (pMediaLine)
			pRetLabel = pMediaLine->label;
	}

	return pRetLabel;
}
////////////////////////////////////////////////////////////////////
char* CSipCntl::GetLocalStreamLabel(ERoleLabel eRole) const
{
	if (eRole == kRolePeople)
		return STREAM_LABEL_VIDEO;
	return STREAM_LABEL_CONTENT;
}
////////////////////////////////////////////////////////////////////
void CSipCntl::SetFloorParamsInLocalCaps()
{
	m_pChosenLocalCap->SetFloorIdParamsForBfcp(BFCP_FLOOR_ID_PPC, STREAM_LABEL_CONTENT);
}
////////////////////////////////////////////////////////////////////
void CSipCntl::SetLabelsAndContentAttributesInLocalSdp(sipSdpAndHeadersSt &sdp)
{
	sipMediaLineSt* pVideoMline = ::GetMediaLine(sdp, kMediaLineInternalTypeVideo);
	sipMediaLineSt* pContentMline = ::GetMediaLine(sdp, kMediaLineInternalTypeContent);

	if (pVideoMline && pContentMline)
	{
		// content attributes:
		pVideoMline->content = eMediaLineContentMain;
		pContentMline->content = eMediaLineContentSlides;

		// labels:
		strncpy(pVideoMline->label, STREAM_LABEL_VIDEO, MAX_LABEL_LENGTH);
		pVideoMline->label[MAX_LABEL_LENGTH-1] = '\0';
		strncpy(pContentMline->label, STREAM_LABEL_CONTENT, MAX_LABEL_LENGTH);
		pContentMline->label[MAX_LABEL_LENGTH-1] = '\0';
	}
}


////////////////////////////////////////////////////////////////////////////////////////
// sets ssrc range, stream label, rtcp-size attributes in case of Lync2013 sdp
void CSipCntl::SetLync2013SpecificMLinesAttributes(sipSdpAndHeadersSt &sdp)
{
	PTRACE(eLevelInfoNormal, "DBG CSipCntl::SetLync2013SpecificAttributes");

		sipMediaLineSt *pMediaLine = NULL;
		unsigned int mediaLinePos = 0;
		int curIndex = 0;
		sipMediaLinesEntrySt* pMediaLinesEntry = (sipMediaLinesEntrySt*)sdp.capsAndHeaders;
		unsigned int numOfMlines = pMediaLinesEntry->numberOfMediaLines;

		DWORD videoLineNum = 0;

		for (unsigned int mlineIndex = 0; mlineIndex < numOfMlines; mlineIndex++)
		{
			pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
			mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;
			eMediaLineType mediaLineType = (eMediaLineType)pMediaLine->type;

			// set rtcp-size
			pMediaLine->rtcp_rsize = 1;

			if(mediaLineType == eMediaLineTypeAudio)
			{
				// set label
				memset(pMediaLine->label, '\0', MAX_LABEL_LENGTH);
				strcpy(pMediaLine->label, "main-audio");

				// set ssrc range
				pMediaLine->ssrcrange[0] = pMediaLine->ssrcrange[1] = m_pChosenLocalCap->getMsftSsrcAudio();

			} else if (mediaLineType == eMediaLineTypeVideo && pMediaLine->internalType == kMediaLineInternalTypeVideo )
			{
				videoLineNum ++;

				// set label
				memset(pMediaLine->label, '\0', MAX_LABEL_LENGTH);
				strcpy(pMediaLine->label, "main-video");

				// set ssrc range
				pMediaLine->ssrcrange[0] = m_pChosenLocalCap->getMsftSsrcVideoFirst(videoLineNum);
				pMediaLine->ssrcrange[1] = m_pChosenLocalCap->getMsftSsrcVideoLast(videoLineNum);

			} else if ( mediaLineType == eMediaLineTypeVideo && pMediaLine->internalType == kMediaLineInternalTypeNotSupported ){
				pMediaLine->rtcp_rsize = 0;
				pMediaLine->rtcpPort = 0; // bridge-8307
				pMediaLine->ssrcrange[0] = pMediaLine->ssrcrange[1] = 0;
				PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetLync2013SpecificMLinesAttributes not supported media line #", mlineIndex);

			} else
			{
				pMediaLine->ssrcrange[0] = pMediaLine->ssrcrange[1] = 0;
				PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetLync2013SpecificMLinesAttributes not video and not audio media line media line #", mlineIndex);
			}
		}

  return;
}
////////////////////////////////////////////////////////////////////////////////////////
void  CSipCntl::UpdatePresentationOutStream()
{
	PTRACE2(eLevelInfoNormal,"CSipCntl::UpdatePresentationOutStream  Name - ",PARTYNAME);

	// No need to send updatePortOpenRtp - will be send when channel is open.
	if(m_eContentOutState == eNoChannel)
		m_eContentOutState = eWaitToSendStreamOn;

	// updatePortOpenRtp was already sent once with stream off, now we send it again with StreamOn.
	if(m_eContentOutState == eStreamOff)
	{
			m_eContentOutState = eWaitToSendStreamOn;
			CSipChannel* pChannel = m_pCall->GetChannel(VIDEO_CONT_OUT);
			if(pChannel)
			{
            	kChanneltype channelType = ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel());
            	if(!m_bIsMrcCall || (channelType == kIpContentChnlType))
				{
					Rtp_FillAndSendUpdatePortOpenRtpStruct(pChannel);
				}
			}
			else
				PASSERTMSG(1, "GetChannel return NULL");
	}
	else
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::UpdatePresentationOutStream", m_eContentOutState);
}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendContentOnOffReqToRtp()
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendContentOnOffReqToRtp - Stream state = ",(APIU32)m_eContentInState);

	DWORD 	dwOpcode	= 0;
	APIU32	bunIsOnOff	= 0;

	if (m_eContentInState == eSendStreamOn)
	{
		bunIsOnOff = 1;
		dwOpcode = ART_CONTENT_ON_REQ;
	}
	else if (m_eContentInState == eSendStreamOff)
	{
		bunIsOnOff = 0;
		dwOpcode = ART_CONTENT_OFF_REQ;
	}
	else
	{
		PASSERTMSG((DWORD)m_eContentInState,"CSipCntl::SendContentOnOffReqToRtp - Wrong status");
		return;
	}

	TContentOnOffReq* pStruct = new TContentOnOffReq;
	pStruct->unChannelDirection = cmCapReceive;
	pStruct->bunIsOnOff = bunIsOnOff;
	SendMsgToMpl((BYTE*)(pStruct), sizeof(TContentOnOffReq), dwOpcode);
	PDELETE(pStruct);
}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendEvacuateReqForRtpOnH239Stream()
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendEvacuateReqForRtpOnH239Stream - Con Id ",m_pCsRsrcDesc->GetConnectionId());

	TEvacuateReq* pStruct = new TEvacuateReq;

	pStruct->unChannelType = (DWORD)kIpContentChnlType;
	pStruct->unChannelDirection = cmCapReceive;

	SendMsgToMpl((BYTE*)(pStruct), sizeof(TEvacuateReq), ART_EVACUATE_REQ);
	PDELETE(pStruct);
}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::HandleContentOnOffAck(ACK_IND_S* pAckIndStruct)
{
	eContentState eTempContentInState = m_eContentInState;
	if (pAckIndStruct->ack_base.status == STATUS_OK)
	{
		TRACEINTO << "CSipCntl::HandleContentOnOffAck : ART_CONTENT_ON_REQ/ART_CONTENT_OFF_REQ - status is ok -  Media Type = " << pAckIndStruct->media_type <<
									", Direction = " << pAckIndStruct->media_direction << ", ConnId = " << GetHWInterface(pAckIndStruct->ack_base.ack_opcode,FALSE)->GetConnectionId();

		// Here we will update the stream state accordingly and send a message to the party saying the the ack was received
		if (pAckIndStruct->media_direction == cmCapReceive)
		{
			if (m_eContentInState != eNoChannel)
			{
				if (pAckIndStruct->ack_base.ack_opcode == ART_CONTENT_ON_REQ)
					m_eContentInState = eStreamOn;
				else
					m_eContentInState = eStreamOff;
			}
			if (pAckIndStruct->ack_base.ack_opcode == ART_CONTENT_ON_REQ)
			{
				/* Avaya AVA-1303 P0 content problem. initiate INTRA for content  */
				//FastUpdateReq(kRoleContentOrPresentation, eTipVideoPosCenter);
				CSegment *pParam = new CSegment;
				*pParam << (DWORD)kRoleContentOrPresentation;
				*pParam << (DWORD)eTipVideoPosCenter;
				SendFastUpdateReq(pParam);
				POBJDELETE(pParam);
				TRACEINTO << "CSipCntl::HandleContentOnOffAck : ART_CONTENT_ON_REQ - m_eContentInState = " << m_eContentInState;
			}
			else
				TRACEINTO << "CSipCntl::HandleContentOnOffAck : ART_CONTENT_OFF_REQ - m_eContentInState = " << m_eContentInState;
		}
		else
			PASSERTMSG(pAckIndStruct->media_direction, "CSipCntl::HandleContentOnOffAck : ART_CONTENT_ON_REQ/ART_CONTENT_OFF_REQ - Wrong direction");

	}
	else
	{
		TRACEINTO << "CSipCntl::HandleContentOnOffAck : ART_CONTENT_ON_REQ/ART_CONTENT_OFF_REQ - status is NOT ok -  Media Type = " << pAckIndStruct->media_type <<
									", Direction = " << pAckIndStruct->media_direction << ", ConnId = " << GetHWInterface(pAckIndStruct->ack_base.ack_opcode,FALSE)->GetConnectionId();
		DBGPASSERT(GetHWInterface(pAckIndStruct->ack_base.ack_opcode,FALSE)->GetConnectionId());
	}

	m_pPartyApi->SendContentOnOffAck(pAckIndStruct->ack_base.status, m_eContentInState);
}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::HandleRtpEvacuateAck(ACK_IND_S* pAckIndStruct)
{
	if (pAckIndStruct->ack_base.status == STATUS_OK)
	{
		TRACEINTO << "CSipCntl::HandleRtpEvacuateAck : ART_EVACUATE_REQ - status is ok -  Media Type = " << pAckIndStruct->media_type <<
									", Direction = " << pAckIndStruct->media_direction << ", ConnId = " << GetHWInterface(pAckIndStruct->ack_base.ack_opcode,FALSE)->GetConnectionId();
	}
	else
	{
		TRACEINTO << "CSipCntl::HandleRtpEvacuateAck : ART_EVACUATE_REQ - status is NOT ok -  Media Type = " << pAckIndStruct->media_type <<
									", Direction = " << pAckIndStruct->media_direction << ", ConnId = " << GetHWInterface(pAckIndStruct->ack_base.ack_opcode,FALSE)->GetConnectionId();
		DBGPASSERT(GetHWInterface(pAckIndStruct->ack_base.ack_opcode,FALSE)->GetConnectionId());
	}
	if (m_eContentInState == eStreamOff || m_eContentInState == eSendStreamOff)
		m_pPartyApi->SendContentEvacuateAck(pAckIndStruct->ack_base.status);
}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::RemoveCapSet(const CCapSetInfo& capInfo, ERoleLabel eRole)
{
	if (m_pChosenLocalCap)
		m_pChosenLocalCap->RemoveCapSet(capInfo, eRole);

	//CLargeString str;
	//m_pChosenLocalCap->DumpToString(str);
	//PTRACE2(eLevelInfoNormal,"CSipCntl::RemoveCapSet m_pChosenLocalCap:",str.GetString());

}
////////////////////////////////////////////////////////////////////
void CSipCntl::SetRateForLocalSdp(sipSdpAndHeadersSt &sdp, eMediaLineInternalType sipMediaLineIntType, DWORD bitRate, int mediaCap)
{
	sipMediaLineSt *pMediaLine = NULL;
	pMediaLine = GetMediaLine(sdp, sipMediaLineIntType);
	if (pMediaLine)
	{
		capBuffer* pCapBuffer = (capBuffer*) &pMediaLine->caps[0];
		const BYTE*	pTemp = (const BYTE*)pCapBuffer;

		for (unsigned int i = 0 ; i < pMediaLine->numberOfCaps; i++)  //according to media line type(sipMediaLineIntType)
		{
			CCapSetInfo capInfo = (CapEnum) pCapBuffer->capTypeCode;

			// False if we want to set the rate to all caps
			// True if we want to set the rate to a specific cap
			if (mediaCap > -1 && mediaCap != (int) pCapBuffer->capTypeCode)
			{
				pTemp 		+= sizeof(capBufferBase) + pCapBuffer->capLength;
				pCapBuffer 	= (capBuffer*)pTemp;
				continue;
			}

			if (capInfo.IsType(cmCapAudio))   // to make sure that this is not belongs to ice,lpr..
			{
				CBaseAudioCap* pCap = (CBaseAudioCap*) CBaseCap::AllocNewCap((CapEnum)pCapBuffer->capTypeCode, pCapBuffer->dataCap);

				if (pCap && bitRate)
					pCap->SetBitRate(bitRate);

				POBJDELETE(pCap);
			}

			if (capInfo.IsType(cmCapVideo))   // to make sure that this is not belongs to ice,lpr..
			{
				CBaseVideoCap* pCap = (CBaseVideoCap*) CBaseCap::AllocNewCap((CapEnum)pCapBuffer->capTypeCode, pCapBuffer->dataCap);

				if (pCap && bitRate)
				{
					pCap->SetBitRate(bitRate);

					if( (CapEnum)pCapBuffer->capTypeCode  == eH261CapCode)
						((CH261VideoCap*)pCap)->SetBitRateWithoutLimitation(bitRate);
				}
				POBJDELETE(pCap);
			}

			pTemp += sizeof(capBufferBase) + pCapBuffer->capLength;
			pCapBuffer = (capBuffer*)pTemp;
		}
	}
}
////////////////////////////////////////////////////////////////////
void CSipCntl::AddContentCapIfNeeded(CIpComMode *pScm, CCapSetInfo capInfo)
{
	if (!m_pChosenLocalCap->IsCapSet(capInfo,kRolePresentation))
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::AddContentCapIfNeeded : Add content cap to local caps - ", (CapEnum)capInfo);
		CIpComMode* pTempScm = new CIpComMode(*pScm);
		pTempScm->SetContentBitRate(m_fullContentRate, cmCapReceiveAndTransmit);
		BYTE bIsRcvContentHighProfile = pTempScm->IsH264HighProfileContent(cmCapReceive);  //HP content
		m_pChosenLocalCap->AddSingleContentCap(pTempScm, (CapEnum)capInfo, bIsRcvContentHighProfile);
		POBJDELETE(pTempScm);
	}
}
////////////////////////////////////////////////////////////////////
void CSipCntl::RemoveBfcpCaps()
{
	m_pChosenLocalCap->CleanMedia(cmCapBfcp); // bfcp
	m_pMaxLocalCaps->CleanMedia(cmCapBfcp); // bfcp
}
////////////////////////////////////////////////////////////////////
void CSipCntl::RemoveContentCaps()
{
	m_pChosenLocalCap->CleanMedia(cmCapVideo, kRolePresentation); // content
	m_pMaxLocalCaps->CleanMedia(cmCapVideo, kRolePresentation); // content
}
////////////////////////////////////////////////////////////////////
void CSipCntl::RemoveBfcpAndContentCaps()
{
	RemoveBfcpCaps();
	RemoveContentCaps();
}
///////////////////////////////////////////
void CSipCntl::RemoveFeccCaps()
{
	m_pChosenLocalCap->CleanMedia(cmCapData); // bfcp
	m_pMaxLocalCaps->CleanMedia(cmCapData); // bfcp
	m_pChosenLocalCap->CleanSdesMedia(cmCapData);
	m_pMaxLocalCaps->CleanSdesMedia(cmCapData);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::DumpUdpAddresses()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::DumpUdpAddresses" );
	CLargeString *pStr = new CLargeString;
	*pStr	<< "AudioChannelPort	 = " << m_UdpAddressesParams.AudioChannelPort  <<'\n'
			<< "VideoChannelPort	 = " << m_UdpAddressesParams.VideoChannelPort  <<'\n'
			<< "ContentChannelPort 	 = " << m_UdpAddressesParams.ContentChannelPort  <<'\n'
			<< "FeccChannelPort		 = " << m_UdpAddressesParams.FeccChannelPort  <<'\n'
			<< "BfcpChannelPort		 = " << m_UdpAddressesParams.BfcpChannelPort  <<'\n'
			<< "UdpAddressType		 = " << m_UdpAddressesParams.IpType  <<'\n';


	*pStr << "IP v4	  = " << m_UdpAddressesParams.IpV4Addr.ip  <<'\n';

	*pStr << "Ip V6:";
	mcTransportAddress tempAddr;
	char szIP[IPV6_ADDRESS_LEN];
	for (int i=0; i<NUM_OF_IPV6_ADDRESSES; i++)
	{
		memset(&tempAddr,0,sizeof(mcTransportAddress));
		memset(szIP,0,IPV6_ADDRESS_LEN);

		tempAddr.ipVersion = (DWORD)eIpVersion6;
		tempAddr.addr.v6.scopeId = m_UdpAddressesParams.IpV6AddrArray[i].scopeId;
		memcpy(tempAddr.addr.v6.ip,m_UdpAddressesParams.IpV6AddrArray[i].ip,IPV6_ADDRESS_BYTES_LEN);
		::ipToString(tempAddr,szIP,1);

		*pStr << "\nIp V6 " << i << " ="
		      << "\nScope Id: " << m_UdpAddressesParams.IpV6AddrArray[i].scopeId
		      << "\nIp: " << szIP << "\n";
	}


	//		*pStr << "IP v6	  = " << (WORD)m_udpAddresses.IpAddr.v6.ip  <<'\n';
	PTRACE(eLevelInfoNormal, pStr->GetString());
	POBJDELETE(pStr);
}
////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateDtmf2833PayloadTypeAccordingToRemoteCap(CSipChannel* pChannel)
{
	//For audio receive channel only
	if (pChannel == NULL || pChannel->GetDirection() != cmCapReceive || pChannel->GetMediaType() != cmCapAudio)
		return;

	CSipAudioChannel* 	pAudioChannel		= (CSipAudioChannel*)pChannel;
	CCapSetInfo 		dtmfCapInfo			= eRfc2833DtmfCapCode;

	WORD   				profile  			= H264_Profile_None;
	APIS32 				H264mode 			= H264_standard;
	APIU8 				packetizationMode	= 0;

	//Search for Dtmfs payload types
	payload_en dtmfRemotePayload 	= m_pLastRemoteCaps->GetPayloadTypeByDynamicPreference(dtmfCapInfo, profile, pChannel->GetRoleLabel(), H264mode, packetizationMode);
	payload_en dtmfLocalPayload 	= m_pChosenLocalCap->GetPayloadTypeByDynamicPreference(dtmfCapInfo, profile, pChannel->GetRoleLabel(), H264mode, packetizationMode);

	//Found a remote DTMF
	if(dtmfRemotePayload != _UnKnown)
	{
		//Swap local & max dtmf caps to the remote dtmf payload if needed
		if (dtmfRemotePayload != dtmfLocalPayload)
		{
			m_pChosenLocalCap->SwapPayloadTypes(dtmfCapInfo, pChannel->GetRoleLabel(), dtmfLocalPayload, profile, dtmfRemotePayload);
			m_pMaxLocalCaps->SwapPayloadTypes(dtmfCapInfo, pChannel->GetRoleLabel(), dtmfLocalPayload, profile, dtmfRemotePayload);
		}

		//Set channel Dtmf Payload according to remote cap
		pAudioChannel->SetDtmfPayloadType(dtmfRemotePayload);
	}
	else
	{
		//Set channel Dtmf Payload to _UnKnown = 255 = -1
		pAudioChannel->SetDtmfPayloadType(_UnKnown);//dtmfLocalPayload); //26/09/11 - dont support rfc2833 if remote not support as well
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdatePayloadTypeInRecieveChannelsAccordingToRemoteCaps()
{
	CSipChannel* pChannel = NULL;

	// multi_line - temp temp temp - must be removed !!!

	if(m_bIsMrcCall)
	{
		return;
	}

	// multi_line - temp temp temp - must be removed !!!

	for (int i=0; i<MAX_SIP_CHANNELS; i++)
	{
		pChannel = m_pCall->GetChannel(i, true);

		if (pChannel && pChannel->GetDirection() == cmCapReceive && pChannel->IsMediaChannel())
		{
			if (pChannel->GetMediaType() == cmCapAudio)
			{
				UpdateDtmf2833PayloadTypeAccordingToRemoteCap(pChannel);
			}

			CCapSetInfo capInfo	= pChannel->GetAlgorithm();
			payload_en payloadToSet;
			WORD   profile  = H264_Profile_None;
			APIS32 H264mode = H264_standard;
			APIU8  packetizationMode = 0;

			if ((CapEnum)capInfo == eH264CapCode)
			{
				CH264VideoCap* pH264VidCap = (CH264VideoCap*)pChannel->GetDataAsCapClass();

				if (pH264VidCap)
				{
					profile  = pH264VidCap->GetProfile();
					H264mode = pH264VidCap->GetH264mode();
					packetizationMode = pH264VidCap->GetPacketizationMode();
				}

				POBJDELETE(pH264VidCap);
			}

			payloadToSet = m_pLastRemoteCaps->GetPayloadTypeByDynamicPreference(capInfo, profile, pChannel->GetRoleLabel(), H264mode, packetizationMode);

			if (payloadToSet != _UnKnown)
			{
				if (m_pChosenLocalCap)
				{
					if (::IsDynamicPayloadType(payloadToSet)) //if remote supports dynamic, check local support
					{
						payload_en localPayload = m_pChosenLocalCap->GetPayloadTypeByDynamicPreference(capInfo, profile, pChannel->GetRoleLabel(), H264mode, packetizationMode);
						if (::IsValidPayloadType(localPayload) && !::IsDynamicPayloadType(localPayload))	//if local doesn't support dynamic, we need to use the static
							payloadToSet = localPayload;
					}
				}

				WORD channelPayload = pChannel->GetPayloadType();
				pChannel->SetPayloadType(payloadToSet);

				//update local & max caps
				if (m_pChosenLocalCap)
				    m_pChosenLocalCap->SwapPayloadTypes(capInfo, pChannel->GetRoleLabel(), channelPayload, profile, payloadToSet);
				else
				    PTRACE(eLevelError,"CSipCntl::UpdatePayloadTypeInRecieveChannelsAccordingToRemoteCaps - m_pChosenLocalCap is NULL");

				m_pMaxLocalCaps->SwapPayloadTypes(capInfo, pChannel->GetRoleLabel(), channelPayload, profile, payloadToSet);
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetMaxRate(DWORD rate)
{
	m_pNetSetup->SetMaxRate(rate);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetMsftTotalBW(DWORD bw)
{

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMsftTotalBW - bw=",bw);
	m_pChosenLocalCap->setMsftRxVideoBwLimitation(bw);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnCmRtcpVideoPreferenceInd(CSegment* pParam)
{


	//if( m_pParty->IsActiveTransaction() && pParam!= NULL)
	if( m_pParty->IsActiveTransaction() || pParam == NULL)
	{
		//Incase we receive RTCP req with video references in the middle of another trans than we will ignore this req
		// because this req should be sent several times
		PTRACE(eLevelInfoNormal,"CSipCntl::OnCmRtcpVideoPreferenceInd -Video Preferences in a middle of another trans - ignore");

		return;
	}

	TCmRtcpVideoPreference* dataStruct = (TCmRtcpVideoPreference*) pParam->GetPtr(1);

	DWORD Width = (dataStruct->tCmRtcpVideoPreferenceInfo).uFrameResWidth;
	DWORD Height = (dataStruct->tCmRtcpVideoPreferenceInfo).uFrameResHeight;
	DWORD BitRate =  (dataStruct->tCmRtcpVideoPreferenceInfo).uBitRate;
	DWORD FrameRate =  (dataStruct->tCmRtcpVideoPreferenceInfo).uFrameRate;
	CSipChannel* pVideoChannel = NULL;

/*	// Retrieve data from segment received
		TCmRtcpVideoPreference dataStruct;
	    memset(&dataStruct,0,sizeof(TCmRtcpVideoPreference));
	    pParam->Get( (BYTE*)&dataStruct, sizeof(TCmRtcpVideoPreference));
	    kChanneltype channelType = (kChanneltype)dataStruct.media_type;
	    cmCapDirection channelDirection = (cmCapDirection)dataStruct.media_direction;
*/
	    CSmallString cLog;
	    cLog << "Width " << Width << ", Hight " << Height <<", BitRate "<< BitRate <<", FrameRate "<<FrameRate;
	    PTRACE2(eLevelInfoNormal,"CSipCntl::OnCmRtcpVideoPreferenceInd: ",cLog.GetString());

	    if(m_pCall)
	    	pVideoChannel = m_pCall->GetChannel(true, cmCapVideo, cmCapTransmit);

	    if(pVideoChannel)
	    {
	    	if(pVideoChannel->GetAlgorithm() == eRtvCapCode)
	    	{
	    		 PTRACE(eLevelInfoNormal,"CSipCntl::OnCmRtcpVideoPreferenceInd: This is RTV channel");
	    		 m_pPartyApi->UpdatePartyOnVideoPreference(Width,Height,BitRate,FrameRate);
	    	}
	    }

}
//////////////////////////////////////////////////////////
void CSipCntl::OnCmRtcpVideoPreferenceIndAnycase(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnCmRtcpVideoPreferenceIndAnycase : ");
}

//////////////////////////////////////////////////////////
void CSipCntl::SendRtcpVideoPreferenceReq(DWORD Width,DWORD Height)
{
	RTVVideoModeDetails rtvVidModeDetails;
	DWORD BitRate;

	// bridge-11167
	BOOL isNeedToSendPreferenceAVMCU2010 = ( ( GetRemoteIdent() == Microsoft_AV_MCU ) && (IsSendPreferenceRequestToAVMCU2010()) ) ? YES : NO;

	//Will be sent only to MOCs
	if(GetRemoteIdent() == MicrosoftEP_R1 || GetRemoteIdent() == MicrosoftEP_R2 || m_remoteIdent == MicrosoftEP_Lync_R1  || m_remoteIdent == MicrosoftEP_Lync_2013 || m_remoteIdent == MicrosoftEP_MAC || (m_remoteIdent == MicrosoftEP_MAC_Lync || isNeedToSendPreferenceAVMCU2010 /*|| GetRemoteIdent() == Microsoft_AV_MCU*/ || GetRemoteIdent() == Microsoft_AV_MCU2013))
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SendRtcpVideoPreferenceReq to MOC or Lync");

		TCmRtcpVideoPreference* pStruct = new TCmRtcpVideoPreference;
		memset(pStruct,0,sizeof(TCmRtcpVideoPreference));

		(pStruct->tCmRtcpHeader).uDspNumber = 0;
		(pStruct->tCmRtcpHeader).uPortNumber = 0;

		if(Width && Height)
		{
			(pStruct->tCmRtcpVideoPreferenceInfo).uFrameResWidth = Width;
			(pStruct->tCmRtcpVideoPreferenceInfo).uFrameResHeight = Height;
		}
		else
		{
			CSuperLargeString str;
			m_pChosenLocalCap ->DumpToString(str);
			PTRACE2(eLevelInfoNormal,"CSipCntl::SendRtcpVideoPreferenceReq :  ",str.GetString());

			m_pChosenLocalCap->GetRtvCap(rtvVidModeDetails,BitRate);
			(pStruct->tCmRtcpVideoPreferenceInfo).uFrameResWidth = rtvVidModeDetails.Width;
			(pStruct->tCmRtcpVideoPreferenceInfo).uFrameResHeight = rtvVidModeDetails.Height;
		}

		//Send RTCP Req to CM
		SendMsgToMpl((BYTE*)(pStruct), sizeof(TCmRtcpVideoPreference), IP_CM_RTCP_VIDEO_PREFERENCE_REQ);
		PDELETE(pStruct);
	}

}
//////////////////////////////////////////////////////////
void CSipCntl::OnCmRtcpReceiverBandwidthInd(CSegment* pParam)
{
	TCmRtcpBandwidth* dataStruct = (TCmRtcpBandwidth*) pParam->GetPtr(1);

	DWORD NewBitRate =   dataStruct->nBandwidth;

	CSipChannel* pVideoChannel = NULL;
	if(m_pCall)
	   	pVideoChannel = m_pCall->GetChannel(true, cmCapVideo, cmCapTransmit);

	if(pVideoChannel)
	{
	   	if(pVideoChannel->GetAlgorithm() == eRtvCapCode)
	  		 PTRACE(eLevelInfoNormal,"CSipCntl::OnCmRtcpVideoPreferenceInd: This is RTV channel");

	   	m_pPartyApi->UpdatePartyVideoBitRate(NewBitRate*10, cmCapTransmit, kRolePeople);
	}

}
////////////////////////////////////////////////////
void CSipCntl::SendRTCPBandwidthLimitation(APIU32 rate)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendRTCPBandwidthLimitation, rate recieved is   = ", (APIU32)(rate));

	TCmRtcpBandwidth* pStruct = new TCmRtcpBandwidth;
	memset(pStruct,0,sizeof(TCmRtcpBandwidth));

	pStruct->nBandwidth = rate/10;

	//Send RTCP Req to CM
	SendMsgToMpl((BYTE*)(pStruct), sizeof(TCmRtcpBandwidth), IP_CM_RTCP_RECEIVER_BANDWIDTH_REQ);
	PDELETE(pStruct);

}
/////////////////////////////////////////////////
DWORD CSipCntl::GetCopMaxCallRate()
{
	DWORD AudioRate = m_pCall->GetAudioRate(cmCapReceive);
	DWORD videoOut = m_pParty->GetTargetMode()->GetMediaBitRate(cmCapVideo, cmCapTransmit, kRolePeople);
	DWORD videoIn = m_pParty->GetTargetMode()->GetMediaBitRate(cmCapVideo, cmCapReceive, kRolePeople);
	DWORD contentOut = m_pParty->GetTargetMode()->GetMediaBitRate(cmCapVideo, cmCapTransmit, kRolePresentation);
	DWORD contentIn = m_pParty->GetTargetMode()->GetMediaBitRate(cmCapVideo, cmCapReceive, kRolePresentation);

	DWORD maxVideo = max((videoOut + contentOut ) , (videoIn + contentIn));

	return (maxVideo + AudioRate);


}

////////////////////////////////////////////////////////////////////////////////////////////////
// TIP -----------------------------------------------------------------------
//void CSipCntl::SetIsTipCall(BYTE isTipCall )
//{
//	m_bIsTipCall = isTipCall;
//}
///////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::GetIsTipCall() const
{
  // D.K.VNGR-22035
	return m_pParty ? m_pParty->GetIsTipCall() : 0;
}
/////////////////////////////////////////////////////////////////////////////
BOOL CSipCntl::IsTipRtcpMessage(OPCODE opCode)
{
	if ((opCode == IP_CM_TIP_NEGOTIATION_RESULT_IND)
		|| (opCode == IP_CM_TIP_CONTENT_MSG_IND)
		|| (opCode == IP_CM_TIP_LAST_ACK_RECEIVED_IND))
		return TRUE;
	return FALSE;
}
/////////////////////////////////////////////////////////////////////////////
void CSipCntl::StartTipNegotiation()
{
	PTRACE(eLevelInfoNormal, "IS_PREFER_TIP_MODE: CSipCntl::StartTipNegotiation");

	if (m_pParty)
	{
		if (m_pTipRtcpCntl)
			POBJDELETE(m_pTipRtcpCntl);
		m_pTipRtcpCntl = new CTipRtcpCntl(m_pParty);

		if (IsValidPObjectPtr(m_pTipRtcpCntl))
		{
			m_pTipRtcpCntl->Initialize(m_pMfaInterface, m_pPartyApi, m_pParty->GetMcuNum(), m_pParty->GetTerminalNum(), m_pChosenLocalCap->GetTipAuxFPS());

			CSipComMode *pTaregtMode = (CSipComMode*) m_pParty->GetTargetMode();

			pTaregtMode->SetTipMode(eTipModePossible);

			//isPreferTip is field for TIP call from Polycom EPs feature: CSipCntl::StartTipNegotiation
			CSegment*  pSeg        = new CSegment;
			CCommConf* pCommConf   = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
			APIU32     isPreferTip = 0;

			if (pCommConf && pCommConf->GetIsTipCompatible() == eTipCompatiblePreferTIP)
			{
			    isPreferTip = 1;
			    PTRACE(eLevelError, "IS_PREFER_TIP_MODE: CSipCntl::StartTipNegotiation PREFER TIP FOR POLYCOM EP eTipCompatiblePreferTIP");
			}
			else
			{
			    PTRACE(eLevelError, "IS_PREFER_TIP_MODE: CSipCntl::StartTipNegotiation !DONOT! PREFER TIP FOR POLYCOM EP");
			    if (pCommConf)
			        PTRACE2INT(eLevelError, "IS_PREFER_TIP_MODE: CSipCntl::StartTipNegotiation !DONOT! PREFER TIP FOR POLYCOM EP TipCompatible:",pCommConf->GetIsTipCompatible());
			    else
			        PTRACE(eLevelError, "IS_PREFER_TIP_MODE: CSipCntl::StartTipNegotiation pCommConf is NULL");
			}

			*pSeg << isPreferTip;

			m_pTipRtcpCntl->DispatchEvent(SIP_PARTY_START_TIP_NEGOTIATION, pSeg);
			POBJDELETE(pSeg);
			//m_pTipRtcpCntl->DispatchEvent(SIP_PARTY_START_TIP_NEGOTIATION);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::EndTipNegotiation(ETipNegStatus eStatus)
{
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::EndTipNegotiation : status=", eStatus);

	if (IsValidPObjectPtr(m_pTipRtcpCntl))
	{
		CSegment*  pSeg = new CSegment;
		*pSeg << (DWORD)eStatus;
		m_pTipRtcpCntl->DispatchEvent(SIP_PARTY_NEGOTIATION_HANDLED, pSeg);
		POBJDELETE(pSeg);
	}


}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendTipCallMessageToMPL(DWORD masterId, DWORD leftId, DWORD rightId, DWORD audioAuxId, DWORD opcode)
{
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::SendTipCallMessageToMPL : opcode=", opcode);

	mcTipMsgInfoReq *dataStruct = new mcTipMsgInfoReq;
    memset(dataStruct,0,sizeof(mcTipMsgInfoReq));

    dataStruct->centerTipChannelPartyId.bIsActive = 1;
    dataStruct->centerTipChannelPartyId.unPartyId = masterId;

    if( leftId !=0 )
    {
        dataStruct->leftTipChannelDescr.bIsActive = 1;
        dataStruct->leftTipChannelDescr.unPartyId = leftId;
    }
    if( rightId !=0 )
    {
        dataStruct->rightTipChannelDescr.bIsActive = 1;
        dataStruct->rightTipChannelDescr.unPartyId = rightId;
    }
    if( audioAuxId !=0 )
    {
		dataStruct->auxTipChannelDescr.bIsActive = 1;
		dataStruct->auxTipChannelDescr.unPartyId = audioAuxId;
    }

    SendMsgToMpl((BYTE*)(dataStruct), sizeof(mcTipMsgInfoReq), opcode);
    PDELETE(dataStruct);
}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::HandleMuxTipAck(ACK_IND_S* pAckIndStruct)
{
	if (pAckIndStruct->ack_base.status == STATUS_OK)
	{
		TRACEINTO << "CSipCntl::HandleMuxTipAck : - status is ok -  opcode = " << pAckIndStruct->ack_base.ack_opcode;
	}
	else
	{
		TRACEINTO << "CSipCntl::HandleMuxTipAck : - status is NOT ok -  opcode = " << pAckIndStruct->ack_base.ack_opcode;
		DBGPASSERT(GetHWInterface(pAckIndStruct->ack_base.ack_opcode,FALSE)->GetConnectionId());
	}
}
////////////////////////////////////////////////////////////////////////////
void CSipCntl::TipReInviteReq(WORD nStreams, BYTE bIsVideoAux)
{

	TipPrepareRatesInLocalCaps( nStreams,bIsVideoAux );
	m_pParty->StartTransaction(kSipTransReInviteWithSdpReq, SIP_PARTY_SEND_REINVITE, NULL);
}

////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::CheckPartyMonitoringReq()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::CheckPartyMonitoringReq");
	if (m_pMfaInterface->GetRsrcParams() != NULL )
	{
		return 1;
	}
	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::CheckPartyMonitoringReq - Party is not connected yet");
		return 0;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::CloseTipSessionIfNeeded()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::CloseTipSessionIfNeeded");
	if (IsValidPObjectPtr(m_pTipRtcpCntl))
		m_pTipRtcpCntl->DispatchEvent(SIP_PARTY_CLOSE_TIP_SESSION);
}
////////////////////////////////////////////////////////////////////////////
void  CSipCntl::SendTokenMessageReq(DWORD opcode, BYTE mcuId, BYTE terminalId)
{

    /*Begin:added by Richer for BRIDGE-12317 ,2014.3.20*/
    CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
    if (pCommConf && pCommConf->GetVideoRecoveryStatus() )
    {
        PTRACE(eLevelInfoNormal,"CSipCntl::SendTokenMessageReq: video recovery, isBlockSendTokenReq");
        return;
    }
    /*End:added by Richer for BRIDGE-12317 ,2014.3.20*/

	if ( GetIsTipCall() && (m_pParty->GetTipPartyTypeAndPosition() != eTipMasterCenter) )
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SendTokenMessageReq: not master TIP party");
		return;
	}
	CSipChannel* pChannel = m_pCall->GetChannel(true, cmCapVideo, cmCapReceive,kRolePeople);

	BYTE isBlockSendTokenReq = FALSE;

	if( (pChannel && pChannel->IsMuted() == TRUE) || m_pParty->GetIsTipNegotiationActive() )
		isBlockSendTokenReq = TRUE;

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendTokenMessageReq: isBlockSendTokenReq ",isBlockSendTokenReq);

	if( opcode == CONTENT_NO_ROLE_PROVIDER && GetIsTipCall() && isBlockSendTokenReq)// || m_pParty->GetTargetMode()->IsTipNegotiated() == FALSE))
    	return;
	enMediaOnHold eMediaOnHold = m_pParty->GetNonTipPartyOnHold();
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SendTokenMessageReq - MediaOnHold: ",(WORD)eMediaOnHold);
	if( !GetIsTipCall() && eMediaOnHold )
		return;
	if ( GetIsTipCall() && IsValidPObjectPtr(m_pTipRtcpCntl) )
		m_pTipRtcpCntl->SendContentMsgReq(opcode);
	else
		SendBfcpMessageReq(opcode, mcuId, terminalId);
}
////////////////////////////////////////////////////////////////////////////
void  CSipCntl::SetRemoteCapsTipAuxFPS(ETipAuxFPS tipAuxFPS)
{
	m_pLastRemoteCaps->SetTipAuxFPS(tipAuxFPS);
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetRemoteCapsTipAuxFPS : IsCapableTipAux5Fps ",m_pLastRemoteCaps->IsCapableTipAux5Fps());
}
////////////////////////////////////////////////////////////////////////////
void  CSipCntl::AddTipNegotiationCapsToRemoteCaps()
{
	if (IsValidPObjectPtr(m_pTipRtcpCntl) && m_pTipRtcpCntl->IsAuxVideo5FpsNegotiated())
		m_pLastRemoteCaps->SetTipAuxFPS(eTipAux5FPS);

	BYTE bFixTipVideoRate = CheckIfNeedToUpdateRateForTipCall();

	TRACEINTOFUNC << "IsCapableTipAux5Fps:    " << ( (TRUE == m_pLastRemoteCaps->IsCapableTipAux5Fps()) ? "TRUE" : "FALSE" )
				  << "\nneed to fix video rate: " << ( (TRUE == bFixTipVideoRate) ? "TRUE" : "FALSE" );

	if (bFixTipVideoRate)
		m_pLastRemoteCaps->TipFixRemoteRateByTipNegotiation(m_pParty->TipGetNumOfStreams());
}
////////////////////////////////////////////////
BYTE CSipCntl::UpdateRemoteCapsForTipNegRes()//return TRUE if content was seted at true!!!!
{
	BYTE res = FALSE;
	if (IsValidPObjectPtr(m_pTipRtcpCntl) && m_pTipRtcpCntl->IsAuxVideo5FpsNegotiated())
	{
		m_pLastRemoteCaps->SetTipAuxFPS(eTipAux5FPS);
		return TRUE;
	}
	return FALSE;

}

///////////////////////////////////////////////
void CSipCntl::SetITPRtcpMask()
{
	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	BYTE isRoomSwitch = NO;
	if(pCommConf && CPObject::IsValidPObjectPtr(pCommConf) && (pCommConf->GetTelePresenceLayoutMode() == eTelePresenceLayoutRoomSwitch ||
                                                               pCommConf->GetTelePresenceLayoutMode() == eTelePresenceLayoutCpSpeakerPriority))
		isRoomSwitch = YES;
	m_RtcpCnameMask = ::BuildRtcpCnameMask(isRoomSwitch);
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetITPRtcpMask m_RtcpCnameMask ",m_RtcpCnameMask);

}
//////////////////////////////////////////////////////////////////////////
void CSipCntl::RetriveCNAMEInfoIfNeeded(CSegment* pParam)
{
	//PTRACE(eLevelInfoNormal,"CSipCntl::RetriveCNAMEInfoIfNeeded");

	TCmRtcpCnameInfoAsStringInd dataStruct;
	memset(&dataStruct,0,sizeof(TCmRtcpCnameInfoAsStringInd));
	pParam->Get( (BYTE*)&dataStruct, sizeof(TCmRtcpCnameInfoAsStringInd));
	if(m_IsNeedToExtractInfoFromRtcpCname)
	{
		if (m_pParty)
		{
			if (m_pParty->GetTargetMode()->IsTipNegotiated() == FALSE)
			{
				PTRACE2(eLevelInfoNormal,"CSipCntl::RetriveCNAMEInfoIfNeeded ",dataStruct.cCname);
				RetriveCnameInfoFromEpIfPosible(dataStruct.cCname);
			}
			else /* bridge-3714 - Check RTCP, if case of Polycom product mute slaves (this is a solution for TPX echo)*/
			{
				if (!strncmp(dataStruct.cCname, "Polycom", (sizeof("Polycom")-1))) {
					/* In case RTCP string starts with Polycom, mute the channels*/
					PTRACE(eLevelDebug,"CSipCntl::RetriveCNAMEInfoIfNeeded - TIP call with a Polycom product, mute the slaves if there are any");
					m_pParty->SendMuteToSlaves();
					m_pParty->ChangeVideoOutForPolycomTip(); //_t_p
				}
				else
				{
					PTRACE(eLevelError,"CSipCntl::RetriveCNAMEInfoIfNeeded-tip call can't get this message ignore - EP problem ");
				}
			}
		}
		else
		{
			/* in case m_Party doesn't exist, consider as a non-tip call */
			PTRACE2(eLevelInfoNormal,"CSipCntl::RetriveCNAMEInfoIfNeeded, mParty=null,  ",dataStruct.cCname);
			RetriveCnameInfoFromEpIfPosible(dataStruct.cCname);
		}
	}
	else
	{
		PTRACE2(eLevelInfoNormal,"CSipCntl::RetriveCNAMEInfoIfNeeded-no need to extract either it came from SIP signaling or twice by mistake ",dataStruct.cCname);
	}


}
/////////////////////////////////////////////////////////////////////
//This function get CNAME from RTCP and pass it to party.
//////////////////////////////////////////////////////////////////////
APIU16 CSipCntl::RetriveCnameInfoFromEpIfPosible(char *pCnameString)
{
	m_IsNeedToExtractInfoFromRtcpCname =FALSE;
	char siteName[MAX_SITE_NAME_ARR_SIZE] = {0}; //33
	char mask[MASK_LENGTH_CHAR + 1] = {0};

	if(!strstr(pCnameString,"Polycom"))
		return FALSE;
	char* startmask = strstr(pCnameString, "@");
	if(!startmask)
		return FALSE;
	else
	{
		startmask++;
		char* endOfMask = strstr(pCnameString, " ");
		if(!endOfMask)
			return FALSE;
		endOfMask--;
		if((endOfMask - startmask) != 3 )
		{
			return FALSE;
		}

		strncpy(mask, startmask, MASK_LENGTH_CHAR);
		strncpy(siteName,(endOfMask + 2),MAX_SITE_NAME_ARR_SIZE - 1 );
	}

	siteName[MAX_SITE_NAME_ARR_SIZE - 1] = '\0';
	BuildRepresentableSiteName(siteName);
	 mask[MASK_LENGTH_CHAR] = '\0';

	//APIU16 CnameMaskWord = atoi(mask);
	APIU16 CnameMaskWord = 0;
	CnameMaskWord = strtol (mask,NULL,16);

	if(CnameMaskWord & ITP_MCU)
		return FALSE;
	eTelePresencePartyType  eLocalTelePresencePartyType = eTelePresencePartyNone;
	if(CnameMaskWord & ITP_RPX)
		eLocalTelePresencePartyType = eTelePresencePartyRPX;
	if(CnameMaskWord & ITP_FLEX)
	{
		if( CnameMaskWord & CAM_CAP_MASK )
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::RetriveCnameInfoFromEpIfPosible ITP_MAUI");
			eLocalTelePresencePartyType = eTelePresencePartyMaui;
		}
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::RetriveCnameInfoFromEpIfPosible ITP_FLEX");
			eLocalTelePresencePartyType = eTelePresencePartyFlex;
		}

	}

	BYTE bIsVisualName = TRUE;
	if(strlen(siteName) < 1)
		 bIsVisualName = FALSE;
	if(bIsVisualName)
	{
		PTRACE2(eLevelInfoNormal,"CSipCntl::RetriveCnameInfoFromEpIfPosible siteName ",siteName );
		CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
		if (pCommConf)
		{
		    CConfParty* pConfParty = pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());
		    if (pConfParty)
		    {
		        pConfParty->SetRemoteName(siteName);
		        pConfParty->SetVisualPartyName(siteName);
		    }
		    else
		        PTRACE(eLevelInfoNormal,"CSipCntl::RetriveCnameInfoFromEpIfPosible - pConfParty is NULL - can not setRemoteName");
		}
		else
		    PTRACE(eLevelInfoNormal,"CSipCntl::RetriveCnameInfoFromEpIfPosible - pCommConf is NULL - can not setRemoteName");

		// speakerIndication
		TRACEINTO << "speakerIndication - send to PartyControl - m_remoteIdent: " << m_remoteIdent;
		m_pPartyApi->SendSiteAndVisualNamePlusProductIdToPartyControl(bIsVisualName, siteName, FALSE /*bIsProductId*/, ""/*productId*/,FALSE /*bIsVersionId*/,NULL /*pVersionId*/, eLocalTelePresencePartyType,FALSE,m_remoteIdent);

		return TRUE;
	}
	return FALSE;


}
/////////////////////////////////////////////////////////////////////
//This function is for SIP signaling in order to pass the mask
////////////////////////////////////////////////////////////////////
void CSipCntl::BuildCnameStringFromMask(APIU16 mask,char *fullString)
{
//	char* fullString = new char[CNAME_STRING_MAX_LEN];
	//memset(fullString,'\0',CNAME_STRING_MAX_LEN);
	sprintf (fullString,"%04X ", mask);
	PTRACE2(eLevelInfoNormal,"CSipCntl::BuildCnameStringFromMask",fullString);

}
////////////////////////////////////////////////////////////////////////
//This function get info from SIP signaling which has the same info as CNAME RTCP if we can't attrive this info we will retrive cname info
//////////////////////////////////////////////////////////////////////
APIU16 CSipCntl::RetriveMaskAndNameFromEpIfPosible(char *pCnameString,BYTE bIsProductId, char* productId, BYTE bIsVersionId, char* VersionId)
{

	char* siteName 	= new char[MAX_SITE_NAME_ARR_SIZE + 1]; //33
	memset(siteName,'\0',MAX_SITE_NAME_ARR_SIZE + 1);
	char* mask 		= new char[MASK_LENGTH_CHAR + 1];
	//if(!strstr(pCnameString,"vnd.polycom.PlcmMaskCap:"))
	//	return FALSE;
	char* startmask;
	//startmask = strstr(pCnameString, ":");
	//if(!startmask)
	//	return FALSE;

	startmask = pCnameString;

	char* endOfMask = strstr(pCnameString, " ");

	if(!endOfMask)
	{
		PDELETEA (siteName);
		PDELETEA (mask);
		return FALSE;
	}

	endOfMask--;

	if((endOfMask - startmask) != 3 )
	{
		PDELETEA (siteName);
		PDELETEA (mask);
		return FALSE;
	}

	strncpy(mask, startmask,( (endOfMask - startmask) + 1) );
	strncpy(siteName,(endOfMask + 2),MAX_SITE_NAME_ARR_SIZE );

	siteName[MAX_SITE_NAME_ARR_SIZE - 1] = '\0';
	mask[MASK_LENGTH_CHAR] = '\0';
	BuildRepresentableSiteName(siteName);

	//APIU16 CnameMaskWord = atoi(mask);
	APIU16 CnameMaskWord = 0;
	CnameMaskWord = strtol (mask,NULL,16);

	if(CnameMaskWord & ITP_MCU)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::RetriveMaskAndNameFromEpIfPosible ITP_MCU");
		PDELETEA (siteName);
		PDELETEA (mask);
		return FALSE;
	}

	eTelePresencePartyType  eLocalTelePresencePartyType = eTelePresencePartyNone;

	if(CnameMaskWord & ITP_RPX)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::RetriveMaskAndNameFromEpIfPosible ITP_RPX");
		eLocalTelePresencePartyType = eTelePresencePartyRPX;
	}

	if(CnameMaskWord & ITP_FLEX)
	{
		if( CnameMaskWord & CAM_CAP_MASK )
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::RetriveMaskAndNameFromEpIfPosible ITP_MAUI");
			eLocalTelePresencePartyType = eTelePresencePartyMaui;
		}
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::RetriveMaskAndNameFromEpIfPosible ITP_FLEX");
			eLocalTelePresencePartyType = eTelePresencePartyFlex;
		}
	}

	BYTE bIsVisualName = TRUE;

	if(strlen(siteName) < 1)
		 bIsVisualName = FALSE;

	if(bIsVisualName)
	{
		PTRACE2(eLevelInfoNormal,"CSipCntl::RetriveMaskAndNameFromEpIfPosible siteName ",siteName );
		CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
		if (pCommConf)
		{
		    CConfParty* pConfParty = pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());
		    if (pConfParty)
		        pConfParty->SetRemoteName(siteName);
		    else
		        PTRACE(eLevelInfoNormal,"CSipCntl::RetriveCnameInfoFromEpIfPosible - pConfParty is NULL - can not setRemoteName");
		}
		else
		    PTRACE(eLevelInfoNormal,"CSipCntl::RetriveCnameInfoFromEpIfPosible - pCommConf is NULL - can not setRemoteName");

		// speakerIndication
		TRACEINTO << "speakerIndication -current remote ident- m_remoteIdent: " << m_remoteIdent;
		m_pPartyApi->SendSiteAndVisualNamePlusProductIdToPartyControl(bIsVisualName, siteName, bIsProductId /*bIsProductId*/, productId,bIsVersionId /*bIsVersionId*/,VersionId /*pVersionId*/, eLocalTelePresencePartyType,FALSE,m_remoteIdent);

		PDELETEA (siteName);
		PDELETEA (mask);
		return TRUE;
	}
	PDELETEA (siteName);
	PDELETEA (mask);
	return FALSE;
}

//////////////////////////////////////////////////////////////////////////
void  CSipCntl::BandwidthAllocationStatus(DWORD reqBandwidth, DWORD allocBandwidth )
{
	m_pPartyApi->SipBandwidthAllocationStatus(reqBandwidth, allocBandwidth);
}

//////////////////////////////////////////////////////////////////////////
void  CSipCntl::OnMfaICEInsufficientBandwidthEventInd(CSegment* pParam)
{
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnMfaICEInsufficientBandwidthEventInd Name - ", PARTYNAME);
	m_pPartyApi->ICEInsufficientBandwidthEvent();
}

////////////////////////////////////////////////////
void CSipCntl::OnMfaICESessionIndexInd(CSegment* pParam)
{
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnMfaICESessionIndexInd Name - ", PARTYNAME);

	if (m_IsEnableICE)
	{

		if(pParam && CPObject::IsValidPObjectPtr(pParam))
		{
			ICE_GENERAL_IND_S* pAnswerStruct = (ICE_GENERAL_IND_S*) pParam->GetPtr(1);
			m_Ice_Session_Index = pAnswerStruct->ice_session_index;
			m_bIsIceHasSessionIndex = TRUE;
		}
		else
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::OnMfaICESessionIndexInd - Invalid params ");
			SetIsEnableICE(FALSE);
		}

		if (m_bNeedToCancelIceSession)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::OnMfaICESessionIndexInd - late canceling of ICE session");

			m_bNeedToCancelIceSession = FALSE;

			DispatchEvent(SIP_CS_SIG_CANCEL_IND, m_cancelIndParams);
			return;
		}
	}
}

////////////////////////////////////////////////////
void CSipCntl::OnMrmpRtcpFirInd(CSegment* pParam)
{
	m_pPartyApi->HandleMrmpRtcpFirInd(pParam);
}

////////////////////////////////////////////////////
BYTE CSipCntl::CheckIfNeedToUpdateRateForTipCall()//need to add and remote has video caps
{
	if (!GetIsTipCall())
		return FALSE;

	if (m_pParty->TipGetNumOfStreams() > 0)
		return TRUE;

	return FALSE;
}
////////////////////////////////////////////////////////////////////

int CSipCntl::AddClosedMediaLinesFromRemoteSDP(sipSdpAndHeadersSt* pSdpAndHeaders, vector<eMediaLineInternalType>* pCopiedTypes,BYTE isNotCopyFullRemovedContentLineTip) const
{
	PTRACE(eLevelInfoNormal, "CSipCntl::AddClosedMediaLinesFromRemoteSDP start copying");

	sipMediaLinesEntrySt* pMediaLinesEntry = (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders;

	unsigned int mediaLinePos = 0;
    sipMediaLineSt *pMediaLine = NULL;
    int size = 0;
    BYTE copyContentFullMedialIne = TRUE;

	// Go to the last local m-line:
	for (unsigned int i = 0; i < pMediaLinesEntry->numberOfMediaLines; i++)
	{
		pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
		mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;
	}

	for(int i = (int)kMediaLineInternalTypeAudio; i < (int) kMediaLineInternalTypeNotSupported; i++)
	{
		eMediaLineInternalType type = (eMediaLineInternalType)i;
		if(::IsMediaContainedInSdp(m_pRemoteSdp, type) && !::IsMediaContainedInDirtySdp(pMediaLinesEntry, type))
		{
			if( isNotCopyFullRemovedContentLineTip )
			{
				if(i == (int)kMediaLineInternalTypeContent)
					copyContentFullMedialIne = FALSE;
			}

			int copySize = CopyMLineFromRemoteSDP(pMediaLinesEntry, type, mediaLinePos,-1 /*index default*/,copyContentFullMedialIne);
			if(copySize)
			{
				size += copySize;
				mediaLinePos += copySize;
				pCopiedTypes->push_back(type);
			}
			copyContentFullMedialIne = TRUE;
		}
//		if(::IsMediaContainedInSdp(m_pRemoteSdp, type))
//		    PTRACE2INT(eLevelInfoNormal, "CSipCntl::CopyMLineFromRemoteSDP for media=", (int)type);
	}

	return size;
}
////////////////////////////////////////////////////////////////////
int CSipCntl::CopyMLineFromRemoteSDP(sipMediaLinesEntrySt* pMediaLinesEntry, eMediaLineInternalType mediaType, int mediaLinePos, int index,BYTE copyContentFullMedialIne) const //modified for ANAT
{
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::CopyMLineFromRemoteSDP for media=", (int)mediaType);

	sipMediaLineSt* pNewMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
	sipMediaLineSt* pRemoteMediaLine = GetMediaLine(*m_pRemoteSdp, mediaType, index);
	unsigned int copySize = 0;

	if (pRemoteMediaLine)
	{
		if(copyContentFullMedialIne || mediaType != kMediaLineInternalTypeContent )
		copySize = sizeof(sipMediaLineBaseSt) + pRemoteMediaLine->lenOfDynamicSection;
		else if(copyContentFullMedialIne == FALSE)
		{
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::CopyMLineFromRemoteSDP  removing remote caps from sdp for tip for media=", (int)mediaType);
			copySize = sizeof(sipMediaLineBaseSt);
			pNewMediaLine->numberOfCaps = 0;
		}
		memcpy((void*)pNewMediaLine, (void*)pRemoteMediaLine, copySize);

		if(copyContentFullMedialIne == FALSE)
		{
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::CopyMLineFromRemoteSDP  removing remote caps from sdp for tip for setting 0 media=", (int)mediaType);
			pNewMediaLine->numberOfCaps = 0;
			pNewMediaLine->lenOfDynamicSection = 0;
		}

		pNewMediaLine->index = pMediaLinesEntry->numberOfMediaLines;
		//PTRACE2INT(eLevelInfoNormal, "CSipCntl::CopyMLineFromRemoteSDP  removing remote caps from sdp for tip for setting 0pMediaLinesEntry->numberOfMediaLines", ((int)pMediaLinesEntry->numberOfMediaLines));
		pMediaLinesEntry->numberOfMediaLines ++;
		pMediaLinesEntry->lenOfDynamicSection += copySize;
	}
	else
		DBGPASSERT(YES);

	return copySize;
}
/////////////////////////////////////////
int CSipCntl::GetClosedMediaSize(BYTE isNotCopyFullRemovedContentLineTip) const
{
    //PTRACE(eLevelInfoNormal,"CSipCntl::GetClosedMediaSize:");

    int size = 0;
	sipMediaLineSt* pRemoteMediaLine = NULL;

	//CSipCaps*  ptmpRemoteCaps  = new CSipCaps(*m_pLastRemoteCaps);
	//CLargeString msgRC;
	//ptmpRemoteCaps->DumpToString(msgRC);


	if(::IsMediaContainedInSdp(m_pRemoteSdp, kMediaLineInternalTypeAudio) && !m_pChosenLocalCap->IsMedia(cmCapAudio))
	{
		sipMediaLineSt* pRemoteMediaLine = GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeAudio);
	    if (pRemoteMediaLine)
		size += sizeof(sipMediaLineBaseSt) + pRemoteMediaLine->lenOfDynamicSection;
	}
	if(::IsMediaContainedInSdp(m_pRemoteSdp, kMediaLineInternalTypeVideo) && !m_pChosenLocalCap->IsMedia(cmCapVideo))
	{

	    //CLargeString str;
	    //m_pChosenLocalCap->DumpToString(str);
	    //PTRACE2(eLevelInfoNormal,"CSipCntl::GetClosedMediaSize m_pChosenLocalCap cmCapVideo: ",str.GetString());

	    sipMediaLineSt* pRemoteMediaLine = GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeVideo);
	    if (pRemoteMediaLine)
		size += sizeof(sipMediaLineBaseSt) + pRemoteMediaLine->lenOfDynamicSection;
	}
	if(::IsMediaContainedInSdp(m_pRemoteSdp, kMediaLineInternalTypeFecc) && !m_pChosenLocalCap->IsMedia(cmCapData))
	{
	    sipMediaLineSt* pRemoteMediaLine = GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeFecc);
	    if (pRemoteMediaLine)
		size += sizeof(sipMediaLineBaseSt) + pRemoteMediaLine->lenOfDynamicSection;
	}
	if(::IsMediaContainedInSdp(m_pRemoteSdp, kMediaLineInternalTypeContent) && !m_pChosenLocalCap->IsMedia(cmCapVideo, cmCapReceiveAndTransmit, kRolePresentation))
	{
	    //PTRACE(eLevelInfoNormal,"CSipCntl::GetClosedMediaSize kRolePresentation");

	    sipMediaLineSt* pRemoteMediaLine = GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeContent);
	    if (pRemoteMediaLine && isNotCopyFullRemovedContentLineTip == FALSE)
	    	size += sizeof(sipMediaLineBaseSt) + pRemoteMediaLine->lenOfDynamicSection;
	    else if(pRemoteMediaLine)
	    	size += sizeof(sipMediaLineBaseSt);
	}
	if (::IsMediaContainedInSdp(m_pRemoteSdp, kMediaLineInternalTypeBfcp) && !m_pChosenLocalCap->IsMedia(cmCapBfcp))//m_pCall->GetIsBfcpSupported())
	{
	    //PTRACE(eLevelInfoNormal,"CSipCntl::GetClosedMediaSize  - close bfcp");

	    sipMediaLineSt* pRemoteMediaLine = GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeBfcp);
	    if (pRemoteMediaLine)
		size += sizeof(sipMediaLineBaseSt) + pRemoteMediaLine->lenOfDynamicSection;
	}

	return size;
}
/////////////////////////////////////////////
void CSipCntl::UpdatePortInClosedMedias(sipSdpAndHeadersSt* pSdpAndHeaders, vector<eMediaLineInternalType> copiedTypes) const
{
    sipMediaLinesEntrySt* pMediaLinesEntry = (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders;

	for(unsigned int i = 0; i < copiedTypes.size(); i++)
	{
		sipMediaLineSt* pMediaLine = GetMediaLine(*pSdpAndHeaders, copiedTypes.at(i));

		if(pMediaLine)
		{
			pMediaLine->mediaIp.transAddr.port = 0;
		}
	}
}


void CSipCntl::SetIceCallOnNetSetup(BOOL isEnableSipICE)
{
	m_pNetSetup->SetEnableSipICE(isEnableSipICE);
}

void CSipCntl::TipPrepareRatesInLocalCaps(WORD nStreams, BYTE bIsVideoAux)
{
	CMedString str;

	DWORD currVidRate = m_pCall->GetVideoCallRate(cmCapReceive);//m_pCall->GetCallRate(cmCapReceive);// need to take lower rate between call and remote

	DWORD newAudRate  = (nStreams == 1 ? 128 : 256);// audio rate is 128 in case of 1 screen (audio + aux) or 256 in case of 3 screens (3*audio +aux)

	newAudRate = newAudRate * 10;


	DWORD minTIPlineRate = GetSystemCfgFlagInt<DWORD>(CFG_KEY_MIN_TIP_COMP_LINE_RATE) * 10;

	if (minTIPlineRate == 0)
		minTIPlineRate = 10240;

	str << "m_pNetSetup->GetMaxRate: " << m_pNetSetup->GetMaxRate() / 100 << ", GetCallRate: " << m_pCall->GetCallRate(cmCapReceive);

	PTRACE2(eLevelInfoNormal, "CSipCntl::TipPrepareRatesInLocalCaps: ", str.GetString());

	str.Clear();

	if( currVidRate == 0 )
		currVidRate = m_pNetSetup->GetMaxRate() / 100;

	str << "curr video rate: " << currVidRate << ", max allowed rate: " << currVidRate << ", min allowed rate: " << minTIPlineRate;

	PTRACE2(eLevelInfoNormal, "CSipCntl::TipPrepareRatesInLocalCaps: ", str.GetString());

	str.Clear();

	//	if (currVidRate > maxTIPlineRate && maxTIPlineRate > minTIPlineRate)
	//		currVidRate = maxTIPlineRate;

	if (currVidRate < minTIPlineRate)
		currVidRate = minTIPlineRate;

	// need to add video auxiliary rate to calculation
	DWORD newVidRate = currVidRate * nStreams;

	if (bIsVideoAux)
		newVidRate += 5000; // Add 0.5M to call rate in case of content. We open TIP content with 5fps and according to TIP the rate should be 0.5M
							// In case of other fps (1 or 30), we need to make some changes to address it.

	DWORD newCallRate = newAudRate + newVidRate;

	str << "call rate: " << newCallRate << ", newAudRate: " << newAudRate<< ", currVidRate: " << newVidRate << ", bIsVideoAux: " << bIsVideoAux;

	PTRACE2(eLevelInfoNormal, "CSipCntl::TipPrepareRatesInLocalCaps: ", str.GetString());

//	CSipChannel* pAudChannel = GetChannel(cmCapAudio,cmCapReceive);

	m_tipAudioRate = newAudRate;
	m_tipVideoRate = newVidRate;

//	if (pAudChannel)
//		pAudChannel->SetTipBitRate(newAudRate);

//	CSipChannel* pVidChannel = GetChannel(cmCapVideo,cmCapReceive);
//
//	if (pVidChannel)
//	{
		//pVidChannel->SetTipBitRate(newVidRate);
	    PTRACE(eLevelInfoNormal, "CSipCntl::TipPrepareRatesInLocalCaps remove HP:");

		m_pNetSetup->SetMaxRate(newCallRate * 100);

		m_pChosenLocalCap->RemoveCapsForTIPCall();
		m_pChosenLocalCap->RemoveH264SpecifProfileCapSet(eH264CapCode,kRolePeople,H264_Profile_High);
		m_pChosenLocalCap->SetVideoRateInallCaps(currVidRate/*newVidRate*/);
//	}
}


////////////////////////////////////////////////////////
//VNFR-22823 - check if SDP is ICE compatible
BYTE CSipCntl::isSdpICECompatible(char *pSdpString, DWORD sdpSize)
{
	//PTRACE(eLevelInfoNormal,"isSdpICECompatible");
	int 	length 		= 0;
	DWORD 	strSize 	= 0;

//	char* pStrTail 		= NULL;
//	char *pSdpPointer 	= NULL;
//	char *TmpPtr;

	BOOL IsGeneralSessionUfrag		= FALSE;
	BOOL IsGeneralSessionPwd		= FALSE;
	BOOL isGeneralSessionCandidate  = FALSE;

	if (sdpSize && pSdpString)
	{
//		pSdpPointer = pSdpString;
//
//		while (strSize < sdpSize)
//		{
//			length = 0;
//
//			pStrTail = strstr(pSdpPointer,"\r\n");
//
//			if (pStrTail)
//			{
//				length = pStrTail - pSdpPointer;
//
//				if (length > 2)
//				{
//					char* pOneLineString = new char[length+1];
//					strncpy(pOneLineString,pSdpPointer,length);
//					pOneLineString[length] = '\0';

					if (strstr(pSdpString, "a=ice-ufrag"))
						IsGeneralSessionUfrag = TRUE;

					if (strstr(pSdpString, "a=ice-pwd"))
						IsGeneralSessionPwd = TRUE;

					if (strstr(pSdpString, "a=candidate:") || strstr(pSdpString, "a=x-candidate-ipv6:"))
						isGeneralSessionCandidate = TRUE;

//					PDELETEA(pOneLineString);
//
//					if (IsGeneralSessionUfrag && IsGeneralSessionPwd &&  isGeneralSessionCandidate)
//						break;
//				}
//			}
//			else
//				break;
//
//			strSize   = strSize + length+2; //+2 for /r/n
//			TmpPtr = strstr(pSdpPointer,"\r\n");
//			pSdpPointer = TmpPtr+2;
//		}

	} else
		return FALSE;

	if (IsGeneralSessionUfrag && IsGeneralSessionPwd &&  isGeneralSessionCandidate)
		return TRUE;
	else
		return FALSE;
}

////////////////////////////////////////////
int CSipCntl::GetContentCapsCountInSentSdp()
{
    int contentCapsCount = 0;
    sipMediaLineSt* pMediaLine = GetMediaLine(*m_pLocalSdp, kMediaLineInternalTypeContent);

    capBuffer* pCapBuffer = (capBuffer*) &pMediaLine->caps[0];
    const BYTE*	pTemp = (const BYTE*)pCapBuffer;

    // VNGR-25210
    if(pMediaLine != NULL)
    {
		for (unsigned int i = 0 ; i < pMediaLine->numberOfCaps; i++)
		{
			CCapSetInfo capInfo = (CapEnum) pCapBuffer->capTypeCode;

			if (capInfo.IsType(cmCapVideo))   // to make sure that this is not belongs to ice,lpr,sdes.
				contentCapsCount++;

			pTemp += sizeof(capBufferBase) + pCapBuffer->capLength;
			pCapBuffer = (capBuffer*)pTemp;
		}
	}

    return contentCapsCount;
}

// ---------------------------- BFCP ----------------------------------------
/////////////////////////////////////////////////////////////////////////////
void CSipCntl::CreateSipBfcpCtrl()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::CreateSipBfcpCtrl");

	BOOL isToCreateBfcpCntrl = TRUE;
	sipMediaLineSt* pMediaLine = NULL;

	TRACECOND_AND_RETURN(!m_pParty, "CSipCntl::CreateSipBfcpCtrl: m_pParty is NULL!!");

	if(m_pRemoteSdp)
	{
		if(m_pRemoteSdp->sipHeadersOffset)
		{
			pMediaLine = GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeBfcp);
			if(!pMediaLine)
				isToCreateBfcpCntrl = FALSE;
		}
	}

	eSipBfcpMode4DialOut mode = CalcBfcpMode4DialOut();

	if (m_pParty && isToCreateBfcpCntrl)
	{
		if (m_pSipBfcpCtrl)
			POBJDELETE(m_pSipBfcpCtrl);

		m_pSipBfcpCtrl = new CSipBfcpCtrl(m_pParty,mode);
	}

	if (IsValidPObjectPtr(m_pSipBfcpCtrl))
	{
		enTransportType  transType 		= (mode == BFCP_TCP_ONLY) ? eTransportTypeTcp : eTransportTypeUdp;
		eBFCPConnection  connection 	= kConnectionNew;
		eBfcpConnection  apiConnection 	= bfcp_connection_new;
		//eBFCPSetup 		 setup 			= kSetupPassive;
		eBfcpFloorCtrl   floorCtrl		= bfcp_flctrl_s_only;

		if(pMediaLine)
			transType = ConvertBfcpMediaLineSubTypeToTransportType((eMediaLineSubType)pMediaLine->subType);

        TRACEINTO << "transType= " << (int)transType << " McuNum " << ((int)(m_pParty->GetMcuNum())) << " TerminalNum " << ((int)(m_pParty->GetTerminalNum()));

		if (m_pParty)
			m_pSipBfcpCtrl->Initialize(m_pMfaInterface, m_pPartyApi, m_pParty->GetMcuNum(), m_pParty->GetTerminalNum(), transType, m_remoteIdent);

		if(m_pRemoteSdp && m_pRemoteSdp->sipHeadersOffset && m_pLastRemoteCaps)
		{
			if (isToCreateBfcpCntrl) /* bridge-6818 - if remote doesn't have bfcp sdp yet, (C60 ice fallback) we offered bfcp client instead of server */
			floorCtrl       = GetAnswerFloorCtrl(m_pLastRemoteCaps->GetBfcpFloorCtrlAttribute());

			apiConnection 	= m_pLastRemoteCaps->GetBfcpConnectionAttribute();
			connection 		= ConvertApiToBFCPConnectionType(apiConnection);

			//if(transType == eTransportTypeTcp || eTransportTypeTls)
				m_pSipBfcpCtrl->SetBfcpConnMode(ConvertApiToBFCPSetupType(m_pLastRemoteCaps->GetBfcpSetupAttribute()));

		}

		m_pSipBfcpCtrl->SetBfcpConnection(connection);

		eBfcpSetup apiSetup = ConvertBFCPSetupTypeToApi(m_pSipBfcpCtrl->GetBfcpSetupMode());

		eBfcpMStreamType mstreamType = GetMStreamType();

		if (m_pChosenLocalCap)
		{
			m_pChosenLocalCap->SetBfcpTransportType(transType);
			m_pChosenLocalCap->SetBfcpParameters(apiSetup, apiConnection, floorCtrl, mstreamType);
			m_pChosenLocalCap->SetFloorIdParamsForBfcp(BFCP_FLOOR_ID_PPC, STREAM_LABEL_CONTENT);
		}

		if (m_pMaxLocalCaps)
		{
			m_pMaxLocalCaps->SetBfcpTransportType(transType);
			m_pMaxLocalCaps->SetBfcpParameters(apiSetup, apiConnection, floorCtrl, mstreamType);
			m_pMaxLocalCaps->SetFloorIdParamsForBfcp(BFCP_FLOOR_ID_PPC, STREAM_LABEL_CONTENT);
		}

		if (m_pFullLocalCaps)
		{
			m_pFullLocalCaps->SetBfcpTransportType(transType);
			m_pFullLocalCaps->SetBfcpParameters(apiSetup, apiConnection, floorCtrl, mstreamType);
			m_pFullLocalCaps->SetFloorIdParamsForBfcp(BFCP_FLOOR_ID_PPC, STREAM_LABEL_CONTENT);
		}

		if (m_pPartialLocalCaps)
		{
			m_pPartialLocalCaps->SetBfcpTransportType(transType);
			m_pPartialLocalCaps->SetBfcpParameters(apiSetup, apiConnection, floorCtrl, mstreamType);
			m_pPartialLocalCaps->SetFloorIdParamsForBfcp(BFCP_FLOOR_ID_PPC, STREAM_LABEL_CONTENT);
		}

		WORD confId = 0;
		WORD userId = 0;

		CSipComMode *pTargetMode = (CSipComMode*) m_pParty->GetTargetMode();

		if (pTargetMode)
		{
			pTargetMode->SetBfcpTransportType(transType);
			pTargetMode->SetBfcpParameters(apiSetup, apiConnection, floorCtrl, mstreamType);
			pTargetMode->SetFloorIdParamsForBfcp(BFCP_FLOOR_ID_PPC, STREAM_LABEL_CONTENT);

			confId = pTargetMode->GetBfcpConfId();
			userId = pTargetMode->GetBfcpUserId();
		}

		CSipComMode *pTargetModeMax = (CSipComMode*) m_pParty->GetTargetModeMaxAllocation();

		if (pTargetModeMax)
		{
			pTargetModeMax->SetBfcpTransportType(transType);
			pTargetModeMax->SetBfcpParameters(apiSetup, apiConnection, floorCtrl, mstreamType);
			pTargetModeMax->SetFloorIdParamsForBfcp(BFCP_FLOOR_ID_PPC, STREAM_LABEL_CONTENT);

			pTargetModeMax->SetConfUserIdForBfcp(confId, userId);
		}

		UpdateBfcpTransportType(transType, FALSE);
	}
}

eSipBfcpMode4DialOut CSipCntl::CalcBfcpMode4DialOut()
{
    eSipBfcpMode4DialOut mode = BFCP_FULL_FLOW;

    CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());

	//AS-SIP conf support only in BFCP-UDP
	if (pCommConf && pCommConf->GetIsAsSipContent())
	{
		mode = BFCP_UDP_ONLY;
	}
	else
	{
  	  if(!(m_pRemoteSdp && m_pRemoteSdp->sipHeadersOffset && m_pLastRemoteCaps)) //Dial Out or Dial In no SDP
    	  {
        	CSysConfig *sysConfig = CProcessBase::GetProcess()->GetSysConfig();
        	std::string dialOutMode;
        	sysConfig->GetDataByKey(CFG_KEY_SIP_BFCP_DIAL_OUT_MODE, dialOutMode);

	        if(dialOutMode.compare("UDP")==0)
        	    mode = BFCP_UDP_ONLY;
        	else if(dialOutMode.compare("TCP")==0)
            		mode = BFCP_TCP_ONLY;

		//added for ANAT
		if (IsAnatSupported())
		mode = BFCP_UDP_ONLY;
 	   }
	}

    return mode;
}


eBfcpMStreamType CSipCntl::GetMStreamType()
{
	if(m_pRemoteSdp && m_pLastRemoteCaps)
	{
		eBfcpMStreamType mstreamType = m_pLastRemoteCaps->GetBfcpMStreamType();
		if(mstreamType != bfcp_m_stream_None)
			m_bfcpMStreamType = mstreamType;
	}

	if(((m_remoteIdent != PolycomEp && m_remoteIdent != AvayaEP) && m_bfcpMStreamType== bfcp_m_stream_None) || (m_bfcpMStreamType == bfcp_mstrm))
		return bfcp_mstrm;
	else
		return bfcp_m_stream;
}

/////////////////////////////////////////////////////////////////////////////
eMediaLineSubType CSipCntl::GetBfcpType() const
{
	eMediaLineSubType subType = eMediaLineSubTypeNull;

	if(m_pSipBfcpCtrl)
		subType = ConvertBfcpTransportToMediaLineSubType(m_pSipBfcpCtrl->GetBfcpTransportType());

	return subType;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSipCntl::IsSipBfcpCtrlMessage(OPCODE opCode)
{
	if ((opCode == IP_CM_BFCP_MESSAGE_IND) || (opCode == IP_CM_BFCP_MESSAGE_REQ))
		return TRUE;

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateBfcpParametersByRemoteSdp(BOOL isToFixTransport)
{
    PTRACE(eLevelInfoNormal,"CSipCntl::UpdateBfcpParametersByRemoteSdp");

	if(m_pRemoteSdp && m_pRemoteSdp->sipHeadersOffset && m_pLastRemoteCaps && m_pSipBfcpCtrl)
	{
		//if(m_pSipBfcpCtrl->GetBfcpTransportType() == eTransportTypeTcp || m_pSipBfcpCtrl->GetBfcpTransportType() == eTransportTypeTls)
		m_pSipBfcpCtrl->SetBfcpConnMode(ConvertApiToBFCPSetupType(m_pLastRemoteCaps->GetBfcpSetupAttribute()));

		eBfcpConnection connection 	= m_pLastRemoteCaps->GetBfcpConnectionAttribute();
		eBfcpFloorCtrl  floorCtrl	= GetAnswerFloorCtrl(m_pLastRemoteCaps->GetBfcpFloorCtrlAttribute());
		eBfcpSetup setup 		    = ConvertBFCPSetupTypeToApi(m_pSipBfcpCtrl->GetBfcpSetupMode());
		eBfcpMStreamType mstreamType = GetMStreamType();

		m_pChosenLocalCap->SetBfcpParameters(setup, connection, floorCtrl, mstreamType);

		if(isToFixTransport)
		{
		    sipMediaLineSt* pBfcpMediaLine = GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeBfcp);

		    if(pBfcpMediaLine)
		    {
		        enTransportType receivedBfcpTransType = ConvertBfcpMediaLineSubTypeToTransportType((eMediaLineSubType)pBfcpMediaLine->subType);

		        if(receivedBfcpTransType != m_pSipBfcpCtrl->GetBfcpTransportType())
		        {
		            PTRACE(eLevelInfoNormal,"CSipCntl::UpdateBfcpParametersByRemoteSdp - fixing different protocols");
		            UpdateBfcpTransportType(eUnknownTransportType, FALSE);
		            m_pSipBfcpCtrl->UpdateParams(receivedBfcpTransType, m_remoteIdent);
		            m_pChosenLocalCap->SetBfcpTransportType(receivedBfcpTransType);
		        	m_pSipBfcpCtrl->SetBfcpConnMode(ConvertApiToBFCPSetupType(m_pLastRemoteCaps->GetBfcpSetupAttribute()));
		            m_pParty->HandleBfcpScmAndCaps();
		        }
		    }
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateBfcpTransportType(enTransportType transType, BOOL isUpdateBfcpCntl)
{
	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	if (pCommConf)
	{
	    CConfParty* pConfParty = pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());
	    if (pConfParty)
	        pConfParty->SetBfcpTransportType(transType);
	    else
	        PTRACE(eLevelError,"CSipCntl::UpdateBfcpTransportType - pConfParty is NULL - can not SetBfcpTransportType");
	}
	else
	    PTRACE(eLevelError,"CSipCntl::UpdateBfcpTransportType - pCommConf is NULL - can not SetBfcpTransportType");

	if(m_pSipBfcpCtrl && isUpdateBfcpCntl)
		m_pSipBfcpCtrl->UpdateParams(transType, m_remoteIdent);
}
/////////////////////////////////////////////////////////////////////////////
void CSipCntl::DeclareOnContentFromScmOnly(BYTE bIsToDeclareFromScmOnly)
{
	m_bDeclareOnContentFromScmOnly = bIsToDeclareFromScmOnly;
}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::RemoveH263FromRemoteIfNeeded(CSipChanDifArr* pDifArr)
{
	PASSERTMSG_AND_RETURN(!pDifArr || !m_pParty , "!pDifArr || !m_pParty");

	CCapSetInfo h263capInfo (eH263CapCode);

	BOOL bIsOnHold 				= 	m_pParty && (m_pParty->GetNonTipPartyOnHold() != eMediaOnHoldNon );
	BOOL bIsTipCall				= 	GetIsTipCall();
	BOOL bIsCurrMediaNotOnHold 	=   CheckIfCallisPutOnHoldByMedia(pDifArr) == eMediaOnHoldNon;
	BOOL bIsCurrMediaNotResume 	=   CheckIfCallisResumedByMedia(pDifArr) == eMediaOnHoldNon;

	TRACEINTO << " bIsOnHold " << (int)bIsOnHold << " bIsTipCall " << (int)bIsTipCall
			  << " bIsCurrMediaNotOnHold " << (int)bIsCurrMediaNotOnHold << " bIsCurrMediaNotResume " << (int)bIsCurrMediaNotResume;

	if(bIsOnHold && !bIsTipCall && bIsCurrMediaNotOnHold && bIsCurrMediaNotResume)
	{
		TRACEINTO << "Possible loopback SDP from CUCM -We are still on hold - Removing H263 from Remote caps to prevent changemode";
		m_pLastRemoteCaps->RemoveCapSet(h263capInfo);

	}
}
//////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateReceivedBfcpProtocol()
{
    PTRACE(eLevelInfoNormal,"CSipCntl::UpdateReceivedBfcpProtocol");
	sipMediaLineSt* pBfcpMediaLine = NULL;
	CMedString str;

	//add for ANAT
	if (IsAnatSupported())
		pBfcpMediaLine = GetMLineAccordingToInternalTypeAndIpVersion(kMediaLineInternalTypeBfcp, m_pRemoteSdp, m_AnatSelectedIpVersion);
	else
		pBfcpMediaLine = GetMediaLine(*m_pRemoteSdp, kMediaLineInternalTypeBfcp);

	if (pBfcpMediaLine)
	{
		enTransportType receivedBfcpTransType 	= ConvertBfcpMediaLineSubTypeToTransportType((eMediaLineSubType)pBfcpMediaLine->subType);

		int nReceivedBfcpPort 					= pBfcpMediaLine->mediaIp.transAddr.port;

		str << " receivedBfcpTransType= " << receivedBfcpTransType << "\n nReceivedBfcpPort=" << nReceivedBfcpPort;
		PTRACE2(eLevelInfoNormal,"CSipCntl::UpdateReceivedBfcpProtocol ", str.GetString());

		if (m_pSipBfcpCtrl && m_pSipBfcpCtrl->GetBfcpTransportType() == eTransportTypeUdp)
		{
			bool bIsNeedReInviteBfcp 		= (nReceivedBfcpPort == 0) || (receivedBfcpTransType != eTransportTypeUdp);
			bool bIsNeedClearRemoteBfcpCap 	= nReceivedBfcpPort != 0 && receivedBfcpTransType != eTransportTypeUdp;

			//fix remove remote TCP/BFCP to flow the same as received UDP 0.
			//if(bIsNeedClearRemoteBfcpCap)
			//	m_pLastRemoteCaps->CleanMedia(cmCapBfcp);

			PTRACE2INT(eLevelInfoNormal,"CSipCntl::UpdateReceivedBfcpProtocol bIsNeedReInviteBfcp=",bIsNeedReInviteBfcp);

			//Switch transport to TCP in order to reinvite
			if (bIsNeedReInviteBfcp)
			{
				//m_pSipBfcpCtrl->UpdateParams(eTransportTypeTcp, m_remoteIdent);
				UpdateBfcpTransportType(eTransportTypeTcp);
				m_pSipBfcpCtrl->SetBfcpConnMode(eTcpPassive);

				m_pChosenLocalCap->SetBfcpTransportType(eTransportTypeTcp);
			}
			else
			{
				UpdateBfcpTransportType(eTransportTypeUdp);
				UpdateBfcpParametersByRemoteSdp();

				m_pChosenLocalCap->SetBfcpTransportType(eTransportTypeUdp);
			}

		}
		else if(m_pSipBfcpCtrl && (m_pSipBfcpCtrl->GetBfcpTransportType() == eTransportTypeTcp || m_pSipBfcpCtrl->GetBfcpTransportType() == eTransportTypeTls))
		{
			if ((nReceivedBfcpPort == 0) && (receivedBfcpTransType == eTransportTypeTcp || receivedBfcpTransType == eTransportTypeTls || receivedBfcpTransType == eTransportTypeUdp)) // --> BRIDGE-2807
			{
				UpdateBfcpTransportType(eUnknownTransportType);
			}
		}
	}
	else if(m_pRemoteSdp && m_pRemoteSdp->sipHeadersOffset) //no bfcp mline
	{
	    PTRACE(eLevelInfoNormal,"CSipCntl::UpdateReceivedBfcpProtocol - no bfcp mline");
	    UpdateBfcpTransportType(eUnknownTransportType);
	}
}

////////////////////////////////////////////////////////////////////////////////////
eSipBfcpMode4DialOut CSipCntl::GetBfcpMode4DialOut() const
{
    eSipBfcpMode4DialOut mode = BFCP_FULL_FLOW;

    if(m_pSipBfcpCtrl)
        mode = m_pSipBfcpCtrl->GetDialOutMode();

    return mode;
}
///////////////////////////////////////////////////////////////////////////////////////

BOOL CSipCntl::IsUndefinedParty()
{
	CCommConf* pCommConf 	= ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());

	PASSERTMSG_AND_RETURN_VALUE(pCommConf==NULL, "GetCurrentConf returned NULL", FALSE);

	CConfParty* pConfParty 	= pCommConf->GetCurrentParty(m_pParty->GetMonitorPartyId());
	PASSERTMSG_AND_RETURN_VALUE(pConfParty==NULL, "GetCurrentParty returned NULL", FALSE);

	return pConfParty->IsUndefinedParty();
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::GetConfEncryptionMode()
{
	CCommConf* pCommConf 	= ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());

	BYTE EncryptionType = eEncryptNone;
	if (pCommConf)
	{
		EncryptionType = pCommConf->GetEncryptionType();
	}
	return 	 EncryptionType;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CSipCntl::IsWhenAvailableEncryptionMode()
{
	CCommConf* pCommConf 	= ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	if (pCommConf && (pCommConf->GetEncryptionType() == eEncryptWhenAvailable) )
		return TRUE;
	else
		return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CSipCntl::IsEncryptAllMode()
{
	CCommConf* pCommConf 	= ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	if (pCommConf && (pCommConf->GetEncryptionType() == eEncryptAll) )
		return TRUE;
	else
		return FALSE;
}

void CSipCntl::SendReqToSipProxy(CSegment *pSeg, OPCODE opcode)
{
    TRACESTR(eLevelInfoNormal) <<" CSipCntl::SendReqToSipProxy - opcode = " << (DWORD)opcode << ",  Name - " << PARTYNAME;

    CSipProxyTaskApi api(m_serviceId);
    api.SendMsg(pSeg, opcode);

}

void CSipCntl::OnDialogRecoveryMessageInd(CSegment *pSeg)
{
  TRACESTR(eLevelInfoNormal) <<" CSipCntl::OnDialogRecoveryMessageInd - Name - " << PARTYNAME;

  CCommConf* pCommConf  = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
  if( !pCommConf || (pCommConf->GetServiceRegistrationContentRegister(m_serviceId-1) == FALSE) ) //What should we do if we shouldn't be registered?
  {
    SendDialogRecoveryMsgToCS(1);
    return;
  }

   CSegment*  pSendSeg = new CSegment;
  *pSendSeg << (DWORD)m_pParty->GetMonitorConfId();
  *pSendSeg << pCommConf->GetName();
  *pSendSeg << (DWORD)m_pCsRsrcDesc->GetPartyRsrcId();
  *pSendSeg << (DWORD)m_pCsRsrcDesc->GetConnectionId();


  SendReqToSipProxy(pSendSeg, DIALOG_RECOVERY_IND);

  StartTimer(DIALOG_RECOVERY_TIMER, 36 * SECOND);

}
void CSipCntl::OnDialogRecoveryMessageIndDisconnecting(CSegment *pSeg)
{
  TRACESTR(eLevelInfoNormal) <<" CSipCntl::OnDialogRecoveryMessageIndDisconnecting - Name - " << PARTYNAME;
  SendDialogRecoveryMsgToCS(0);
}

void CSipCntl::OnDialogRecoveryFromProxy(CSegment *pSeg)
{
  TRACESTR(eLevelInfoNormal) <<" CSipCntl::OnDialogRecoveryFromProxy - Name - " << PARTYNAME;
  DWORD status=0;
  *pSeg >> status;
  if( IsValidTimer(DIALOG_RECOVERY_TIMER) )
     DeleteTimer(DIALOG_RECOVERY_TIMER);

  SendDialogRecoveryMsgToCS(status);
}

void CSipCntl::SendDialogRecoveryMsgToCS(DWORD status)
{
  mcReqDialogRecovery* pMsg = new mcReqDialogRecovery;
  size_t size = sizeof(mcReqDialogRecovery);
  memset(pMsg, 0, size);
  pMsg->status = status;
  SendSIPMsgToCS(SIP_CS_SIG_DIALOG_RECOVERY_REQ, pMsg, size);

  PDELETE(pMsg);
}

void CSipCntl::OnDialogRecoveryTimeOut(CSegment *pSeg)
{
  TRACESTR(eLevelInfoNormal) <<" CSipCntl::OnDialogRecoveryTimeOut - Name - " << PARTYNAME;
  SendDialogRecoveryMsgToCS(0);
}
///////////////////////////////////////////////////////////////////////////////////////

void     CSipCntl::SetRecevRingback(BOOL flag)
{
    m_bRingback= flag;
}

///////////////////////////////////////////////////////////////////////////////////////

BOOL     CSipCntl::GetRecevRingback()
{
    return m_bRingback;
}

//-------TCP-KEEP-ALIVE ---------------------------------------------------------------------//
//==================================================================//
void   CSipCntl::crlf_vGetKaParametersFromFormatedString(  char  * szMsKeepAlive_Data
                                               , DWORD * pKa_Frequency
                                               , DWORD * pnKa_PongTimeout
                                               , DWORD * pnKa_Behavior
                                               , DWORD * pnKa_Tipe)
{
    if(NULL != szMsKeepAlive_Data)
    {
        char * apStr[4];
        int    nDataLen     = strlen(szMsKeepAlive_Data);
        int    nInd         = 0;
        int    nI           = 0;

        apStr[0]= szMsKeepAlive_Data;
        apStr[1]= NULL;
        apStr[2]= NULL;
        apStr[3]= NULL;

        for(nInd = 0; nInd < nDataLen; nInd++)
        {
            if('|' == szMsKeepAlive_Data[nInd])
            {
                szMsKeepAlive_Data[nInd] ='\0';
                nI++;
                apStr[nI] = &szMsKeepAlive_Data[nInd+1];
            }
        }

        if(NULL != apStr[0])
            *pKa_Frequency = atoi(apStr[0]);
        if(NULL != apStr[1])
            *pnKa_PongTimeout = atoi(apStr[1]);
        if(NULL != apStr[2])
            *pnKa_Behavior = atoi(apStr[2]);
        if(NULL != apStr[3])
            *pnKa_Tipe = atoi(apStr[3]);
    }
}
//==================================================================//
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::GetKeppAliveParameters ()
{
    DWORD rmtMsKeepAliveTimeOut = 0;
    char cHeaderValue[256] = {0};
    CSipHeader* pMsKeepAlive  = NULL;

    memset(cHeaderValue, '\0', sizeof(cHeaderValue));

    sipMessageHeaders *pRmtHeaders = GetRmtHeaders();
    if(pRmtHeaders)
    {
        CSipHeaderList cRmtHeaders(*pRmtHeaders);
        pMsKeepAlive  = (CSipHeader*) cRmtHeaders.GetNextHeader(kMsKeepAliveTimeout);
        if ( pMsKeepAlive )
        {
            strncpy(cHeaderValue, pMsKeepAlive->GetHeaderStr(), sizeof(cHeaderValue)-1);
            cHeaderValue[sizeof(cHeaderValue)-1] = '\0';

            this->crlf_vGetKaParametersFromFormatedString(
                cHeaderValue, &this->m_dwKeepAliveFrequency_Sec, &this->m_MsKeepAlivePongTimeOut
              , &this->m_dwKeppAliveBehavior, &this->m_dwKeepAliveType);
        }
    }
    return;
}
////////////////////////////////////////////////////////////////////////////////
//-------TCP-KEEP-ALIVE -------------END-----------------------------------------------------//

////////////////////////////////////////////////////////////////////////////////
DWORD CSipCntl::GetRmtMsKeepAliveTimeOut()
{
  DWORD rmtMsKeepAliveTimeOut = 0;
  char cHeaderValue[256] = {0};
  CSipHeader* pMsKeepAlive  = NULL;

  sipMessageHeaders *pRmtHeaders = GetRmtHeaders();
  if(pRmtHeaders)
  {
    CSipHeaderList cRmtHeaders(*pRmtHeaders);
    pMsKeepAlive  = (CSipHeader*) cRmtHeaders.GetNextHeader(kMsKeepAliveTimeout);
    if ( pMsKeepAlive )
    {
      strncpy(cHeaderValue, pMsKeepAlive->GetHeaderStr(), sizeof(cHeaderValue)-1);
      cHeaderValue[sizeof(cHeaderValue)-1] = '\0';
      rmtMsKeepAliveTimeOut = atoi(cHeaderValue);
    }
  }
  return rmtMsKeepAliveTimeOut;
}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnMsKeepAliveClientTimeOut(CSegment *pSeg)
{
  mcReqSendCrlf* pMsg = new mcReqSendCrlf;
  size_t size = sizeof(mcReqSendCrlf);
  memset(pMsg, 0, size);
  pMsg->dwMsKepAliveTimeOut_Sec = m_dwKeepAliveFrequency_Sec;

  pMsg->registrarTransportAddr.unionProps.unionSize = sizeof(ipAddressIf);

  SendSIPMsgToCS(SIP_CS_SIG_SEND_CRLF_REQ, pMsg, size);

  PDELETE(pMsg);

  if(m_MsKeepAlivePongTimeOut > 0)
       StartTimer(MS_KEEP_ALIVE_SERVER_TIMER, (m_MsKeepAlivePongTimeOut) * SECOND);//SOCKET ACTIVITY DETECTION
  else
  if(m_dwKeepAliveFrequency_Sec > 0)
      StartTimer(MS_KEEP_ALIVE_CLIENT_TIMER, (m_dwKeepAliveFrequency_Sec/2) * SECOND);
}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::vStoreTcpAliveParameters()
{
    char szKeppAliveParams[MaxIdentifierSize] = {0};
    sipMessageHeaders *pRemoteSipHeaders = GetRmtHeaders();//

    if (pRemoteSipHeaders)
    {
        ::SipGetHeaderValue(pRemoteSipHeaders, kMsKeepAliveTimeout, szKeppAliveParams, MaxIdentifierSize);
        this->crlf_vGetKaParametersFromFormatedString(
            szKeppAliveParams, &this->m_dwKeepAliveFrequency_Sec, &this->m_MsKeepAlivePongTimeOut
            , &this->m_dwKeppAliveBehavior, &this->m_dwKeepAliveType);
    }

    {
        char szLog[256]="";
        sprintf(szLog, "%d|%d|%d|%d"
            ,m_dwKeepAliveFrequency_Sec, m_MsKeepAlivePongTimeOut, m_dwKeppAliveBehavior, m_dwKeepAliveType);
        PTRACE2(eLevelError,"TCP-KEEP-ALIVE:  INVITE IND. - ",szLog);
    }
    return;
}
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnMsKeepAliveServerTimeOut(CSegment *pSeg)
{
  mcReqIndSocketStatistics* pMsg = new mcReqIndSocketStatistics;
  size_t size = sizeof(mcReqIndSocketStatistics);
  memset(pMsg, 0, size);
  SendSIPMsgToCS(SIP_CS_SIG_SOCKET_ACTIVITY_REQ, pMsg, size);
  PDELETE(pMsg);
  //StartTimer(MS_KEEP_ALIVE_CLIENT_TIMER, m_MsKeepAliveClientTout/2 * SECOND);
}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnMsSocketActivityInd(CSegment *pSeg)
{
  APIU32 callIndex = 0;
  APIU32 channelIndex = 0;
  APIU32 mcChannelIndex = 0;
  APIU32 stat1 = 0;
  APIU16 srcUnitId = 0;

  *pSeg >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

  mcReqIndSocketStatistics* pMcIndSocket = (mcReqIndSocketStatistics *)pSeg->GetPtr(1);
  DWORD silenceTimeRecv = pMcIndSocket->dwSilenceTimeRecv_mSec;
  DWORD silenceTimeSend = pMcIndSocket->dwSilenceTimeSend_mSec;

  BOOL  bisReRegistering = FALSE;

  //PTRACE2INT(eLevelInfoNormal,"Sasha-Tmp. CSipCntl::OnMsSocketActivityInd  silenceTimeRecv: ", silenceTimeRecv);
  //PTRACE2INT(eLevelInfoNormal,"Sasha-Tmp. CSipCntl::OnMsSocketActivityInd  silenceTimeSend: ", silenceTimeSend);


  if(1 == m_dwKeepAliveType)//MS; Call- INCOMING
  {
      if(m_MsKeepAlivePongTimeOut > 0)
        StartTimer(MS_KEEP_ALIVE_SERVER_TIMER, m_MsKeepAlivePongTimeOut * SECOND);

      if(  ((silenceTimeRecv == 0xFFFFFFFF)||(silenceTimeSend == 0xFFFFFFFF))
         ||(silenceTimeRecv >= m_MsKeepAlivePongTimeOut)
        )
      {
          bisReRegistering = TRUE;
      }
  }
  else
  if((2 == m_dwKeepAliveType)||(3 == m_dwKeepAliveType))//RFC-5662 | RFC-6223
  {
      if((0 == m_dwKeepAliveFrequency_Sec)&&(m_MsKeepAlivePongTimeOut > 0))//INCOMING
          StartTimer(MS_KEEP_ALIVE_SERVER_TIMER, m_MsKeepAlivePongTimeOut * SECOND);
      else
          if(m_dwKeepAliveFrequency_Sec > 0) //OUTGOING
            StartTimer(MS_KEEP_ALIVE_CLIENT_TIMER, (m_dwKeepAliveFrequency_Sec/2) * SECOND);

      if(  ((silenceTimeRecv == 0xFFFFFFFF)||(silenceTimeSend == 0xFFFFFFFF))
          ||(silenceTimeRecv >= m_MsKeepAlivePongTimeOut)
          )
      {
          bisReRegistering = TRUE;
      }
  }
  else{
	  // do nothing
  }

  if(TRUE == bisReRegistering)
  {
      if(0 != m_dwKeppAliveBehavior)//Re-REGISTERING
      {
          PTRACE(eLevelInfoNormal," CSipCntl::OnMsSocketActivityInd. Re-REGISTER procedure.");

          CCommConf* pCommConf  = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
          if( !pCommConf || (pCommConf->GetServiceRegistrationContentRegister(m_serviceId-1) == FALSE) ) //What should we do if we shouldn't be registered?
          {
              DeleteTimer(MS_KEEP_ALIVE_CLIENT_TIMER);
              DeleteTimer(MS_KEEP_ALIVE_SERVER_TIMER);
              if(m_dwKeepAliveFrequency_Sec > 0)
                StartTimer(MS_KEEP_ALIVE_CLIENT_TIMER, (m_dwKeepAliveFrequency_Sec/2) * SECOND);
          }
          else
          {
              CSegment*  pSendSeg = new CSegment;
              *pSendSeg << (DWORD)m_pParty->GetMonitorConfId();
              *pSendSeg << pCommConf->GetName();
              *pSendSeg << (DWORD)m_pCsRsrcDesc->GetPartyRsrcId();
              *pSendSeg << (DWORD)m_pCsRsrcDesc->GetConnectionId();

              DeleteTimer(MS_KEEP_ALIVE_CLIENT_TIMER);
              DeleteTimer(MS_KEEP_ALIVE_SERVER_TIMER);

              PTRACE(eLevelInfoNormal,"CSipCntl::OnMsSocketActivityInd.  Re-REGISTER ordered");
              SendReqToSipProxy(pSendSeg, DIALOG_RECOVERY_IND);
              PTRACE(eLevelInfoNormal,"CSipCntl::OnMsSocketActivityInd.  2*CRLF continue ");
              if(m_dwKeepAliveFrequency_Sec > 0)
                StartTimer(MS_KEEP_ALIVE_CLIENT_TIMER, (m_dwKeepAliveFrequency_Sec) * SECOND);
          }
      }
  }
}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnMsKeepAliveErrInd(CSegment *pSeg)
{
  APIU32 callIndex = 0;
  APIU32 channelIndex = 0;
  APIU32 mcChannelIndex = 0;
  APIU32 stat1 = 0;
  APIU16 srcUnitId = 0;

  *pSeg >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

  mcIndSigCrlfError* pMcIndCrlf = (mcIndSigCrlfError *)pSeg->GetPtr(1);
  DWORD errorCode = pMcIndCrlf->eCrlfSendingErrorCode;

  switch(errorCode)
  {
    case 0:
    case 2:
       TRACESTR(eLevelInfoNormal) <<" CSipCntl::OnMsKeepAliveErrInd - disconnect";
       m_pPartyApi->SipPartyCallFailed(SIP_REMOTE_STOP_RESPONDING);
       break;
    case 1:
      TRACESTR(eLevelInfoNormal) <<" CSipCntl::OnMsKeepAliveErrInd - stop timer";
      if (IsValidTimer(MS_KEEP_ALIVE_CLIENT_TIMER))
      {
        DeleteTimer(MS_KEEP_ALIVE_CLIENT_TIMER);
      }
    break;
    default:
      TRACESTR(eLevelInfoNormal) <<" CSipCntl::OnMsKeepAliveErrInd - default";
      if (IsValidTimer(MS_KEEP_ALIVE_CLIENT_TIMER))
      {
        DeleteTimer(MS_KEEP_ALIVE_CLIENT_TIMER);
      }
      break;
 }
}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SipBfcpReconnect()
{
	if (m_state == IP_CONNECTED || m_state == IP_CHANGEMODE)
	{
		SipCloseChannelReq(BFCP_IN);
		SipCloseChannelReq(BFCP_OUT);

		m_bBfcpReconnect         	= TRUE;
		m_bfcpChannelsAckCounter 	= 2;
		//Begin:modified by Richer for 8072
		m_pParty->ClearNumOfBfcpReestablish();
		//End:modified by Richer for 8072
	}
	else
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::SipBfcpReconnect, don't try to reconnect in state: ", m_state);
}

////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetRemoteIdent(RemoteIdent rmtIdent)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetRemoteIdent, new remote ident: ", rmtIdent);

	m_remoteIdent = rmtIdent;
}
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendStartFecToCM(BOOL isFecStartedBecauseOfLync2013)
{

	if(GetIsFecStarted() == FALSE)
	{
		SetIsFecStarted(TRUE);

		TActivePacketLossReq *pStruct = new TActivePacketLossReq;

		pStruct->channelType			= (APIU32)kIpVideoChnlType;

		if (isFecStartedBecauseOfLync2013 == TRUE)
			pStruct->channelDirection	= (APIU32)cmCapReceiveAndTransmit;
		else //for old FEC (RTV)
			pStruct->channelDirection	= (APIU32)cmCapTransmit;

		pStruct->bIsIce                 = (APIU32)GetIsIceCall();

		SendMsgToMpl((BYTE*)(pStruct), sizeof(TActivePacketLossReq), ACTIVATE_PACKET_LOSS_REQ );

		PTRACE(eLevelInfoNormal,"LYNC2013_FEC_RED: CSipCntl::SendStartFecToCM - Send to CM -  ACTIVATE_PACKET_LOSS_REQ");

	//	SendIntraReqToEP();
	}
	else
		PTRACE(eLevelInfoNormal,"LYNC2013_FEC_RED: CSipCntl::SendStartFecToCM - already updated CM");

}
//////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendStartRedToCM()
{

	if(GetIsRedStarted() == FALSE)
	{
		SetIsRedStarted(TRUE);

		TActivePacketLossReq *pStruct = new TActivePacketLossReq;

		pStruct->channelType			= (APIU32)kIpAudioChnlType;
		pStruct->channelDirection		= (APIU32)cmCapReceiveAndTransmit;
		pStruct->bIsIce                 = (APIU32)GetIsIceCall();

		SendMsgToMpl((BYTE*)(pStruct), sizeof(TActivePacketLossReq), ACTIVATE_PACKET_LOSS_REQ );

		PTRACE(eLevelInfoNormal,"LYNC2013_FEC_RED: CSipCntl::SendStartRedToCM - Send to CM -  ACTIVATE_PACKET_LOSS_REQ");

	}
	else
		PTRACE(eLevelInfoNormal,"LYNC2013_FEC_RED: CSipCntl::SendStartRedToCM - already updated CM");

}
////////////////////////////////////////////////////////////////////////////////
/*void CSipCntl::SendIntraReqToEP()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SendIntraReqToEP");

	if (IsValidTimer(FECINTRATOUT))
		DeleteTimer(FECINTRATOUT);

	StartTimer(FECINTRATOUT,  0.5*SECOND);

	CSegment *pParam = new CSegment;
	*pParam << (DWORD)kRolePeople;
	*pParam << (DWORD)eTipVideoPosCenter;
	SendFastUpdateReq(pParam);
	POBJDELETE(pParam);


}
*/
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendFecOrRedReqToART(DWORD type, WORD status)
{
	TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId()
			  << ", type:" << type << " ,m_FecFractionLossInPercent:" << m_FecFractionLossInPercent << ", m_RedFractionLossInPercent:" << m_RedFractionLossInPercent;

	TFEC_RED_OnOffReq *pStruct = new TFEC_RED_OnOffReq;

	if (type == cmCapVideo)
	{

		pStruct->bunIsOnOff		    = (APIU32)GetIsFecOn(); 
		pStruct->eMediaType         = kIpVideoChnlType;
		pStruct->unDspFractionLoss  = (APIU32)m_FecFractionLossInPercent;

		SetIsActiveFecFlow(FALSE);

		if (m_savedFecPacketLossStatus.isNeedToHandleNewData == TRUE)
		{
			TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId()
					  << " - need to handle another FEC msg that we got";

			m_savedFecPacketLossStatus.isNeedToHandleNewData = FALSE;
			HandleFecPacketLossInd(m_savedFecPacketLossStatus.fractionLossInPercent,m_savedFecPacketLossStatus.mediaType,m_savedFecPacketLossStatus.ssrc);
		}

	}
	else  // type == 1 == cmCapAudio
	{

		pStruct->bunIsOnOff		    = (APIU32)GetIsRedOn();
		pStruct->eMediaType         = kIpAudioChnlType;
		pStruct->unDspFractionLoss  = (APIU32)m_RedFractionLossInPercent;

		SetIsActiveRedFlow(FALSE);

		if (m_savedRedPacketLossStatus.isNeedToHandleNewData == TRUE)
		{
			TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId()
					  << " - need to handle another RED msg that we got";
			m_savedRedPacketLossStatus.isNeedToHandleNewData = FALSE;
			HandleRedPacketLossInd(m_savedRedPacketLossStatus.fractionLossInPercent,m_savedRedPacketLossStatus.mediaType,m_savedRedPacketLossStatus.ssrc);
		}

	}

	pStruct->FecFrameRatio		= (APIU32)1; // default is 1.

	if (status == statOK)
		SendMsgToMpl((BYTE*)(pStruct), sizeof(TFEC_RED_OnOffReq), ART_FEC_RED_ON_OFF_REQ);
	else
		TRACEINTO << "LYNC2013_FEC_RED: status is not OK";

	PDELETE(pStruct);

}
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::CloseFecOrRedDueToChannelClose(CSipChannel *pChannel)
{
	if(pChannel)
	{
		if ( (pChannel->GetMediaType() == cmCapVideo) && ( pChannel->GetDirection() == cmCapTransmit) && (GetIsFecStarted() == TRUE) )
		{
			TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId() << " - close FEC!!!";
			SetIsFecStarted(FALSE);
			SetIsFecOn(FALSE); 
		}
		if ( (pChannel->GetMediaType() == cmCapAudio) && ( pChannel->GetDirection() == cmCapTransmit) && (GetIsRedStarted() == TRUE) )
		{
			TRACEINTO << "LYNC2013_FEC_RED: PartyID:" << m_pParty->GetPartyId() << " - close RED!!!";
			SetIsRedStarted(FALSE);
			SetIsRedOn(FALSE); 
		}
	}
}
////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SetRtcpMaskIntoCall(APIS32 rtcpFeedback)
{
	CSipChannel* pContentChannel = m_pCall->GetChannel(true, cmCapVideo, cmCapReceive, kRolePresentation);
	CSmallString str;

	str << "rtcpFeedback = " <<  rtcpFeedback;

	if(pContentChannel)
	{
		CBaseVideoCap* pContCap = (CBaseVideoCap*)pContentChannel->GetDataAsCapClass();
		if (pContCap)
		{
			pContCap->SetRtcpFeedbackMask(rtcpFeedback);
			POBJDELETE(pContCap);
		}
		else
			str << " ## no alloc channel";
	}
	else
		str << " ## no channel";

	PTRACE2(eLevelInfoNormal,"CSipCntl::SetRtcpMaskIntoCall() ", str.GetString());

}

/////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::CheckIfCallIsResumed(CSipChanDifArr* pDifArr)
{
	TRACECOND_AND_RETURN_VALUE(!m_pParty->GetTipPartyOnHold() && !m_bIsResuming , "CSipCntl::CheckIfCallIsResumed GetTipPartyOnHold = FALSE, not on hold", FALSE);
	BYTE bIsResumeMedia = FALSE;
	if( pDifArr )
	{
		CSipChanDif* pAudOutChanDif = pDifArr->GetChanDif(cmCapAudio, cmCapTransmit);
		CSipChanDif* pVidOutChanDif = pDifArr->GetChanDif(cmCapVideo, cmCapTransmit);

		if ( (pAudOutChanDif && (pAudOutChanDif->IsUnMute() || pAudOutChanDif->IsAddChannel())) ||//&& pAudInChanDif->IsUnMute())
			 (pVidOutChanDif && (pVidOutChanDif->IsUnMute() || pVidOutChanDif->IsAddChannel())) )//pVidInChanDif->IsUnMute()))
		{
			bIsResumeMedia 	= TRUE;
			m_bIsResuming 	= TRUE;

			if (m_bIsResuming)
				m_bIsOnHold = FALSE;
		}
	}

	PTRACE2INT(eLevelInfoNormal, "CSipCntl::CheckIfCallIsResumed, bIsResumeMedia: ", bIsResumeMedia);
	return bIsResumeMedia;
}
/////////////////////////////////////////////////////////////////////////////////

BYTE CSipCntl::CheckIfCallIIsPutOnHold(CSipChanDifArr* pDifArr)
{
	BYTE bIsHoldMedia = FALSE;
	if( pDifArr )
	{
		CSipChanDif* pAudOutChanDif = pDifArr->GetChanDif(cmCapAudio, cmCapTransmit);
		CSipChanDif* pVidOutChanDif = pDifArr->GetChanDif(cmCapVideo, cmCapTransmit);
		if ( (pAudOutChanDif && (pAudOutChanDif->IsRemoveChannel() || pAudOutChanDif->IsMute() )) &&
			 (pVidOutChanDif && (pVidOutChanDif->IsRemoveChannel() || pVidOutChanDif->IsMute() ))
		   )
		{
			bIsHoldMedia 	= TRUE;
			m_bIsOnHold 	= TRUE;

			if (m_bIsOnHold)
				m_bIsResuming = FALSE;
		}
	}
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::CheckIfCallIIsPutOnHold, bIsHoldMedia: ", bIsHoldMedia);
	return bIsHoldMedia;
}
/////////////////////////////////////////////////////////////////////////////////
enMediaOnHold CSipCntl::CheckIfCallisResumedByMedia(CSipChanDifArr* pDifArr)
{
	enMediaOnHold enResumeMedia = eMediaOnHoldNon;
	if( pDifArr )
	{
		CSipChanDif* pAudInChanDif = pDifArr->GetChanDif(cmCapAudio, cmCapTransmit);
		CSipChanDif* pVidInChanDif = pDifArr->GetChanDif(cmCapVideo, cmCapTransmit);

		if (pAudInChanDif && (pAudInChanDif->IsUnMute() || pAudInChanDif->IsAddChannel()))
		{
			enResumeMedia = eMediaOnHoldAudio;
		}
		 if(pVidInChanDif && (pVidInChanDif->IsUnMute() || pVidInChanDif->IsAddChannel()))
		{
			if(eMediaOnHoldAudio == enResumeMedia)
			{
				enResumeMedia 	= eMediaOnHoldAplusV;
			}
			else
				enResumeMedia = eMediaOnHoldVideo;
		}
	}

	PTRACE2INT(eLevelInfoNormal, "CSipCntl::CheckIfCallisResumedByMedia, enResumeMedia: ", (WORD) enResumeMedia);
	return enResumeMedia;
}

enMediaOnHold CSipCntl::CheckIfCallisPutOnHoldByMedia(CSipChanDifArr* pDifArr)
{
	enMediaOnHold enHoldMedia = eMediaOnHoldNon;
	if( pDifArr )
	{
		CSipChanDif* pAudInChanDif = pDifArr->GetChanDif(cmCapAudio, cmCapTransmit);
		CSipChanDif* pVidInChanDif = pDifArr->GetChanDif(cmCapVideo, cmCapTransmit);
		if ( pAudInChanDif && (pAudInChanDif->IsMute()|| pAudInChanDif->IsRemoveChannel()) )
		{
			enHoldMedia  = eMediaOnHoldAudio;
		}
		if (pVidInChanDif && (pVidInChanDif->IsMute()|| pVidInChanDif->IsRemoveChannel()) )
		{
			if(eMediaOnHoldAudio == enHoldMedia)
			{
				enHoldMedia = eMediaOnHoldAplusV;
			}
			else
				enHoldMedia = eMediaOnHoldVideo;
		}
	}
	PTRACE2INT(eLevelInfoNormal, "CSipCntl::CheckIfCallisPutOnHoldByMedia, enHoldMedia: ", (WORD) enHoldMedia);
	return enHoldMedia;
}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::FillAndSendMrmpRtcpFirStruct(RelayIntraParam *pIntraParam, DWORD channelHandle)
{
	if((!m_bIsMrcCall) && m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvcVsw)
	{
		TRACEINTO<<"avc_vsw_relay CSipCntl::FillAndSendMrmpRtcpFirStruct: sending FastUpdateReq for kVswRelayAvc";
		FastUpdateReq(kRolePeople,eTipVideoPosCenter);
		return;
	}

	int listSsrcSize = 0;
	TICKS curTimer = SystemGetTickCount();
	unsigned int syncSources[MAX_NUM_RECV_STREAMS_FOR_FIR_FILTER];
	std::list<unsigned int>::iterator itr;

	for (itr = pIntraParam->m_listSsrc.begin(); itr != pIntraParam->m_listSsrc.end(); itr++)
	{

		if (listSsrcSize >= MAX_NUM_RECV_STREAMS_FOR_FIR_FILTER)
		{
			PTRACE(eLevelError, "CSipCntl::FillAndSendMrmpRtcpFirStruct, listSsrcSize is oversize, failed to add ssrc");
			break;
		}

		// VNGSWIBM-300
//		if (m_pParty->FirFilter(*itr, curTimer))
//		{
			syncSources[listSsrcSize] = (*itr);
			listSsrcSize++;
//		}
	}
	if (listSsrcSize == 0)
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::FillAndSendMrmpRtcpFirStruct, listSsrcSize == 0, original size = ", pIntraParam->m_listSsrc.size());
		return;
	}

	int size = sizeof(MrmpRtcpFirStruct) + sizeof(APIU32) * (listSsrcSize - 1);

	char *buf = new char[size];

	MrmpRtcpFirStruct* pStruct = (MrmpRtcpFirStruct*) buf;

    pStruct->unSequenseNumber = 0;
	pStruct->unChannelHandle = channelHandle;
	pStruct->nNumberOfSyncSources = listSsrcSize;
	pStruct->bIsGdr = ( (true==pIntraParam->m_bIsGdr) ? TRUE : FALSE );

	for (int i = 0; i < listSsrcSize; i++)
		pStruct->syncSources[i] = syncSources[i];

	SendMsgToMpl((BYTE*)(pStruct), size, CONF_PARTY_MRMP_RTCP_FIR_REQ);

	delete [] buf;
}

void CSipCntl::OnScpStreamsRequest(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"_scp_flow_ CSipCntl::OnScpStreamsRequest");
    m_pPartyApi->SipPartyScpRequestFromEP(pParam);
}


void CSipCntl::OnScpStreamsNotificationFromEpInd(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnScpStreamsNotificationFromEpInd");
	m_pPartyApi->SipPartyScpNotificationIndFromEP(pParam);
}

void CSipCntl::OnScpStreamNotificationAckInd(CSegment* pParam)
{
	APIU32 channelHandle = 0;
	APIU32 remoteSequenceNumber = 0;
	APIUBOOL bIsAck = FALSE;

	*pParam >> channelHandle
			>> remoteSequenceNumber
			>> bIsAck;

	TRACEINTOFUNC << " - channelHandle: " << channelHandle << ", remoteSeqNum: " << remoteSequenceNumber << ", IsAck: " << bIsAck;

	m_pPartyApi->SipPartyScpNotificationAckFromEP(channelHandle, remoteSequenceNumber, bIsAck);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendAckForScpReq(unsigned int aSequenceNumber)
{
	PTRACE(eLevelInfoNormal,"_scp_flow_ CSipCntl::SendAckFroScpReq ");
    DWORD seqNum = 0;
	CSipChannel* pChannel = NULL;
	cmCapDirection channelDirection=cmCapTransmit;
	ERoleLabel eRole=kRolePeople;
	cmCapDataType mediaType=cmCapData;

	pChannel = m_pCall->GetChannel(true, mediaType, channelDirection, eRole);
	if (!pChannel)
	{
	    PTRACE(eLevelInfoNormal,"_scp_flow_ CSipCntl::SendAckForScpReq scp flow channel is NULL ");
	    return;
	}

	MrmpScpAckStruct* pAckIndStruct = new MrmpScpAckStruct;
	pAckIndStruct->bIsAck=TRUE;

	if(pChannel)
		pAckIndStruct->unChannelHandle=pChannel->GetChannelHandle();
	else
		PASSERTMSG(1, "GetChannel return NULL");

	/*  temporary code for scp ack   */
	pAckIndStruct->unRemoteSequenseNumber = aSequenceNumber;


	PTRACE2INT(eLevelInfoNormal,"_scp_flow_ CSipCntl::SendAckFroScpReq scp flow ended sequenceNumber= ", aSequenceNumber);

    seqNum = SendMsgToMpl((BYTE*)(pAckIndStruct), sizeof(MrmpScpAckStruct), CONF_PARTY_MRMP_SCP_STREAM_ACK_REQ);

	POBJDELETE(pAckIndStruct);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendAckFroScpNotificationInd(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal, "CSipCntl::SendAckFroScpNotificationInd ");

	APIU32 sequenceNum;
	*pParam >> sequenceNum;

	CSipChannel* pChannel;
	cmCapDirection channelDirection=cmCapTransmit;
	ERoleLabel eRole=kRolePeople;
	cmCapDataType mediaType=cmCapData;

	pChannel = m_pCall->GetChannel(true, mediaType, channelDirection, eRole);

	MrmpScpAckStruct* pAckReqStruct = new MrmpScpAckStruct;
	pAckReqStruct->bIsAck=TRUE;
	if(pChannel)
		pAckReqStruct->unChannelHandle = pChannel->GetChannelHandle();
	else
		PASSERTMSG(1, "GetChannel() return NULL");

	pAckReqStruct->unRemoteSequenseNumber = sequenceNum;

	TRACEINTOFUNC << " sequenceNumber=" << sequenceNum << ", channelHandle=" << pAckReqStruct->unChannelHandle;

	DWORD seqNum = 0;
	seqNum = SendMsgToMpl((BYTE*)(pAckReqStruct), sizeof(MrmpScpAckStruct), CONF_PARTY_MRMP_SCP_STREAM_NOTIFICATION_ACK_REQ);

	POBJDELETE(pAckReqStruct);
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdateRelayChannel(CSipChannel *pChannel)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::UpdateRelayChannel");
	mcTransportAddress rmtAddress;
	memset(&rmtAddress, 0, sizeof(mcTransportAddress));
	APIU32 rmtRtcpPort = 0;
	BYTE isUpdate = TRUE;
	BYTE confIsEncrypted = FALSE;
	int chnType=OPEN_CHANNEL_NORMAL_MODE;

	if (m_pParty->GetTargetMode()->GetIsEncrypted() == Encryp_On && pChannel->IsMediaChannel())
	{
		confIsEncrypted = TRUE;
		PTRACE(eLevelInfoNormal,"Encryp_On");
	}

	if(m_pRemoteSdp)
	{
		//for ANAT
		int	index = -1;
		eMediaLineInternalType mlineInternalType = GetMediaLineInternalType(pChannel->GetMediaType(), pChannel->GetRoleLabel());
		BOOL isANATContained = IsANATPresentInSDP(m_pRemoteSdp);

		if (isANATContained)  //need the condition "isUpdate=NO"?
		{
			index = GetIndexAccordingToInternalTypeAndIpVersion(mlineInternalType, m_pRemoteSdp, m_AnatSelectedIpVersion);
		}

		rmtRtcpPort = ExtractMLineRtcpPort(mlineInternalType, (const sipSdpAndHeadersSt *)m_pRemoteSdp, rmtRtcpPort, confIsEncrypted, index);
		rmtAddress = ExtractMLineMediaIp(mlineInternalType, (const sipSdpAndHeadersSt *)m_pRemoteSdp, m_dummyMediaIp, confIsEncrypted, index).transAddr;
	}

	OpenSvcChannel(pChannel, rmtAddress, rmtRtcpPort, OPEN_CHANNEL_NORMAL_MODE, isUpdate);
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::OpenSvcChannel(CSipChannel *pChannel, mcTransportAddress &rmtAddress, APIU32 rmtRtcpPort,BYTE mode, BYTE isUpdate)
{
	char s[50];
	DWORD seqNum = 0;
	kChanneltype channelType ;

	sprintf(s, "\nDest address is 0x%x", rmtAddress.addr.v4.ip);
	TRACEINTOFUNC << "IsUpdate: " << ( isUpdate ? "true" : "false" ) << s;

	MrmpOpenChannelRequestStruct* pStruct = new MrmpOpenChannelRequestStruct;
	memset(pStruct,0,sizeof(MrmpOpenChannelRequestStruct));

	channelType = ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel());
	pStruct->m_channelType = channelType;

	TRACEINTO << "mix_mode: channelType = " << ChanneltypeToString(channelType)
		<< " media type = " << ::GetTypeStr(pChannel->GetMediaType())
		<< " role = " << ::GetRoleStr(pChannel->GetRoleLabel());

    if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc)
    {
		if (mode == OPEN_CHANNEL_MIX_MODE)
		{
		    if (channelType == kIpAudioChnlType)
		    {
		        pStruct->m_channelType = kAvcToSacChnlType;
		        TRACEINTO << "channelType set to kAvcToSacChnlType";
		    }
		    else
		    {
                pStruct->m_channelType = kSvcAvcChnlType;
                TRACEINTO << "channelType set to kSvcAvcChnlType";
		    }
		}
    }

    if (!m_bIsMrcCall && m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvcVsw)
    {
    	if (mode == OPEN_CHANNEL_VSW_RELAY)
 		{
 			pStruct->m_channelType		 = kAvcVSWChnType;//kUnknownChnlType; //kSvcAvcChnlType; /* kAvcVSWChnType need to change APICOM for a new channel type  */
 		}
    }

	pStruct->m_channelDirection = pChannel->GetDirection();
    pStruct->m_partyId=m_pParty->GetPartyRsrcID();

	//Todo to had the content type
    if (channelType == kIpContentChnlType || channelType == kBfcpChnlType)
    {
    	TRACEINTOFUNC << "m_channelType==kIpContentChnlType. Call standard function, channel type: "
			<< ChanneltypeToString(channelType);
        Cm_FillAndSendOpenUdpPortOrUpdateUdpAddrStruct(pChannel, rmtAddress, rmtRtcpPort, isUpdate);
        PDELETE(pStruct);

        return;
    }

	//fill local address
	// IpV6
	enIpVersion eIpAddrMatch = eIpVersion4;
	if (m_state == IP_CHANGEMODE)
		eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetSipLocalMediaType(),m_UdpAddressesParams.IpType);
	else
		eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);

	pStruct->m_localAddress.ipVersion = eIpAddrMatch;

	bool bIsLocalAddressIpV4 = ( (pStruct->m_localAddress.ipVersion == (APIU32)eIpVersion4) ? true : false );
	if (true == bIsLocalAddressIpV4)
	{
		pStruct->m_localAddress.addr.v4.ip = m_UdpAddressesParams.IpV4Addr.ip;
	}

	else
	{
		// --- UDP: array of addresses ---
		// First we will look for the best IpV6 address match -> Meaning we will match ScopeId's
		BYTE place = FindMatchingIpV6MediaAddressByScopeId();
		memcpy(pStruct->m_localAddress.addr.v6.ip, m_UdpAddressesParams.IpV6AddrArray[place].ip, 16);
		pStruct->m_localAddress.addr.v6.scopeId = m_UdpAddressesParams.IpV6AddrArray[place].scopeId;
	}
	pStruct->m_localAddress.transportType = eTransportTypeUdp;


	//fill remote address
	pStruct->m_remoteAddress.ipVersion = eIpAddrMatch;

	bool bIsRemoteAddressIpV4 = ( (pStruct->m_remoteAddress.ipVersion == (APIU32)eIpVersion4) ? true : false );
    if (true == bIsRemoteAddressIpV4) //v4
	{
		pStruct->m_remoteAddress.addr.v4.ip = rmtAddress.addr.v4.ip;
	}
	else
	{
		memcpy(pStruct->m_remoteAddress.addr.v6.ip, rmtAddress.addr.v6.ip, 16);
		pStruct->m_remoteAddress.addr.v6.scopeId = rmtAddress.addr.v6.scopeId;
	}


    // send to trace (local and remote addresses)
    if (bIsLocalAddressIpV4 && bIsRemoteAddressIpV4)
    {
    	TRACEINTOFUNC << "Local address type: IPv4, remote address type: IPv4";
    }

    else
    {
        TRACEINTOFUNC
        	<< "Local address type: " << ( bIsLocalAddressIpV4 ? "IPv4" : "IPv6" )
        	<< ", remote address type: " << ( bIsRemoteAddressIpV4 ? "IPv4" : "IPv6" );

        if (!bIsLocalAddressIpV4)
        {
    		BYTE place = FindMatchingIpV6MediaAddressByScopeId();
        	TRACEINTOFUNC << "Local address type: Ipv6, place: " << place;
        }

        if (!bIsRemoteAddressIpV4)
        {
        	TRACEINTOFUNC << "Remote address type: Ipv6, scope: " << rmtAddress.addr.v6.scopeId;
        }
    }



	//fill fields for both local and remote addresses
   pStruct->m_localAddress.distribution  = eDistributionUnicast;// Don't Care
   pStruct->m_localAddress.distribution = eDistributionUnicast;// Don't Care

   pStruct->m_remoteAddress.transportType = eTransportTypeUdp;


   // fill local rtcp address




   	pStruct->m_localRtcpAddress.ipVersion = eIpAddrMatch;

   	bool bIsLocalRtcpAddressIpV4 = ( (pStruct->m_localRtcpAddress.ipVersion == (APIU32)eIpVersion4) ? true : false );
	if (true == bIsLocalRtcpAddressIpV4) //v4
	{
		pStruct->m_localRtcpAddress.addr.v4.ip = m_UdpAddressesParams.IpV4Addr.ip;
	}

	else
	{
		// --- UDP: array of addresses ---
		// First we will look for the best IpV6 address match -> Meaning we will match ScopeId's
		BYTE place = FindMatchingIpV6MediaAddressByScopeId();
		memcpy(pStruct->m_localRtcpAddress.addr.v6.ip, m_UdpAddressesParams.IpV6AddrArray[place].ip, 16);
		pStruct->m_localRtcpAddress.addr.v6.scopeId = m_UdpAddressesParams.IpV6AddrArray[place].scopeId;
	}
	pStruct->m_localRtcpAddress.transportType = eTransportTypeUdp;


	//fill remote rtcp address
	pStruct->m_remoteRtcpAddress.ipVersion = eIpAddrMatch;

	bool bIsRemoteRtcpAddressIpV4 = ( (pStruct->m_remoteRtcpAddress.ipVersion == (APIU32)eIpVersion4) ? true : false );
    if (true == bIsRemoteRtcpAddressIpV4) //v4
	{
		pStruct->m_remoteRtcpAddress.addr.v4.ip = rmtAddress.addr.v4.ip;
	}
	else
	{
		memcpy(pStruct->m_remoteRtcpAddress.addr.v6.ip, rmtAddress.addr.v6.ip, 16);
		pStruct->m_remoteRtcpAddress.addr.v6.scopeId = rmtAddress.addr.v6.scopeId;
	}


	// send to trace (local and remote RTCP addresses)
	if (bIsLocalRtcpAddressIpV4 && bIsRemoteRtcpAddressIpV4)
	{
		TRACEINTOFUNC << "Local RTCP address type: IPv4, remote RTCP address type: IPv4";
	}

	else
	{
		TRACEINTOFUNC
			<< "Local RTCP address type: " << ( bIsLocalRtcpAddressIpV4 ? "IPv4" : "IPv6" )
			<< ", remote RTCP address type: " << ( bIsRemoteRtcpAddressIpV4 ? "IPv4" : "IPv6" );

		if (!bIsLocalAddressIpV4)
		{
			BYTE place = FindMatchingIpV6MediaAddressByScopeId();
			TRACEINTOFUNC << "Local RTCP address type: Ipv6, place: " << place;
		}

		if (!bIsRemoteAddressIpV4)
		{
			TRACEINTOFUNC << "Remote RTCP address type: Ipv6, scope: " << rmtAddress.addr.v6.scopeId;
		}
	}


	//fill fields for both local and remote addresses
    pStruct->m_localRtcpAddress.distribution  = eDistributionUnicast;// Don't Care
    pStruct->m_localRtcpAddress.distribution = eDistributionUnicast;// Don't Care

    pStruct->m_remoteRtcpAddress.transportType = eTransportTypeUdp;

	// end rtcp

	cmCapDataType dataType = pChannel->GetMediaType();
	ERoleLabel eRole = pChannel->GetRoleLabel();

	pStruct->ice_channel_rtp_id = 0;
	pStruct->ice_channel_rtcp_id = 0;
	pStruct->bIsIceEnable = FALSE;

	if (GetIsEnableICE() && m_pIceParams)
	{
		pStruct->bIsIceEnable = TRUE;
	}

	switch (dataType)
	{
		case cmCapAudio:

			pStruct->m_localAddress.port  = m_UdpAddressesParams.AudioChannelPort;
			pStruct->m_remoteAddress.port = rmtAddress.port;
			pStruct->m_localRtcpAddress.port			  = m_UdpAddressesParams.AudioChannelPort + 1;
			pStruct->m_remoteRtcpAddress.port			  = rmtRtcpPort;

			if ((GetIsEnableICE() || m_bNeedUpdateIceToNonIce) && m_pIceParams)
			{
				pStruct->ice_channel_rtp_id = m_pIceParams->GetAudioRtpId();
				pStruct->ice_channel_rtcp_id = m_pIceParams->GetAudioRtcpId();
			}


		break;

		case cmCapVideo:

			if (eRole == kRolePeople)
			{
				pStruct->m_localAddress.port  = m_UdpAddressesParams.VideoChannelPort;
				pStruct->m_remoteAddress.port = rmtAddress.port;
				pStruct->m_localRtcpAddress.port			  = m_UdpAddressesParams.VideoChannelPort + 1;
				pStruct->m_remoteRtcpAddress.port			  = rmtRtcpPort;

				if ((GetIsEnableICE() || m_bNeedUpdateIceToNonIce) && m_pIceParams)
				{
					pStruct->ice_channel_rtp_id = m_pIceParams->GetVideoRtpId();
					pStruct->ice_channel_rtcp_id = m_pIceParams->GetVideoRtcpId();
				}
			}
			else
			{
				pStruct->m_localAddress.port  = m_UdpAddressesParams.ContentChannelPort;
				pStruct->m_remoteAddress.port = rmtAddress.port;
				pStruct->m_localRtcpAddress.port			  = m_UdpAddressesParams.ContentChannelPort + 1;
				pStruct->m_remoteRtcpAddress.port			  = rmtRtcpPort;


			}
			break;

		case cmCapData:

			pStruct->m_localAddress.port  = m_UdpAddressesParams.FeccChannelPort;
			pStruct->m_remoteAddress.port = rmtAddress.port;
			pStruct->m_localRtcpAddress.port			  = m_UdpAddressesParams.FeccChannelPort + 1;
			pStruct->m_remoteRtcpAddress.port			  = rmtRtcpPort;

			if ((GetIsEnableICE() || m_bNeedUpdateIceToNonIce) && m_pIceParams)
			{
				pStruct->ice_channel_rtp_id = m_pIceParams->GetDataRtpId();
				pStruct->ice_channel_rtcp_id = m_pIceParams->GetDataRtcpId();
			}

			break;

		default:
			pStruct->m_localAddress.port  = 0;
			pStruct->m_remoteAddress.port = 0;
			pStruct->m_localRtcpAddress.port			  = 0;
			pStruct->m_remoteRtcpAddress.port			  = 0;
			break;
	}

	pChannel->SetAddress(pStruct->m_localAddress);
	pChannel->SetRmtAddress(pStruct->m_remoteAddress);
	pChannel->SetRtcpPort(pStruct->m_localRtcpAddress.port);
	pChannel->SetRtcpRmtPort(pStruct->m_remoteRtcpAddress.port);


	memset(&(pStruct->physicalId), 0, sizeof(PHYSICAL_RESOURCE_INFO_S));

	pStruct->m_capTypeCode=pChannel->GetAlgorithm();

    if(m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc)
    {

		if(mode==OPEN_CHANNEL_MIX_MODE)
		{
			pStruct->m_capTypeCode=eSvcCapCode;
		}
    }

	pStruct->m_PayloadType=pChannel->GetPayloadType();

	// Temp bug of Fecc, remove it !!!!!!!!!!!!!!!!!
	if(m_bIsMrcCall && channelType==kIpFeccChnlType && pChannel->GetDirection()==cmCapTransmit)// Temp bug of Fecc, remove it !!!!!!!!!!!!!!!!!
		pStruct->m_PayloadType=100;// Temp bug of Fecc, remove it !!!!!!!!!!!!!!!!!



/////////////////////////////////////////////////////////////////
//	TRACEINTO << "hold hold - to be removed";
//	if (m_bIsMrcCall)
//	{
//		if (channelType==kIpAudioChnlType)
//		{
//			if (pChannel->GetDirection()==cmCapTransmit)
//				pStruct->m_PayloadType = 104;
//			else
//				pStruct->m_PayloadType = 127;
//		}
//		else if (channelType==kIpVideoChnlType)
//		{
//			if (pChannel->GetDirection()==cmCapTransmit)
//				pStruct->m_PayloadType = 105;
//			else
//				pStruct->m_PayloadType = 115;
//		}
//	}
//	TRACEINTO << "hold hold - to be removed";
/////////////////////////////////////////////////////////////////




	// temp temp temp
	pStruct->m_dtmfPayloadType=pChannel->GetDtmfPayloadType();

//	pStruct->tMrmpOpenChannelRequestMessage.m_capTypeCode = pChannel->GetAlgorithm();

  // setting spesific parameters - hardcoded for now:

	memset(pStruct->m_ssrcInfo, 0, (sizeof(IncomingSsrcInfo)*MAX_SSRC_PER_INCOMING_CHANNEL));

	pStruct->m_operationPointsSetId=m_pParty->GetConfId();//1;

//	int i=0,num=0;
//	channelSpecificParameters* pChannelParams=(channelSpecificParameters*)pChannel->GetData();

    if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc && mode==OPEN_CHANNEL_MIX_MODE)
    {
        APIU32* ssrcIds = NULL;
        int numOfSsrcIds = 0;
        if (channelType == kIpAudioChnlType)
        {
            m_pParty->GetTargetMode()->GetSsrcIds(cmCapAudio, cmCapReceive, ssrcIds, &numOfSsrcIds);
        }
        else
        {
            m_pParty->GetTargetMode()->GetSsrcIds(cmCapVideo, cmCapReceive, ssrcIds, &numOfSsrcIds);
        }

        TRACEINTO << "mix_mode: Open MRMP channel numOfSsrcIds=" << numOfSsrcIds;
        for (int i = 0; i < numOfSsrcIds; i++)
        {
            // add the channel to the channels array in SipCall
            TRACEINTO << "mix_mode: add SSRC #" << i << "=" << ssrcIds[i];
            pStruct->m_ssrcInfo[i].m_ssrc = ssrcIds[i];
        }
        delete []ssrcIds;
    }
    else if(m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvcVsw && mode==OPEN_CHANNEL_VSW_RELAY)
    {
		if(pStruct->m_channelType==kAvcVSWChnType && pChannel->GetDirection()==cmCapReceive) /* kAvcVSWChnType need to change APICOM for a new channel type  */
		{
			 pStruct->m_ssrcInfo[0].m_ssrc=m_pParty->GetSSRcIdsForAvc(0,cmCapReceive, cmCapVideo); // Rx //pChannelParams->pSvc.recvStreamsGroup.streams[i].streamSsrcId;
		}
		if(pStruct->m_channelType==kAvcVSWChnType && pChannel->GetDirection()==cmCapTransmit) /* kAvcVSWChnType need to change APICOM for a new channel type  */
		{
			//APIU32 txSsrc=0x000FFFFF & (m_pParty->GetSSRcIdsForAvc(0));  // Tx
			 pStruct->m_ssrcInfo[0].m_ssrc=m_pParty->GetSSRcIdsForAvc(0,cmCapTransmit, cmCapVideo); /*txSsrc;*/  //pChannelParams->pSvc.recvStreamsGroup.streams[i].streamSsrcId;
		}
    }
	else
	{
		int i=0;
		const std::list <StreamDesc> streamsDescList = pChannel->GetStreams();
		std::list <StreamDesc>::const_iterator itr_streams;

		for(itr_streams=streamsDescList.begin();itr_streams!=streamsDescList.end();itr_streams++)
		{
			pStruct->m_ssrcInfo[i].m_ssrc=itr_streams->m_pipeIdSsrc;
			i++;
		}
	}


	pStruct->m_videoFlag=YES;
	FillMrmpOpenChannelPhysicalIdInfo(pStruct, ((kChanneltype)channelType), pChannel->GetDirection(), m_pParty->GetTargetMode()->IsHdVswInMixMode());

	if(channelType == kIpVideoChnlType)
	{// update max video bit rate - needed for MBA
		cmCapDirection channelDirection = pChannel->GetDirection();
		DWORD audioRate = m_pParty->GetTargetMode()->GetMediaBitRate(cmCapAudio, channelDirection);
		DWORD contentRate = m_pParty->GetTargetMode()->GetMediaBitRate(cmCapVideo, channelDirection, kRoleContentOrPresentation);
		DWORD commonBR = m_pNetSetup->GetMaxRate() / 100;//m_pChosenLocalCap->GetMaxVideoBitRate();
		//Jason.MA : GetMaxVideoBitRate equals to the value of actureConfRate - audioRate, so repalce it with the acture Call Rate for BRIDGE-3004
		// Bella: commonBR  and contentRate are in (kbps * 10) units and audio in kbps
		if(contentRate > commonBR)
			contentRate = 0;
		pStruct->m_maxVideoBR = (commonBR - contentRate) / 10 - audioRate;
		TRACEINTOFUNC << "CSipCntl::OpenSvcChannel audio bit rate=" << audioRate
					<< " content bit rate=" << contentRate << " common bit rate=" << commonBR
					<< " max video bit rate=(commonBR - contentRate) / 10 - audioRate=" << pStruct->m_maxVideoBR;
	}
	else
	{
		pStruct->m_maxVideoBR = 0;
	}

	// uRtpKeepAlivePeriod
	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	if(pCommConf)
	{
		pStruct->uRtpKeepAlivePeriod = pCommConf->GetNatKAPeriod();
		TRACEINTOFUNC << "\npCommConf->GetNatKAPeriod(): " << pCommConf->GetNatKAPeriod()
					  << "\nuRtpKeepAlivePeriod:         " << pStruct->uRtpKeepAlivePeriod;
	}
	else
	{
		TRACEINTOFUNC << "GetCurrentConf return NULL";
	}


	if (dataType == cmCapAudio)
		pStruct->tosValue[MEDIA_TOS_VALUE_PLACE] = m_pQos->m_bIpAudio;
	else if ((dataType == cmCapVideo) && (eRole == kRolePeople))
		pStruct->tosValue[MEDIA_TOS_VALUE_PLACE] = m_pQos->m_bIpVideo;
	else if ((dataType == cmCapVideo) && (eRole & kRoleContentOrPresentation) && GetpPrecedenceSettingsDB() -> IsPrecedenceEnabled())
		pStruct->tosValue[MEDIA_TOS_VALUE_PLACE] = m_pQos->m_bIpVideo;
	else if ((dataType == cmCapBfcp) && GetpPrecedenceSettingsDB() -> IsPrecedenceEnabled())
		pStruct->tosValue[MEDIA_TOS_VALUE_PLACE] = m_pQos->m_bIpSignaling;
	else if ((dataType == cmCapData) && GetpPrecedenceSettingsDB() -> IsPrecedenceEnabled())
		pStruct->tosValue[MEDIA_TOS_VALUE_PLACE] = m_pQos->m_bIpVideo;
	else
		pStruct->tosValue[MEDIA_TOS_VALUE_PLACE] = 0;

	PTRACE2INT(eLevelInfoNormal, "CSipCntl::OpenSvcChannel - Setting TOS: ", pStruct->tosValue[MEDIA_TOS_VALUE_PLACE]);

	BOOL isRtcpQosIsEqualToRtp = NO;
	std::string key = "RTCP_QOS_IS_EQUAL_TO_RTP";
	CProcessBase::GetProcess()->GetSysConfig()->GetBOOLDataByKey(key, isRtcpQosIsEqualToRtp);
	if( isRtcpQosIsEqualToRtp )
		pStruct->tosValue[RTCP_TOS_VALUE_PLACE] = pStruct->tosValue[MEDIA_TOS_VALUE_PLACE];
	else
		pStruct->tosValue[RTCP_TOS_VALUE_PLACE] = m_pQos->m_bIpRtcp;


	//SRTP
	//memset(&pStruct->m_sDesCapSt, 0, sizeof(sdesCapSt));
	if(pChannel->IsChannelSdesEnabled() && (pStruct->m_channelType != kAvcVSWChnType))
	{
		CSdesCap* pSdesCap = NULL;
		pSdesCap = pChannel->GetChannelSdes();
		CopySdesCapsFromClassToStruct(&pStruct->m_sDesCapSt, pSdesCap);
	}
	else
	{
		pStruct->m_sDesCapSt.bIsSrtpInUse = 0;
	}

	///////////////////////////////////////////////
	// SIP disconnection detect timer
	if(!isUpdate)
	{
		CSipCall* pCall = pChannel->GetCallPtr();
		if((kIpAudioChnlType == pStruct->m_channelType ||kIpVideoChnlType == pStruct->m_channelType)
			&&(cmCapTransmit ==pStruct->m_channelDirection))
		{
			pStruct->ulDetectionTimerLen = pCall->GetMediaDetectionTimer();
			if(kIpVideoChnlType == pStruct->m_channelType)
			{
				pCall->SetMediaDetectioHasVideo(TRUE);
				pCall->SetMediaDetectioIsSvcOpened(TRUE);
			}
		}
		else
		{
			pStruct->ulDetectionTimerLen = 0;
		}
	}

	pStruct->mrdVersion.majorVer = m_mrdVersion.majorVer;
    pStruct->mrdVersion.middleVer = m_mrdVersion.middleVer;
    pStruct->mrdVersion.minorVer = m_mrdVersion.minorVer;

    pStruct->bIsLinkParty = FALSE;
    BYTE cascadeMode = GetCascadeMode();
    if ((cascadeMode == CASCADE_MODE_MASTER) || (cascadeMode == CASCADE_MODE_SLAVE))
    	pStruct->bIsLinkParty = TRUE;

	if(isUpdate)
	{
		seqNum = SendMsgToMpl((BYTE*)(pStruct), sizeof(MrmpOpenChannelRequestStruct), CONF_PARTY_MRMP_UPDATE_CHANNEL_REQ);
	}
	else
	{
		seqNum = SendMsgToMpl((BYTE*)(pStruct), sizeof(MrmpOpenChannelRequestStruct), CONF_PARTY_MRMP_OPEN_CHANNEL_REQ);
	}

	pChannel->SetSeqNumCm(seqNum);
	PDELETE(pStruct);
}

////////////////////////////////////////////////////////////////////////////
CSipChannel* CSipCntl::ShouldOpenMRMPAvcChannel(CSipChannel *pChannel,int& chnType)
{
	CSipChannel* pChannelEx=NULL;

	if (!pChannel)
	{
    	return NULL;
	}

	cmCapDataType dataType = pChannel->GetMediaType();
	ERoleLabel eRole = pChannel->GetRoleLabel();
	cmCapDirection direction=pChannel->GetDirection();

    if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc)
    {
		PTRACE(eLevelInfoNormal,"eyaln CSipCntl::ShouldOpenMRMPAvcChannel bIsActiveAvcToSvc==TRUE");
    	chnType=OPEN_CHANNEL_MIX_MODE;

        return NULL;
    }

    if (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvcVsw)
    {
		PTRACE(eLevelInfoNormal,"eyaln CSipCntl::ShouldOpenMRMPAvcChannel bIsActiveVswRelay==TRUE");
    	chnType=OPEN_CHANNEL_VSW_RELAY;
    }

    if (m_pParty->GetTargetMode()->GetConfMediaType() != eMixAvcSvc
   		&& m_pParty->GetTargetMode()->GetConfMediaType() != eMixAvcSvcVsw)
    {
		TRACEINTO << "Not mixMode and not MFW VSW - return NULL";
    	return NULL;
    }

	if (dataType==cmCapVideo &&
	    ((m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc && direction== cmCapReceive) ||
	     (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvcVsw))
		&& (eRole == kRolePeople) && (m_pParty->GetTargetMode()->GetConfType() != kCop))
	{
		pChannelEx=m_pCall->GetChannel(false, dataType, direction, eRole);
		PTRACE(eLevelInfoNormal,"eyaln CSipCntl::ShouldOpenMRMPAvcChannel should return true ");

		return pChannelEx; // bug_in_tests
	}

	return NULL;
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::CloseSvcChannel(CSipChannel *pChannel, BYTE mode)
{
    // content channels should use the regular functions
    kChanneltype channelType = ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel());
    if(channelType == kIpContentChnlType || channelType == kBfcpChnlType)
    {
        PTRACE(eLevelInfoNormal,"CSipCntl::CloseSvcChannel m_channelType: kIpContentChnlType, Call standard function");
        Cm_FillAndSendCloseUdpPortStruct(pChannel);
        return;
    }

    DWORD seqNum = 0;
    if(m_pMrmpInterface)
    {
        PTRACE2INT(eLevelInfoNormal,"CSipCntl::CloseSvcChannel - ConnectionId: ", m_pMrmpInterface->GetConnectionId());
    }
    else
    {
      TRACEINTO<<"!@# m_pMrmpInterface already NULL";
    }

    MrmpCloseChannelRequestStruct* pCloseStruct = new MrmpCloseChannelRequestStruct;
    memset(pCloseStruct, 0, sizeof(MrmpCloseChannelRequestStruct));
    MrmpCloseChannelRequestMessage*  pUdpCloseSt=&pCloseStruct->tMrmpCloseChannelRequestMessage;

    // ======== fill params

    // ----- channelHandle, m_channelDirection
    pUdpCloseSt->channelHandle=pChannel->GetChannelHandle();
    pUdpCloseSt->m_channelDirection = pChannel->GetDirection();

    // ----- m_channelType
    if( (m_pParty->GetTargetMode()->GetConfMediaType() == eMixAvcSvc) && (OPEN_CHANNEL_MIX_MODE == mode) )
    {
        if (channelType == kIpAudioChnlType)
        {
            channelType = kAvcToSacChnlType;
            TRACEINTO << "channelType set to " << kAvcToSacChnlType;
        }
        else
        {
            channelType = kSvcAvcChnlType;
            TRACEINTO << "channelType set to " << kSvcAvcChnlType;
        }
    }

	if( (m_pParty->GetTargetMode()->GetConfMediaType()==eMixAvcSvcVsw) && (OPEN_CHANNEL_VSW_RELAY == mode) )
	{
		channelType = kAvcVSWChnType; /* kAvcVSWChnType need to change APICOM for a new channel type  */
	}
	pUdpCloseSt->m_channelType = channelType;


    // ----- m_localAddress
	enIpVersion eIpAddrMatch = eIpVersion4;
	if (m_state == IP_CHANGEMODE)
		eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetSipLocalMediaType(),m_UdpAddressesParams.IpType);
	else
		eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);

	pUdpCloseSt->m_localAddress.ipVersion = eIpAddrMatch;

	bool bIsLocalAddressIpV4 = ( (pUdpCloseSt->m_localAddress.ipVersion == (APIU32)eIpVersion4) ? true : false );
	if (true == bIsLocalAddressIpV4) //v4
	{
		pUdpCloseSt->m_localAddress.addr.v4.ip = m_UdpAddressesParams.IpV4Addr.ip;
	}
	else
	{
		// --- UDP: array of addresses ---
		// First we will look for the best IpV6 address match -> Meaning we will match ScopeId's
		BYTE place = FindMatchingIpV6MediaAddressByScopeId();
		memcpy(pUdpCloseSt->m_localAddress.addr.v6.ip, m_UdpAddressesParams.IpV6AddrArray[place].ip, 16);
		pUdpCloseSt->m_localAddress.addr.v6.scopeId = m_UdpAddressesParams.IpV6AddrArray[place].scopeId;
	}

	pUdpCloseSt->m_localAddress.transportType = eTransportTypeUdp;
	pUdpCloseSt->m_localAddress.distribution  = eDistributionUnicast;// Don't Care
	pUdpCloseSt->m_localAddress.distribution = eDistributionUnicast;// Don't Care


    // ----- m_remoteAddress
	pUdpCloseSt->m_remoteAddress.ipVersion = eIpAddrMatch;

	bool bIsRemoteAddressIpV4 = ( (pUdpCloseSt->m_remoteAddress.ipVersion == (APIU32)eIpVersion4) ? true : false );
    if (true == bIsRemoteAddressIpV4) //v4
	{
    	pUdpCloseSt->m_remoteAddress.addr.v4.ip = pChannel->GetRmtAddress()->addr.v4.ip;
	}
	else
	{
		memcpy(pUdpCloseSt->m_remoteAddress.addr.v6.ip, pChannel->GetRmtAddress()->addr.v6.ip, 16);
		pUdpCloseSt->m_remoteAddress.addr.v6.scopeId = pChannel->GetRmtAddress()->addr.v6.scopeId;
	}

    pUdpCloseSt->m_remoteAddress.transportType = eTransportTypeUdp;

    // send to trace (local and remote addresses)
	if (bIsLocalAddressIpV4 && bIsRemoteAddressIpV4)
	{
		TRACEINTOFUNC << "Local address type: IPv4, remote address type: IPv4";
	}

	else
	{
		TRACEINTOFUNC
			<< "Local address type: " << ( bIsLocalAddressIpV4 ? "IPv4" : "IPv6" )
			<< ", remote address type: " << ( bIsRemoteAddressIpV4 ? "IPv4" : "IPv6" );

		if (!bIsLocalAddressIpV4)
		{
			BYTE place = FindMatchingIpV6MediaAddressByScopeId();
			TRACEINTOFUNC << "Local address type: Ipv6, place: " << place
						  << "\nIP v4 = " << CIPV4Wrapper(m_UdpAddressesParams.IpV4Addr)
						  << "\nIP v6 = " << CIPV6AraryWrapper(m_UdpAddressesParams.IpV6AddrArray) <<'\n';
		}

		if (!bIsRemoteAddressIpV4)
		{
			TRACEINTOFUNC << "Remote address type: Ipv6, scope: " << pChannel->GetRmtAddress()->addr.v6.scopeId;
		}
	}



    // ----- m_localRtcpAddress
    pUdpCloseSt->m_localRtcpAddress.ipVersion = eIpAddrMatch;

    bool bIsLocalRtcpAddressIpV4 = ( (pUdpCloseSt->m_localRtcpAddress.ipVersion == (APIU32)eIpVersion4) ? true : false );
 	if (true == bIsLocalRtcpAddressIpV4) //v4
 	{
 		pUdpCloseSt->m_localRtcpAddress.addr.v4.ip = m_UdpAddressesParams.IpV4Addr.ip;
 	}

 	else
 	{
 		// --- UDP: array of addresses ---
 		// First we will look for the best IpV6 address match -> Meaning we will match ScopeId's
 		BYTE place = FindMatchingIpV6MediaAddressByScopeId();
		memcpy(pUdpCloseSt->m_localRtcpAddress.addr.v6.ip, m_UdpAddressesParams.IpV6AddrArray[place].ip, 16);
 		pUdpCloseSt->m_localRtcpAddress.addr.v6.scopeId = m_UdpAddressesParams.IpV6AddrArray[place].scopeId;
 	}

 	pUdpCloseSt->m_localRtcpAddress.transportType = eTransportTypeUdp;
 	pUdpCloseSt->m_localRtcpAddress.distribution  = eDistributionUnicast;// Don't Care
 	pUdpCloseSt->m_localRtcpAddress.distribution = eDistributionUnicast;// Don't Care


    // ----- m_remoteRtcpAddress
 	pUdpCloseSt->m_remoteRtcpAddress.ipVersion = eIpAddrMatch;

 	bool bIsRemoteRtcpAddressIpV4 = ( (pUdpCloseSt->m_remoteRtcpAddress.ipVersion == (APIU32)eIpVersion4) ? true : false );
    if (bIsRemoteRtcpAddressIpV4) //v4
	{
		pUdpCloseSt->m_remoteRtcpAddress.addr.v4.ip = pChannel->GetRmtAddress()->addr.v4.ip;
	}
	else
	{
		memcpy(pUdpCloseSt->m_remoteRtcpAddress.addr.v6.ip, pChannel->GetRmtAddress()->addr.v6.ip, 16);
		pUdpCloseSt->m_remoteRtcpAddress.addr.v6.scopeId = pChannel->GetRmtAddress()->addr.v6.scopeId;
	}

    pUdpCloseSt->m_remoteRtcpAddress.transportType = eTransportTypeUdp;

	// send to trace (local and remote RTCP addresses)
	if (bIsLocalRtcpAddressIpV4 && bIsRemoteRtcpAddressIpV4)
	{
		TRACEINTOFUNC << "Local RTCP address type: IPv4, remote RTCP address type: IPv4";
	}

	else
	{
		TRACEINTOFUNC
			<< "Local RTCP address type: " << ( bIsLocalRtcpAddressIpV4 ? "IPv4" : "IPv6" )
			<< ", remote RTCP address type: " << ( bIsRemoteRtcpAddressIpV4 ? "IPv4" : "IPv6" );

		if (!bIsLocalAddressIpV4)
		{
	 		BYTE place = FindMatchingIpV6MediaAddressByScopeId();
			TRACEINTOFUNC << "Local RTCP address type: Ipv6, place: " << place
						  << "\nIP v4 = " << CIPV4Wrapper(m_UdpAddressesParams.IpV4Addr)
						  << "\nIP v6 = " << CIPV6AraryWrapper(m_UdpAddressesParams.IpV6AddrArray) <<'\n';
		}

		if (!bIsRemoteAddressIpV4)
		{
			TRACEINTOFUNC << "Remote RTCP address type: Ipv6, scope: " << pChannel->GetRmtAddress()->addr.v6.scopeId;
		}
	}

 	// ----- m_localAddress, m_remoteAddress, m_localRtcpAddress, m_remoteRtcpAddress
	cmCapDataType dataType = pChannel->GetMediaType();
	ERoleLabel eRole = pChannel->GetRoleLabel();

	UpdateIceChannelsIds(pUdpCloseSt, pChannel);

	switch (dataType)
	{
		case cmCapAudio:
		{
			pUdpCloseSt->m_localAddress.port  = m_UdpAddressesParams.AudioChannelPort;
			/*code review*/
			//pUdpCloseSt->m_remoteAddress.port = rmtAddress.port;
			pUdpCloseSt->m_remoteAddress.port = pChannel->GetRmtAddress()->port;
			pUdpCloseSt->m_localRtcpAddress.port			  = m_UdpAddressesParams.AudioChannelPort + 1;
			/*code review*/
			//pUdpCloseSt->m_remoteRtcpAddress.port			  = rmtRtcpPort;
			pUdpCloseSt->m_remoteRtcpAddress.port			  = pChannel->GetRtcpRmtPort();
			break;
		}


		case cmCapVideo:
		{
			if (eRole == kRolePeople)
			{
				pUdpCloseSt->m_localAddress.port  = m_UdpAddressesParams.VideoChannelPort;
				/*code review*/
				//pUdpCloseSt->m_remoteAddress.port = rmtAddress.port;
				pUdpCloseSt->m_remoteAddress.port = pChannel->GetRmtAddress()->port;
				pUdpCloseSt->m_localRtcpAddress.port			  = m_UdpAddressesParams.VideoChannelPort + 1;
				/*code review*/
				//pUdpCloseSt->m_remoteRtcpAddress.port			  = rmtRtcpPort;
				pUdpCloseSt->m_remoteRtcpAddress.port			  = pChannel->GetRtcpRmtPort();

			}
			else
			{
				pUdpCloseSt->m_localAddress.port  = m_UdpAddressesParams.ContentChannelPort;
				/*code review*/
				//pUdpCloseSt->m_remoteAddress.port = rmtAddress.port;
				pUdpCloseSt->m_remoteAddress.port = pChannel->GetRmtAddress()->port;
				pUdpCloseSt->m_localRtcpAddress.port			  = m_UdpAddressesParams.ContentChannelPort + 1;
				/*code review*/
				//pUdpCloseSt->m_remoteRtcpAddress.port			  = rmtRtcpPort;
				pUdpCloseSt->m_remoteRtcpAddress.port			  = pChannel->GetRtcpRmtPort();
			}
			break;
		}

		case cmCapData:
		{
			pUdpCloseSt->m_localAddress.port  = m_UdpAddressesParams.FeccChannelPort;
			/*code review*/
			//pUdpCloseSt->m_remoteAddress.port = rmtAddress.port;
			pUdpCloseSt->m_remoteAddress.port = pChannel->GetRmtAddress()->port;
			pUdpCloseSt->m_localRtcpAddress.port			  = m_UdpAddressesParams.FeccChannelPort + 1;
			/*code review*/
			//pUdpCloseSt->m_remoteRtcpAddress.port			  = rmtRtcpPort;
			pUdpCloseSt->m_remoteRtcpAddress.port			  = pChannel->GetRtcpRmtPort();
			break;
		}
		default:
		{
			pUdpCloseSt->m_localAddress.port  = 0;
			pUdpCloseSt->m_remoteAddress.port = 0;
			pUdpCloseSt->m_localRtcpAddress.port			  = 0;
			pUdpCloseSt->m_remoteRtcpAddress.port			  = 0;
			break;
		}
	}

	///////////////////////////////////////////////
	// in case of downgrade to AudioOnly
	if(kIpVideoChnlType == pCloseStruct->tMrmpCloseChannelRequestMessage.m_channelType)
	{
		CSipCall* pCall = pChannel->GetCallPtr();
		if(cmCapTransmit ==pCloseStruct->tMrmpCloseChannelRequestMessage.m_channelDirection)
		{
			 pCall->SetMediaDetectioHasVideo(FALSE);
			 pCall->SetMediaDetectioIsSvcOpened(FALSE);
		}
	}

    memset(&(pCloseStruct->physicalId[0]), 0, sizeof(PHYSICAL_RESOURCE_INFO_S)); // @#@ - physicalId
    pCloseStruct->physicalId[0].connection_id = INVALID;
    pCloseStruct->m_allocatedPhysicalResources = 0;
    seqNum = SendMsgToMpl((BYTE*)(pCloseStruct), sizeof(MrmpCloseChannelRequestStruct), CONF_PARTY_MRMP_CLOSE_CHANNEL_REQ);
    pChannel->SetSeqNumCm(seqNum);
    PDELETE(pCloseStruct);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendScpNotificationReq(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"_scp_flow_ CSipCntl::SendScpNotificationReq");

	CScpNotificationWrapper tmpWrapper;
	tmpWrapper.DeSerialize(NATIVE,*pParam);

	int size = sizeof(MrmpScpStreamsNotificationStructBase);
	if (tmpWrapper.m_pipes.size())
	{
		size += ( tmpWrapper.m_pipes.size() * sizeof(MrmpScpPipe) );
	}

	char *buf = new char[size];
	MrmpScpStreamsNotificationStruct* pStruct = new (buf)MrmpScpStreamsNotificationStruct;

	// temp temp temp - haggai - for debugging
//	CSipChannel* pChannel;
	ERoleLabel eRole=kRolePeople;
	cmCapDataType mediaType=cmCapData;
	cmCapDirection channelDirection=cmCapTransmit;
	CSipChannel* pChannel = m_pCall->GetChannel(true, mediaType, channelDirection, eRole);
	if (!pChannel)
	{
	    PTRACE(eLevelInfoNormal, "pChannel is NULL");
	    return;
	}

//	CSipChannel* pChannel = m_pCall->GetChannel(cmCapData, cmCapTransmit, kRolePeople);
//	CMedString *pStr = new CMedString;
//	*pStr	<< "CSipCntl::SendScpNotificationReq\nChannelHandle from bridge: "
//			<< tmpWrapper.m_channelHandle
//			<< "\nChannelHandle from calc: "
//			<< pChannel->GetChannelHandle();
//	if (pChannel->GetChannelHandle() != tmpWrapper.m_channelHandle)
//	{
//		*pStr	<< "\n ++++++++++++ Replace channelHandle to be from calc";
//	}
//	else
//	{
//		*pStr	<< "\n ++++++++++++ ChannelHandle from bridge okay";
//	}
//	PTRACE(eLevelInfoNormal, pStr->GetString());
//	POBJDELETE(pStr);
	pStruct->unChannelHandle        = pChannel->GetChannelHandle(); //tmpWrapper.m_channelHandle
	pStruct->unSequenseNumber		= tmpWrapper.m_sequenceNumber;
	pStruct->unRemoteSequenseNumber	= tmpWrapper.m_remoteSequenceNumber;
	pStruct->nNumberOfScpPipes		= tmpWrapper.m_numOfPipes;

	int i = 0;
	std::list<CScpPipeWrapper>::iterator itr;
	for (itr = tmpWrapper.m_pipes.begin(); itr != tmpWrapper.m_pipes.end(); itr++)
	{
		pStruct->scpPipe[i].unPipeId		= (*itr).m_pipeId;
		pStruct->scpPipe[i].unNotifyType	= (*itr).m_notificationType;
		pStruct->scpPipe[i].unReason		= (*itr).m_reason;
		pStruct->scpPipe[i].bIsPermanent	= (*itr).m_bIsPermanent;

		i++;
	}

	SendMsgToMpl((BYTE*)(pStruct), size, CONF_PARTY_MRMP_SCP_STREAM_NOTIFICATION_REQ);

	delete [] buf;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendScpIvrStateNotificationReq(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"_scp_flow_ CSipCntl::SendScpIvrStateNotificationReq");

	DWORD ivrState = 0;
	DWORD seqNumber = 0;

	*pParam >> seqNumber;
	*pParam >> ivrState;

	MrmpScpIvrStateNotificationStruct mrmpScpIvrStateNotificationStruct;

	DWORD channelHandle = GetChannelHandle(cmCapData,cmCapTransmit,kRolePeople);

	if (channelHandle != INVALID_CHANNEL_HANDLE)
	{
		mrmpScpIvrStateNotificationStruct.unChannelHandle = channelHandle;
		mrmpScpIvrStateNotificationStruct.unSequenseNumber = seqNumber;
		mrmpScpIvrStateNotificationStruct.unIvrState = ivrState;

		SendMsgToMpl((BYTE*)(&mrmpScpIvrStateNotificationStruct), sizeof(MrmpScpIvrStateNotificationStruct), CONF_PARTY_MRMP_SCP_IVR_STATE_NOTIFICATION_REQ);

	}
	else
	{
		PASSERTMSG(1,"Can't send ivr state notification, outgoing data channel handle is invalid!");
	}

}
//////////////////////////////////////////////////////
DWORD CSipCntl::GetChannelHandle(cmCapDataType eMediaType,cmCapDirection eDirection, ERoleLabel eRole) const
{
	DWORD channelHandle = INVALID_CHANNEL_HANDLE;
	CSipChannel* pChannel = m_pCall->GetChannel(true, eMediaType, eDirection, eRole);
	if (!pChannel)
	{
		TRACEINTOFUNC << "pChannel is NULL (media type: " << eMediaType << " eDirection:" << eDirection << ", eRole:" << eRole << ")";
	}
	else
	{
		channelHandle = pChannel->GetChannelHandle();
	}

	return channelHandle;
}
//////////////////////////////////////////////////////
void CSipCntl::InitSpeakerParams()
{
	m_speakerMcuNum  = 0;
	m_speakerTermNum = 0;
	m_speakerPartyId = 0;
}

void CSipCntl::OnRelayTimerFastUpdateConnected(CSegment* pParam) //eyaln_fix_intra
{
	PTRACE(eLevelInfoNormal,"@@@! CSipCntl::OnRelayTimerFastUpdateConnected- sending fast update");
//	CSegment* pseg=new CSegment(*pParam);
	SendFastUpdateReq(/*pseg*/ pParam);
//	POBJDELETE(pParam);

}
void CSipCntl::OnRelayTimerFastUpdateNotConnected(CSegment* pParam) //eyaln_fix_intra
{
	PTRACE(eLevelInfoNormal,"@@@! CSipCntl::OnRelayTimerFastUpdateNotConnected - restarting timer");
	CSegment* pseg=new CSegment(*pParam);
	StartTimer(RELAY_FASTUPDATETOUT, ( 1 * SECOND),/*pParam pseg*/ pseg);
}

void  CSipCntl::SetConfMediaType(eConfMediaType aConfMediaType)
{
	if (m_pCall)
	{
		TRACEINTO << "mix_mode: Update sipCall with m_confMediaType= " << ConfMediaTypeToString(aConfMediaType);
		m_pCall->SetConfMediaType(aConfMediaType);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SendScpPipesMappingNotificationReq(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"_scp_flow_ CSipCntl::SendScpPipesMappingNotificationReq");


	CScpPipeMappingNotification pipesMapNotifyStruct;
    pipesMapNotifyStruct.DeSerialize(NATIVE,*pParam);
	pipesMapNotifyStruct.Dump();

	int size = sizeof(MrmpScpStreamsNotificationStructBase); // (MrmpScpPipesMappingNotificationStruct also uses MrmpScpStreamsNotificationStructBase)
	int listSize = pipesMapNotifyStruct.GetPipesListSize();
	if (listSize)
	{
		size += ( listSize * sizeof(MrmpScpPipeMapping) );
	}

	char *buf = new char[size];
	MrmpScpPipesMappingNotificationStruct* pStruct = new (buf)MrmpScpPipesMappingNotificationStruct;

	// temp temp temp - haggai - for debugging
//	CSipChannel* pChannel;
	ERoleLabel eRole=kRolePeople;
	cmCapDataType mediaType=cmCapData;
	cmCapDirection channelDirection=cmCapTransmit;
	CSipChannel* pChannel = m_pCall->GetChannel(true, mediaType, channelDirection, eRole);
	if (!pChannel)
	{
	    PTRACE(eLevelInfoNormal, "pChannel is NULL");
	    delete [] buf;
	    POBJDELETE(pParam);
	    return;
	}

	pStruct->unChannelHandle        = pChannel->GetChannelHandle(); //tmpWrapper.m_channelHandle
	pStruct->unSequenseNumber		= pipesMapNotifyStruct.GetSeuqenceNumber();
	pStruct->unRemoteSequenseNumber	= pipesMapNotifyStruct.GetRemoteSeuqenceNumber();
	pStruct->nNumberOfScpPipes		= listSize;


	std::list <CScpPipeMappingObj> copiedList;
	pipesMapNotifyStruct.RetrievePipesList(copiedList);

	int i = 0;
	std::list<CScpPipeMappingObj>::iterator itr;
	for (itr = copiedList.begin(); itr != copiedList.end(); itr++)
	{
		pStruct->scpPipeMapping[i].unPipeId		= (*itr).GetPipeId();
		pStruct->scpPipeMapping[i].unCsrc		= (*itr).GetCsrc();

		i++;
	}


//	int i = 0;
//	std::list<CScpPipeMappingObj>::iterator itr;
//	for (itr = pipesMapNotifyStruct.m_listOfPipes.begin(); itr != pipesMapNotifyStruct.m_listOfPipes.end(); itr++)
//	{
//		pStruct->scpPipeMapping[i].unPipeId		= (*itr).GetPipeId();
//		pStruct->scpPipeMapping[i].unCsrc		= (*itr).GetCsrc();
//
//		i++;
//	}

	SendMsgToMpl((BYTE*)(pStruct), size, CONF_PARTY_MRMP_SCP_PIPES_MAPPING_NOTIFICATION_REQ);
	PTRACE(eLevelInfoNormal, "CONF_PARTY_MRMP_SCP_PIPES_MAPPING_NOTIFICATION_REQ sent to MRMP");

	delete [] buf;
	POBJDELETE(pParam);
}

//LyncCCS
#define		MAX_TIMES_FOR_PARTY_AUTH			3
void CSipCntl::OnSipPartyAuthInfoInd(mcIndConfPwdInfo *sConfPwdInfo , APIU32 dTxId)
{
	enPartyAuthRespStatus  authRespStatus = ePartyAuthRespInvalid;

	SendPartyAuthResponse(dTxId, SipCodesOk);// Send 200OK anyway
	if((NULL == sConfPwdInfo)||(MAX_TIMES_FOR_PARTY_AUTH < m_AuthCounter))
	{
		return;
	}

	enPartyAuthState enPwdstate = GetPartyAuthState();
	if((ePartyAuthStateTobeMatched != enPwdstate)&&(ePartyAuthStateCompleted!= enPwdstate))
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipPartyAuthInfoInd :  wrong AuthState - ", enPwdstate);
	}
	else
	{
		PTRACE2(eLevelInfoNormal,"CSipCntl::OnSipPartyAuthInfoInd : Pwd - ", sConfPwdInfo->pwd);

		m_AuthCounter++;
		if(MAX_TIMES_FOR_PARTY_AUTH < m_AuthCounter) //Too much (4 times) INFO from remote, indicate remote once and then keep silence
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::OnSipPartyAuthInfoInd :	Too many retry times! ");
			authRespStatus = ePartyAuthRespInvalid;
			SendPartyAuthStatus(authRespStatus);
			return;
		}

		BYTE pwdStatus = CheckPartyAuthPwd(sConfPwdInfo->pwd);
		if(0 == pwdStatus)
		{
			if(MAX_TIMES_FOR_PARTY_AUTH == m_AuthCounter) //Auth Failed for 3 times!Notify Conf!
			{
				//This condition should not be merged with above
				if(ePartyAuthStateTobeMatched == GetPartyAuthState())
				{
					m_pPartyApi->SendLocalAuthStatus(pwdStatus);
					SetPartyAuthState(ePartyAuthStateCompleted);

					PDELETEA(m_pAuthPwd);
				}
			}
			authRespStatus = ePartyAuthRespFailed;
		}
		else
		{
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnSipPartyAuthInfoInd :	COMPLETED! status - ", pwdStatus);
			if(ePartyAuthStateTobeMatched == GetPartyAuthState())
			{
				m_pPartyApi->SendLocalAuthStatus(pwdStatus);
				SetPartyAuthState(ePartyAuthStateCompleted);
				PDELETEA(m_pAuthPwd);
			}
			authRespStatus = ePartyAuthRespSuccess;
		}
		SendPartyAuthStatus(authRespStatus);
		return;
	}
}

//////////////////////////////////////////////////////////////////////////////////////
//
//4   Yiping.C: The (m_ePartyAuthState) state transfer diagram is shown below:
//
//    INITIAL ---(receive IND from Conf)---------------------> WAITING_REMOTE
//       |                                                                                                    |(receive SIP ACK)
//       |--(receive SIP ACK)--->WAITING_LOCAL                                    |
//       |                                                |  (receive IND from Conf)            V
//       |                                                |-----------------------> TO_BE_MATCHED--------------|
//       |                                                |                                                           |             ^                             |
//       | (Rev IND, & Pwd is NULL)         |                                                           |             |                              |
//       |----------<-------------|                                                           |             |                              |
//       |                                                                                                              |             |                              |
//       V                                                                                                              |             |      (wrong PWD)    |
//      COMPLETED <----receive correct PWD or wrong for 3 times ----------|             |----------------
//
///////////////////////////////////////////////////////////////////////////////////////
BYTE  CSipCntl::SetPartyAuthState(enPartyAuthState  eState)
{
	PTRACE2INT(eLevelInfoNormal, " CSipCntl::SetPartyAuthState, state- ", eState);

	if(ePartyAuthStateIdle > eState|| ePartyAuthStateCompleted < eState)
	{
		return false;
	}
	m_ePartyAuthState = eState;
	return true;
}
BYTE  CSipCntl::SetPartyAuthPwd(char* pPwd)
{
	if(NULL == pPwd)
	{
		return false;
	}
	PTRACE2(eLevelInfoNormal,"CSipCntl::SetPartyAuthPwd : Pwd - ", pPwd);
	PDELETEA(m_pAuthPwd);
	int len = strlen(pPwd);
	m_pAuthPwd = new char[len+1];
	memset(m_pAuthPwd, 0, len);
	snprintf(m_pAuthPwd, len+1, "%s", pPwd);
	return true;
}

//Not support N/A pwd if the Conf intiate Auth procedure!
//(Only if there's really pwd exists, Conf can intiate the auth procedure)
BYTE  CSipCntl::CheckPartyAuthPwd(char* pPwd)
{
	BYTE  confPwdLen = 0;
	BYTE  h243PwdLen = 0;
	char		szConfPwd[32];
	char		szH243Pwd[32];


	PTRACE(eLevelInfoNormal, " CSipCntl::CheckPartyAuthPwd ");
	if(NULL == pPwd || NULL == m_pAuthPwd)
	{
		return 0;
	}
	BYTE  localLen = strlen(m_pAuthPwd);

	char*  pConfPwd = strstr(m_pAuthPwd, "ConfPwd:");
	char* pH243Pwd = strstr(m_pAuthPwd, "H243Pwd:");
	 if(!pH243Pwd || ! pConfPwd || pH243Pwd < pConfPwd)
	 {
		 PTRACE(eLevelInfoNormal, " CSipCntl::CheckPartyAuthPwd: invalid format of local password, let plugin in ");
		return 1;
	 }
	 confPwdLen = pH243Pwd - pConfPwd -strlen("ConfPwd:");
	 h243PwdLen = localLen - confPwdLen - strlen("ConfPwd:") - strlen( "H243Pwd:");
	 PTRACE2INT(eLevelInfoNormal, " CSipCntl::CheckPartyAuthPwd,  confPwd Length - ", confPwdLen);
	 PTRACE2INT(eLevelInfoNormal, " CSipCntl::CheckPartyAuthPwd,  h243Pwd Length - ", h243PwdLen);

	BYTE  remoteLen=strlen(pPwd);
	if(confPwdLen == 0 && h243PwdLen == 0)
	{
		 PTRACE(eLevelInfoNormal, " CSipCntl::CheckPartyAuthPwd: no local password, let plugin in ");
		return 1;
	}
	else
	{
		if(confPwdLen != 0)
		{
			PASSERT_AND_RETURN_VALUE(confPwdLen > sizeof(szConfPwd) - 1, 0);
			strncpy(szConfPwd, pConfPwd+strlen("ConfPwd:"), confPwdLen);
			szConfPwd[confPwdLen] = '\0';

			if(strstr(pPwd, szConfPwd))
			{
				return 1;
			}
		}
		if(h243PwdLen != 0)
		{
			PASSERT_AND_RETURN_VALUE(h243PwdLen > sizeof(szH243Pwd) - 1, 0);
			strncpy(szH243Pwd, pH243Pwd+strlen("H243Pwd:"), h243PwdLen);
			szH243Pwd[h243PwdLen] = '\0';

			if(strstr(pPwd, szH243Pwd))
			{
				return 1;
			}
		}
	}
	return 0;

}

BYTE  CSipCntl::SendPartyAuthRequired()
{
	if(ePartyAuthStateTobeMatched != GetPartyAuthState())
	{
		return false;
	}

	PTRACE(eLevelInfoNormal, " CSipCntl::SendPartyAuthRequired ");
	mcReqInfo* pInfoReq;
	size_t size = 0;
	size = sizeof(mcReqInfo);
	pInfoReq = (mcReqInfo*)new BYTE[size];
	pInfoReq->subOpcode = CcsPluginConfPwd;
	pInfoReq->dynamicLen = 0;
	 SendSIPMsgToCS(SIP_CS_SIG_INFO_REQ, pInfoReq, size);
	PDELETEA(pInfoReq);
	return true;
}
BYTE  CSipCntl::SendPartyAuthStatus(enPartyAuthRespStatus  authStatus)
{
	PTRACE(eLevelInfoNormal, " CSipCntl::SendPartyAuthStatus ");

	mcReqInfo* pInfoReq;
	size_t size = 0;
	size = sizeof(mcReqInfo) + sizeof(mcReqCcsConfPwd);
	pInfoReq = (mcReqInfo*)new BYTE[size];
	memset((char*)pInfoReq, 0, size);

	//fill body
	mcReqCcsConfPwd*	pReqCcsConfPwd	= (mcReqCcsConfPwd*) &pInfoReq->buff[0];
	pReqCcsConfPwd->status	= (APIU32) authStatus;

	//fill header
	pInfoReq->subOpcode = CcsPluginConfPwdResult;
	pInfoReq->dynamicLen = sizeof(mcReqCcsConfPwd);

	 SendSIPMsgToCS(SIP_CS_SIG_INFO_REQ, pInfoReq, size);
	PDELETEA(pInfoReq);
	return true;
}

BYTE  CSipCntl::SendPartyAuthResponse(APIU32 transId, APIS32 status)
{
	DWORD	indLen	= sizeof(mcReqInfoResp);
	BYTE*  pReqArray = new BYTE [indLen];
	memset((char *)pReqArray,0,indLen);

	mcReqInfoResp* mcReq = (mcReqInfoResp*)(pReqArray);
	mcReq->dTxnId =  transId;
	mcReq->subOpcode = CcsPluginConfPwd;
	mcReq->status = status;
	SendSIPMsgToCS(SIP_CS_SIG_INFO_RESP_REQ, pReqArray, indLen);
	PDELETEA(pReqArray);
	return true;

}

BYTE  CSipCntl::PartyAuthIndReceiveFromConf(char* pstrPwd)
{
	if(NULL == pstrPwd)
	{
		return false;
	}
	PTRACE(eLevelInfoNormal, " CSipCntl::PartyAuthIndReceiveFromConf ");

	enPartyAuthState    eState = GetPartyAuthState();

	if(((ePartyAuthStateIdle == eState) || (ePartyAuthStateWaitingLocal == eState))
		&& ((strlen("ConfPwd:") + strlen("H243Pwd:")) >= strlen(pstrPwd)))
	{
		m_pPartyApi->SendLocalAuthStatus(true);
		SetPartyAuthState(ePartyAuthStateCompleted);
		return true;
	}

	switch(eState)
	{
		case ePartyAuthStateIdle:
		{
			SetPartyAuthPwd(pstrPwd);
			SetPartyAuthState(ePartyAuthStateWaitingRemote);
			break;
		}
		case ePartyAuthStateWaitingLocal:
		{
			SetPartyAuthPwd(pstrPwd);
			SetPartyAuthState(ePartyAuthStateTobeMatched);
			SendPartyAuthRequired();
			break;
		}
		default:
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::PartyAuthIndReceiveFromConf   -state: ", eState);
			break;
	}
	return true;

}

BYTE  CSipCntl::PartyAuthAckReceiveFromCS()
{
	enPartyAuthState    eState = GetPartyAuthState();

	PTRACE(eLevelInfoNormal, " CSipCntl::PartyAuthAckReceiveFromCS ");
	switch(eState)
	{
		case ePartyAuthStateIdle:
		{
			SetPartyAuthState(ePartyAuthStateWaitingLocal);
			break;
		}
		case ePartyAuthStateWaitingRemote:
		{
			SetPartyAuthState(ePartyAuthStateTobeMatched);
			SendPartyAuthRequired();
			break;
		}
		case ePartyAuthStateCompleted:
			PTRACE(eLevelInfoNormal, "CSipCntl::PartyAuthAckReceiveFromCS(), auth already done before!");
			break;
		default:
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::PartyAuthAckReceiveFromCS()  -state: ", eState);
			break;
	}
	return true;

}
#undef MAX_TIMES_FOR_PARTY_AUTH


//added for ANAT begin
void CSipCntl::SetMediaLinesInternalTypeForRmtSdpForAnat(sipSdpAndHeadersSt &sdp)
{
	if (sdp.sipMediaLinesLength)
	{
		const sipMediaLinesEntrySt* pMediaLinesEntry = (const sipMediaLinesEntrySt*) &sdp.capsAndHeaders[sdp.sipMediaLinesOffset];
		int mediaLinePos = 0;

		sipMediaLineSt *pFirstVideoMediaLine = NULL;
		sipMediaLineSt *pFirstOtherVideoMediaLine = NULL;
		sipMediaLineSt *pContentVideoMediaLine = NULL;
		sipMediaLineSt *pOtherContentVideoMediaLine = NULL;
		BOOL           isBFCP = FALSE;

		for (unsigned int j = 0; j < pMediaLinesEntry->numberOfMediaLines; j++)
		{
			sipMediaLineSt *pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
			eMediaLineType mediaLineType = (eMediaLineType)pMediaLine->type;

			switch (mediaLineType)
			{
				case eMediaLineTypeAudio:
					pMediaLine->internalType = kMediaLineInternalTypeAudio;
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdpForAnat eMediaLineTypeAudio media line #", j);
					break;
				case eMediaLineTypeVideo:
					if (pFirstVideoMediaLine == NULL)
					{
						pMediaLine->internalType = kMediaLineInternalTypeVideo;
						pFirstVideoMediaLine = pMediaLine;
						PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdpForAnat kMediaLineInternalTypeVideo media line #", j);
					}
					else
					{
						if (pFirstVideoMediaLine->content == pMediaLine->content || pMediaLine->content == 0 || pMediaLine->content == eMediaLineContentMain)
						{
							pMediaLine->internalType = kMediaLineInternalTypeVideo;
							pFirstOtherVideoMediaLine = pMediaLine;
							PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdpForAnat kMediaLineInternalTypeVideo media line #", j);
						}
						else
						{
							pMediaLine->internalType = kMediaLineInternalTypeContent;
							if (pContentVideoMediaLine == NULL)
								pContentVideoMediaLine = pMediaLine;
							else
								pOtherContentVideoMediaLine = pMediaLine;
							PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdpForAnat kMediaLineInternalTypeContent media line #", j);
						}
					}

					if (pFirstVideoMediaLine && pContentVideoMediaLine)
					{
						eMediaLineContent contentType1 = (eMediaLineContent)pFirstVideoMediaLine->content;
						eMediaLineContent contentType2 = (eMediaLineContent)pContentVideoMediaLine->content;

						if ((contentType1 >= eMediaLineContentSlides) && (contentType1 <= eMediaLineContentMain)
						 && (contentType2 >= eMediaLineContentSlides) && (contentType2 <= eMediaLineContentMain))
						{
							if (contentType1 < contentType2)
							{
								pFirstVideoMediaLine->internalType = kMediaLineInternalTypeContent;
								if (pFirstOtherVideoMediaLine)
									pFirstOtherVideoMediaLine->internalType = kMediaLineInternalTypeContent;
								pContentVideoMediaLine->internalType = kMediaLineInternalTypeVideo;
								if (pOtherContentVideoMediaLine)
									pOtherContentVideoMediaLine->internalType = kMediaLineInternalTypeVideo;
								PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdpForAnat kMediaLineInternalTypeVideo exchange, m-line #", j);
							}
						}
					}
					break;
				case eMediaLineTypeApplication:
					if ((pMediaLine->subType == eMediaLineSubTypeTcpBfcp) || (pMediaLine->subType == eMediaLineSubTypeTcpTlsBfcp) || (pMediaLine->subType == eMediaLineSubTypeUdpBfcp))
					{
						pMediaLine->internalType = kMediaLineInternalTypeBfcp;
						isBFCP = TRUE;
						PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdpForAnat bfcp sub type:", pMediaLine->subType);
					}
					else
						pMediaLine->internalType = kMediaLineInternalTypeFecc;
					break;
				case eMediaLineTypeNotSupported:
					pMediaLine->internalType = kMediaLineInternalTypeNotSupported;
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdpForAnat Media Line Type is Not Supported by input", 0);
					break;
				default:
					DBGPASSERT(mediaLineType+100);
			}

			mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;
		}
	}
	else
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::SetMediaLinesInternalTypeForRmtSdpForAnat: Media lines size is zero. Length of dynamic section: ", sdp.lenOfDynamicSection);
}

void CSipCntl::SetLabelsAndContentAttributesInLocalSdpForAnat(sipSdpAndHeadersSt &sdp)
{
	sipMediaLineSt* pVideoMline = ::GetMediaLine(sdp, kMediaLineInternalTypeVideo);
	sipMediaLineSt* pContentMline = ::GetMediaLine(sdp, kMediaLineInternalTypeContent);
	int numberOfMLine = 0;

	if (pVideoMline && pContentMline)
	{
		while (pVideoMline || pContentMline)
		{
			numberOfMLine++;

			if (pVideoMline)
			{
				pVideoMline->content = eMediaLineContentMain;
				strncpy(pVideoMline->label, STREAM_LABEL_VIDEO, MAX_LABEL_LENGTH);
				pVideoMline->label[MAX_LABEL_LENGTH-1] = '\0';
			}

			if (pContentMline)
			{
				pContentMline->content = eMediaLineContentSlides;
				strncpy(pContentMline->label, STREAM_LABEL_CONTENT, MAX_LABEL_LENGTH);
				pContentMline->label[MAX_LABEL_LENGTH-1] = '\0';
			}

			PTRACE(eLevelInfoNormal,"CSipCntl::SetLabelsAndContentAttributesInLocalSdpForAnat set media line's content!"); //ANAT for debug
			if (numberOfMLine >= MAX_GROUP_ANAT_MEMBER_NUM)
				break;

			pVideoMline = GetMediaLine(sdp, kMediaLineInternalTypeVideo, 1);
			pContentMline = GetMediaLine(sdp, kMediaLineInternalTypeContent, 1);
		}
	}
}

int CSipCntl::GetClosedMediaSizeForAnat() const
{
    //PTRACE(eLevelInfoNormal,"CSipCntl::GetClosedMediaSizeForAnat:");
	int sizeOfNotSupported = 0;
   	 int size = 0;
	sipMediaLineSt* pRemoteMediaLine = NULL;

	for(int i = (int)kMediaLineInternalTypeAudio; i < (int)kMediaLineInternalTypeNotSupported; i++)
	{
		eMediaLineInternalType type = (eMediaLineInternalType)i;
		cmCapDataType mediaType;
		ERoleLabel eRole;
		int nLineOfSameInnerType = GetNumberOfMediaLinesOfIntenalType(m_pRemoteSdp, type, sizeOfNotSupported);
		size += sizeOfNotSupported;

		GetMediaDataTypeAndRole((eMediaLineInternalType)i, mediaType, eRole);

		for (int j=0; j<nLineOfSameInnerType; j++)
		{
			int copySize = 0;
			sipMediaLineSt* pRemoteMediaLine = GetMediaLine(*m_pRemoteSdp, type, j);

			if(pRemoteMediaLine && (m_AnatSelectedIpVersion == (enIpVersion)pRemoteMediaLine->mediaIp.transAddr.ipVersion))
			{
				if (!m_pChosenLocalCap->IsMedia(mediaType, cmCapReceiveAndTransmit,eRole))
				{
					size += sizeof(sipMediaLineBaseSt) + pRemoteMediaLine->lenOfDynamicSection;
					PTRACE(eLevelInfoNormal, "CSipCntl::GetClosedMediaSizeForAnat does not find type from local cap");
				}
				else
					PTRACE(eLevelInfoNormal, "CSipCntl::GetClosedMediaSizeForAnat Find type from local cap");
			}
			else if (pRemoteMediaLine)
			{
				size += sizeof(sipMediaLineBaseSt) + pRemoteMediaLine->lenOfDynamicSection;
				PTRACE(eLevelInfoNormal, "CSipCntl::GetClosedMediaSizeForAnat local does not support this IP address type");
			}
		}
	}

	return size;
}

int CSipCntl::AddClosedMediaLinesFromRemoteSDPForAnat(sipSdpAndHeadersSt* pSdpAndHeaders, vector<int>* pCopiedIndexes) const
{
	//PTRACE(eLevelInfoNormal, "CSipCntl::AddClosedMediaLinesFromRemoteSDPForAnat start copying");

	sipMediaLinesEntrySt* pMediaLinesEntry = (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders;

	unsigned int mediaLinePos = 0;
	unsigned int mediaLinePos2 = 0;
    	sipMediaLineSt *pMediaLine = NULL;
	sipMediaLineSt* pRemoteMediaLine = NULL;
	eMediaLineInternalType type = kMediaLineInternalTypeNone;
	int nLineOfSameInnerType = 0;
    	int size = 0;
	int copySize = 0;
	int sizeOfNotSupported = 0;
	// Go to the last local m-line:
	for (unsigned int i = 0; i < pMediaLinesEntry->numberOfMediaLines; i++)
	{
		pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
		mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;
		//TRACEINTOFUNC << "media line " << i << " internal type " << (eMediaLineInternalType)pMediaLine->internalType;
	}

	for(int i = (int)kMediaLineInternalTypeAudio; i < (int)kMediaLineInternalTypeNotSupported; i++)
	{
		type = (eMediaLineInternalType)i;
		nLineOfSameInnerType = GetNumberOfMediaLinesOfIntenalType(m_pRemoteSdp, type, sizeOfNotSupported);
		size += sizeOfNotSupported;

		for (int j=0; j<nLineOfSameInnerType; j++)
		{
			copySize = 0;
			pMediaLine = NULL;
			mediaLinePos2 = 0;

			pRemoteMediaLine = GetMediaLine(*m_pRemoteSdp, type, j);

			if(pRemoteMediaLine && (m_AnatSelectedIpVersion == (enIpVersion)pRemoteMediaLine->mediaIp.transAddr.ipVersion))
			{
				//TRACEINTOFUNC << "Get media line, type = " << type << " local media line num = " << pMediaLinesEntry->numberOfMediaLines;
				//pMediaLine = GetMediaLine(*pSdpAndHeaders, type); //here local media ip is not assigned yet
				for (unsigned int k = 0; k < pMediaLinesEntry->numberOfMediaLines; k++)
				{
					pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos2];
					mediaLinePos2 += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;

					if (pMediaLine->internalType == type)
					{
						PTRACE(eLevelInfoNormal, "CSipCntl::AddClosedMediaLinesFromRemoteSDPForAnat Find type from local");
						break;
					}
				}

				if (pMediaLine)
				{
					pMediaLine->mid = pRemoteMediaLine->mid;
					pMediaLine->midAnatGroup[0] = pMediaLine->mid;
					pMediaLine->midAnatGroup[1] = 0;  // 0 used for default value. means "not use".
					//memcpy((void*)pMediaLine->midAnatGroup, (void*)pRemoteMediaLine->midAnatGroup, MAX_GROUP_ANAT_MEMBER_NUM);
				}
				else       //Local not support this internaltype
				{
					copySize = CopyMLineFromRemoteSDP(pMediaLinesEntry, type, mediaLinePos, j);
					if(copySize)
					{
						size += copySize;
						mediaLinePos += copySize;
						pCopiedIndexes->push_back(pMediaLinesEntry->numberOfMediaLines-1);
					}
				}
			}
			else if (pRemoteMediaLine)  //Local not support this Ip address type
			{
				PTRACE(eLevelInfoNormal, "CSipCntl::AddClosedMediaLinesFromRemoteSDPForAnat: local does not support this Ip address type");
				copySize = CopyMLineFromRemoteSDP(pMediaLinesEntry, type, mediaLinePos, j);
				if(copySize)
				{
					size += copySize;
					mediaLinePos += copySize;
					pCopiedIndexes->push_back(pMediaLinesEntry->numberOfMediaLines-1);
				}
			}
		}
	}

	return size;
}

int CSipCntl::AddClosedMediaLinesFromRemoteSDPReinvteForAnat(sipSdpAndHeadersSt* pSdpAndHeaders, vector<int>* pCopiedIndexes) const
{
	sipMediaLinesEntrySt* pMediaLinesEntry = (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders;

	unsigned int mediaLinePos = 0;
    	sipMediaLineSt *pMediaLine = NULL;
    	int size = 0;
	int copySize = 0;
	int sizeOfNotSupported = 0;

	// Go to the last local m-line:
	for (unsigned int i = 0; i < pMediaLinesEntry->numberOfMediaLines; i++)
	{
		pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
		mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;
	}

	for(int i = (int)kMediaLineInternalTypeAudio; i < (int) kMediaLineInternalTypeNotSupported; i++)
	{
		eMediaLineInternalType type = (eMediaLineInternalType)i;
		if(::IsMediaContainedInSdp(m_pRemoteSdp, type) && !::IsMediaContainedInDirtySdp(pMediaLinesEntry, type))
		{
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::AddClosedMediaLinesFromRemoteSDPReinvteForAnat start copying type = %d", type);
			int nLineOfSameInnerType = GetNumberOfMediaLinesOfIntenalType(m_pRemoteSdp, type, sizeOfNotSupported);
			size += sizeOfNotSupported;

			for (int j=0; j<nLineOfSameInnerType; j++)
			{
				copySize = CopyMLineFromRemoteSDP(pMediaLinesEntry, type, mediaLinePos, j);
				if(copySize)
				{
					size += copySize;
					mediaLinePos += copySize;
					pCopiedIndexes->push_back(pMediaLinesEntry->numberOfMediaLines-1);
				}
			}
		}
	}

	return size;
}

int CSipCntl::AddSimulcastVideoMLinesToSDPForLync2013(sipSdpAndHeadersSt* pSdpAndHeaders)
{
	if(!pSdpAndHeaders)
	{
			PTRACE(eLevelInfoNormal,"CSipCntl::AddSimulcastVideoMLinesToSDPForLync2013 - pSdpAndHeaders is NULL");
			return 0;
	}
	TRACEINTO;

	sipMediaLinesEntrySt* pMediaLinesEntry = (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders;

	// Go to the main video m line: - pMainVideoMediaLine, videoMediaLinePos
	DWORD videoMediaLinePos = 0;
	sipMediaLineSt* ptmpMLine = NULL;
	sipMediaLineSt* pMainVideoMediaLine = NULL;

	for (unsigned int i = 0; i < pMediaLinesEntry->numberOfMediaLines; i++)
	{
		ptmpMLine = (sipMediaLineSt *)&pMediaLinesEntry->mediaLines[videoMediaLinePos];
		if(kMediaLineInternalTypeVideo == ptmpMLine->internalType && strstr(ptmpMLine->label, "main-video") )
		{
			pMainVideoMediaLine = ptmpMLine;
			break;
		}
		videoMediaLinePos += sizeof(sipMediaLineBaseSt) + ptmpMLine->lenOfDynamicSection;
	}

	if(!pMainVideoMediaLine){ //  no video mline
		PTRACE(eLevelInfoNormal,"CSipCntl::AddSimulcastVideoMLinesToSDPForLync2013 no main-video mline");
		return 0;
	}

	// 1. create the first mline(bufVideoMLine)
	BYTE bufVideoMLine[SIP_MEDIA_LINE_BUFFER_SIZE];
	sipMediaLineSt *pMultipleVideoMediaLine = (sipMediaLineSt *) &bufVideoMLine[0];
	memset(bufVideoMLine, 0, sizeof(bufVideoMLine));
		// copy sipMediaLineBaseSt
	memcpy(bufVideoMLine, pMainVideoMediaLine, sizeof(sipMediaLineBaseSt));
	pMultipleVideoMediaLine->numberOfCaps = 0;
	pMultipleVideoMediaLine->lenOfDynamicSection = 0;

		// make manipulations on media line to create: remove ICE, set a=recvonly
	DWORD originalNumOfCaps = pMainVideoMediaLine->numberOfCaps;
	DWORD capSize = 0;
	capBuffer* pCapBuffer = (capBuffer*) &pMainVideoMediaLine->caps[0];
	BYTE* pTempCap = (BYTE*)pCapBuffer;
	int copyTo = 0;

	for(unsigned int i=0; i < originalNumOfCaps; i++)
	{
		//current cap size
		capSize = sizeof(capBufferBase) + pCapBuffer->capLength;
		if((CapEnum)pCapBuffer->capTypeCode != eIceCandidateCapCode)
		{
			if (!AddCapInMediaLine(pCapBuffer, capSize, pMultipleVideoMediaLine, SIP_MEDIA_LINE_BUFFER_SIZE, copyTo))
				PTRACE(eLevelInfoNormal,"CSipCntl::AddSimulcastVideoMLinesToSDPForLync2013 AddCapInMediaLine failed ");
		}

		pTempCap += capSize;
		pCapBuffer = (capBuffer*)pTempCap;
	}

	// set receive only attribute to all caps in the media line
	SetMediaLineDirectionAttribute(pMultipleVideoMediaLine, cmCapReceive);


	// 2. copy it 5 times to pMediaLinesEntry->mediaLines, set indexes

	// Go to the end of mlines: - endMediaLinesPos, pMediaLinesEntry->mediaLines[endMediaLinesPos]
	DWORD endMediaLinesPos = 0;
	sipMediaLineSt* pMediaLine = NULL;
	for (unsigned int i = 0; i < pMediaLinesEntry->numberOfMediaLines; i++)
	{
		pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[endMediaLinesPos];
		endMediaLinesPos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;
	}

	// copy it 5 times and set indexes, set ssrc ranges
	DWORD mLineSize = sizeof(sipMediaLineBaseSt) + pMultipleVideoMediaLine->lenOfDynamicSection;
	DWORD mLinePos = endMediaLinesPos;
	int addSize =0;

	PTRACE2INT(eLevelInfoNormal,"dbg CSipCntl::AddSimulcastVideoMLinesToSDPForLync2013 mLineSize = ", mLineSize);
	for (unsigned int i=0; i < MaxMsftSvcSimulcastVideoMlines; i++) // i - simulcast video mline number 0-4
	{
		sipMediaLineSt *pMultipleVideoMLineInSDP = (sipMediaLineSt*) &pMediaLinesEntry->mediaLines[mLinePos];
		memcpy((void*)pMultipleVideoMLineInSDP, (void*)pMultipleVideoMediaLine, mLineSize);
		pMultipleVideoMLineInSDP->index = pMediaLinesEntry->numberOfMediaLines;
		pMultipleVideoMLineInSDP->ssrcrange[0] = m_pChosenLocalCap->getMsftSsrcVideoFirst(i+2);
		pMultipleVideoMLineInSDP->ssrcrange[1] = m_pChosenLocalCap->getMsftSsrcVideoLast(i+2);

		pMediaLinesEntry->numberOfMediaLines++;
		pMediaLinesEntry->lenOfDynamicSection += mLineSize;

		addSize += mLineSize;
		mLinePos += mLineSize;
	}

	return addSize;
}

int CSipCntl::CopyMLineFromLocalForAnat(sipSdpAndHeadersSt* pSdpAndHeaders, BYTE isReinvite)
 {
 	sipMediaLinesEntrySt* pMediaLinesEntry = (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders;

	unsigned int mediaLinePos = 0;
	unsigned int mediaLinePos2 = 0;
    sipMediaLineSt *pMediaLine = NULL;
	sipMediaLineSt* pExistingMediaLine = NULL;
	sipMediaLineSt* pNewMediaLine = NULL;
	int nLineOfSameInnerType = 0;
    	int size = 0;
	int copySize = 0;
	BYTE bIsCallInitiator = m_pCall->IsCallInitiator();

	// Go to the last local m-line:
	for (unsigned int i = 0; i < pMediaLinesEntry->numberOfMediaLines; i++)
	{
		pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
		mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;
	}

	unsigned int currentMLineNum = pMediaLinesEntry->numberOfMediaLines;

	for (unsigned int k = 0; k < currentMLineNum; k++)
	{
		copySize = 0;
		pExistingMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos2];

		if (pExistingMediaLine)
		{
			mediaLinePos2 += sizeof(sipMediaLineBaseSt) + pExistingMediaLine->lenOfDynamicSection; // klocwork
			pNewMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];

			//PTRACE2INT(eLevelInfoNormal,"CSipCntl::CopyMLineFromLocalForAnat: copy index = ",  pExistingMediaLine->index);	//debug for ANAT
			copySize = sizeof(sipMediaLineBaseSt) + pExistingMediaLine->lenOfDynamicSection;
			memcpy((void*)pNewMediaLine, (void*)pExistingMediaLine, copySize);
			pNewMediaLine->index = pMediaLinesEntry->numberOfMediaLines;
			pMediaLinesEntry->numberOfMediaLines ++;
			pMediaLinesEntry->lenOfDynamicSection += copySize;

			if (bIsCallInitiator)     //dial out
			{

				if (m_LastAnatSelectedIpVersion == enIpVersionMAX || m_AnatSelectedIpVersion == m_LastAnatSelectedIpVersion)
				{
					switch (pExistingMediaLine->internalType)
					{
						case kMediaLineInternalTypeAudio:
							pExistingMediaLine->mid = 1;
							pNewMediaLine->mid = 6;
							break;
						case kMediaLineInternalTypeVideo:
							pExistingMediaLine->mid = 2;
							pNewMediaLine->mid = 7;
							break;
						case kMediaLineInternalTypeFecc:
							pExistingMediaLine->mid = 3;
							pNewMediaLine->mid = 8;
							break;
						case kMediaLineInternalTypeContent:
							pExistingMediaLine->mid = 10;
							pNewMediaLine->mid = 11;
							break;
						case kMediaLineInternalTypeBfcp:
							pExistingMediaLine->mid = 4;
							pNewMediaLine->mid = 9;
							break;
						default:
							pExistingMediaLine->mid = 12;
							pNewMediaLine->mid = 13;
							break;
					}
				}
				else
				{
					switch (pExistingMediaLine->internalType)
					{
						case kMediaLineInternalTypeAudio:
							pExistingMediaLine->mid = 6;
							pNewMediaLine->mid = 1;
							break;
						case kMediaLineInternalTypeVideo:
							pExistingMediaLine->mid = 7;
							pNewMediaLine->mid = 2;
							break;
						case kMediaLineInternalTypeFecc:
							pExistingMediaLine->mid = 8;
							pNewMediaLine->mid = 3;
							break;
						case kMediaLineInternalTypeContent:
							pExistingMediaLine->mid = 11;
							pNewMediaLine->mid = 10;
							break;
						case kMediaLineInternalTypeBfcp:
							pExistingMediaLine->mid = 9;
							pNewMediaLine->mid = 4;
							break;
						default:
							pExistingMediaLine->mid = 13;
							pNewMediaLine->mid = 12;
							break;
					}
				}
			}
			else  //dial in
			{
				sipMediaLineSt *pMediaLineRmt = NULL;
				pMediaLineRmt = GetMLineAccordingToInternalTypeAndIpVersion((eMediaLineInternalType)pExistingMediaLine->internalType, m_pRemoteSdp, m_AnatSelectedIpVersion);
				if (pMediaLineRmt)
					pExistingMediaLine->mid = pMediaLineRmt->mid;
				else
				{
					if (kMediaLineInternalTypeContent == (eMediaLineInternalType)pExistingMediaLine->internalType)
						pExistingMediaLine->mid = 10;
					else
						DBGPASSERT(YES);
				}

				enIpVersion eIpAddrMatch = ((m_AnatSelectedIpVersion == eIpVersion4) ? eIpVersion6 : eIpVersion4);
				pMediaLineRmt = GetMLineAccordingToInternalTypeAndIpVersion(eMediaLineInternalType(pExistingMediaLine->internalType), m_pRemoteSdp, eIpAddrMatch);
				if (pMediaLineRmt)
					pNewMediaLine->mid = pMediaLineRmt->mid;
				else
				{
					if (kMediaLineInternalTypeContent == (eMediaLineInternalType)pExistingMediaLine->internalType)
						pNewMediaLine->mid = 11;
					else
						DBGPASSERT(YES);
				}
			}

			pExistingMediaLine->midAnatGroup[0] = pExistingMediaLine->mid;

			if (!isReinvite && bIsCallInitiator)
				pExistingMediaLine->midAnatGroup[1] = pNewMediaLine->mid;
			else
				pExistingMediaLine->midAnatGroup[1] = 0;
			memcpy((void*)pNewMediaLine->midAnatGroup, (void*)pExistingMediaLine->midAnatGroup, sizeof(pNewMediaLine->midAnatGroup));
		}
		else
			DBGPASSERT(YES);

		if (copySize)
		{
			size += copySize;
			mediaLinePos += copySize;
		}

	}

	return size;

 }

void CSipCntl::UpdatePortInClosedMediasForAnat(sipSdpAndHeadersSt* pSdpAndHeaders, vector<int> copiedIndexes) const
{
    	sipMediaLinesEntrySt* pMediaLinesEntry = (sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders;
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::UpdatePortInClosedMediasForAnat: number of closed media line #",  copiedIndexes.size());

	for(unsigned int i = 0; i < copiedIndexes.size(); i++)
	{
		sipMediaLineSt* pMediaLine = GetMediaLineAtIndex(*pSdpAndHeaders, copiedIndexes.at(i));

		if(pMediaLine)
		{
			pMediaLine->mediaIp.transAddr.port = 0;
		}
	}
}

BYTE CSipCntl::checkForMediaIpVersionMismatchForPreAnat(const sipSdpAndHeadersSt* pSdpAndHeaders)
{
	enIpVersion eIpAddrMatch = CheckForMatchBetweenPartyAndUdp(m_pNetSetup->GetIpVersion(),m_UdpAddressesParams.IpType);

	//added for ANAT
	BYTE	isIpVersionChanged = FALSE;
	enIpVersion eLocalChnlIpVersion = (enIpVersion)m_pCall->GetChannelIpAddress(cmCapAudio, cmCapReceive).ipVersion;
	if (eLocalChnlIpVersion != eIpAddrMatch)
	{
		isIpVersionChanged = TRUE;
		m_LastAnatSelectedIpVersion = eLocalChnlIpVersion;
		PTRACE2INT(eLevelError, "CSipCntl::checkForMediaIpVersionMismatchForPreAnat, local channel Ip version is different, it is ", eLocalChnlIpVersion);
	}

	if (!isIpVersionChanged)
		return 0; // Match
	else
		return 1; //No match
}

void CSipCntl::DecideAnatSelectedIpVersion(sipSdpAndHeadersSt* pSdpAndHeaders)
{
	//TRACEINTOFUNC << "m_AnatSelectedIpVersion before update is:" << m_AnatSelectedIpVersion;

	enIpVersion	tmpAnatSelectedIpVersion = enIpVersionMAX;
	string anatProtocol = "";
	CProcessBase::GetProcess()->GetSysConfig()->GetDataByKey(
			"ANAT_IP_PROTOCOL", anatProtocol);
	TRACEINTOFUNC << "ANAT_IP_PROTOCOL system flag is:" << anatProtocol.c_str();

	//2.1 dial Out
	if(m_pCall->IsCallInitiator())
	{
		TRACEINTOFUNC << "Dial Out case.";

		if(eIpType_Both == m_UdpAddressesParams.IpType && !GetIsEnableICE())
		{
			int globalPlace = -1;
			int sitePlace = -1;
			int linkPlace = -1;

			//1. set preferred Ip scope for IPV6, priority: global>site>link
			for (int i = 0;i < NUM_OF_IPV6_ADDRESSES; i++)
			{
				if (eScopeIdGlobal == (enScopeId)m_UdpAddressesParams.IpV6AddrArray[i].scopeId && globalPlace == -1)
					globalPlace = i;
				else if (eScopeIdSite == (enScopeId)m_UdpAddressesParams.IpV6AddrArray[i].scopeId && sitePlace == -1)
					sitePlace = i;
				else if (eScopeIdLink == (enScopeId)m_UdpAddressesParams.IpV6AddrArray[i].scopeId && linkPlace == -1)
					linkPlace = i;
			}

			if (eScopeIdGlobal != -1)
				m_pNetSetup->SetPerferedIpV6ScopeAddr(eScopeIdGlobal);
			else if (eScopeIdSite != -1)
				m_pNetSetup->SetPerferedIpV6ScopeAddr(eScopeIdSite);
			else if (eScopeIdLink != -1)
				m_pNetSetup->SetPerferedIpV6ScopeAddr(eScopeIdLink);
			else
				m_pNetSetup->SetPerferedIpV6ScopeAddr(eScopeIdOther);

			//2. decide ip version
			if(anatProtocol.compare("AUTO") == 0)
			{
				TRACEINTOFUNC << "AUTO.";
				tmpAnatSelectedIpVersion = eIpVersion4;	//open IPv4 first.If EP choose Ipv6, close the ipv4 and open ipv6 then
			}
			else if(anatProtocol.compare("PREFER_IPv4") == 0)
			{
				TRACEINTOFUNC << "PREFER_IPv4.";
				tmpAnatSelectedIpVersion = eIpVersion4;
			}
			else if(anatProtocol.compare("PREFER_IPv6") == 0)
			{
				TRACEINTOFUNC << "PREFER_IPv6.";
				tmpAnatSelectedIpVersion = eIpVersion6;
			}
			else     //"DISABLED"
			{
				TRACEINTOFUNC << "DISABLED.";
				tmpAnatSelectedIpVersion = enIpVersionMAX;
			}
		}
		else
			tmpAnatSelectedIpVersion = enIpVersionMAX;
	}

	//2.2 dial in
	else
	{
		TRACEINTOFUNC << "Dial In case.";

		BOOL isANATContained = FALSE;

		if (pSdpAndHeaders)
			isANATContained = IsANATPresentInSDP(pSdpAndHeaders);
		if (isANATContained && !GetIsEnableICE())
		{
			TRACEINTOFUNC << "Incoming SDP contain ANAT info";

			//set preferred Ip scope for IPV6
			sipMediaLineSt *pMediaLine = NULL;
			pMediaLine = GetMLineAccordingToInternalTypeAndIpVersion(kMediaLineInternalTypeAudio, const_cast<sipSdpAndHeadersSt*>(pSdpAndHeaders), eIpVersion6);

			if (pMediaLine)
			{
				enScopeId ePerferedIpV6ScopeAddr = (enScopeId)pMediaLine->mediaIp.transAddr.addr.v6.scopeId;
				m_pNetSetup->SetPerferedIpV6ScopeAddr(ePerferedIpV6ScopeAddr);
			}

			//RMX only support IPv4 or Ipv6
			if(eIpType_Both != m_UdpAddressesParams.IpType)
			{
				TRACEINTOFUNC << "RMX only support " << m_UdpAddressesParams.IpType;
				if(eIpType_IpV6 == m_UdpAddressesParams.IpType)
					tmpAnatSelectedIpVersion = eIpVersion6;
				else
					tmpAnatSelectedIpVersion = eIpVersion4;
			}
			else
			{
				if((anatProtocol.compare("DISABLED") == 0) ||
					(anatProtocol.compare("AUTO") == 0))
					tmpAnatSelectedIpVersion = (enIpVersion)(ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.ipVersion);
				else if(anatProtocol.compare("PREFER_IPv4") == 0)
					tmpAnatSelectedIpVersion = eIpVersion4;
				else if(anatProtocol.compare("PREFER_IPv6") == 0)
					tmpAnatSelectedIpVersion = eIpVersion6;
			}
		}
		else
		{
			TRACEINTOFUNC << "Incoming SDP doesn't contain ANAT info";
			tmpAnatSelectedIpVersion = enIpVersionMAX;
		}
	}

	if (m_AnatSelectedIpVersion != enIpVersionMAX)
		m_LastAnatSelectedIpVersion = m_AnatSelectedIpVersion;

	m_AnatSelectedIpVersion = tmpAnatSelectedIpVersion;

	TRACEINTOFUNC << "m_AnatSelectedIpVersion after update is:" << m_AnatSelectedIpVersion;
}

BYTE CSipCntl::UpdateAnatSelectedIpVersionIfNecessary(sipSdpAndHeadersSt* pSdpAndHeaders)
{
	BYTE isNeedtoUpdate = FALSE;
	int	index1 = -1;
	int	index2 = -1;

	enIpVersion otherIpVersion = ((m_AnatSelectedIpVersion == eIpVersion4) ? eIpVersion6 : eIpVersion4);
	index1 = GetIndexAccordingToInternalTypeAndIpVersion(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_AnatSelectedIpVersion);
	index2 = GetIndexAccordingToInternalTypeAndIpVersion(kMediaLineInternalTypeAudio, pSdpAndHeaders, otherIpVersion);

	mcXmlTransportAddress &mediaIp1 = ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted(), index1);
	mcXmlTransportAddress &mediaIp2 = ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted(), index2);

	if (mediaIp1.transAddr.port == 0 /*&& mediaIp2.transAddr.port != 0*/)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::UpdateAnatSelectedIpVersionIfNecessary: current IP address type is different from the expected one from EP");

		if (otherIpVersion == eIpVersion6)
			m_pNetSetup->SetPerferedIpV6ScopeAddr((enScopeId)mediaIp2.transAddr.addr.v6.scopeId);

		m_LastAnatSelectedIpVersion = m_AnatSelectedIpVersion;
		m_AnatSelectedIpVersion = otherIpVersion;

		isNeedtoUpdate = TRUE;
	}
	return isNeedtoUpdate;
}

void CSipCntl::OrderMediaLinesForMsft2013AVMCU(sipSdpAndHeadersSt &sdp)
{
	sipMediaLinesEntrySt* pMediaLinesEntry = (sdp.sipMediaLinesLength) ? (sipMediaLinesEntrySt*)&sdp.capsAndHeaders[sdp.sipMediaLinesOffset] : NULL;

	if (pMediaLinesEntry && pMediaLinesEntry->lenOfDynamicSection && m_pRemoteSdp && m_pRemoteSdp->sipMediaLinesLength)
	{
		sipMediaLinesEntrySt* pRemoteMediaLinesEntry = (sipMediaLinesEntrySt*)&m_pRemoteSdp->capsAndHeaders[m_pRemoteSdp->sipMediaLinesOffset];
		unsigned int numOfMlines = pMediaLinesEntry->numberOfMediaLines;
		unsigned int remoteNumOfMlines = 0;
		if (pRemoteMediaLinesEntry)
			remoteNumOfMlines = pRemoteMediaLinesEntry->numberOfMediaLines;
		DWORD maxMediaLinesNumber = max(numOfMlines, remoteNumOfMlines);

		PTRACE2INT(eLevelInfoNormal,"dbg CSipCntl::OrderMediaLinesForMsft2013AVMCU: numOfMlines = ", numOfMlines);
		PTRACE2INT(eLevelInfoNormal,"dbg CSipCntl::OrderMediaLinesForMsft2013AVMCU: remoteNumOfMlines = ", remoteNumOfMlines);

		if (numOfMlines > 0 )
		{
			eMediaLineInternalType givenMediaLines[maxMediaLinesNumber];
			memset(givenMediaLines,0,sizeof(givenMediaLines));
			eMediaLineInternalType remoteMediaLines[maxMediaLinesNumber];

			for (unsigned int i = 0; i < maxMediaLinesNumber; i++)
			{
				givenMediaLines[i] = ::GetMediaLineInternalType(&sdp, i);
				remoteMediaLines[i] = ::GetMediaLineInternalType(m_pRemoteSdp, i);
			}

			BYTE* pNewMediaLinesBuffer = new BYTE[pMediaLinesEntry->lenOfDynamicSection];

			unsigned int destPos = 0;
			unsigned int newIndex = 0;
			unsigned int notSupportedMediaCounter = 0;
			unsigned int videoMLineNum = 0;
			// copy mlines that exist in the remoteMediaLines array:
			for (unsigned int i = 0; i < maxMediaLinesNumber; i++)
			{
				sipMediaLineSt* pCurrentMediaLine = NULL;

				if (remoteMediaLines[i] == kMediaLineInternalTypeNotSupported) {
					pCurrentMediaLine = GetMediaLine(sdp, remoteMediaLines[i], notSupportedMediaCounter);
					notSupportedMediaCounter++;
				}
				else
				{
					if(kMediaLineInternalTypeVideo == remoteMediaLines[i])
					{

						pCurrentMediaLine = GetMediaLine(sdp, remoteMediaLines[i], videoMLineNum);
						videoMLineNum ++;

					}
					else
						pCurrentMediaLine = GetMediaLine(sdp, remoteMediaLines[i]);
				}


				if (pCurrentMediaLine && (givenMediaLines[pCurrentMediaLine->index] != kMediaLineInternalTypeNone))
				{
					unsigned int copySize = sizeof(sipMediaLineBaseSt) + pCurrentMediaLine->lenOfDynamicSection;
					memcpy(&pNewMediaLinesBuffer[destPos], pCurrentMediaLine, copySize);
					((sipMediaLineSt*)&pNewMediaLinesBuffer[destPos])->index = newIndex;
					destPos += copySize;
					newIndex++;
					givenMediaLines[pCurrentMediaLine->index] = kMediaLineInternalTypeNone; // mark it as copied.
				}
			}
			// copy mlines that still were not copied:
			for (unsigned int i = 0; i < numOfMlines; i++)
			{
				if (givenMediaLines[i] != kMediaLineInternalTypeNone)
				{
					PTRACE(eLevelInfoNormal,"dbg CSipCntl::OrderMediaLinesForMsft2013AVMCU copy mline that still was not copied ");
					sipMediaLineSt* pCurrentMediaLine = NULL;
					if(kMediaLineInternalTypeVideo == givenMediaLines[i])
					{
						pCurrentMediaLine = GetMediaLine(sdp, givenMediaLines[i],videoMLineNum);
						videoMLineNum++;
					} else
					{
						pCurrentMediaLine = GetMediaLine(sdp, givenMediaLines[i]);
					}
					if (pCurrentMediaLine)
					{
						unsigned int copySize = sizeof(sipMediaLineBaseSt) + pCurrentMediaLine->lenOfDynamicSection;
						memcpy(&pNewMediaLinesBuffer[destPos], pCurrentMediaLine, copySize);
						((sipMediaLineSt*)&pNewMediaLinesBuffer[destPos])->index = newIndex;
						destPos += copySize;
						newIndex++;
					}

				}
			}



			if (destPos == pMediaLinesEntry->lenOfDynamicSection) // destination position should be equal to lenOfDynamicSection
				memcpy(pMediaLinesEntry->mediaLines, pNewMediaLinesBuffer, pMediaLinesEntry->lenOfDynamicSection); // copy the new order to the original structure.
			else
				DBGPASSERT(YES);

			delete[] pNewMediaLinesBuffer;
		}
	}
}

void CSipCntl::OrderMediaLinesForAnat(sipSdpAndHeadersSt &sdp)
{
	sipMediaLinesEntrySt* pMediaLinesEntry = (sdp.sipMediaLinesLength) ? (sipMediaLinesEntrySt*)&sdp.capsAndHeaders[sdp.sipMediaLinesOffset] : NULL;

	if (pMediaLinesEntry && pMediaLinesEntry->lenOfDynamicSection && m_pRemoteSdp && m_pRemoteSdp->sipMediaLinesLength)
	{
		sipMediaLinesEntrySt* pRemoteMediaLinesEntry = (sipMediaLinesEntrySt*)&m_pRemoteSdp->capsAndHeaders[m_pRemoteSdp->sipMediaLinesOffset];
		unsigned int numOfMlines = pMediaLinesEntry->numberOfMediaLines;
		unsigned int remoteNumOfMlines = 0;
		if (pRemoteMediaLinesEntry)
			remoteNumOfMlines = pRemoteMediaLinesEntry->numberOfMediaLines;
		DWORD maxMediaLinesNumber = max(numOfMlines, remoteNumOfMlines);

		if (numOfMlines > 0 )
		{
			eMediaLineInternalType givenMediaLines[maxMediaLinesNumber];
			eMediaLineInternalType remoteMediaLines[maxMediaLinesNumber];
			enIpVersion remoteMediaLinesIpType[maxMediaLinesNumber];

			for (unsigned int i = 0; i < maxMediaLinesNumber; i++)
			{
				givenMediaLines[i] = ::GetMediaLineInternalType(&sdp, i);
				remoteMediaLines[i] = ::GetMediaLineInternalType(m_pRemoteSdp, i);
				remoteMediaLinesIpType[i] = ::GetMediaLineIpVersionlType(m_pRemoteSdp, i);
			}

			BYTE* pNewMediaLinesBuffer = new BYTE[pMediaLinesEntry->lenOfDynamicSection];
			if (pNewMediaLinesBuffer==NULL)
			{
				PASSERTMSG(1,"CSipCntl::OrderMediaLinesForAnat, memory allocation failure!!!");
				return;
			}

			unsigned int destPos = 0;
			unsigned int newIndex = 0;
			// copy mlines that exist in the remoteMediaLines array:
			for (unsigned int i = 0; i < maxMediaLinesNumber; i++)
			{
				int index = -1;
				if (remoteMediaLinesIpType[i] == m_AnatSelectedIpVersion)
					index = 0;
				else
					index = 1;
				//TRACEINTOFUNC << "numOfMlines = " << numOfMlines  << " LineNO = " << i << " index = " << index;

				sipMediaLineSt* pCurrentMediaLine = GetMediaLine(sdp, remoteMediaLines[i], index);

				if (pCurrentMediaLine && (givenMediaLines[pCurrentMediaLine->index] != kMediaLineInternalTypeNone))
				{
					unsigned int copySize = sizeof(sipMediaLineBaseSt) + pCurrentMediaLine->lenOfDynamicSection;
					memcpy(&pNewMediaLinesBuffer[destPos], pCurrentMediaLine, copySize);
					((sipMediaLineSt*)&pNewMediaLinesBuffer[destPos])->index = newIndex;
					destPos += copySize;
					newIndex++;
					givenMediaLines[pCurrentMediaLine->index] = kMediaLineInternalTypeNone; // mark it as copied.
				}
			}
			// copy mlines that still were not copied:
			BOOL bIsFirstAudioLineForANAT = TRUE;
			BOOL bIsFirstVideoLineForANAT = TRUE;
			BOOL bIsFirstContentLineForANAT = TRUE;
			BOOL bIsFirstFeccLineForANAT = TRUE;
			BOOL bIsFirstBfcpLineForANAT = TRUE;
			BOOL bIsFirstUnsupportedLineForANAT = TRUE;

			for (unsigned int i = 0; i < numOfMlines; i++)
			{
				if (givenMediaLines[i] != kMediaLineInternalTypeNone)
				{
					TRACEINTOFUNC << "givenMediaLines = " << givenMediaLines[i] << " Line No = " <<i;
					if ((kMediaLineInternalTypeAudio == givenMediaLines[i] && bIsFirstAudioLineForANAT) ||
				     (kMediaLineInternalTypeVideo == givenMediaLines[i] && bIsFirstVideoLineForANAT)	||
				     (kMediaLineInternalTypeContent == givenMediaLines[i] && bIsFirstContentLineForANAT)	||
				     (kMediaLineInternalTypeFecc== givenMediaLines[i] && bIsFirstFeccLineForANAT)	||
				     (kMediaLineInternalTypeBfcp == givenMediaLines[i] && bIsFirstBfcpLineForANAT) ||
				     (kMediaLineInternalTypeNotSupported == givenMediaLines[i] && bIsFirstUnsupportedLineForANAT))
					{
						for (int k=0; k<2; k++)
						{
							sipMediaLineSt* pCurrentMediaLine = GetMediaLine(sdp, givenMediaLines[i], k);
							if (pCurrentMediaLine)
							{
								TRACEINTOFUNC << "more media line in local, pMediaLinesEntry->lenOfDynamicSection = "<< pMediaLinesEntry->lenOfDynamicSection<<" destPos="<<destPos;
								unsigned int copySize = sizeof(sipMediaLineBaseSt) + pCurrentMediaLine->lenOfDynamicSection;
								if ((destPos+copySize) > pMediaLinesEntry->lenOfDynamicSection)
								{
									DBGFPASSERT(destPos);
									break;
								}
								memcpy(&pNewMediaLinesBuffer[destPos], pCurrentMediaLine, copySize);
								((sipMediaLineSt*)&pNewMediaLinesBuffer[destPos])->index = newIndex;
								destPos += copySize;
								newIndex++;

								//givenMediaLines[pCurrentMediaLine->index] = kMediaLineInternalTypeNone; // mark it as copied.
							}
						}

						switch(givenMediaLines[i] )
						{
							case kMediaLineInternalTypeAudio:
								bIsFirstAudioLineForANAT = FALSE;
								break;
							case kMediaLineInternalTypeVideo:
								bIsFirstVideoLineForANAT = FALSE;
								break;
							case kMediaLineInternalTypeFecc:
								bIsFirstFeccLineForANAT = FALSE;
								break;
							case kMediaLineInternalTypeContent:
								bIsFirstContentLineForANAT = FALSE;
								break;
							case kMediaLineInternalTypeBfcp:
								bIsFirstBfcpLineForANAT = FALSE;
								break;
							case kMediaLineInternalTypeNotSupported:
								bIsFirstUnsupportedLineForANAT = FALSE;
								break;
							default:
								break;
						}
					}

				}
			}

			if (destPos == pMediaLinesEntry->lenOfDynamicSection) // destination position should be equal to lenOfDynamicSection
				memcpy(pMediaLinesEntry->mediaLines, pNewMediaLinesBuffer, pMediaLinesEntry->lenOfDynamicSection); // copy the new order to the original structure.
			else
				DBGPASSERT(YES);

			delete[] pNewMediaLinesBuffer;
		}
	}
}
//added for ANAT end

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SipStartDtlsChannelReq(cmCapDirection channelDirection)//EIpChannelType chanArr)
{
	int iNumOfChannels = 0;

	cmCapDirection	direction;
	cmCapDataType 	mediaType;
	ERoleLabel 	  	role;
	kChanneltype	channelType;

	CSipChannel* pChannel = NULL;
	CSipComMode* pTargetMode = NULL;
	CSdesCap*	 pSdesCap = NULL;

	iNumOfChannels = m_pCall->GetNumOfChannels();

	PTRACE2INT(eLevelInfoNormal, "CSipCntl::SipStartDtlsChannelReq, iNumOfChannels:", iNumOfChannels);

	if(m_pParty)
		pTargetMode = (CSipComMode*)m_pParty->GetTargetMode();

	PASSERTMSG_AND_RETURN(pTargetMode == NULL,"Target mode not found");

	for (int i = 0; i < iNumOfChannels; i++)
	{
		pChannel = m_pCall->GetChannel(i/*chanArr*/, true);

		if (!pChannel)
			continue;

		direction 	= pChannel->GetDirection();
		mediaType 	= pChannel->GetMediaType();
		role	  	= pChannel->GetRoleLabel();

		channelType = ::DataTypeToChannelType(mediaType, role);

		if ((pChannel && direction == channelDirection && pChannel->IsMediaChannel()) 	&&
		    (channelType == kIpAudioChnlType || channelType == kIpVideoChnlType) 		&&
		    (pTargetMode && pTargetMode->IsMediaOn(mediaType,direction,role) && pTargetMode->GetIsDtlsEncrypted() == Encryp_On))
		{
			TDtlsStartStruct *pStruct 		= new TDtlsStartStruct;

			PTRACE2INT(eLevelInfoNormal, "CSipCntl::SipStartDtlsChannelReq, channel index:", i);

			if (pStruct)
			{
				mcReqCmDtlsStart *pStartDtlsReq = &pStruct->tCmDtlsStart;

				pStartDtlsReq->channelType		 	= channelType;
				pStartDtlsReq->channelDirection 	= direction;

				pStartDtlsReq->CmLocalUdpAddressIp 	= pChannel->GetAddress();

				pStartDtlsReq->LocalRtcpPort = pChannel->GetRtcpPort();

				memcpy(&(pStartDtlsReq->CmRemoteUdpAddressIp), pChannel->GetRmtAddress(), sizeof(mcTransportAddress));
				pStartDtlsReq->RemoteRtcpPort = pChannel->GetRtcpRmtPort();

				if(pChannel->GetChannelSdes())
					pSdesCap = pChannel->GetChannelSdes();
				else
					pSdesCap = pTargetMode->GetSipDtls(mediaType,direction,role);


				CopySdesCapsFromClassToStruct(&pStartDtlsReq->sdesCap, pSdesCap);


				if(pChannel->GetChannelSdes() == NULL)
				{
					PTRACE2INT(eLevelInfoNormal, "CSipCntl::SipStartDtlsChannelReq, no SDES channel index:", i);
					pStartDtlsReq->sdesCap.bIsSrtpInUse = 0;
				}


				pChannel->SetDtlsConnectionState(kConnecting);

				memset(&(pStruct->physicalPort.physical_id), 0, sizeof(PHYSICAL_RESOURCE_INFO_S));
				pStruct->physicalPort.connection_id = m_pMfaInterface->GetConnectionId();
				pStruct->physicalPort.party_id 		= m_pCsRsrcDesc->GetPartyRsrcId();

				CMedString str;

				str << "channelType:" << pStartDtlsReq->channelType << ", channelDirection:" << pStartDtlsReq->channelDirection << ", channel dtls state:" << pChannel->GetDtlsConnectionState();

				PTRACE2(eLevelError, "IP_CM_DTLS_START_REQ is sent to CM, ", str.GetString());

				SendMsgToMpl((BYTE*)(pStruct), sizeof(TDtlsStartStruct), IP_CM_DTLS_START_REQ);

				str.Clear();

				str << " mediaType: " << pChannel->GetMediaType()
					<< ", direction: " << pChannel->GetDirection()
					<< ", dtls state: " << pChannel->GetDtlsConnectionState()
					<< ", channel state: " << pChannel->GetConnectionState()
					<< ", is channel dtls enable:	" << pChannel->IsChannelDtlsEnabled();

				PTRACE2(eLevelError,"CSipCntl::SipStartDtlsChannelReq :",str.GetString());

				PDELETE(pStruct);
			}
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnCmDtlsEndInd(CSegment* pParam)
{
//	PTRACE(eLevelInfoNormal, "OnCmDtlsEndInd");

	APIU32		status;				// status 0 - OK, 1 Violate.
	APIU32		channelType;		// kChanneltype
	APIU32		channelDirection;	// cmCapDirection.

	cmCapDataType mediaType;
	ERoleLabel 	  role;

	sdesCapSt	*pSdesCap = NULL;  // remote sdes caps
	CDtlsCap 	*pDtlsCap = NULL;
	CSipComMode	*pTargetMode = NULL;
	CSipChannel *pChannel = NULL;

	*pParam >> status;
	*pParam >> channelType;
	*pParam >> channelDirection;

	CMedString str;
	mediaType = ChannelTypeToDataType((kChanneltype) channelType, role);

	str << "mediaType:" << mediaType << ", channelDirection:" << channelDirection;
	PTRACE2(eLevelInfoNormal, "CSipCntl::OnCmDtlsEndInd - Setting DTLS for channel: ", str.GetString());

	pSdesCap = (sdesCapSt*) pParam->GetPtr(1);

	pChannel = m_pCall->GetChannel(true, mediaType, (cmCapDirection) channelDirection, role);

	PASSERTMSG_AND_RETURN(pChannel == NULL,"CSipCntl::OnCmDtlsEndInd - pChannel not found");

	PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnCmDtlsEndInd, channel state:", pChannel->GetDtlsConnectionState());

	if (status == STATUS_OK)
	{
		if(m_pParty)
			pTargetMode = (CSipComMode*)m_pParty->GetTargetMode();
		else
			PTRACE(eLevelInfoNormal, "CSipCntl::OnCmDtlsEndInd - m_pParty is NULL");

		m_bIsOneDtlsArrived = TRUE;
		if (pTargetMode && pTargetMode->IsMediaOn(mediaType,(cmCapDirection)channelDirection,role) && pTargetMode->GetIsDtlsEncrypted() == Encryp_On)
		{
			pDtlsCap = pTargetMode->GetSipDtls(mediaType,(cmCapDirection)channelDirection,role);

			if (CopySdesCapsFromStructToClass(pDtlsCap , pSdesCap))
			{
				pChannel->RemoveChannelDtls();
				pChannel->SetChannelDtls(pDtlsCap);

				pChannel->SetDtlsConnectionState(kConnected);

				// in TIP call set the video DTLS to content
				if (GetIsTipCall() && mediaType == cmCapVideo)
				{
					if (pTargetMode->IsMediaOn(mediaType,(cmCapDirection)channelDirection,kRolePresentation))
					{
						PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnCmDtlsEndInd - Setting DTLS for content, direction: ", channelDirection);

						CSipChannel *pContentChannel = m_pCall->GetChannel(true, mediaType, (cmCapDirection) channelDirection, kRolePresentation);//amirk-rebase
						CDtlsCap 	*pDtlsContentCap = pTargetMode->GetSipDtls(mediaType,(cmCapDirection)channelDirection,kRolePresentation);

						if (pContentChannel && pDtlsContentCap)
						{
							CopySdesCapsFromStructToClass(pDtlsContentCap , pSdesCap);

							pContentChannel->SetChannelDtls(pDtlsContentCap);
						}
						else if(pContentChannel)
						{
							PTRACE(eLevelInfoNormal, "CSipCntl::OnCmDtlsEndInd -no DTLS cotentn cap put video DTLS cap ");
							pContentChannel->SetChannelDtls(pDtlsCap);

						}
						else
							PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnCmDtlsEndInd - failed to set DTLS for content, no channel - direction: ", channelDirection);
					}
					else
						PTRACE2INT(eLevelInfoNormal, "CSipCntl::OnCmDtlsEndInd - failed to set DTLS for content, media off - direction: ", channelDirection);
				}
			}
			else
				pChannel->SetDtlsConnectionState(kDisconnecting);
		}
		else
			PTRACE(eLevelInfoNormal, "CSipCntl::OnCmDtlsEndInd, no target mode or media off or no dtls for media");
	}
	else
	{
		pChannel->SetDtlsConnectionState(kDisconnecting);
	}

	str.Clear();

	str << "status:" << status << ", mediaType:" << mediaType << ", channelDirection:" << channelDirection << ", channel state:" << pChannel->GetDtlsConnectionState();

	PTRACE2(eLevelInfoNormal, "CSipCntl::OnCmDtlsEndInd, ", str.GetString());

	if (m_pCall->AreAllDtlsChannelsConnected())
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::OnCmDtlsEndInd, All Dtls Channels are connected");
		m_pPartyApi->SipPartyDtlsStatus(STATUS_OK);
	}
	else if (m_pCall->IsOnlyOneDtlsChannelDisconnectionState(kDisconnecting))
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::OnCmDtlsEndInd, Need to close Dtls Channels");
		m_pPartyApi->SipPartyDtlsStatus(STATUS_FAIL);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipCloseAllDtlsChannelsReq()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipCloseAllDtlsChannelsReq");

	BYTE 	bIsMessageSent = FALSE;
	int 	iNumOfChannels = 0;

	CSipChannel* pChannel 		= NULL;


	if (m_pCall == NULL)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::SipCloseAllDtlsChannelsReq - m_pCall not found");
		return FALSE;
	}

	iNumOfChannels = m_pCall->GetNumOfChannels();
	PTRACE2INT(eLevelError,"CSipCntl::SipCloseDtlsChannelReq iNumOfChannels: ", iNumOfChannels);

	for (int i = 0; i < iNumOfChannels; i++)
	{
		pChannel = m_pCall->GetChannel(i, true);

		if(!pChannel)
		{
			PTRACE2INT(eLevelError,"CSipCntl::SipCloseDtlsChannelReq i: ", i);
			continue;
		}

		bIsMessageSent |= SipCloseDtlsChannelReq(pChannel);
	}

	return bIsMessageSent;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::SipCloseAllDtlsChannelsAfterDtlsFailureReq()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::SipCloseAllDtlsChannelsAfterDtlsFailureReq");

	int iNumOfChannels = 0;

	CSipChannel* pChannel 		= NULL;
	CSipComMode* pTargetMode 	= NULL;
	kChanneltype channelType;

	PASSERTMSG_AND_RETURN(m_pCall == NULL,"CSipCntl::SipCloseAllDtlsChannelsAfterDtlsFailureReq - m_pCall not found");

	iNumOfChannels = m_pCall->GetNumOfChannels();

	/*BRIDGE-6184
	m_bChangeModeWithinTransaction = YES; // Most of cases

	m_state = IP_CHANGEMODE;
	*/

	if(m_pParty)
		pTargetMode = (CSipComMode*)m_pParty->GetTargetMode();

	PASSERTMSG_AND_RETURN(pTargetMode == NULL,"CSipCntl::SipCloseAllDtlsChannelsAfterDtlsFailureReq - pTargetMode is NULL");

	pTargetMode->SetDtlsEncryption(FALSE);

	for (int i = 0; i < iNumOfChannels; i++)
	{
		pChannel = m_pCall->GetChannel(i, true);

		if(!pChannel)
			continue;

		SipCloseDtlsChannelReq(pChannel);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::SipCloseDtlsChannelReq(CSipChannel* pChannel)
{
	if (!pChannel)
	{
		PTRACE(eLevelError, "CSipCntl::SipCloseDtlsChannelReq - pChannel is NULL");
		return FALSE;
	}

	TRACEINTO << "SIPControl m_state: " << m_state ;


	CLargeString str;

	str << " mediaType: " << pChannel->GetMediaType()
		<< ", direction: " << pChannel->GetDirection()
		<< ", dtls state: " << pChannel->GetDtlsConnectionState()
		<< ", channel state: " << pChannel->GetConnectionState()
		<< ", is channel dtls enable:	" << pChannel->IsChannelDtlsEnabled();

	PTRACE2(eLevelError,"CSipCntl::SipCloseDtlsChannelReq :",str.GetString());

	CSipComMode* pTargetMode 	= NULL;
	kChanneltype channelType;

	if (m_pParty)
		pTargetMode = (CSipComMode*)m_pParty->GetTargetMode();

	if (!pTargetMode)
	{
		TRACEINTO << "CSipCntl::SipCloseAllDtlsChannelsAfterDtlsFailureReq - pTargetMode is NULL";
		return FALSE;
	}

	if ((pChannel->GetConnectionState() == kConnected) &&
		((pChannel->GetDtlsConnectionState() == kConnected)     ||
		(pChannel->GetDtlsConnectionState() == kConnecting)    ||
		(pChannel->GetDtlsConnectionState() == kDisconnecting)))
	{
		channelType = ::DataTypeToChannelType(pChannel->GetMediaType(), pChannel->GetRoleLabel());

		if (pChannel->GetMediaType() != cmCapBfcp && channelType != kIpFeccChnlType)
		{
			TDtlsCloseStruct *pStruct = new TDtlsCloseStruct;

			if (pStruct)
			{
				mcReqCmDtlsClose 	*pCloseDtlsReq 	= &pStruct->tCmDtlsClose;

				pChannel->RemoveChannelDtls();
				pChannel->SetDtlsConnectionState(kDisconnecting);

				pTargetMode->RemoveSipDtls(pChannel->GetMediaType(), pChannel->GetDirection(), pChannel->GetRoleLabel());

				pCloseDtlsReq->channelType		 	= channelType;
				pCloseDtlsReq->channelDirection 	= pChannel->GetDirection();

				pCloseDtlsReq->CmLocalUdpAddressIp 	= pChannel->GetAddress();

				pCloseDtlsReq->LocalRtcpPort 		= pChannel->GetRtcpPort();

				memcpy(&(pCloseDtlsReq->CmRemoteUdpAddressIp), pChannel->GetRmtAddress(), sizeof(mcTransportAddress));
				pCloseDtlsReq->RemoteRtcpPort = pChannel->GetRtcpRmtPort();

				memset(&(pStruct->physicalPort.physical_id), 0, sizeof(PHYSICAL_RESOURCE_INFO_S));
				pStruct->physicalPort.connection_id = m_pMfaInterface->GetConnectionId();
				pStruct->physicalPort.party_id 		= m_pCsRsrcDesc->GetPartyRsrcId();

				CMedString str;

				str << "channelType:" << pCloseDtlsReq->channelType << ", channelDirection:" << pCloseDtlsReq->channelDirection;

				PTRACE2(eLevelInfoNormal, "IP_CM_DTLS_CLOSE_REQ is sent to CM, ", str.GetString());

				SendMsgToMpl((BYTE*)(pStruct), sizeof(TDtlsCloseStruct), IP_CM_DTLS_CLOSE_REQ);

				PDELETE(pStruct);

				str.Clear();

				str << " mediaType: " << pChannel->GetMediaType()
					<< ", direction: " << pChannel->GetDirection()
					<< ", dtls state: " << pChannel->GetDtlsConnectionState()
					<< ", channel state: " << pChannel->GetConnectionState()
					<< ", is channel dtls enable:	" << pChannel->IsChannelDtlsEnabled();

				PTRACE2(eLevelError,"CSipCntl::SipCloseDtlsChannelReq :",str.GetString());

				return TRUE;
			}
			else
				PTRACE2INT(eLevelError,"CSipCntl::SipCloseDtlsChannelReq pStruct is NULL, channelType:", channelType);
		}
	}
	else
		TRACEINTO << "CSipCntl::SipCloseDtlsChannelReq channel or dtls isn't connected, channel state: " << (int)(pChannel->GetConnectionState()) << " DTLS channel state: " << (int)(pChannel->GetDtlsConnectionState());
		//PTRACE2INT(eLevelError,"CSipCntl::SipCloseDtlsChannelReq channel or dtls isn't connected, channel state: ", pChannel->GetConnectionState());

	return FALSE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::OnCmTipEarlyPacketInd(CSegment* pParam)
{
	if (m_bIsOneDtlsArrived == TRUE)
	{
		TRACEINTO << "DTLS arrived - ignore this";
		return;
	}
	TRACEINTO;
	m_pPartyApi->SipPartyTipEarlyPacketInd();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::CopySdesCapsFromClassToStruct(sdesCapSt *pToSdesCap, CSdesCap *pFromSdesCap)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::CopySdesCapsFromClassToStruct");
	APIU32 numOfKeys 				= 0;

	BOOL bIsKdrInUse 				= FALSE;
	BOOL bIsSdesWshInUse 			= FALSE;
	BOOL bIsSdesFecOrderInUse 		= FALSE;
	BOOL bIsSdesLifeTimeInUse 		= FALSE;
	BOOL bIsSdesMkiInUse 			= FALSE;
	BOOL bIsSdesMkiValueLenInUse 	= FALSE;

	TRACECOND_AND_RETURN(!pToSdesCap, "CSipCntl::CopySdesCapsFromClassToStruct - pToSdesCap is NULL");
	memset(pToSdesCap, 0, sizeof(sdesCapSt));

	if (pToSdesCap && pFromSdesCap)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::CopySdesCapsFromClassToStruct - bIsSrtpInUse is TRUE");

		pToSdesCap->bIsSrtpInUse = 1;
		pToSdesCap->cryptoSuite = pFromSdesCap->GetSdesCryptoSuite();
		//Session params
		pToSdesCap->sessionParams.sdesUnencryptedSrtp 	= pFromSdesCap->GetIsSdesUnencryptedSrtp();
		pToSdesCap->sessionParams.sdesUnencryptedSrtcp 	= pFromSdesCap->GetIsSdesUnencryptedSrtcp();
		pToSdesCap->sessionParams.sdesUnauthenticatedSrtp = pFromSdesCap->GetIsSdesUnauthenticatedSrtp();

		bIsKdrInUse = pFromSdesCap->GetIsSdesKdrInUse();
		pToSdesCap->sessionParams.bIsKdrInUse = bIsKdrInUse;

		if (bIsKdrInUse)
			pToSdesCap->sessionParams.sdesKdr = pFromSdesCap->GetSdesKdr();

		bIsSdesWshInUse = pFromSdesCap->GetIsSdesWshInUse();
		pToSdesCap->sessionParams.bIsWshInUse = bIsSdesWshInUse;

		if (bIsSdesWshInUse)
			pToSdesCap->sessionParams.sdesWsh = pFromSdesCap->GetSdesWsh();

		bIsSdesFecOrderInUse = pFromSdesCap->GetIsSdesFecOrderInUse();
		pToSdesCap->sessionParams.bIsFecOrderInUse = bIsSdesFecOrderInUse;

		if (bIsSdesFecOrderInUse)
			pToSdesCap->sessionParams.sdesFecOrder = pFromSdesCap->GetSdesFecOrder();

		pToSdesCap->sessionParams.bIsFecKeyInUse = pFromSdesCap->GetIsSdesFecKeyInUse();

		numOfKeys = pFromSdesCap->GetSdesNumOfKeysParam();
		pToSdesCap->numKeyParams = numOfKeys;

		//keyParamsList
		for (APIU32 i = 0; i < numOfKeys; i++)
		{
			pToSdesCap->keyParamsList[i].keyMethod = pFromSdesCap->GetSdesKeyMethod(i);

			bIsSdesLifeTimeInUse = pFromSdesCap->GetIsSdesLifeTimeInUse(i);
			pToSdesCap->keyParamsList[i].keyInfo.bIsLifeTimeInUse = bIsSdesLifeTimeInUse;

			if (bIsSdesLifeTimeInUse)
				pToSdesCap->keyParamsList[i].keyInfo.lifetime = pFromSdesCap->GetSdesLifeTime(i);

			bIsSdesMkiInUse = pFromSdesCap->GetIsSdesMkiInUse(i);
			pToSdesCap->keyParamsList[i].keyInfo.bIsMkiInUse = bIsSdesMkiInUse;

			if(bIsSdesMkiInUse)
				pToSdesCap->keyParamsList[i].keyInfo.mkiValue = pFromSdesCap->GetSdesMkiValue(i);

			bIsSdesMkiValueLenInUse = pFromSdesCap->GetIsSdesMkiValueLenInUse(i);
			pToSdesCap->keyParamsList[i].keyInfo.bIsMkiValueLenInUse = bIsSdesMkiValueLenInUse;

			if(bIsSdesMkiValueLenInUse)
				pToSdesCap->keyParamsList[i].keyInfo.mkiValueLen = pFromSdesCap->GetSdesMkiValueLen(i);

			char *sdesBase64KeySalt = pFromSdesCap->GetSdesBase64KeySalt(i);

			if ( sdesBase64KeySalt )
				strncpy(&pToSdesCap->keyParamsList[i].keyInfo.keySalt[0],
					sdesBase64KeySalt, MAX_BASE64_KEY_SALT_LEN);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::CopySdesCapsFromStructToClass(CSdesCap *pToSdesCap, sdesCapSt *pFromSdesCap)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::CopySdesCapsFromStructToClass");

	APIU32 numOfKeys 				= 0;

	BOOL bIsKdrInUse 				= FALSE;
	BOOL bIsSdesWshInUse 			= FALSE;
	BOOL bIsSdesFecOrderInUse 		= FALSE;
	BOOL bIsSdesLifeTimeInUse 		= FALSE;
	BOOL bIsSdesMkiInUse 			= FALSE;
	BOOL bIsSdesMkiValueLenInUse 	= FALSE;

	if (pToSdesCap && pFromSdesCap)
	{
		if (pFromSdesCap->bIsSrtpInUse)
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::CopySdesCapsFromStructToClass, bIsSrtpInUse is TRUE");

			numOfKeys = pFromSdesCap->numKeyParams;

			PTRACE2INT(eLevelInfoNormal,"CSipCntl::CopySdesCapsFromStructToClass, numOfKeys:", numOfKeys);

			if (numOfKeys <= 0)
				return FALSE;

//			pSdesCap->SetSdesTag(1);
			pToSdesCap->SetSdesCryptoSuite(pFromSdesCap->cryptoSuite);
			pToSdesCap->SetNumOfKeysParam(numOfKeys);

			for (int i = 0; i < (int) numOfKeys; i++)
			{
				pToSdesCap->SetIsSdesLifeTimeInUse(i, pFromSdesCap->keyParamsList[i].keyInfo.bIsLifeTimeInUse);

				bIsSdesMkiInUse = pFromSdesCap->keyParamsList[i].keyInfo.bIsMkiInUse;

				if (bIsSdesMkiInUse)
				{
					pToSdesCap->SetIsSdesMkiInUse(i, bIsSdesMkiInUse);
					pToSdesCap->SetSdesMkiValue(i, pFromSdesCap->keyParamsList[i].keyInfo.mkiValue);

					bIsSdesMkiValueLenInUse = pFromSdesCap->keyParamsList[i].keyInfo.bIsMkiValueLenInUse;

					pToSdesCap->SetIsSdesMkiValueLenInUse(i, bIsSdesMkiValueLenInUse);
					pToSdesCap->SetSdesMkiValueLen(i,pFromSdesCap->keyParamsList[i].keyInfo.mkiValueLen);
				}
				else
				{
					pToSdesCap->SetIsSdesMkiInUse(i, FALSE);
					pToSdesCap->SetSdesMkiValue(i, 0);
					pToSdesCap->SetIsSdesMkiValueLenInUse(i, FALSE);
					pToSdesCap->SetSdesMkiValueLen(i,0);
				}

				if (strlen(pFromSdesCap->keyParamsList[i].keyInfo.keySalt) == 0)
				{
					PTRACE(eLevelInfoNormal,"CSipCntl::CopySdesCapsFromStructToClass, keySalt is empty!!!");
					return FALSE;
				}

				pToSdesCap->SetSdesBase64KeySalt(i, pFromSdesCap->keyParamsList[i].keyInfo.keySalt);
				pToSdesCap->SetSdesLifeTime(i, pFromSdesCap->keyParamsList[i].keyInfo.lifetime);
				pToSdesCap->SetSdesKeyMethod(i, pFromSdesCap->keyParamsList[i].keyMethod);
			}

			pToSdesCap->SetIsSdesUnencryptedSrtp(pFromSdesCap->sessionParams.sdesUnencryptedSrtp);
			pToSdesCap->SetIsSdesUnencryptedSrtcp(pFromSdesCap->sessionParams.sdesUnencryptedSrtcp);
			pToSdesCap->SetIsSdesUnauthenticatedSrtp(pFromSdesCap->sessionParams.sdesUnauthenticatedSrtp);
			pToSdesCap->SetIsSdesKdrInUse(pFromSdesCap->sessionParams.bIsKdrInUse);
			pToSdesCap->SetSdesKdr(pFromSdesCap->sessionParams.sdesKdr);
			pToSdesCap->SetIsSdesWshInUse(pFromSdesCap->sessionParams.bIsWshInUse);
			pToSdesCap->SetSdesWsh(pFromSdesCap->sessionParams.sdesWsh);
			pToSdesCap->SetIsSdesFecOrderInUse(pFromSdesCap->sessionParams.bIsFecOrderInUse);
			pToSdesCap->SetSdesFecOrder(pFromSdesCap->sessionParams.sdesFecOrder);
			pToSdesCap->SetIsSdesFecKeyInUse(pFromSdesCap->sessionParams.bIsFecKeyInUse);
		}
	}

	return TRUE;
}

void CSipCntl::UpdateArtWithSsrc(DWORD ssrc)
{
    TRACEINTO << "mix_mode: ssrc = " << ssrc;
    TRtpUpdateRelayReq stRelayParamsIn;
    int size = sizeof(TRtpUpdateRelayReq);

    stRelayParamsIn.unChannelType = kIpVideoChnlType;
    stRelayParamsIn.unChannelDirection = cmCapReceive;
    stRelayParamsIn.nSSRC.numOfSSRC = 1;
    stRelayParamsIn.nSSRC.ssrcList[0] = ssrc;

    stRelayParamsIn.unIvrSsrc = 0; //relevant only for audio out
    stRelayParamsIn.unIvrCsrc = 0; //relevant only for audio out

    SendMsgToMpl((BYTE*)(&stRelayParamsIn), size, ART_UPDATE_RELAY_PARAMS_REQ);
}

////////////////////////////////////////////////////////////////////////////
void CSipCntl::HandleArtUpdateWithSsrcAck(ACK_IND_S* pAckIndStruct)
{
    if (pAckIndStruct->ack_base.status != STATUS_OK)
    {
        TRACEINTO << "ART_UPDATE_RELAY_PARAMS_REQ - status is NOT ok";
    }
    m_pParty->SendArtUpdateWithSsrcAck(pAckIndStruct->ack_base.status);
}
////////////////////////////////////////////////////////////////////////////



void CSipCntl::HandleInternalArtAck(ACK_IND_S *pAckIndStruct, ConnectionID connectionId)
{
	TRACEINTO<<"!@# THE connectionId: " << connectionId;
	TRACEINTO<<"!@# pAckIndStruct->ack_base.ack_opcode:" << pAckIndStruct->ack_base.ack_opcode;
	InternalTranslatorInterface* curTranslatorInterface=NULL;
	if(pAckIndStruct->ack_base.ack_opcode == TB_MSG_OPEN_PORT_REQ 	)
	{
		if(GetArtInterfaceByConnId(connectionId,curTranslatorInterface))
		{
			curTranslatorInterface->state=STATE_ON;
			TRACEINTOFUNC <<"!@#  dynMixedPosAck art connected: curTranslatorInterface->state:"<<(curTranslatorInterface->state==STATE_ON ? "STATE_ON":"STATE_OFF");

		}
        if(AreAllInternalArtsConnected())
        {
            m_pPartyApi->IPPartyInternalArtsConnected();
        }
	}
	else if (pAckIndStruct->ack_base.ack_opcode == TB_MSG_CLOSE_PORT_REQ)
	{
		if (GetArtInterfaceByConnId(connectionId,curTranslatorInterface))
		{
			curTranslatorInterface->state=STATE_OFF;
			TRACEINTOFUNC <<"!@#  curTranslatorInterface->state:"<<(curTranslatorInterface->state==STATE_ON ? "STATE_ON":"STATE_OFF");

		}
		if (m_state!=IP_DISCONNECTING && m_state!=DISCONNECT)
		{
		    // remove art from resource table
		    RemoveArtByConnId(connectionId);

			// if all disconnecting arts are already disconnected, notify party
			if (!IsAtLeastOneInternalArtDisconnecting())
			    m_pPartyApi->IPPartyInternalArtsDisconnected();
		}
        else if(AreAllInternalArtsDisconnected())
        {
            if(m_IsEnableICE && m_bIsSentICEStackReq)
            {
                CloseIceSession();
            }
            else
                ContinueToEndCloseChannels();
        }

	}
}


eConfMediaType CSipCntl::GetTargetConfMediaType()
{
	if (!m_pParty)
		return eConfMediaType_dummy;
	if (!m_pParty->GetTargetMode())
		return eConfMediaType_dummy;

	return m_pParty->GetTargetMode()->GetConfMediaType();
}
void CSipCntl::PrintChangeModeWithinTransactionValue()
{
  TRACEINTO<<"m_state="<<m_state<<" m_bChangeModeWithinTransaction="<<(int)m_bChangeModeWithinTransaction;
}
void CSipCntl::ResetChangeModeWithinTransactionValue()
{
  TRACEINTO<<"m_state="<<m_state<<" before reset: m_bChangeModeWithinTransaction="<<(int)m_bChangeModeWithinTransaction;
  m_bChangeModeWithinTransaction=NO;
  TRACEINTO<<"m_state="<<m_state<<" after reset: m_bChangeModeWithinTransaction="<<(int)m_bChangeModeWithinTransaction;

}

////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::IsASSIPContentDisabledinASSIPConf()
{

	CCommConf*   pCommConf  = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	PASSERT_AND_RETURN_VALUE(NULL == pCommConf, FALSE);

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::IsASSIPContentDisabledinASSIPConf - Is ASSIP conf:",pCommConf->GetIsAsSipContent());
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::IsASSIPContentDisabledinASSIPConf - m_isASSIPContentEnable:",m_isASSIPContentEnable);


	if(pCommConf->GetIsAsSipContent() && !m_isASSIPContentEnable)
		return  TRUE;
	else
		return FALSE;

}
////////////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::IsAsSipConf()
{
	CCommConf*   pCommConf  = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	PASSERT_AND_RETURN_VALUE(NULL == pCommConf, FALSE);

	PTRACE2INT(eLevelInfoNormal,"CSipCntl::IsAsSipConf - Is ASSIP conf:",pCommConf->GetIsAsSipContent());

	return pCommConf->GetIsAsSipContent();
}
//////////////////////////////////////////////////////////////////////////////
void CSipCntl::ReActivateContentNotificationForTip()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::ReActivateContentNotificationForTip ");
	if(m_pTipRtcpCntl)
		m_pTipRtcpCntl->SetIsRequestSent(FALSE);
}

/////////////////////////////////////////////////////////
void  CSipCntl::OnMediaDisconnectDetectionInd(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnMediaDisconnectDetectionInd");
	PASSERT_AND_RETURN(!m_pParty || !m_pPartyApi || !m_pParty -> GetConfApi() || !m_pCall);
	
	TMediaDisconnectedIndStruct  mediaDisconnectDetectionInd;
	DWORD  structLen = sizeof(TMediaDisconnectedIndStruct);
	memset(&mediaDisconnectDetectionInd,0,structLen);
	pParam->Get((BYTE*)(&mediaDisconnectDetectionInd),structLen);

	kChanneltype   channelTpe 	=(kChanneltype) mediaDisconnectDetectionInd.unChannelType;
	BYTE		isRTPChannel	= (BYTE) mediaDisconnectDetectionInd.bIsRTP;

	CMedString str;
	str << " Channel Type= " << (DWORD) channelTpe << "; isRTP=" << (DWORD) isRTPChannel;
	PTRACE2(eLevelInfoNormal,"CSipCntl::OnMediaDisconnectDetectionInd ", str.GetString());

	//BRIDGE-15677
	bool bIsTipMediaOnHeld 	= m_pParty->GetTipPartyOnHold();
	if(GetIsTipCall() && bIsTipMediaOnHeld)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::OnMediaDisconnectDetectionInd -- skip the media disconnection event for TIP call on HOLD!");
		return;
	}

	enMediaOnHold eMediaOnHeld = m_pParty->GetNonTipPartyOnHold();

	if((PolycomEp != GetRemoteIdent())&&(eMediaOnHeld))
	{
		if((eMediaOnHeld & eMediaOnHoldVideo)&&(kIpVideoChnlType == channelTpe))
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::OnMediaDisconnectDetectionInd -- skip the VIDEO disconnection event for  non-polycom EP onHold! ");
			return;
		}
		else if((eMediaOnHeld & eMediaOnHoldAudio)&&(kIpAudioChnlType == channelTpe))
		{
			PTRACE(eLevelInfoNormal,"CSipCntl::OnMediaDisconnectDetectionInd -- skip the AUDIO disconnection event for  non-polycom EP onHold! ");
			return;
		}
		else
		{
			PTRACE2INT(eLevelError,"CSipCntl::OnMediaDisconnectDetectionInd -- eMediaOnhold: ", (WORD)eMediaOnHeld);
		}
	}
		
	BYTE isNeedBye = m_pCall->HandleMediaDetectionInd(channelTpe, isRTPChannel);

	if(isNeedBye)
	{
		m_pPartyApi->SipPartyCallFailed(SIP_REMOTE_STOP_RESPONDING);
	}
	else
	{
		//==================================================================================================
		// If video RTP is disconnected long enough to be considered in timeout, we should remove its cell
		//==================================================================================================
		const std::string unmuteKey = CFG_KEY_RETURN_EP_TO_LAYOUT_ON_NO_VIDEO_TIMER;
		DWORD unmuteDuration = 0;
		CSysConfig* pSysConfig = CProcessBase::GetProcess() ? CProcessBase::GetProcess()->GetSysConfig() : NULL;
		BOOL cfgFailure = !pSysConfig || !pSysConfig->GetDWORDDataByKey(unmuteKey, unmuteDuration);
		PASSERT(cfgFailure);

		if (!cfgFailure && kIpVideoChnlType == channelTpe && isRTPChannel)
		{
			//==========================================
			// Checking if video reached timeout state
			//==========================================
			stMediaDetectionInfo& mediaDetect = m_pCall->MediaDetectionInfo();
			if (!mediaDetect.inTimeout[MEDIA_DETECTION_VIDEO_RTP])
			{
				if (unmuteDuration && mediaDetect.CheckForMediaTimeout(MEDIA_DETECTION_VIDEO_RTP))
				{
					//==================================================================================
					// Muting video cell and starting timer to check when video cell should be resumed
					//==================================================================================
					PTRACE(eLevelInfoNormal,"CSipCntl::OnMediaDisconnectDetectionInd - Muting video cell");
					m_pParty -> GetConfApi() -> IpMuteMedia(m_pParty -> GetPartyId(), AUTO, AUTO, eOn,  AUTO,
																					  AUTO, AUTO, AUTO, AUTO);
					MediaDisconnectionTimerKick();
				}
				else if (0 == unmuteDuration)
				{
					PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnMediaDisconnectDetectionInd - Not checking for video cell mute, since unmuteDuration is ", unmuteDuration);
				}
			}
			else
			{
				//====================================================================================================================
				// Video already in timeout state and a new media disconnection has been received - extending media detection period
				//====================================================================================================================
				MediaDisconnectionTimerKick();
			}
		}
	}
}

void CSipCntl::MediaDisconnectionTimerKick()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::MediaDisconnectionTimerKick");

	const std::string unmuteKey = CFG_KEY_RETURN_EP_TO_LAYOUT_ON_NO_VIDEO_TIMER;
	DWORD unmuteDuration = 0;
	CSysConfig* pSysConfig = CProcessBase::GetProcess() ? CProcessBase::GetProcess()->GetSysConfig() : NULL;
	PASSERT_AND_RETURN(!m_pCall || !pSysConfig || !pSysConfig->GetDWORDDataByKey(unmuteKey, unmuteDuration));
	stMediaDetectionInfo& mediaDetect = m_pCall->MediaDetectionInfo();
	if (mediaDetect.inTimeout[MEDIA_DETECTION_VIDEO_RTP])
	{
		if (IsValidTimer(MEDIA_DISCONNECTION_RESUME_CELL_TIMER))
		{
			DeleteTimer(MEDIA_DISCONNECTION_RESUME_CELL_TIMER);
		}

		//==================================================================================
		// Raising the timer to at least the frequency emb will send the indications to us
		//==================================================================================
		unmuteDuration = max(unmuteDuration, mediaDetect.detectTimeLen + 2);
		StartTimer(MEDIA_DISCONNECTION_RESUME_CELL_TIMER, unmuteDuration * SECOND);
	}
	else
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::MediaDisconnectionTimerKick - Media not currently in timeout");
	}
}


void CSipCntl::OnMediaResume(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::OnMediaResume - Resuming video cell");
	PASSERT_AND_RETURN(!m_pCall || !m_pParty || !m_pParty -> GetConfApi());
	m_pParty -> GetConfApi() -> IpMuteMedia(m_pParty -> GetPartyId(), AUTO, AUTO, eOff,  AUTO,
																				  AUTO, AUTO, AUTO, AUTO);
	m_pCall->MediaDetectionInfo().MediaResumed(MEDIA_DETECTION_VIDEO_RTP);
}

/////////////////////////////////////////////////////////
void  CSipCntl::OnMediaDisconnectDetectionIndInAnycase(CSegment* pParam)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnMediaDisconnectDetectionIndInAnycase, NOT proper state for disconnections: ", m_state);
	MediaDisconnectionTimerKick();
}

/////////////////////////////////////////////////////////
void  CSipCntl::OnMediaDisconnectDetectionIndConnecting(CSegment* pParam)
{
	PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnMediaDisconnectDetectionIndConnecting, behavior dependant on m_allowMediaBasedDisconnectionInReinvite: ", m_allowMediaBasedDisconnectionInReinvite);

	if (m_allowMediaBasedDisconnectionInReinvite)
	{
		OnMediaDisconnectDetectionInd(pParam);
	}
	else
	{
		OnMediaDisconnectDetectionIndInAnycase(pParam);
	}
	MediaDisconnectionTimerKick();
}

/////////////////////////////////////////////////////////
// update video in streams according to best mode streams
void CSipCntl::UpdateVideoInStreamsList(const std::list <StreamDesc>& streamsDescList)
{
	CSipChannel* pChannel = GetChannel( cmCapVideo, cmCapReceive, kRolePeople);
	if(pChannel)
		pChannel->SetStreamsList(streamsDescList);
}

/////////////////////////////////////////////////////////
void  CSipCntl::MrmpStreamIsMustReq(CSegment* pParam)
{
	MrmpStreamIsMustStruct 		dataStruct;
	uint32_t 			exp = 0 ,
						mantissa = 0,
						overhead = RTP_HEADER_SIZE;
	CMedString 			str;
	WORD  msgType;
	DWORD PartyId;

    DWORD ssrc;
    DWORD channelID;
    DWORD bIsMust;

	memset(&dataStruct,0,sizeof(MrmpStreamIsMustStruct));
	*pParam>>PartyId
	  >>msgType
	  >>ssrc
	  >>channelID
	  >>bIsMust;

	TRACEINTO<<"ssrc="<<ssrc<<"channelID="<<channelID<<"bIsMust="<<bIsMust;
	dataStruct.unSyncSource=ssrc;
	dataStruct.unChannelHandle=channelID;
	dataStruct.bIsMust=bIsMust;
	TRACEINTO<<"dataStruct.unSyncSource: "<<dataStruct.unSyncSource<<"dataStruct.unChannelHandle: "<<dataStruct.unChannelHandle<<"dataStruct.bIsMust: "<<dataStruct.bIsMust;

 SendMsgToMpl((BYTE*)(&dataStruct), sizeof(MrmpStreamIsMustStruct),CONF_PARTY_MRMP_STREAM_IS_MUST_REQ);
}

//////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::IsCallGeneratorConf()
{
	CCommConf*   pCommConf  = ::GetpConfDB()->GetCurrentConf(m_pParty->GetMonitorConfId());
	if (pCommConf)
	{
		PTRACE2INT(eLevelInfoNormal,"CSipCntl::IsCallGeneratorConf - Is CG conf:",pCommConf->GetIsCallGeneratorConference());
		return pCommConf->GetIsCallGeneratorConference();
	}
	else
	{
		PASSERTMSG(NULL == pCommConf,"pCommConf is NULL");
	    	return FALSE;
	}
}

//////////////////////////////////////////////////////////////////////////
//  username@domainname
//  sip:username@domainname, <sip:    username@domainname>
//  "username@domainname"
//  "sip:username@domainname"
//  "displayname"<sip:username@domainname>
// To get the username
//
void  CSipCntl::GetSipUsernameFromUrl(char* sipUsername, char* sipUrl, APIU32 maxLen)
{
	if(NULL == sipUsername || NULL==sipUrl)
		return;

	char* pszUrl = new char[MAX_SITE_NAME_ARR_SIZE ];
	memset(pszUrl, 0, MAX_SITE_NAME_ARR_SIZE );
    //to please klocwork

//	RemoveOpeningAndEndingInvertedCommas(pszUrl);

	char *start;
	char siteNameTmp[MAX_SITE_NAME_ARR_SIZE]={0};

	strncpy(siteNameTmp, sipUrl, MAX_SITE_NAME_ARR_SIZE - 1);
	PTRACE2(eLevelInfoNormal,"CSipCntl::GetSipUsernameFromUrl -- Url: ", siteNameTmp);
	// look for first '"'
	start = strchr(siteNameTmp, '"');
	if(start)
	{
	   start++; //we don't need '"'
	   strncpy(pszUrl, start, MAX_SITE_NAME_ARR_SIZE -1);
	}
	else
	{
	   strncpy(pszUrl, siteNameTmp, MAX_SITE_NAME_ARR_SIZE -1);
	}


	// look for last '"'
	char* last = strrchr(pszUrl, '"');
	if (last)
	{
		if (last[1] != '\0')
		{
			*last = '.';
		}
		else
		{
			*last = '\0';
		}
	}

	char*  pTmp=(char*)strstr(pszUrl, "@");
	if(pTmp)
	{
		*pTmp = '\0';
	}

	pTmp = (char*)strstr(pszUrl, "sip:");
	if(NULL == pTmp)
	{
		pTmp = (char*)strstr(pszUrl, "Sip:");
	}
	if(NULL == pTmp)
	{
		pTmp = (char*)strstr(pszUrl, "SIP:");
	}
	if(pTmp)
	{
		char*  pValidUsrname = pTmp+4;
		//remove SP
		while(*pValidUsrname == ' ')
			pValidUsrname++;
		strncpy(sipUsername, pValidUsrname, maxLen);
	}
	else
	{
		strncpy(sipUsername, pszUrl, maxLen);
	}
	sipUsername[maxLen-1] = '\0';
	PDELETEA(pszUrl);
}

//////////////////////////////////////////////////////////////////////////
void  CSipCntl::CreateFastUpdateMsgToMrmp()
{
    if (!m_bIsMrcCall)
        return;

    TRACEINTO << "@#@";

    // create intra params
    RelayIntraParam intraParams;
    DWORD channelHandle = INVALID_CHANNEL_HANDLE;

    intraParams.InitDefaults();
    intraParams.m_partyRsrcId = m_pParty->GetPartyId();
    intraParams.m_bIsGdr = false;
    intraParams.m_bIsSsrc = false;

    CSipChannel * pRxChannel = GetChannel(cmCapVideo, cmCapReceive);
    CSipChannel * pTxChannel = GetChannel(cmCapVideo, cmCapTransmit);
    if (!pRxChannel || !pTxChannel)
    {
        TRACEINTO << "No video channel - cannot request intra.";
        return;
    }

    const std::list <StreamDesc> streamsDescList = pRxChannel->GetStreams();
    std::list <StreamDesc>::const_iterator itr_streams;
    for(itr_streams=streamsDescList.begin(); itr_streams!=streamsDescList.end(); itr_streams++)
    {
        intraParams.m_listSsrc.push_back(itr_streams->m_pipeIdSsrc);
        TRACEINTO << "mix_mode: SSRC " << itr_streams->m_pipeIdSsrc << " added.";
    }

    FillAndSendMrmpRtcpFirStruct(&intraParams, pTxChannel->GetChannelHandle());
}

//////////////////////////////////////////////////////////////////////////
void  CSipCntl::FillMrdVersion()
{
    if (!m_bIsMrcCall)
        return;

    TRACEINTO << "@#@";
    memset(&m_mrdVersion, 0, sizeof(MrdVersionStruct));

    // if no remote SDP, return
    if (!m_pRemoteSdp || !m_pRemoteSdp->sipHeadersLength)
    {
        TRACEINTO << "No remote SDP";
        return;
    }

    sipMessageHeaders *pHeaders = (sipMessageHeaders *) &m_pRemoteSdp->capsAndHeaders[m_pRemoteSdp->sipHeadersOffset];
    char cMrcHeader[MaxUserAgentSize] = "";
    if (SipGetHeaderValue(pHeaders, kMrd, cMrcHeader, MaxUserAgentSize) == NO || !cMrcHeader[0]) // svc check
    {
        TRACEINTO << "No MRD header in remote headers (" << cMrcHeader << ")";
        BYTE bRetVal = SipGetHeaderValue(pHeaders, kSdpSession_s, cMrcHeader, MaxUserAgentSize);
        if (!bRetVal)
        {
            TRACEINTO << "No MRD header in headers and no kSdpSession_s in SDP";
            return;
        }
        if (!cMrcHeader[0] || (NULL == strstr(cMrcHeader, "MRC-V=") ) )
        {
            TRACEINTO << "No MRD header in remote SDP session (" << cMrcHeader << ")";
            return;
        }
    }

    TRACEINTO << "mix_mode: cMrcHeader=" << cMrcHeader;

    // parse the MRD version
    char *pos = strstr(cMrcHeader, "MRC-V=");
    // Add Support for another convention:
    if (!pos)
    	pos = strstr(cMrcHeader, "MRC-V:");
    if (pos == NULL)
	{
		return;
	}
    pos += strlen("MRC-V=");

    // extract major version
    pos = strtok(pos, ".");
    if (pos == NULL)
    {
        return;
    }
    m_mrdVersion.majorVer = atoi(pos);

    // extract middle version
    pos = strtok (NULL, ".");
    if (pos == NULL)
    {
        return;
    }
    m_mrdVersion.middleVer = atoi(pos);

    // extract minor version
    pos = strtok (NULL, ".");
    if (pos == NULL)
    {
        return;
    }
    m_mrdVersion.minorVer = atoi(pos);
}

//////////////////////////////////////////////////////////////////////////
void CSipCntl::initVsrCtrl()
{
//	PASSERT_AND_RETURN(m_pVsrControl!=NULL);

	PTRACE(eLevelInfoNormal, "CSipCntl::initVsrCtrl");
	m_bIsVsrCtrlInitialized = TRUE;

	bool isAvmcu2013 = (m_remoteIdent == Microsoft_AV_MCU2013);
	if (isAvmcu2013 && m_isMs2013Active == eMsft2013AvMCU)
	{
		initAVMcuVsrCtrl();
	}
	else
	{
		initLyncClentMcuVsrCtrl();
	}
//	PASSERT_AND_RETURN(!m_pVsrControl);



}
void CSipCntl::initLyncClentMcuVsrCtrl()
{
	PTRACE(eLevelInfoNormal, "CSipCntl::initLyncClentMcuVsrCtrl");
    mcBasicLync2013InfoReq initMsg;
	memset(&initMsg, 0, sizeof(mcBasicLync2013InfoReq));
	initMsg.bIsAVMCU = 0;
    initMsg.bIsIceParty = GetIsEnableICE() && m_IsEnableICE;
    SingleStreamDesc& initDesc = initMsg.connectedParties[0];
    initDesc.bIsActive = TRUE;
    initDesc.remoteSSRCRange[0] = m_pLastRemoteCaps->getMsftSsrcVideoFirst(1);
    initDesc.remoteSSRCRange[1] = m_pLastRemoteCaps->getMsftSsrcVideoLast(1);
    initDesc.localSSRCRange[0] = m_pChosenLocalCap->getMsftSsrcVideoFirst(1);
    initDesc.localSSRCRange[1] = m_pChosenLocalCap->getMsftSsrcVideoLast(1);
	initDesc.localMSI = m_pLastRemoteCaps->getMsftMsiVideo(1); // Shmulik: VSR_SOURCE_ANY on P2P, on AVMCU "real" MSI should be here
    initDesc.lyncMSI = VSR_SOURCE_ANY;
    initDesc.unPartyId  = m_pMfaInterface->GetPartyRsrcId();
    initDesc.bUpdateArtInfo = FALSE;

    m_pVsrControl->Initialize(m_pMfaInterface, m_pPartyApi, initMsg);
}


void CSipCntl::initAVMcuVsrCtrl()
{
	PTRACE(eLevelInfoNormal, "CSipCntl::initAVMcuVsrCtrl");


	mcAvMcuLync2013InfoReq initMsg;
	memset(&initMsg, 0, sizeof(mcAvMcuLync2013InfoReq));
    initMsg.bIsAVMCU =1;
    initMsg.bIsIceParty = GetIsEnableICE() && m_IsEnableICE;
    SingleStreamDesc& initDesc = initMsg.ConnectedParties[0];


    //main party part
    initDesc.bIsActive = 1;
    initDesc.remoteSSRCRange[0] = m_pLastRemoteCaps->getMsftSsrcVideoFirst(1);
    initDesc.remoteSSRCRange[1] = m_pLastRemoteCaps->getMsftSsrcVideoLast(1);
    initDesc.localSSRCRange[0] = m_pChosenLocalCap->getMsftSsrcVideoFirst(1);
    initDesc.localSSRCRange[1] = m_pChosenLocalCap->getMsftSsrcVideoLast(1);
    initDesc.localMSI = m_pLastRemoteCaps->getMsftMsiVideo(1);
    initDesc.lyncMSI = VSR_SOURCE_ANY;
    initDesc.unPartyId  = m_pMfaInterface->GetPartyRsrcId();
    initDesc.unDspNum              = 0; //will be filled by MPL
    initDesc.unPortNum             = 0; //will be filled by MPL
    initDesc.bUpdateArtInfo = FALSE;

    //now fill for all other "slaves"
    for(unsigned int i = 1; i < MAX_STREAM_LYNC_2013_CONN; i++)
    {
    	SingleStreamDesc& initDesc2  = initMsg.ConnectedParties[i];
    	initDesc2.bIsActive = FALSE;
    	initDesc2.remoteSSRCRange[0] = m_pLastRemoteCaps->getMsftSsrcVideoFirst(i+1);
    	initDesc2.remoteSSRCRange[1] = m_pLastRemoteCaps->getMsftSsrcVideoLast(i+1);
    	initDesc2.localSSRCRange[0] = m_pChosenLocalCap->getMsftSsrcVideoFirst(i+1);
    	initDesc2.localSSRCRange[1] = m_pChosenLocalCap->getMsftSsrcVideoLast(i+1);
    	initDesc2.localMSI = m_pLastRemoteCaps->getMsftMsiVideo(i+1);
    	initDesc2.lyncMSI = VSR_SOURCE_ANY;
    	initDesc2.unDspNum              = 0; //will be filled by MPL
    	initDesc2.unPortNum             = 0; //will be filled by MPL
    	initDesc2.unPartyId  = 0;
    	initDesc2.bUpdateArtInfo = FALSE;
    }

    //encryption
    if (m_pParty && m_pParty->GetTargetMode()->GetIsEncrypted() == Encryp_On)
    {
    	initMsg.bIsEncrypted = 1;
    	//remote
    	for (DWORD i=0; i<m_pLastRemoteCaps->GetNumOfMsftAVMCUSdesCaps(); i++)
    	{
    		PTRACE2INT(eLevelInfoNormal, "CSipCntl::initAVMcuVsrCtrl copy encryption to remote, line ", i);

    		CSdesCap* pCap = m_pLastRemoteCaps->GetVideoSdesCapAVMCU(i);
    		if (!pCap)
    		{
    			break;
    		}

    		CopySdesCapsFromClassToStruct(&(initMsg.RemoteEncryptionParam[i]), pCap);
			POBJDELETE(pCap);
    	}

    	// local
    	CSdesCap* pCap =  m_pChosenLocalCap->GetSdesCap(cmCapVideo, kRolePeople);
    	if (pCap)
    	{
			for (DWORD i=0; i<MaxMsftSvcSdpVideoMlines; i++)
			{
	    		PTRACE2INT(eLevelInfoNormal, "CSipCntl::initAVMcuVsrCtrl copy encryption to local, line ", i);
				CopySdesCapsFromClassToStruct(&(initMsg.localEncryptionParam[i]), pCap);
			}
			POBJDELETE(pCap);
		}
    }


    //m_pLastRemoteCaps->Du
    CSuperLargeString msgRC;
    m_pLastRemoteCaps->DumpToString(msgRC);
    PTRACE2(eLevelInfoNormal,"CSipCntl::initAVMcuVsrCtrl - noa to remove remoteCaps:",msgRC.GetString());

    PTRACE2INT(eLevelInfoNormal ,"CSipCntl::initAVMcuVsrCtrl  initMsg.ConnectedParties[1].localSSRCRange ",((unsigned int)initMsg.ConnectedParties[1].localSSRCRange));
    m_pVsrControl->Initialize(m_pMfaInterface, m_pPartyApi, initMsg);
}


//////////////////////////////////////////////////////////////////////////
BOOL CSipCntl::FillVsrInfo(ST_VSR_SINGLE_STREAM* vsrArr, DWORD vsrNum)
{
	RTVVideoModeDetails rtvVidModeDetails;
	MsSvcVideoModeDetails MsSvcDetails;
    memset(&MsSvcDetails, 0, sizeof(MsSvcDetails));
	BOOL ret = TRUE;

	//=====================
	// General parameters
	//=====================
	PTRACE(eLevelInfoNormal, "CSipCntl::FillVsrInfo - filling general parameters");
	const bool is_msSvc = m_pChosenLocalCap->IsCapSet(eMsSvcCapCode);
	const bool is_rtv = m_pChosenLocalCap->IsCapSet(eRtvCapCode);
	const int num_vsrs_params =  (is_msSvc? 1 : 0) + (is_rtv? 1 :0);
	DWORD bitrate = 0;

	//===============
	// RTV specific
	//===============
	if (is_rtv)
	{
		m_pChosenLocalCap->GetRtvCap(rtvVidModeDetails, bitrate);
	}

	//==================
	// MS-SVC specific
	//==================
	if (is_msSvc && !m_pChosenLocalCap->GetMsSvcVidMode(MsSvcDetails))
	{
		PTRACE(eLevelError, "CSipCntl::FillVsrInfo can't find msSvc details params, vsr send fail!");
		DBGPASSERT(YES);
		ret = FALSE;
	}
	else
	{
		//===============
		// Per-VSR info
		//===============
		PTRACE2INT(eLevelInfoNormal, "CSipCntl::FillVsrInfo - PartyId for first slot is: ", vsrArr[0].partyId);

		if(vsrArr[0].partyId != m_pMfaInterface->GetPartyRsrcId())
		{
			PTRACE2INT(eLevelError, "CSipCntl::FillVsrInfo - error party id in 0 is not main rsrc id: ", m_pMfaInterface->GetPartyRsrcId() );
			vsrArr[0].partyId = m_pMfaInterface->GetPartyRsrcId();
		}
		BOOL isSLynvAvMcu1080p30Enabled = FALSE;
		CSysConfig* pSysConfig = CProcessBase::GetProcess()->GetSysConfig();
		pSysConfig->GetBOOLDataByKey("LYNC_AVMCU_1080p30_ENCODE_RESOLUTION", isSLynvAvMcu1080p30Enabled);

		if(isSLynvAvMcu1080p30Enabled && eMsft2013AvMCU == m_isMs2013Active && MsSvcDetails.maxWidth == 1920 && MsSvcDetails.maxHeight == 1088)
		{
			PTRACE2INT(eLevelInfoNormal, "CSipCntl::FillVsrInfo -av-mcu in hd 1080 asymmetric mode change in to be hd720 ", vsrArr[0].partyId);
			MsSvcVideoModeDetails MsSvcVideoModeDetails;
			CMsSvcVideoMode::GetMsSvcVideoParamsByMaxH264VideoMode(eHD720Symmetric, MsSvcVideoModeDetails);
			MsSvcDetails.aspectRatio = MsSvcVideoModeDetails.aspectRatio;
			MsSvcDetails.maxFrameRate = MsSvcVideoModeDetails.maxFrameRate;
			MsSvcDetails.maxHeight = MsSvcVideoModeDetails.maxHeight;
			MsSvcDetails.maxWidth = MsSvcVideoModeDetails.maxWidth;
			MsSvcDetails.videoModeType = MsSvcVideoModeDetails.videoModeType;
			MsSvcDetails.maxNumOfPixels = MsSvcVideoModeDetails.maxNumOfPixels;
			MsSvcDetails.minBitRate = MsSvcVideoModeDetails.minBitRate;

		}

		for (DWORD i = 0; i < min(vsrNum, MAX_STREAM_LYNC_2013_CONN); ++i)
		{
			ST_VSR_SINGLE_STREAM& vsr = vsrArr[i];
			vsr.sender_ssrc = m_pChosenLocalCap->getMsftSsrcVideoFirst(i+1);
			if (vsr.partyId != (DWORD) NUMERIC_NULL && vsr.msi != VSR_SOURCE_NONE)
			{
				CSmallString log;
				log << "CSipCntl::FillVsrInfo - filling VSR info for slot: i="<<i<<", msi="<<vsr.msi<<", sender_ssrc="<<vsr.sender_ssrc;

				PTRACE(eLevelInfoNormal, log.GetString());

    vsr.key_frame					= TRUE; 
				vsr.num_vsrs_params	= num_vsrs_params; //1 for svc/rtv only, 2 - (default) rtv or svc

				if (is_msSvc)
				{
					ST_VSR_PARAMS& vParams1		= vsr.st_vsrs_params[0];
					vParams1.aspect_ratio		= MsSvcDetails.aspectRatio;
					vParams1.min_bitrate		=   m_pParty->GetTargetMode()->GetVideoBitRate(cmCapReceive, kRolePeople) * 100;
					//// MsSvcDetails.minBitRate;

					vParams1.frame_rate			= MsSvcDetails.maxFrameRate;
					vParams1.max_height			= MsSvcDetails.maxHeight;
					vParams1.max_width			= MsSvcDetails.maxWidth;
					vParams1.payload_type		= eMsSvcDynamicPayload;

					DWORD numOfEntries = vsr.num_vsrs_params;
					if (numOfEntries > VSR_MAX_ENTRIES)
						numOfEntries = VSR_MAX_ENTRIES;

					DWORD indexAccordingToFec = 0;
					if (GetIsFecOn())
						indexAccordingToFec =  VSR_NUM_OF_QUALITY_LEVELS-1;

					TRACEINTO << "LYNC2013_FEC_RED:DEBUG: IsFecOn:" << (DWORD)GetIsFecOn() << ", indexAccordingToFec:" << indexAccordingToFec;


					for (DWORD j=0; j<numOfEntries; ++j)
					{
						for (int k=1; k<VSR_NUM_OF_QUALITY_LEVELS; ++k)
							vsr.st_vsrs_params[j].qualityReportHistogram[k] = 0;

						vsr.st_vsrs_params[j].qualityReportHistogram[indexAccordingToFec] = 1;
					}
				}

				if (is_rtv)
				{
					ST_VSR_PARAMS& vParams2		= vsr.st_vsrs_params[(num_vsrs_params>0)?(num_vsrs_params-1):0];
		vParams2.aspect_ratio		= E_VIDEO_RES_ASPECT_RATIO_16_9; 
					vParams2.min_bitrate		= m_pParty->GetTargetMode()->GetVideoBitRate(cmCapReceive, kRolePeople) * 100 ;
					vParams2.frame_rate			= rtvVidModeDetails.FR;
					vParams2.max_height			= rtvVidModeDetails.Height;
					vParams2.max_width			= rtvVidModeDetails.Width;
					vParams2.payload_type		= eRtvDynamicPayload;
				}
			}
			else
			{
				//=======================================================
				// Party ID or MSI did not contain live connection info
				//=======================================================
				PTRACE2INT(eLevelInfoNormal, "CSipCntl::FillVsrInfo - No VSR info for slot: ", i);
				vsr.num_vsrs_params	= 0;
			}
		}
	}

	return ret;
}

//////////////////////////////////////////////////////////////////////////
void CSipCntl::SendSingleVsr()
{
	//=========================
	// Creating a VSR to send
	//=========================
    ST_VSR_SINGLE_STREAM vsr;
    vsr.msi							= VSR_SOURCE_ANY;
    vsr.partyId						= m_pMfaInterface->GetPartyRsrcId();

	//==========================
	// Filling and sending VSR
	//==========================
    if (FillVsrInfo(&vsr, 1))
    {
    	PTRACE(eLevelInfoNormal, "CSipCntl::SendSingleVsr - sending VSR");
        m_pVsrControl->SendVsr(vsr);
    }
    else
    {
    	PTRACE(eLevelError, "CSipCntl::SendSingleVsr - failed to fill information for VSR, not sending");
    }
}

//////////////////////////////////////////////////////////////////////////
void CSipCntl::SendMultiVsr(ST_VSR_MUTILPLE_STREAMS& multiVsr)
{
	//==========================
	// Filling and sending VSR
	//==========================
    if (FillVsrInfo(multiVsr.st_vsrs_single_stream, min(multiVsr.num_vsrs_streams, MAX_STREAM_LYNC_2013_CONN)))
    {
    	PTRACE(eLevelInfoNormal, "CSipCntl::SendMultiVsr - sending VSRs");
        m_pVsrControl->SendVsr(multiVsr);
    }
    else
    {
    	PTRACE(eLevelError, "CSipCntl::SendMultiVsr - failed to fill information for VSRs, not sending");
    }
}

////////////////////////////////////////////////////
void  CSipCntl::CreateFastUpdateMsgToMsft2013(DWORD remoteSSRC, DWORD priorityID, DWORD msSlavePartyIndex)
{
	DWORD partyIndex = 1 + msSlavePartyIndex;// Shmulik TBD: In AVMCU put partyIndex (1-5)
	CSmallString log;
	log << "CSipCntlFastUpdateMsgToMsft2013 - remoteSSRC[" << remoteSSRC << "], priorityID[" << priorityID << "], msftPliRequestId["<<m_msftPliRequestId[partyIndex-1]<<"]" << ", partyIndex[" << partyIndex << "]";
	PTRACE(eLevelInfoNormal, log.GetString());
	DWORD senderSsrc = m_pChosenLocalCap->getMsftSsrcVideoFirst(partyIndex);

	if (NON_SSRC != remoteSSRC && 0 != remoteSSRC && priorityID != INVALID)
	{
		if (priorityID/8 >= 8)
		{
			PTRACE2INT(eLevelInfoNormal, "CSipCntlFastUpdateMsgToMsft2013 - Invalid priority ID = ",priorityID);
			DBGPASSERT(YES);
			return;
		}

		//send PLI
		TCmRtcpMsSvcPLIMsg msSvcPLIMsg;
		memset(&msSvcPLIMsg,0,sizeof(msSvcPLIMsg));
		TCmRtcpMsSvcPLIInfo& pliInfo = msSvcPLIMsg.cmRtcpMsSvcPLI;

		pliInfo.mediaSourceSSRC	= remoteSSRC;
		pliInfo.senderSSRC 		= senderSsrc;
		pliInfo.requestId		= m_msftPliRequestId[partyIndex-1]++;;
		APIU8* pSfr = &(pliInfo.SFR0);
		pSfr[priorityID/8] = 1 << priorityID%8;

		PTRACE(eLevelInfoNormal, "CSipCntlFastUpdateMsgToMsft2013 - sending PLI");

		SendMsgToMpl((BYTE*)(&msSvcPLIMsg), sizeof(msSvcPLIMsg), IP_CM_RTCP_MS_SVC_PLI_REQ);
	}
	else
	{
		//send VSR (+ Kbit is now ON)
		PTRACE(eLevelInfoNormal, "CSipCntlFastUpdateMsgToMsft2013 - sending VSR");
        m_pVsrControl->VideoSync(senderSsrc, FALSE);
	}
}

//////////////////////////////////////////////////////////////
void CSipCntl::videoInSynched(DWORD partyIndex)
{
	//trun K-bit off in VSR
	DWORD ssrcId = m_pChosenLocalCap->getMsftSsrcVideoFirst(partyIndex);
	if (m_isMs2013Active && m_pVsrControl != NULL)
	{
		m_pVsrControl->VideoSync(ssrcId, TRUE);
	}
}

////////////////////////////////////////////
void CSipCntl::trigerMsftRcvVsr()
{
	if (m_isMs2013Active && m_pVsrControl != NULL)
	{
		PTRACE(eLevelInfoNormal, "CSipCntl::trigerMsftRcvVsr - trigering recev vsr");
		m_pVsrControl->TriggerRcvVsr();
	}
}
//////////////////////////////////////////////////////////////
/*
 * Find the minimim sirenlpr cap between locaal and remote and update the localcaps with the lower cap
 * *
 */
void CSipCntl::IntersectSirenLPRLocalAndRemoteCaps(cmCapDataType eMediaType, WORD payload, ERoleLabel eRole)
{

	CapEnum 		localSirenLPRCap	= eUnknownAlgorithemCapCode;
	CapEnum 		remoteSirenLPRCap 	= eUnknownAlgorithemCapCode;

	localSirenLPRCap = m_pChosenLocalCap->FindAlgAccordingToPayload(eMediaType, payload, eRole);

	int numOfMediaCapSet		= 0;
	capBuffer** pMediaCapList	= NULL;

	remoteSirenLPRCap = m_pLastRemoteCaps->FindSirenLPRInCaps(eMediaType, eRole);


	if (remoteSirenLPRCap < localSirenLPRCap)
	{
		/// Need to update localCaps with lower LPR rate
		m_pChosenLocalCap->ReplaceCapWithOtherCapByPayload(remoteSirenLPRCap, payload);

	}
}

//////////////////////////////////////////////////////////////////////////
void  CSipCntl::RemoveIceParamsObject()
{
	if (m_pIceParams)
	{
		POBJDELETE (m_pIceParams);
		m_pIceParams = NULL;
	}
}
//////////////////////////////////////////////////////////////////////////
void CSipCntl::SetBfcpCap(const CIpComMode* pScm)
{
	CSipCaps* allCaps[] = {	m_pChosenLocalCap, m_pFullLocalCaps, m_pPartialLocalCaps, m_pMaxLocalCaps};

	for (BYTE i = 0; i < sizeof (allCaps) / sizeof (allCaps[0]); ++i)
	{
		if (allCaps[i]) allCaps[i] -> SetBfcp(pScm, NULL);
	}
}

//////////////////////////////////////////////////////////////////////////
void CSipCntl::SetContentCap(const CIpComMode* pScm)
{
	CSipCaps* allCaps[] = {	m_pChosenLocalCap, m_pFullLocalCaps, m_pPartialLocalCaps, m_pMaxLocalCaps};

	for (BYTE i = 0; i < sizeof (allCaps) / sizeof (allCaps[0]); ++i)
	{
		if (allCaps[i]) allCaps[i] -> SetContent(pScm, NULL);
	}
}

//////////////////////////////////////////////////////////////////////////
void CSipCntl::AddBfcpOnFallback(CIpComMode* pPartyScm1, CIpComMode* pPartyScm2)
{
	PTRACE(eLevelInfoNormal,"CSipCntl::AddBfcpOnFallback : Adding bfcp");
	BOOL isOfferer = m_pParty->IsOfferer();
	enTransportType transportType = m_pLastRemoteCaps->GetBfcpTransportType();

    	if (transportType == eUnknownTransportType)
    	{
		isOfferer = TRUE; //if there's no BFCP in remote Caps, we add it via System flag
		transportType = eTransportTypeUdp;
    	}
	SetBfcpInSipPartyScm(pPartyScm1, isOfferer, transportType);
	SetBfcpCap(pPartyScm1);
	UpdateBfcpTransportType(pPartyScm1->GetBfcpTransportType(), TRUE);

	if(pPartyScm2)
		SetBfcpInSipPartyScm(pPartyScm2, isOfferer, transportType);

	pPartyScm1->SetConfUserIdForBfcp(m_BFCPcapConfIDfield, m_BFCPcapUserIDfield);
	CreateSipBfcpCtrl();
}
////////////////////////////////////////////////////////////////////////////////////////////////
void CSipCntl::UpdatePayloadTypeInRecieveChannelAccordingToRemoteCaps(CSipChannel * pChannel)
{

	if(m_bIsMrcCall)
	{
		return;
	}

	if (pChannel && pChannel->GetDirection() == cmCapReceive && pChannel->IsMediaChannel())
	{
		if (pChannel->GetMediaType() == cmCapAudio)
		{
			UpdateDtmf2833PayloadTypeAccordingToRemoteCap(pChannel);
		}
		CCapSetInfo capInfo	= pChannel->GetAlgorithm();
		payload_en payloadToSet;
		WORD   profile  = H264_Profile_None;
		APIS32 H264mode = H264_standard;
		APIU8  packetizationMode = 0;
		if ((CapEnum)capInfo == eH264CapCode)
		{
			CH264VideoCap* pH264VidCap = (CH264VideoCap*)pChannel->GetDataAsCapClass();
			if (pH264VidCap)
			{
				profile  = pH264VidCap->GetProfile();
				H264mode = pH264VidCap->GetH264mode();
				packetizationMode = pH264VidCap->GetPacketizationMode();
			}
			POBJDELETE(pH264VidCap);
		}
		payloadToSet = m_pLastRemoteCaps->GetPayloadTypeByDynamicPreference(capInfo, profile, pChannel->GetRoleLabel(), H264mode, packetizationMode);
	    if( payloadToSet != _UnKnown )
		{
	    	if (m_pChosenLocalCap)
			{
				if (::IsDynamicPayloadType(payloadToSet)) //if remote supports dynamic, check local support
				{
					payload_en localPayload = m_pChosenLocalCap->GetPayloadTypeByDynamicPreference(capInfo, profile, pChannel->GetRoleLabel(), H264mode, packetizationMode);
					if (::IsValidPayloadType(localPayload) && !::IsDynamicPayloadType(localPayload))	//if local doesn't support dynamic, we need to use the static
							payloadToSet = localPayload;
				}
			}
			WORD channelPayload = pChannel->GetPayloadType();
			pChannel->SetPayloadType(payloadToSet);

			//update local & max caps
			if (m_pChosenLocalCap)
			    m_pChosenLocalCap->SwapPayloadTypes(capInfo, pChannel->GetRoleLabel(), channelPayload, profile, payloadToSet);
			else
			    PTRACE(eLevelError,"CSipCntl::UpdatePayloadTypeInRecieveChannelsAccordingToRemoteCaps - m_pChosenLocalCap is NULL");
			m_pMaxLocalCaps->SwapPayloadTypes(capInfo, pChannel->GetRoleLabel(), channelPayload, profile, payloadToSet);
		}

	}
}

//////////////////////////////////////////////////////////////////////////
void CSipCntl::Deescalate()
{
    if (m_bIsMrcCall)
    {// reply back to party control
        TRACEINTO << "Nothing to do. m_bIsMrcCall=" << (m_bIsMrcCall?"TRUE":"FALSE");
        m_pPartyApi->IPPartyInternalArtsDisconnected();
        return;
    }

    DeescalateChannelsByMedia(cmCapAudio);
    DeescalateChannelsByMedia(cmCapVideo);

    APIU32* ssrcIds = NULL;
    int numOfSsrcIds = 0;
    m_pParty->GetTargetMode()->GetSsrcIds(cmCapVideo, cmCapReceive, ssrcIds, &numOfSsrcIds);

    // close unused internal ARTs
    CSipChannel *pAudioChannel = NULL;
    CSipChannel *pVideoChannel = NULL;

    bool isCloseArt = false;
    int numOfRequiredVidStreams = 0;

    for (int i = 0; i < NUMBER_OF_INTERNAL_AVC_TO_SVC_TRANSLATORS && m_AvcToSvcTranslatorInterface[i].pAvcToSvcTranslatorInterface; i++)
    {
        // find the audio channel
		pAudioChannel = m_pCall->GetChannel(false, cmCapAudio ,cmCapTransmit, kRolePeople,
			m_AvcToSvcTranslatorInterface[i].pAvcToSvcTranslatorInterface->GetConnectionId());
		pVideoChannel = m_pCall->GetChannel(false, cmCapVideo ,cmCapTransmit, kRolePeople,
			m_AvcToSvcTranslatorInterface[i].pAvcToSvcTranslatorInterface->GetConnectionId());

		numOfRequiredVidStreams = (AUDIO_AVC_TO_SVC_TRANSLATOR_INDEX == i) ? 1 : 2;

		TRACEINTO << "numOfRequiredVidStreams = " << numOfRequiredVidStreams ;
        if (pAudioChannel == NULL && pVideoChannel == NULL && numOfSsrcIds < numOfRequiredVidStreams)
        {
        	if (AUDIO_AVC_TO_SVC_TRANSLATOR_INDEX != i || CProcessBase::GetProcess()->GetProductFamily() == eProductFamilySoftMcu)
        	{
        		TRACEINTO << "ART has no connected channels. Close it. index=" << i;
				// do it by index
				CloseInternalArtByConnId(m_AvcToSvcTranslatorInterface[i].pAvcToSvcTranslatorInterface->GetConnectionId());
        	}

        }
    }
}

//////////////////////////////////////////////////////////////////////////
void CSipCntl::DeescalateChannelsByMedia(cmCapDataType aDataType)
{
    // go over current mode and for each stream in the current mode which is not in the target mode,
    // close the internal channel and the ART

    m_pParty->GetTargetMode()->Dump("CSipCntl::DeescalateChannelsByMedia Target mode", eLevelInfoNormal);
    m_pParty->GetCurrentMode()->Dump("CSipCntl::DeescalateChannelsByMedia Current mode", eLevelInfoNormal);

    APIU32* ssrcIds = NULL;
    int numOfSsrcIds = 0;
    m_pParty->GetTargetMode()->GetSsrcIds(aDataType, cmCapReceive, ssrcIds, &numOfSsrcIds);

    APIU32* currentSsrcIds = NULL;
    int currentNumOfSsrcIds = 0;
    m_pParty->GetCurrentMode()->GetSsrcIds(aDataType, cmCapReceive, currentSsrcIds, &currentNumOfSsrcIds);

    // close internal channels
    CSipChannel *pChannel = NULL;
    for (int i = numOfSsrcIds; i < currentNumOfSsrcIds; i++)
    {
        // find the channel
    	pChannel=NULL;
		
       	if (i<NUMBER_OF_INTERNAL_AVC_TO_SVC_TRANSLATORS && m_AvcToSvcTranslatorInterface[i].pAvcToSvcTranslatorInterface)
    	{
    		pChannel = m_pCall->GetChannel(false, aDataType, cmCapTransmit, kRolePeople, m_AvcToSvcTranslatorInterface[i].pAvcToSvcTranslatorInterface->GetConnectionId());
    	}

        if (pChannel == NULL)
        {
            TRACEINTO << "@#@ No channels to close for index=" << i;
        }
        else
        {
            pChannel->SetRtpConnectionState(kDisconnected);
            pChannel->SetCmConnectionState(kDisconnected);
            pChannel->SetConnectionState(kDisconnected);
            RemoveChannel(pChannel);
        }
    }

    delete [] ssrcIds;
    delete [] currentSsrcIds;
}

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
void  CSipCntl::FillRemoteInformationHeader()
{
    sipMessageHeaders *pHeaders = (sipMessageHeaders *) &m_pRemoteSdp->capsAndHeaders[m_pRemoteSdp->sipHeadersOffset];
    if (!pHeaders)
    {
    	TRACEINTO << "---cascade--- No pHeaders";
    	return;
    }

    char cInformation[MAX_SDP_INFORMATION_HEADER_SIZE] = "";

    BYTE bIsInfoHeader = ::SipGetHeaderValue(pHeaders, kSdpSession_i, cInformation, MAX_SDP_INFORMATION_HEADER_SIZE);
    if ( (NO == bIsInfoHeader) || (!cInformation[0]) )
    {
        return;
    }

    // store in m_sdpRemoteSessionInformation
	int len  = strlen(cInformation);
	if(m_sdpRemoteSessionInformation)
	{
		PDELETEA(m_sdpRemoteSessionInformation);
	}
	m_sdpRemoteSessionInformation = new char[len+1];
	memset(m_sdpRemoteSessionInformation, 0, len);
	snprintf(m_sdpRemoteSessionInformation, len+1, "%s", cInformation);

    TRACEINTO << "---cascade--- cInformation=" << cInformation << ", m_sdpRemoteSessionInformation: " << m_sdpRemoteSessionInformation;
}

//////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::IsRemoteSlave() const
{
	BYTE bIsRemoteSlave = FALSE;

	const char* pSdpRemoteSessionInformation = GetSdpRemoteSessionInformation();
	if ( pSdpRemoteSessionInformation &&
		 ( !strcmp(pSdpRemoteSessionInformation, INFO_HEADER_STR_SLAVE) ) )
	{
		bIsRemoteSlave = TRUE;
		TRACEINTO << "---cascade--- bIsRemoteSlave: TRUE";
	}

	return bIsRemoteSlave;
}

//////////////////////////////////////////////////////////////////////////
BYTE CSipCntl::IsRemoteMaster() const
{
	BYTE bIsRemoteMaster = FALSE;

	const char* pSdpRemoteSessionInformation = GetSdpRemoteSessionInformation();
	if ( pSdpRemoteSessionInformation &&
		 ( !strcmp(pSdpRemoteSessionInformation, INFO_HEADER_STR_MASTER) ) )
	{
		bIsRemoteMaster = TRUE;
		TRACEINTO << "---cascade--- bIsRemoteMaster: TRUE";
	}

	return bIsRemoteMaster;
}

//////////////////////////////////////////////////////////////////////////
void  CSipCntl::RemoveOperationPointsFromSvcCap(sipSdpAndHeadersSt &pSdpAndHeaders)
{
	TRACEINTO;

	BYTE rVal = STATUS_OK;

	if ( pSdpAndHeaders.sipMediaLinesLength )
	{
		sipMediaLinesEntrySt *pMediaLinesEntry = (sipMediaLinesEntrySt *) &pSdpAndHeaders.capsAndHeaders[pSdpAndHeaders.sipMediaLinesOffset];
		int mediaLinePos = 0;

		for (unsigned int j=0; j<(pMediaLinesEntry->numberOfMediaLines); j++)
		{
			const sipMediaLineSt *pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
			mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;

			const capBuffer* pCapBuffer = (capBuffer *) &pMediaLine->caps[0];
			const BYTE*	pTemp = (const BYTE*)pCapBuffer;

			if ( pMediaLine->internalType == kMediaLineInternalTypeVideo )
			{
				for (unsigned int i=0 ; i<(pMediaLine->numberOfCaps); i++)
				{
					BaseCapStruct *pBaseCap  = (BaseCapStruct*)pCapBuffer->dataCap;
					CapEnum capCodeType = (CapEnum)pBaseCap->header.capTypeCode;

					if(capCodeType == eSvcCapCode)
					{
						svcCapStruct* pSvcStruct = (svcCapStruct*)(pBaseCap);
						memset( &(pSvcStruct->operationPoints), 0, sizeof(pSvcStruct->operationPoints) );
					}

					pTemp += sizeof(capBufferBase) + pCapBuffer->capLength;
					pCapBuffer = (capBuffer*)pTemp;
				} // end loop over numberOfCaps
			}
		} // end loop over numberOfMediaLines
	}

}


//////////////////////////////////////////////////////////////////////////
void CSipCntl::MsftSendMsgToMux(mcMuxLync2013InfoReq& msSvcMuxMsg)
{
	PTRACE(eLevelInfoNormal, "CSipCntl::MsftSendMsgToMux");

	msSvcMuxMsg.bIsAVMCU = 1;
	msSvcMuxMsg.bIsIceParty =  m_IsEnableICE;

	for (int i=0; i < MAX_STREAM_MUX_LYNC_CONN; ++i)
	{
		SingleStreamDesc& muxDesc     = msSvcMuxMsg.txConnectedParties[i];
		muxDesc.unDspNum              = 0; //will be filled by MPL
		muxDesc.unPortNum             = 0; //will be filled by MPL
		muxDesc.remoteSSRCRange[0]    = m_pLastRemoteCaps->getMsftSsrcVideoFirst(i+1);
		muxDesc.remoteSSRCRange[1]    = m_pLastRemoteCaps->getMsftSsrcVideoLast(i+1);
		muxDesc.lyncMSI               = VSR_SOURCE_ANY;
		muxDesc.localMSI              = m_pLastRemoteCaps->getMsftMsiVideo(i+1);
	}
	memcpy(&m_LastAvMcuMux, &msSvcMuxMsg,  sizeof(mcMuxLync2013InfoReq));

	SendMsgToMpl((BYTE*)(&msSvcMuxMsg), sizeof(mcMuxLync2013InfoReq), CONFPARTY_CM_MUX_ON_AVMCU_CALL_REQ);
}


//////////////////////////////////////////////////////////////////////////
void CSipCntl::SetCallConnected()
{
	PTRACE(eLevelInfoNormal, "CSipCntl::SetCallConnected");
	m_pCall->SetConnectionState(kConnected);
	m_pCall->SetChannelsConnectingState(kConnected,MAX_SIP_CHANNELS,NULL);

}
////////////////////////////////////////
void CSipCntl::CreateFakeIceCandidates()
{
	PTRACE(eLevelInfoNormal,"CSipCntl::CreateFakeIceCandidates");
	CSipCaps* fakeLocalCaps = new CSipCaps;
	*fakeLocalCaps  = *m_pChosenLocalCap;
	fakeLocalCaps->CleanIceCapSets();
	fakeLocalCaps->CreateIceFakeCandidates(m_UdpAddressesParams );
	CLargeString strCaps1;
	fakeLocalCaps ->DumpIceCapsToString(strCaps1);
	PTRACE2(eLevelInfoNormal,"CSipCntl::CreateFakeIceCandidates   fakeLocalCaps =",strCaps1.GetString());


	CLargeString strCaps2;
	m_pChosenLocalCap ->DumpIceCapsToString(strCaps2);
	PTRACE2(eLevelInfoNormal,"CSipCntl::CreateFakeIceCandidates   m_pChosenLocalCap =",strCaps2.GetString());
	m_pCall->SetIceData(fakeLocalCaps );
	POBJDELETE(fakeLocalCaps);


}

///////////////////////////////////////////////////////////////
//eFeatureRssDialin   -- To be extented to send RTCP-FB message to MPL
BYTE  CSipCntl::SendRecordingControlCmd(const char* szControlCmd)
{
	mcReqInfo* pInfoReq;
	size_t size = 0;
	size = sizeof(mcReqInfo) + sizeof(mcReqSrsCmd);
	BYTE* tmp = new BYTE[size]; AUTO_DELETE_ARRAY(tmp);
	pInfoReq = (mcReqInfo*)tmp;
	memset((char*)pInfoReq, 0, size);

	//fill body
	mcReqSrsCmd*	pReqRssCmd= (mcReqSrsCmd*) &pInfoReq->buff[0];

	PTRACE(eLevelInfoNormal, " CSipCntl::SendRecordingControlCmd ");

	if(NULL == szControlCmd)
	{
		PTRACE(eLevelError, " CSipCntl::SendRecordingControlCmd - invalid parameter! ");
		return false;
	}

	if(0 == strncmp(szControlCmd, SRS_CONTROL_START_RESUME, strlen(SRS_CONTROL_START_RESUME)))
	{
	//START
		pReqRssCmd->command  = (APIU32)1;
	}
	else if(0 == strncmp(szControlCmd, SRS_CONTROL_PAUSE, strlen(SRS_CONTROL_PAUSE)))
	{
	//PAUSE
		pReqRssCmd->command  = (APIU32)3;
	}
	else if(0 == strncmp(szControlCmd, SRS_CONTROL_STOP, strlen(SRS_CONTROL_STOP)))
	{
	//STOP
		pReqRssCmd->command  = (APIU32)2;
	}
	else
	{
		pReqRssCmd->command = (APIU32) 0;
		PTRACE2(eLevelInfoNormal,"CSipParty::SendRecordingControlCmd, Recording control string - ", szControlCmd);
	}
	//fill header
	pInfoReq->subOpcode = SrsCommand;
	pInfoReq->dynamicLen = sizeof(mcReqSrsCmd);

	 SendSIPMsgToCS(SIP_CS_SIG_INFO_REQ, pInfoReq, size);
	return true;
}

////////////////////////////////////////////////////////////////////////////
///eFeatureRssDialin
enSrsVideoLayoutType   CSipCntl::GetInitVideoLayoutForRL(sipSdpAndHeadersSt* pSdpAndHeaders)
{
	enSrsVideoLayoutType  ret = eSrsVideoLayoutAuto ;
	PTRACE(eLevelInfoNormal, " CSipCntl::GetInitVideoLayoutForRL ");
	if(NULL == pSdpAndHeaders)
	{
		PTRACE(eLevelError, " CSipCntl::GetInitVideoLayoutForRL - invalid parameter! ");
		return ret;
	}
	if(eSrsSessionTypeRegular ==  ::getSrsSessionType(pSdpAndHeaders))
	{
		PTRACE(eLevelInfoNormal, " CSipCntl::GetInitVideoLayoutForRL - regular link ");
		return ret;
	}
	unsigned int mediaLinePos = 0;
	sipMediaLineSt *pMediaLine = NULL;

	if ( pSdpAndHeaders->sipMediaLinesLength)
	{
		const sipMediaLinesEntrySt* pMediaLinesEntry = (sipMediaLinesEntrySt *) &pSdpAndHeaders->capsAndHeaders[pSdpAndHeaders->sipMediaLinesOffset];

		for (unsigned int i = 0; i < pMediaLinesEntry->numberOfMediaLines; i++) {

			if (mediaLinePos >= pSdpAndHeaders->lenOfDynamicSection) {
				DBGFPASSERT(mediaLinePos);
				break;
			}

			pMediaLine = (sipMediaLineSt *) &pMediaLinesEntry->mediaLines[mediaLinePos];
			if(pMediaLine)
			{
				mediaLinePos += sizeof(sipMediaLineBaseSt) + pMediaLine->lenOfDynamicSection;
				if (kMediaLineInternalTypeVideo == (eMediaLineInternalType)pMediaLine->internalType)
				{

					PTRACE2INT(eLevelInfoNormal, " CSipCntl::GetInitVideoLayoutForRL - initial layout -  ", pMediaLine->rssVideoLayout);
					ret = static_cast<enSrsVideoLayoutType>(pMediaLine->rssVideoLayout);
				}
			}
		}
	}
	return ret;
}


/////////////////////////////////////////////////////////////////////////////
///eFeatureRssDialin
void   CSipCntl::OnSipPartySrsStatusInd(mcIndSrsIndicaton *pstRssCmdStatus)
{
	PTRACE(eLevelInfoNormal, " CSipCntl::OnSipPartySrsStatusInd ");
	if(NULL == pstRssCmdStatus)
	{
		return;
	}
	BYTE status = (BYTE) pstRssCmdStatus->status;
 	m_pPartyApi->SendRecordingControlStatus(status);
	return;
}

////////////////////////////////////////////////////////////////////////////
///eFeatureRssDialin
void	   CSipCntl::OnSipPartySrsLayoutInd(mcIndSrsVideolayout *pstRssLayoutCmd)
{
	if(NULL == pstRssLayoutCmd)
	{
		return;
	}
	BYTE layoutRequested = (BYTE)pstRssLayoutCmd->layout;

 	m_pPartyApi->SendLayoutControlLocal(layoutRequested);

}

/////////////////////////////////////////////////////////////////////////////
//8.3.2
void CSipCntl::SetStateOnEndOfTransaction()
{
	if (m_state == IP_CONNECTING)
		m_state = IP_CONNECTED;
}
/////////////////////////////////////////////////////////////////////////////
bool CSipCntl::CheckAndStoreRemoteOriginVersionField()
{
    bool changed = false;
	sipMessageHeaders *pRemoteSipHeaders = GetRemoteCallLegHeaders();
	char sOriginField[MaxUserAgentSize] = {0};
	//if value received from header
	if (pRemoteSipHeaders)
	{
		::SipGetHeaderValue(pRemoteSipHeaders, kSdpSession_o_version, sOriginField, MaxUserAgentSize);
		TRACEINTO << "Origin version: " << sOriginField;
		if (strlen(sOriginField) > 0)
		{
			if( m_sLastOriginVersion != sOriginField )
				changed = true;
			m_sLastOriginVersion = sOriginField;
		}
	}
	return changed;
}

/////////////////////////////////////////////////////////////////////////////
void CSipCntl::FillRemoteCapsFromReInvite()
{

	CSegment* pSavedParam = NULL;
	CSegment* pParam = NULL;

	if(m_SavedTrans && pParam == NULL && m_PendTransType == etransReinvite)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::FillRemoteCapsFromReInvite -begin reinvite from pending trans");
		pParam = new CSegment(*m_SavedTrans);
		/*we save the point here since we need free it in the end of this function*/
		pSavedParam = pParam;
		POBJDELETE(m_SavedTrans);
		m_PendTransType = eNoPendTrans;

	}
	else if(m_SavedTrans == NULL && pParam == NULL)
	{
		PTRACE(eLevelInfoNormal,"CSipCntl::FillRemoteCapsFromReInvite -invalid trans calling.");
		DBGPASSERT_AND_RETURN(1);
	}
	APIU32 callIndex = 0;
	APIU32 channelIndex = 0;
	APIU32 mcChannelIndex = 0;
	APIU32 stat1 = 0;
	APIU16 srcUnitId = 0;
	BYTE bDelSdpHeader = FALSE;

	TRACEINTO;

	BYTE bRemovedAudio, bRemovedVideo;
	bRemovedAudio = bRemovedVideo = 0;

	TRACECOND_AND_RETURN(!pParam , "pParam is NULL");
	*pParam >> callIndex >> channelIndex >> mcChannelIndex >> stat1 >> srcUnitId;

	mcIndReInvite* pReInviteMsg = (mcIndReInvite *)pParam->GetPtr(1);

	if(NULL == pReInviteMsg)
	{
		if(m_PendTransType == eNoPendTrans)
			POBJDELETE(pParam);  // pParam is new by us, delete it before return
		PASSERT_AND_RETURN(1);
	}


	DWORD status = pReInviteMsg->status;
	DBGPASSERT(status); // only if status != STATUS_OK

	sipSdpAndHeadersSt* pSdpAndHeaders	= (sipSdpAndHeadersSt *)&pReInviteMsg->sipSdpAndHeaders;
	if (pSdpAndHeaders)
	{
		SetMediaLinesInternalTypeForRmtSdp(*pSdpAndHeaders);
		SetCapsRolesForRmtSdp(*pSdpAndHeaders, kMediaLineInternalTypeVideo, kRolePeople);
		SetCapsRolesForRmtSdp(*pSdpAndHeaders, kMediaLineInternalTypeContent, kRolePresentation);
	}
	BYTE isRejectReInvite  = NO;
	BYTE isReInviteWithSdp = NO;

	if (status == STATUS_OK)
	{
		APIU32 capabilitiesLength	= pSdpAndHeaders->sipMediaLinesLength; // old api: sipHeadersOffset;
		APIU32 capsAndHeadersLength = pSdpAndHeaders->lenOfDynamicSection;
		if(capsAndHeadersLength && capabilitiesLength && capsAndHeadersLength >= capabilitiesLength)
		{
			isReInviteWithSdp = YES;
			RestoreVideoRate(pSdpAndHeaders);
			CSipCaps*			pRemoteCaps		= new CSipCaps;
			if (m_remoteIdent == MicrosoftEP_R2 || m_remoteIdent == MicrosoftEP_Lync_R1 || m_remoteIdent == MicrosoftEP_Lync_2013)  // patch for MOC R2 features (hold,resume,a->v)
			{
				PTRACE(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected - Handle MOC/Lync ReInvite");

				// save ports and ips:
				SaveAudioAndVideoParams(pSdpAndHeaders);

				int NewMocState = GetNewMOCStateAccoringToSdp(pSdpAndHeaders);

				if (NewMocState==MocStateHold)
				{
					CloneSdpAndHeaders(m_pRemoteSdp, pSdpAndHeaders, bDelSdpHeader);

					TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kInactive,kInactive,kInactive,kInactive,kInactive)";
					SetTheDirectionAttribute(pSdpAndHeaders,kInactive,kInactive,kInactive,kInactive,kInactive);
				}
				else if (NewMocState==MocStateResume)
				{
					CloneSdpAndHeaders(m_pRemoteSdp, pSdpAndHeaders, bDelSdpHeader);

					TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv," << (m_bPauseMyVideo? "kSendOnly" : "kSendRecv") << "kSendRecv,kSendRecv,kSendRecv,TRUE)";
					SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv, m_bPauseMyVideo? kSendOnly : kSendRecv, kSendRecv, kSendRecv, kSendRecv, TRUE);
				}
				else if(NewMocState==MocStateAtoV)
				{
					CSipCaps*	pRemoteCapsWithVideo	= new CSipCaps;
					pRemoteCapsWithVideo->Create(*pSdpAndHeaders, m_pParty->GetTargetMode()->GetConfMediaType(), m_bIsMrcCall);
				//	pRemoteCapsWithVideo->Set4CifMpi ((APIS8)-1);

					int oldCapabilitiesLength = m_pRemoteSdp->sipMediaLinesLength;
					int oldLength = sizeof(sipSdpAndHeadersBaseSt) + oldCapabilitiesLength;
					int newCapsLen = pRemoteCapsWithVideo->CalcCapBuffersSize(cmCapReceiveAndTransmit, NO);
					int newLength = oldLength + newCapsLen;
					pSdpAndHeaders = (sipSdpAndHeadersSt *)new BYTE[newLength];
					memset(pSdpAndHeaders, 0, newLength);
					memcpy(pSdpAndHeaders,m_pRemoteSdp,oldLength);
							pSdpAndHeaders->sipMediaLinesLength = oldCapabilitiesLength;
					pSdpAndHeaders->lenOfDynamicSection = oldCapabilitiesLength;

					int exactCapsSize = pRemoteCapsWithVideo->AddCapsToCapStruct(cmCapReceiveAndTransmit,
																					NO,(sipMediaLinesEntrySt*)pSdpAndHeaders->capsAndHeaders,
																					newLength, GetBfcpType());

					pSdpAndHeaders->sipMediaLinesLength = exactCapsSize;
					pSdpAndHeaders->lenOfDynamicSection = exactCapsSize;

					TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendRecv,kSendRecv,kSendRecv,kSendRecv,TRUE)";
					SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendRecv,kSendRecv,kSendRecv,kSendRecv,TRUE);

					mcXmlTransportAddress &videoIp = ExtractMLineMediaIp(kMediaLineInternalTypeVideo, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted());
					videoIp.transAddr.port = m_savedVideoPort;
					videoIp.transAddr.addr.v4.ip =  m_savedVideoIp;

					POBJDELETE(pRemoteCapsWithVideo);
					bDelSdpHeader = TRUE;
				}
				else if(NewMocState==MocStateVtoA)
				{
					// take the previous sdp:
					CloneSdpAndHeaders(m_pRemoteSdp, pSdpAndHeaders, bDelSdpHeader);
					ExtractMLineMediaIp(kMediaLineInternalTypeVideo, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = 0;
				}
				else if(NewMocState==MocStatePauseMyVideo)
				{
					CloneSdpAndHeaders(m_pRemoteSdp, pSdpAndHeaders, bDelSdpHeader);

					TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendOnly,kSendRecv,kSendRecv,kSendRecv)";
					SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendOnly,kSendRecv,kSendRecv,kSendRecv);

					ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = m_savedAudioPort;
				}
				else if(NewMocState==MocStateResumeMyVideo)
				{
					CloneSdpAndHeaders(m_pRemoteSdp, pSdpAndHeaders, bDelSdpHeader);

					TRACEINTO << "Calling SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendRecv,kSendRecv,kSendRecv,kSendRecv)";
					SetTheDirectionAttribute(pSdpAndHeaders,kSendRecv,kSendRecv,kSendRecv,kSendRecv,kSendRecv);

					ExtractMLineMediaIp(kMediaLineInternalTypeAudio, pSdpAndHeaders, m_dummyMediaIp, m_pParty->GetTargetMode()->GetIsEncrypted()).transAddr.port = m_savedAudioPort;
				}
			}

			pRemoteCaps->Create(*pSdpAndHeaders, m_pParty->GetTargetMode()->GetConfMediaType(), m_bIsMrcCall);

			//ANAT for debug
			CSuperLargeString msgRC;
			pRemoteCaps->DumpToString(msgRC);
			PTRACE2(eLevelInfoNormal,"CSipCntl::OnSipReInviteIndConnected, remote caps reinvite1 for anat: ", msgRC.GetString());

			BYTE isRmxInitiateTransaction = TRUE;
			BYTE bFixVideoRate = CheckIsMobilePhoneByHeader(isRmxInitiateTransaction);

			sipMessageHeaders* pHeaders = NULL;
			if (pSdpAndHeaders->sipHeadersLength)
				pHeaders = (sipMessageHeaders*)((char*)pSdpAndHeaders->capsAndHeaders + pSdpAndHeaders->sipHeadersOffset);
			pRemoteCaps->FixRemoteCapsBySystemSettings(pHeaders, bFixVideoRate);
			//pRemoteCaps->CompleteDataFromOtherCap(*m_pChosenLocalCap );
			CompleteDataFromOtherCapUsingUserAgent(pRemoteCaps);
			pRemoteCaps->CheckAndRemoveCapSetsWithInvalidPayloadType(bRemovedAudio, bRemovedVideo);

			DecideAnatSelectedIpVersion(pSdpAndHeaders); //Added for ANAT

			SavePreviousRemoteCaps();

			POBJDELETE(m_pLastRemoteCaps);

			m_pLastRemoteCaps = pRemoteCaps;
		}

		if(bDelSdpHeader)
			PDELETEA(pSdpAndHeaders);
	}

	POBJDELETE(pSavedParam);

}

void CSipCntl::PartyDisconnectionPrint(std::ostringstream& msg,const char* flow_str, bool isReject, DWORD rejectSipCode, const char* reject_str,bool print){

	msg << "PARTY_DISCONNECTION - confRsrcId: " << m_pParty->GetConfId() << " , partyRsrcId: " << m_pParty->GetPartyRsrcID() << " , " << flow_str;
	if(isReject){
		msg << "\nREJECT rejectSipCode: " << rejectSipCode << "  " << GetRejectReasonStr((enSipCodes)rejectSipCode) << " , " << reject_str;
	}
	if(print){
		TRACEINTO << msg.str().c_str();
	}
}


bool CSipCntl::IsPartyInDiffPayLoadType()
{
	CSipChannel* pChannel = NULL;

	for (int mediaType = cmCapAudio; mediaType <= cmCapData ; ++mediaType)
	{
		pChannel = m_pCall->GetChannel(true, static_cast<cmCapDataType>(mediaType), cmCapReceive, kRolePeople);
		if (pChannel && pChannel->GetDiffPayloadState() == kDiffPayload_UpdateSent)
			return true ;
	}
	// check content channel for diff payload type
	pChannel = m_pCall->GetChannel(true, cmCapVideo, cmCapReceive, kRoleContentOrPresentation);

	return (pChannel && pChannel->GetDiffPayloadState() == kDiffPayload_UpdateSent) ? true : false;
}

/////////////////////////////////////////////////////
//To Handle Content snatching, specifically the change rates flow control msg that need to be sent to the token holder

void CSipCntl::OnSIPPartyContentSpeakerChange(BYTE bIsSpeaker, DWORD curConfContRate)
{

	TRACESTR(eLevelInfoNormal) << " CSipCntl::OnPartyContentSpeakerChange - Conn Id = " << m_pCsRsrcDesc->GetConnectionId() << ",  Name - " << PARTYNAME;

	if (bIsSpeaker && curConfContRate)
	{
		// In this case we will send flow cntl for the content channels of the new speaker.
		m_bIsContentSpeaker = bIsSpeaker;

		CSipChannel* pContentChannel = m_pCall->GetChannel(true, cmCapVideo, cmCapReceive, kRolePresentation);
		if (pContentChannel)
		{
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnPartyContentSpeakerChange SendFlowControlReq curConfContRate = ", curConfContRate);
			SendFlowControlReq(slideType, cmCapReceive,curConfContRate);
		}
		else
			PTRACE2INT(eLevelInfoNormal,"CSipCntl::OnPartyContentSpeakerChange SendFlowControlReq NO OPEN CONTENT CHANNEL !!! curConfContRate = ", curConfContRate);

	}
}

