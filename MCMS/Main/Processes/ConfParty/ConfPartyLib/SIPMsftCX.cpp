
//=================================================================================================
//
//Copyright (C) 2005 POLYCOM
//This file contains confidential information proprietary to ACCORD Networks Ltd. The use or 
//disclosure of any information contained in this file without the written consent of an officer of
//ACCORD Networks Ltd. is expressly forbidden.
//
//=================================================================================================

//=================================================================================================
//
//Module Name:  SIPMSPKG.CPP
//
//General Description:  
//
//    1.	SIP CX - Microsoft conference package 
//
//Generated By: Ori P.                            Date: 19.05.05
//
//Revisions and Updates: 
//
//Date         Updated By         Description
//========   ==============   =====================================================================
// 
//=================================================================================================

#ifndef __SIP_MS_CONFPACKAGE_CPP__
#define __SIP_MS_CONFPACKAGE_CPP__

//===== Include Files =====
#include "SIPMsftCX.h"
#include "psosxml.h"
#include <stdlib.h>
#include "ApiStatuses.h"
#include "SystemFunctions.h"

#define CONF_INFO_NAME	"com.microsoft.sip.cx-conference-info"

#define UPDATE_STATE	if(eNoChange == m_state) m_state = ePartialData;

// ************************************************************************************
//
//	CBasicConfPackageType
//
// ************************************************************************************


///////////////////////////////////////////////////////////////////
CBasicConfPackageType::CBasicConfPackageType()
{
	m_elementName[0]= '\0';
}

///////////////////////////////////////////////////////////////////
CBasicConfPackageType::CBasicConfPackageType(char* pName)
{
	if(pName)
		strncpy(m_elementName, pName, H243_NAME_LEN);
}

///////////////////////////////////////////////////////////////////
CBasicConfPackageType::~CBasicConfPackageType()
{
}

///////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
const char* CBasicConfPackageType::GetElementName()
{
	return m_elementName;
}

// ************************************************************************************
//
//	CConfPackageType
//
// ************************************************************************************

/////////////////////////////////////////////////////////////////////////////
CConfPackageType::CConfPackageType() : m_state(eFullData)
{
}

///////////////////////////////////////////////////////////////////
CConfPackageType::CConfPackageType(char* pName) :CBasicConfPackageType(pName), m_state(eFullData)
{
}

/////////////////////////////////////////////////////////////////////////////
CConfPackageType::~CConfPackageType()
{
}

///////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
eTypeState CConfPackageType::GetState()
{
	return m_state;
}

/////////////////////////////////////////////////////////////////////////////
void CConfPackageType::SerializeXml(CXMLDOMElement* pFatherNode)
{
	SerializeXml(pFatherNode, TRUE);
}

/////////////////////////////////////////////////////////////////////////////
const char* CConfPackageType::GetStateByString()
{
	switch(m_state)
	{
		case(eNoChange):
			return "no-change";

		case(ePartialData):
			return "partial";

		case(eFullData):
			return "full";
			
		case(eDelletedData):
			return "deleted";

		default:
			return "unknown";		
	}	

}

/////////////////////////////////////////////////////////////////////////////
void CConfPackageType::SerializeState(CXMLDOMElement* pFatherNode, BYTE bFull)
{
	if(bFull || eNoChange != m_state)
	{
		CXMLDOMAttribute* pAttribute = new CXMLDOMAttribute();
		pAttribute->set_nodeName("state");

		//if requested to serialize full data
		if(bFull)
		{
			pAttribute->SetValueForElement("full");
		}
		else
		{
			if(eFullData == m_state)
				pAttribute->SetValueForElement("full");
			else
				if(ePartialData == m_state)
					pAttribute->SetValueForElement("partial");
		}
		pFatherNode->AddAttribute(pAttribute);

		if(!bFull || eFullData == m_state)
			m_state = eNoChange;
	}
}



// ************************************************************************************
//
//	CCXConfInfoType
//
// ************************************************************************************

/////////////////////////////////////////////////////////////////////////////
CCXConfInfoType::CCXConfInfoType() : m_entityAtr("")
{
	strncpy(m_elementName, CONF_INFO_NAME, H243_NAME_LEN);
	m_pProperties = new CCXPropertiesType;
}

/////////////////////////////////////////////////////////////////////////////
CCXConfInfoType::CCXConfInfoType(CCommConf* pCommConf, const char* confUri) : m_entityAtr(confUri)
{
	strncpy(m_elementName, CONF_INFO_NAME, H243_NAME_LEN);
	m_pProperties = new CCXPropertiesType(pCommConf);
	SetupUsersList(pCommConf);
}

/////////////////////////////////////////////////////////////////////////////
CCXConfInfoType::~CCXConfInfoType()
{
	CCXUserType* pTempUser = NULL;

	std::vector< CCXUserType * >::iterator itr =  m_UsersList.begin();
	while(itr != m_UsersList.end())
	{
		pTempUser = (*itr);
		m_UsersList.erase(itr);
		POBJDELETE(pTempUser);
		itr = m_UsersList.begin();
	}
	POBJDELETE(m_pProperties);
}

//////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SerializeXml(CXMLDOMElement* pFatherNode, BYTE bFull)
{
	SerializeXml(pFatherNode, bFull, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SerializeXml(CXMLDOMElement* pFatherNode, BYTE bFull, BYTE bIsNewSubscriber)
{
	if(bFull || eNoChange != m_state)
	{
		if(eFullData == m_state)
			bFull = TRUE;

		pFatherNode->set_nodeName(m_elementName);
		
		m_pProperties->SerializeXml(pFatherNode, bFull);
		
		std::vector< CCXUserType * >::iterator itr =  m_UsersList.begin();
		if(0 == m_UsersList.size())
			PTRACE(eLevelInfoNormal, "CCXConfInfoType::SerializeXml, no users to add to XML.");
		
		CCXUserType* pUser = NULL;
		while(itr != m_UsersList.end())
		{
			pUser = (*itr);
			pUser->SerializeXml(pFatherNode, bFull, bIsNewSubscriber);
			itr++;
		}
		
		CXMLDOMAttribute* pEntityAttribute = new CXMLDOMAttribute();
		pEntityAttribute->set_nodeName("entity");
		pEntityAttribute->SetValueForElement(m_entityAtr.GetString());
		pFatherNode->AddAttribute(pEntityAttribute);
		
		CXMLDOMAttribute* pVersionAttribute = new CXMLDOMAttribute();
		pVersionAttribute->set_nodeName("version");
		char version[11] = "1";
		version[2] = '\0';
		//itoa(1, version, 10);
		pVersionAttribute->SetValueForElement(version);
		pFatherNode->AddAttribute(pVersionAttribute);
		
		SerializeState(pFatherNode, bFull);
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetupUsersList(CCommConf* pCommConf)
{
	CConfParty* pConfParty = pCommConf->GetFirstParty();
	while(pConfParty)
	{
		AddParty(pConfParty);
		pConfParty = pCommConf->GetNextParty();
	}
}

/////////////////////////////////////////////////////////////////////////////
CCXUserType* CCXConfInfoType::FindUser(DWORD partyId)
{
	CCXUserType* pUser = NULL;
	std::vector< CCXUserType * >::iterator itr =  m_UsersList.begin();
	while(itr != m_UsersList.end())
	{
		pUser = (*itr);
		if(partyId == pUser->GetUserId())
			break;
		else
		{
			pUser = NULL;
			++itr;
		}
	}

	return pUser;
}

/////////////////////////////////////////////////////////////////////////////
const char* CCXConfInfoType::GetEntity()
{
	return m_entityAtr.GetString();
}

///////////////////////////////////////////////////////////////////
BYTE CCXConfInfoType::WasUpdated()
{
	return (eNoChange != m_state);
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::AddParty(CConfParty* pConfParty)
{
	PTRACE2(eLevelInfoNormal, "CCXConfInfoType::AddParty, party=", pConfParty->GetName());
	if(IsValidPObjectPtr(pConfParty))
	{
		//verify not already in DB
		if(FindUser(pConfParty->GetPartyId()))
			{
				PTRACE(eLevelError, "CCXConfInfoType::AddParty, already in list.");
				return;
			}
		CCXUserType* pUser = new CCXUserType(pConfParty);
		m_UsersList.push_back(pUser);
		UPDATE_STATE;
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::DelParty(DWORD partyId, int numSubscribers)
{
	CCXUserType* pUser = NULL;
	std::vector< CCXUserType * >::iterator itr =  m_UsersList.begin();
	while(itr != m_UsersList.end())
	{
		pUser = (*itr);
		if(partyId == pUser->GetUserId())
		{
				char s[100];
				*s = 0;
				snprintf(s, sizeof(s), "%d, %s, %s", pUser->GetUserId(), pUser->GetDisplayName(), pUser->GetPartyStatus());
				
				if(0 == numSubscribers || pUser->CanDelParty())
				{
					PTRACE2(eLevelInfoNormal, "CCXConfInfoType::DelParty, deleting: ", s);
					m_UsersList.erase(itr);
					POBJDELETE(pUser);
					UPDATE_STATE;
					break;
				}
				else
				{
					pUser->MarkForDelete();
					PTRACE2(eLevelInfoNormal, "CCXConfInfoType::DelParty, not deleting: ", s);
					pUser = NULL;
					++itr;
				}
		}
		++itr;
	}
}
/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::DelDisconnectedParties()
{
	int len = m_UsersList.size();

	char a[30];
	*a = 0;
	sprintf(a, "%d", len);
	PTRACE2(eLevelInfoNormal, "CCXConfInfoType::DelDisconnectedParties, length=", a);

	CCXUserType* pUser = NULL;
	std::vector< CCXUserType * >::iterator itr =  m_UsersList.begin();
	while(itr != m_UsersList.end())
	{
		pUser = (*itr);
		if(IsValidPObjectPtr(pUser))
		{
			char s[100];
			*s = 0;
			snprintf(s, sizeof(s), "%s, %s", pUser->GetDisplayName(), pUser->GetPartyStatus());
			
			if(pUser->IsMarkedForDelete() && pUser->CanDelParty())
			{
				PTRACE2(eLevelInfoNormal, "CCXConfInfoType::DelDisconnectedParties, deleting: ", s);
				m_UsersList.erase(itr);
				POBJDELETE(pUser);
				itr = m_UsersList.begin();
				UPDATE_STATE;
			}
			else
			{
				PTRACE2(eLevelInfoNormal, "CCXConfInfoType::DelDisconnectedParties, not deleting: ", s);
				++itr;
			}
		}
		else
		{
			PTRACE(eLevelInfoNormal, "CCXConfInfoType::DelDisconnectedParties, Invalid pointer.");
			++itr;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetDisplayName(DWORD partyId, char* name)
{
	if(name)
	{
		CCXUserType* pUser = FindUser(partyId);
		int len = strlen(name);
		if(IsValidPObjectPtr(pUser) && strncmp(pUser->GetDisplayName(), name, len))
		{
			pUser->SetDisplayName(name);
			UPDATE_STATE;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetDisplayPhoneNumber(DWORD partyId, char* num)
{
	if(num)
	{
		CCXUserType* pUser = FindUser(partyId);
		if(IsValidPObjectPtr(pUser))
		{
			pUser->SetDisplayPhoneNumber(num);
			UPDATE_STATE;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetSipUri(DWORD partyId, char* sipUri)
{
	if(sipUri)
	{
		CCXUserType* pUser = FindUser(partyId);
		if(IsValidPObjectPtr(pUser))
		{
			pUser->SetSipUri(sipUri);
			UPDATE_STATE;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetAdministrator(DWORD partyId, BYTE onOff)
{
	CCXUserType* pUser = FindUser(partyId);
	if(IsValidPObjectPtr(pUser))
	{
		pUser->SetAdministrator(onOff);
		UPDATE_STATE;
	}
	else
		PTRACE(eLevelError, "CCXConfInfoType::SetAdministrator, user not found");
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetPartyStatus(DWORD partyId, DWORD status, DWORD attendedStatus, int len)
{
	CCXUserType* pUser = FindUser(partyId);
	if(IsValidPObjectPtr(pUser))
	{
		pUser->SetPartyStatus(status, attendedStatus);
		UPDATE_STATE;
	}
	else
		PTRACE(eLevelError, "CCXConfInfoType::SetPartyStatus, user not found");
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetDialOutParty(DWORD partyId)
{
	CCXUserType* pUser = FindUser(partyId);
	if(IsValidPObjectPtr(pUser))
	{
		pUser->SetDialOutParty();
		UPDATE_STATE;
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetDisconnectReason(DWORD partyId, DWORD reason)
{
	CCXUserType* pUser = FindUser(partyId);
	if(IsValidPObjectPtr(pUser))
	{
		if(pUser->SetDisconnectReason(reason))
			UPDATE_STATE;
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetActiveSpeaker(DWORD partyId, BYTE onOff)
{
	CCXUserType* pUser = FindUser(partyId);
	if(IsValidPObjectPtr(pUser) && pUser->GetActiveSpeaker()!=onOff )
	{
		pUser->SetActiveSpeaker(onOff);
		UPDATE_STATE;
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetUriAttribute(DWORD partyId, char* uri)
{
	if(uri)
	{
		CCXUserType* pUser = FindUser(partyId);
		if(IsValidPObjectPtr(pUser))
		{
			pUser->SetUriAttribute(uri);
			UPDATE_STATE;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::MutePartyMedia(DWORD partyId, eMediaContentType mediaType, BYTE onOff)
{
	CCXUserType* pUser = FindUser(partyId);
	if(IsValidPObjectPtr(pUser) && pUser->IsMediaMuted(mediaType) != onOff)
	{
		pUser->MuteMedia(mediaType, onOff);
		UPDATE_STATE;
	}
}
	
/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetActive(BYTE onOff)
{
	if(m_pProperties->GetActive() != onOff)
	{
		m_pProperties->SetActive(onOff);
		UPDATE_STATE;
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetLocked(BYTE onOff)
{
	if(m_pProperties->GetLocked() != onOff)
	{
		m_pProperties->SetLocked(onOff);
		UPDATE_STATE;
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetRollCall(BYTE onOff)
{
	m_pProperties->SetRollCall(onOff);
	UPDATE_STATE;
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetAnnouncements(BYTE onOff)
{
	m_pProperties->SetAnnouncements(onOff);
	UPDATE_STATE;
}

/////////////////////////////////////////////////////////////////////////////
void CCXConfInfoType::SetRecorded(BYTE onOff)
{
	m_pProperties->SetRecorded(onOff);
	UPDATE_STATE;
}


// ************************************************************************************
//
//	CCXUserType
//
// ************************************************************************************

/////////////////////////////////////////////////////////////////////////////
CCXUserType::CCXUserType() : CConfPackageType("user"), m_userId(0), m_displayName(""), m_displayPhoneNumber(""),
							m_isSip(FALSE), m_role(eParticipant), m_status(ePending), m_joinMode(eDialedIn),
							m_disconnectReason(eNotDisconnected), m_activelyTalking(FALSE), m_sendDataBeforeDeleted(eRegular),
							m_isCallBack(FALSE), m_markedforDelete(FALSE)
{
	for(int i=0; i<MEDIA_STREAMS; i++)
		m_pMediaStream[i] = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CCXUserType::CCXUserType(CConfParty* pConfParty) : CConfPackageType("user"), m_sendDataBeforeDeleted(eRegular), m_markedforDelete(FALSE)
{
	m_userId = pConfParty->GetPartyId();
	m_displayName << pConfParty->GetName();
	m_displayPhoneNumber << pConfParty->GetPhoneNumber();
	
	if(SIP_INTERFACE_TYPE == pConfParty->GetNetInterfaceType())
	{
		m_isSip = TRUE;
		//if 'reffered-to' is not empty
		if(strcmp(pConfParty->GetRefferedToUri(), ""))
		{
//****			m_sipUri << pConfParty->GetExtension();
			//if this is refer to itself
			if(!strncmp(pConfParty->GetRefferedToUri(), pConfParty->GetSipPartyAddress(), IP_STRING_LEN))
				m_uriAttribute << "sip:" << pConfParty->GetSipPartyAddress();
			else
				m_uriAttribute << "sip:" << pConfParty->GetRefferedToUri();
		}
		else
		{
			const char* pSipUri = pConfParty->GetSipPartyAddress();
			if(*pSipUri != '\0')
			{
				m_uriAttribute << "sip:" << pSipUri;
				m_sipUri << m_uriAttribute;
			}
			else
			{
				char Ip[16];
				Ip[0]='\0';
// IpV6				SystemDWORDToIpString(pConfParty->GetIpAddress(), Ip);
				m_uriAttribute << "sip:" << Ip << ".user." << SIP_INTERFACE_TYPE << "i";
			}
		}
	}
	else
	{
		m_isSip = FALSE;
		if(H323_INTERFACE_TYPE ==  pConfParty->GetNetInterfaceType())
		{
			//if 'reffered-to' is not empty
			if(strcmp(pConfParty->GetRefferedToUri(), ""))
			{
				m_uriAttribute << "sip:" << pConfParty->GetRefferedToUri();
				m_sipUri << pConfParty->GetExtension();
			}
			else
			{			
				const char* pAlias = pConfParty->GetH323PartyAlias();
				if(pAlias[0] != '\0')
				{
					m_uriAttribute << pAlias << ".user." << H323_INTERFACE_TYPE << "a";
				}
				else
				{
					char Ip[16];
					Ip[0]='\0';
// IpV6					SystemDWORDToIpString(pConfParty->GetIpAddress(), Ip);
					m_uriAttribute << Ip << ".user." << H323_INTERFACE_TYPE << "i";
				}
			}
		}
		else
		{
			//if 'reffered-to' is not empty
			if(strcmp(pConfParty->GetRefferedToUri(), ""))
			{
				m_uriAttribute << "sip:" << pConfParty->GetRefferedToUri();
				m_sipUri << pConfParty->GetExtension();
			}
			else
				m_uriAttribute << pConfParty->GetPhoneNumber() << ".user." << ISDN_INTERFACE_TYPE;
		}
	}

	// add the service's sip host name 
	if (m_uriAttribute.Find("@")==NO) 
	{
		m_uriAttribute << ".id.";
		m_uriAttribute.SetFormat("%d"); 
		m_uriAttribute << pConfParty->GetPartyId() << "@conference.mgc";
		m_sipUri << m_uriAttribute;
	}

/*	if(pConfParty->IsChair())
		m_role  = eAdministrator;
	else******************* */
		m_role = eParticipant;

	SetPartyStatus(pConfParty->GetPartyState(), /****pConfParty->GetAttendedPartyState()*/0);
	
	if(DIAL_OUT == pConfParty->GetConnectionType())
		m_joinMode = eDialedOut;
	else
		m_joinMode = eDialedIn;
	
	if(PARTY_DISCONNECTED == pConfParty->GetPartyState())
		SetDisconnectReason(pConfParty->GetDisconnectCause());
	else
		m_disconnectReason = eNotDisconnected;

	m_activelyTalking = FALSE;

	for(int i=0; i<MEDIA_STREAMS; i++)
		m_pMediaStream[i] = NULL;
		
	m_pMediaStream[0] = new CCXMediaType(eAudio);

	int i = 1;
/*	if(pConfParty->IsIpNetInterfaceType())
	{*/
		m_pMediaStream[i] = new CCXMediaType(eVoip);
		i++;
/*	}
	
	if(!pConfParty->GetVoice())
	{*/
		m_pMediaStream[i] = new CCXMediaType(eVideoT);
		i++;
/*	}*/
	/*if(pConfParty->IsT120_Member())
		m_pMediaStream[i] = new CCXMediaType(eData);****/

	//compare 'referred-by' with 'associated-uri'
	if(!strncmp(pConfParty->GetExtension(), pConfParty->GetRefferedBy(), IP_STRING_LEN))
		m_isCallBack = TRUE;
	else
		m_isCallBack = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
CCXUserType::~CCXUserType()
{
	for(int i=0; i<MEDIA_STREAMS; i++)
		if(m_pMediaStream[i])
			POBJDELETE(m_pMediaStream[i]);
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::MarkForDelete()
{
	m_markedforDelete = TRUE;
	if(eDisconnecting == m_status || eDisconnected == m_status)
		m_sendDataBeforeDeleted = eSendNotifyBeforeDelete;
	
	if(eDisconnected == m_status) 
		SetPartyStatus(PARTY_DELETED_BY_OPERATOR, STATUS_PARTY_NONE);
}

/////////////////////////////////////////////////////////////////////////////
BYTE CCXUserType::IsMarkedForDelete()
{
	return m_markedforDelete;
}

/////////////////////////////////////////////////////////////////////////////
BYTE CCXUserType::CanDelParty()
{
	BYTE result = FALSE;
	
	if(!m_markedforDelete)
	{
		switch(m_status)
		{
			case(ePending):
			case(eBlocked):
			case(eRemoved):
			{
				result = TRUE;
				break;
			}
			case(eCalling):
			case(eRinging):
			case(eOnHold):
			case(eConnected):
			case(eDisconnecting):
			{
				result = FALSE;
				break;
			}
			default:
				// Note: some enumeration value are not handled in switch. Add default to suppress warning.
				break;
		}
		if((eDisconnected == m_status || eRemoved == m_status) &&  eSendNotifyBeforeDelete != m_sendDataBeforeDeleted)
			result = TRUE;
	}
	else
		if(eNotifyWasSent == m_sendDataBeforeDeleted)
			result = TRUE;

	return result;
}

/////////////////////////////////////////////////////////////////////////////
DWORD CCXUserType::GetUserId()
{
	return m_userId;
}

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::SetDisplayName(char* name)
{
	if(name)
	{
		m_displayName = name;
		UPDATE_STATE;
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::SetDisplayPhoneNumber(char* num)
{
	if(num)
	{
		m_displayPhoneNumber = num;
		UPDATE_STATE;
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::SetSipUri(char* sipUri)
{
	m_isSip = TRUE;
	if(sipUri)
	{
		m_sipUri = sipUri;
		UPDATE_STATE;
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::SetAdministrator(BYTE onOff)
{
	if(onOff)
		m_role = eAdministrator;
	else
		m_role = eParticipant;
	UPDATE_STATE;
}

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::SetPartyStatus(DWORD status, DWORD attendedStatus)
{
	switch(status)
	{
		case(PARTY_IDLE):
		case(PARTY_STAND_BY):
		case(PARTY_WAITING_FOR_DIAL_IN):
			m_status = ePending;
			break;
		case(PARTY_CONNECTING):
		case(PARTY_REDIALING):
			m_status = eCalling;
			break;
		case(PARTY_CONNECTED):
		case(PARTY_CONNECTED_PARTIALY):
		case(PARTY_SECONDARY):
		case(PARTY_CONNECTED_WITH_PROBLEM):
			m_status = eConnected;
			break;
		case(PARTY_DISCONNECTING):
			m_status = eDisconnecting;
			break;
		case(PARTY_DISCONNECTED):
			m_status = eDisconnected;
			break;
		case(PARTY_DELETED_BY_OPERATOR):
			m_status = eRemoved;
			break;
	}
	
	if(eDisconnecting == m_status || eRemoved == m_status)
		m_sendDataBeforeDeleted = eSendNotifyBeforeDelete;

/*	if(STATUS_PARTY_ONHOLD == attendedStatus && eConnected == m_status)
		m_status = eOnHold;*/ //************
	UPDATE_STATE;
}

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::SetDialOutParty()
{
	m_joinMode = eDialedOut;
	UPDATE_STATE;
}

/////////////////////////////////////////////////////////////////////////////
BYTE CCXUserType::SetDisconnectReason(DWORD reason)
{
	BYTE result = FALSE;
	switch(reason)
	{
		case(NO_DISCONNECTION_CAUSE):
			m_disconnectReason = eNotDisconnected;
			break;
		case(PARTY_HANG_UP):
			m_disconnectReason = eDeparted;
			break;
		case(DISCONNECTED_BY_OPERATOR):
		case(DISCONNECTED_BY_CHAIR):
			m_disconnectReason = eBooted;
			break;
		default:
			m_disconnectReason = eFailed;
			break;
	}
	if(m_status == eDisconnecting || m_status == eDisconnected || eRemoved == m_status)
	{
		result = TRUE;
		UPDATE_STATE;
	}
	return result;
}

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::SetActiveSpeaker(BYTE onOff)
{
	m_activelyTalking = onOff;
	UPDATE_STATE;
}

/////////////////////////////////////////////////////////////////////////////
BYTE CCXUserType::GetActiveSpeaker()
{
	return m_activelyTalking;
}

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::SetUriAttribute(char* uri)
{
	if(uri)
	{
		m_uriAttribute = uri;
		UPDATE_STATE;
	}
}


/////////////////////////////////////////////////////////////////////////////
const char* CCXUserType::GetDisplayName() const 
{
	return m_displayName.GetString();
}

/////////////////////////////////////////////////////////////////////////////
char* CCXUserType::GetPartyRole() const
{
	switch(m_role)
	{
		case(eAdministrator):
			return "administrator";

		case(eChair):
			return "chair";
			
		case(eParticipant):
		default:
			return "participant";
			
	}
}

/////////////////////////////////////////////////////////////////////////////
char* CCXUserType::GetPartyStatus() const
{
	switch(m_status)
	{
		case(ePending):
			return "pending";

		case(eCalling):
			return "calling";

		case(eRinging):
			return "ringing";

		case(eOnHold):
			return "on-hold";

		case(eConnected):
			return "connected";

		case(eDisconnecting):
			return "disconnecting";

		case(eDisconnected):
			return "disconnected";

		case(eBlocked):
			return "blocked";

		case(eRemoved):
			return "removed";

		default:
			return "unknown";		
	}
}

/////////////////////////////////////////////////////////////////////////////
char* CCXUserType::GetPartyJoinMode() const
{
	switch(m_joinMode)
	{
		case(eDialedIn):
			return "dialed-in";

		case(eDialedOut):
			return "dialed-out";

		default:
			return "unknown";
	}
}

/////////////////////////////////////////////////////////////////////////////
char* CCXUserType::GetPartyDisconnectReason() const
{
	switch(m_disconnectReason)
	{
	case(eDeparted):
			return "departed";

		case(eBooted):
			return "booted";

		case(eFailed):
			return "failed";

		case(eBusy):
			return "busy";

		default:
			return "unknown";
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::MuteMedia(eMediaContentType mediaType, BYTE onOff)
{
	for(int i=0; i<MEDIA_STREAMS; i++)
	{
		if(m_pMediaStream[i])
			if(m_pMediaStream[i]->GetContent() == mediaType && onOff != m_pMediaStream[i]->IsMuted())
			{
				m_pMediaStream[i]->MuteMedia(onOff);
				UPDATE_STATE;
				break;
			}
	}

	//if muted Audio, set active speaker to false
	if(onOff && eAudio == mediaType)
		SetActiveSpeaker(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
BYTE CCXUserType::IsMediaMuted(eMediaContentType mediaType)
{
	BYTE result = FALSE;
	for(int i=0; i<MEDIA_STREAMS; i++)
	{
		if(m_pMediaStream[i])
			if(m_pMediaStream[i]->GetContent() == mediaType)
			{
				result = m_pMediaStream[i]->IsMuted();
				break;
			}
	}
	return result;
}

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::SerializeXml(CXMLDOMElement* pFatherNode, BYTE bFull)
{
	SerializeXml(pFatherNode, bFull, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
void CCXUserType::SerializeXml(CXMLDOMElement* pFatherNode, BYTE bFull, BYTE bIsNewSubscriber)
{
	CXMLDOMElement*  pFeatureNode = NULL;

	if(bIsNewSubscriber && eSendNotifyBeforeDelete == m_sendDataBeforeDeleted && (eDisconnected == m_status ||  eRemoved == m_status))
	{
		PTRACE(eLevelInfoNormal, "CCXUserType::SerializeXml, not serializing data about disconnected party");
		return;
	}

	//Full data
	if(bFull || eFullData == m_state)
	{
		PTRACE2(eLevelInfoNormal, "CCXUserType::SerializeXml, Full user data, user = ", m_displayName.GetString());
		pFeatureNode = pFatherNode->AddChildNode(m_elementName);
		
		pFeatureNode->AddChildNode("display-name", m_displayName);
		if(strcmp(m_displayPhoneNumber.GetString(), ""))
			pFeatureNode->AddChildNode("display-phone-number", m_displayPhoneNumber);
		
		if(m_isSip)
		{
			//if user was referred from msft oc, sip-capable=false
			if(strstr(m_uriAttribute.GetString(),";user=") && !m_isCallBack)
				pFeatureNode->AddChildNode("sip-capable", "false");
			else
				if(strstr(m_uriAttribute.GetString(),";user=phone") && m_isCallBack)
					pFeatureNode->AddChildNode("sip-capable", "false");
				else
					pFeatureNode->AddChildNode("sip-capable", "true");
			pFeatureNode->AddChildNode("associated-sip-uri", m_sipUri);
		}
		else
		{
			//if user was referred from msft oc, sip-capable=true
			if(strstr(m_uriAttribute.GetString(),";user=phone") && m_isCallBack)
				pFeatureNode->AddChildNode("sip-capable", "false");
			else
			{
				if(strstr(m_uriAttribute.GetString(),";user=") && m_isCallBack)
					pFeatureNode->AddChildNode("sip-capable", "true");
				else
					pFeatureNode->AddChildNode("sip-capable", "false");
			}
			pFeatureNode->AddChildNode("associated-sip-uri", m_sipUri);
		}
		
		pFeatureNode->AddChildNode("role", GetPartyRole());
		pFeatureNode->AddChildNode("status", GetPartyStatus());
		pFeatureNode->AddChildNode("join-mode", GetPartyJoinMode());
		
		//Notify about disconnection status only if regular status is disconnection
		if(eNotDisconnected != m_disconnectReason)
			if(eDisconnecting == m_status || eDisconnected == m_status || eRemoved == m_status)
				pFeatureNode->AddChildNode("disconnect-reason", GetPartyDisconnectReason());
		
		if(m_activelyTalking)
			pFeatureNode->AddChildNode("actively-talking", "true");
		else
			pFeatureNode->AddChildNode("actively-talking", "false");
		
		for(int i=0; i<MEDIA_STREAMS; i++)
		{
			if(m_pMediaStream[i])
				m_pMediaStream[i]->SerializeXml(pFeatureNode, bFull);
		}
		
		CXMLDOMAttribute* pUriAttribute = new CXMLDOMAttribute();
		pUriAttribute->set_nodeName("uri");
		pUriAttribute->SetValueForElement(m_uriAttribute.GetString());
		pFeatureNode->AddAttribute(pUriAttribute);
	}
	else 
	{
		//Only delta
		if(ePartialData == m_state)
		{
			PTRACE2(eLevelInfoNormal, "CCXUserType::SerializeXml, Partial user data, user = ", m_displayName.GetString());
			pFeatureNode = pFatherNode->AddChildNode(m_elementName);
			if(m_isSip)
			{
				//if user was referred from msft oc, sip-capable=false
				if(strstr(m_uriAttribute.GetString(),";user=") && !m_isCallBack)
					pFeatureNode->AddChildNode("sip-capable", "false");
				else
					if(strstr(m_uriAttribute.GetString(),";user=phone") && m_isCallBack)
						pFeatureNode->AddChildNode("sip-capable", "false");
					else
						pFeatureNode->AddChildNode("sip-capable", "true");
					pFeatureNode->AddChildNode("associated-sip-uri", m_sipUri);
			}
			else
			{
				//if user was referred from msft oc, sip-capable=true
				if(strstr(m_uriAttribute.GetString(),";user=phone") && m_isCallBack)
					pFeatureNode->AddChildNode("sip-capable", "false");
				else
				{
					if(strstr(m_uriAttribute.GetString(),";user=") && m_isCallBack)
						pFeatureNode->AddChildNode("sip-capable", "true");
					else
						pFeatureNode->AddChildNode("sip-capable", "false");
				}
				pFeatureNode->AddChildNode("associated-sip-uri", m_sipUri);
			}
			pFeatureNode->AddChildNode("role", GetPartyRole());
			pFeatureNode->AddChildNode("status", GetPartyStatus());
			if(eNotDisconnected != m_disconnectReason)
				pFeatureNode->AddChildNode("disconnect-reason", GetPartyDisconnectReason());
			if(m_activelyTalking)
				pFeatureNode->AddChildNode("actively-talking", "true");
			else
				pFeatureNode->AddChildNode("actively-talking", "false");
			
			for(int i=0; i<MEDIA_STREAMS; i++)
			{
				if(m_pMediaStream[i])
					m_pMediaStream[i]->SerializeXml(pFeatureNode, bFull);
			}
			
			CXMLDOMAttribute* pUriAttribute = new CXMLDOMAttribute();
			pUriAttribute->set_nodeName("uri");
			pUriAttribute->SetValueForElement(m_uriAttribute.GetString());
			pFeatureNode->AddAttribute(pUriAttribute);
		}
	}

	SerializeState(pFeatureNode, bFull);

	if(eSendNotifyBeforeDelete == m_sendDataBeforeDeleted && (eDisconnected == m_status || eRemoved == m_status))
	{
		PTRACE(eLevelInfoNormal, "CCXUserType::SerializeXml, user marked as 'eNotifyWasSent'.");
		m_sendDataBeforeDeleted = eNotifyWasSent;
	}
}

// ************************************************************************************
//
//	CCXMediaType
//
// ************************************************************************************

/////////////////////////////////////////////////////////////////////////////
CCXMediaType::CCXMediaType() : CConfPackageType("media-stream"), m_MediaContent(eVoip)
{
	m_pReceiveState = new CCXMediaStateType(TRUE); //muted
}

/////////////////////////////////////////////////////////////////////////////
CCXMediaType::CCXMediaType(eMediaContentType mediaType) : CConfPackageType("media-stream"), m_MediaContent(mediaType)
{
	m_pReceiveState = new CCXMediaStateType(); //not muted
}

/////////////////////////////////////////////////////////////////////////////
CCXMediaType::~CCXMediaType()
{
	POBJDELETE(m_pReceiveState);
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CCXMediaType::SerializeXml(CXMLDOMElement* pFatherNode, BYTE bFull)
{
	CXMLDOMElement*  pFeatureNode = NULL;

	if(bFull || eNoChange != m_state)
	{
		pFeatureNode = pFatherNode->AddChildNode(m_elementName);
		
		CXMLDOMAttribute* pAttribute = new CXMLDOMAttribute();
		pAttribute->set_nodeName("content");
		pAttribute->SetValueForElement(GetContentAsString());
		pFeatureNode->AddAttribute(pAttribute);
		
		m_pReceiveState->SerializeXml(pFeatureNode);
	}
	m_state = eNoChange;
}	

/////////////////////////////////////////////////////////////////////////////
eMediaContentType CCXMediaType::GetContent()
{
	return m_MediaContent;
}

/////////////////////////////////////////////////////////////////////////////
const char* CCXMediaType::GetContentAsString()
{
	switch(m_MediaContent)
	{
		case(eVoip):
			return "voip";
			
		case(eVideoT):
			return "video";

		case(eData):
			return "data";

		case(eAudio):
		default:
			return "audio";
	}
}

/////////////////////////////////////////////////////////////////////////////
void CCXMediaType::MuteMedia(BYTE onOff)
{
	m_pReceiveState->SetMute(onOff);
	UPDATE_STATE;
}

/////////////////////////////////////////////////////////////////////////////
BYTE CCXMediaType::IsMuted()
{
	return m_pReceiveState->IsMuted();
}


// ************************************************************************************
//
//	CCXMediaStateType
//
// ************************************************************************************

/////////////////////////////////////////////////////////////////////////////
CCXMediaStateType::CCXMediaStateType() : CBasicConfPackageType("receive-state"), m_bMuteAttribute(FALSE)
{
}

/////////////////////////////////////////////////////////////////////////////
CCXMediaStateType::CCXMediaStateType(BYTE onOff) : CBasicConfPackageType("receive-state"), m_bMuteAttribute(onOff)
{
}

/////////////////////////////////////////////////////////////////////////////
CCXMediaStateType::~CCXMediaStateType()
{
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CCXMediaStateType::SetMute(BYTE onOff)
{
	m_bMuteAttribute = onOff;
}

/////////////////////////////////////////////////////////////////////////////
BYTE CCXMediaStateType::IsMuted()
{
	return m_bMuteAttribute;
}

/////////////////////////////////////////////////////////////////////////////
void CCXMediaStateType::SerializeXml(CXMLDOMElement* pFatherNode)
{
	CXMLDOMElement*  pFeatureNode = NULL;
	pFeatureNode = pFatherNode->AddChildNode(m_elementName);

	CXMLDOMAttribute* pAttribute = new CXMLDOMAttribute();
	pAttribute->set_nodeName("muted");

	if(m_bMuteAttribute)
		pAttribute->SetValueForElement("true");
	else
		pAttribute->SetValueForElement("false");

	pFeatureNode->AddAttribute(pAttribute);
}	


// ************************************************************************************
//
//	CCXInitialState
//
// ************************************************************************************

/////////////////////////////////////////////////////////////////////////////
CCXInitialState::CCXInitialState() : CBasicConfPackageType("initial-state"), m_role(eParticipant), 
									m_joinType(eDialedIn), m_rejoinType(eDialedIn), m_bMute(FALSE)
{
}

/////////////////////////////////////////////////////////////////////////////
CCXInitialState::~CCXInitialState()
{
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CCXInitialState::SetMute(BYTE onOff)
{
	m_bMute = onOff;
}

/////////////////////////////////////////////////////////////////////////////
void CCXInitialState::SetAdmin()
{
	m_role = eAdministrator;
}

/////////////////////////////////////////////////////////////////////////////
void CCXInitialState::SetJoinAsDialOut()
{
	m_joinType = eDialedOut;
}

/////////////////////////////////////////////////////////////////////////////
void CCXInitialState::SetRejoinAsDialOut()
{
	m_rejoinType = eDialedOut;
}

/////////////////////////////////////////////////////////////////////////////
const char* CCXInitialState::GetRole()
{
	if(eAdministrator == m_role)
		return "administrator";
	else
	{
		if(eChair == m_role)
			return "chair";
		else
			return "participant";
	}
}

/////////////////////////////////////////////////////////////////////////////
const char* CCXInitialState::GetJoinType()
{
	if(eDialedOut == m_joinType)
		return "dialed-out";
	else
		return "dialed-in";
}

/////////////////////////////////////////////////////////////////////////////
const char* CCXInitialState::GetRejoinType()
{
	if(eDialedOut == m_rejoinType)
		return "dialed-out";
	else
		return "dialed-in";
}

/////////////////////////////////////////////////////////////////////////////
void CCXInitialState::SerializeXml(CXMLDOMElement* pFatherNode)
{
	CXMLDOMElement  *pFeatureNode = NULL, *pSubNode = NULL, *pMediaNode = NULL;
	pFeatureNode = pFatherNode->AddChildNode(m_elementName);
	pSubNode = pFeatureNode->AddChildNode("role", GetRole());
	pSubNode = pFeatureNode->AddChildNode("joined", GetJoinType());
	pSubNode = pFeatureNode->AddChildNode("rejoined", GetRejoinType());
	pSubNode = pFeatureNode->AddChildNode("media");
	pMediaNode = pSubNode->AddChildNode("audio");

	if(m_bMute)
		pMediaNode->AddChildNode("receive-muted", "true");
	else
		pMediaNode->AddChildNode("receive-muted", "false");
}	

// ************************************************************************************
//
//	CCXPropertiesType
//
// ************************************************************************************

/////////////////////////////////////////////////////////////////////////////
CCXPropertiesType::CCXPropertiesType() : CConfPackageType("properties"), m_bActive(FALSE), m_bLocked(FALSE),
									m_bRollCall(FALSE), m_bAnnouncement(FALSE), m_bRecorded(FALSE)
{
	for(int i=0; i<MEDIA_STREAMS; i++)
		m_pMediaStream[i] = NULL;
	m_pInitialState = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CCXPropertiesType::CCXPropertiesType(CCommConf* pCommConf) : CConfPackageType("properties"), m_bAnnouncement(FALSE), m_bRecorded(FALSE)
{
	if(pCommConf->GetConnectedPartiesNumber() > 0)
		m_bActive = TRUE;
	else
		m_bActive = FALSE;
	m_bLocked = pCommConf->GetConfLockFlag();
	m_bRollCall = pCommConf->IsRollCall();
	m_pMediaStream[0] = new CCXMediaType(eAudio);
	m_pMediaStream[1] = new CCXMediaType(eVoip);
	
	int i = 2;
	if(!pCommConf->IsAudioConf())
	{
		m_pMediaStream[i] = new CCXMediaType(eVideoT);
		i++;
	}
/****	if(0 != pCommConf->GetT120Rate())
		m_pMediaStream[i] = new CCXMediaType(eData);*/  m_pMediaStream[i] = NULL;

	m_pInitialState = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CCXPropertiesType::~CCXPropertiesType()
{
	for(int i=0; i<MEDIA_STREAMS; i++)
		POBJDELETE(m_pMediaStream[i]);
	POBJDELETE(m_pInitialState);
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CCXPropertiesType::SerializeXml(CXMLDOMElement* pFatherNode, BYTE bFull)
{
	CXMLDOMElement  *pFeatureNode = NULL, *pSubNode = NULL, *pMediaNode = NULL;

	if(bFull || eNoChange != m_state)
	{
		pFeatureNode = pFatherNode->AddChildNode(m_elementName);
		
		if(m_bActive)
			pSubNode = pFeatureNode->AddChildNode("active", "true");
		else
			pSubNode = pFeatureNode->AddChildNode("active", "false");
		
		if(m_bLocked)
			pSubNode = pFeatureNode->AddChildNode("locked", "true");
		else
			pSubNode = pFeatureNode->AddChildNode("locked", "false");
		
		for(int i=0; i<MEDIA_STREAMS; i++)
			if(IsValidPObjectPtr(m_pMediaStream[i]))
				m_pMediaStream[i]->SerializeXml(pFeatureNode, bFull);
		if(bFull)
			if(IsValidPObjectPtr(m_pInitialState))
				m_pInitialState->SerializeXml(pFeatureNode);
		
		
		if(m_bRollCall)
			pSubNode = pFeatureNode->AddChildNode("record-names", "true");
		else
			pSubNode = pFeatureNode->AddChildNode("record-names", "false");
		
		if(m_bAnnouncement)
			pSubNode = pFeatureNode->AddChildNode("announcements", "true");
		else
			pSubNode = pFeatureNode->AddChildNode("announcements", "false");
		
		if(m_bRecorded)
			pSubNode = pFeatureNode->AddChildNode("record-content", "true");
		else
			pSubNode = pFeatureNode->AddChildNode("record-content", "false");
	}
	
	m_state = eNoChange;
}

/////////////////////////////////////////////////////////////////////////////
void CCXPropertiesType::SetActive(BYTE onOff) 
{
	m_bActive = onOff;
	UPDATE_STATE;
}

/////////////////////////////////////////////////////////////////////////////
BYTE CCXPropertiesType::GetActive() 
{
	return m_bActive;
}

/////////////////////////////////////////////////////////////////////////////
void CCXPropertiesType::SetLocked(BYTE onOff)
{
	m_bLocked = onOff;
	UPDATE_STATE;
}

/////////////////////////////////////////////////////////////////////////////
BYTE CCXPropertiesType::GetLocked()
{
	return m_bLocked;
}

/////////////////////////////////////////////////////////////////////////////
void CCXPropertiesType::SetRollCall(BYTE onOff)
{
	m_bRollCall = onOff;
}

/////////////////////////////////////////////////////////////////////////////
void CCXPropertiesType::SetAnnouncements(BYTE onOff)
{
	m_bAnnouncement = onOff;
	UPDATE_STATE;
}

/////////////////////////////////////////////////////////////////////////////
void CCXPropertiesType::SetRecorded(BYTE onOff)
{
	m_bRecorded = onOff;
	UPDATE_STATE;
}



/////////////////////////////////////////////////////////////////////////////
WORD operator==(const CCXUserType& first,const CCXUserType& second)
{
	WORD    rval = 0;     
    
	if ( first.m_userId == second.m_userId)
		rval = 1;   

	return rval;
}

#endif
