//=================================================================================================
//
//Copyright (C) 2000 ACCORD Networks Ltd.
//This file contains confidential information proprietary to ACCORD Networks Ltd. The use or
//disclosure of any information contained in this file without the written consent of an officer of
//ACCORD Networks Ltd. is expressly forbidden.
//
//=================================================================================================
//
//Module Name:    ConfPartiesDialingSequence.cpp
//
//General Description:
//
//    1.	This module containes a small db of conference parties, which all party has instance for every valid interface type (H323 / SIP / ISDN )
//    2.	For use in GW sessions
//
//Generated By: Eitan                          Date: 25.03.09
//
//Revisions and Updates:
//
//Date         Updated By         Description
//========   ==============   =====================================================================
//
//=================================================================================================

#include "ConfPartiesDialingSequence.h"
#include "ApiStatuses.h"
#include "StatusesGeneral.h"
#include "RsrvParty.h"
#include "Segment.h"
#include "ProcessBase.h"
#include "ObjString.h"
#include "NStream.h"


////////////////////////////////////////////////////////////////////////////
//                        CTokenUser
////////////////////////////////////////////////////////////////////////////
CConfPartiesDialingSequence::CConfPartiesDialingSequence()
{
	m_pSequenceDialMap = new SEQUENCE_DIAL_MAP_PER_CONF;
}

////////////////////////////////////////////////////////////////////////////
CConfPartiesDialingSequence::~CConfPartiesDialingSequence()
{
	SEQUENCE_DIAL_MAP_PER_CONF::iterator it;
	for (it = m_pSequenceDialMap->begin(); it != m_pSequenceDialMap->end(); ++it)
	{
		PARTY_SEQUENCE_LIST* list = it->second;
		PARTY_SEQUENCE_LIST::iterator listIterator;
		for (listIterator = list->begin(); listIterator != list->end(); ++listIterator)
		{
			POBJDELETE(*listIterator);
		}

		list->clear();
		POBJDELETE(list);
	}
	m_pSequenceDialMap->clear();

	delete m_pSequenceDialMap;
}

////////////////////////////////////////////////////////////////////////////
const char* CConfPartiesDialingSequence::NameOf() const
{
	return "CConfPartiesDialingSequence";
}

////////////////////////////////////////////////////////////////////////////
void CConfPartiesDialingSequence::Serialize(CSegment &seg)
{
	COstrStream pOstr;
	Serialize(pOstr);
	pOstr.Serialize(seg);
}

////////////////////////////////////////////////////////////////////////////
void CConfPartiesDialingSequence::Serialize(std::ostringstream &ostr)
{

	SEQUENCE_DIAL_MAP_PER_CONF::iterator it;
	ostr << (DWORD)m_pSequenceDialMap->size() << "\n";
	for (it = m_pSequenceDialMap->begin(); it != m_pSequenceDialMap->end(); ++it)
	{
		ostr << (DWORD)it->first << "\n";
		PARTY_SEQUENCE_LIST* list = it->second;
		ostr << (DWORD)list->size() << "\n";
		PARTY_SEQUENCE_LIST::iterator listIterator;
		for (listIterator = list->begin(); listIterator != list->end(); ++listIterator)
		{
			CRsrvParty* tmpRsrvParty = *listIterator;
			tmpRsrvParty->Serialize(NATIVE, ostr);
		}
	}
}

////////////////////////////////////////////////////////////////////////////
void CConfPartiesDialingSequence::DeSerialize(CSegment &seg)
{
	CIstrStream istr(seg);
	DeSerialize(istr);
}

////////////////////////////////////////////////////////////////////////////
void CConfPartiesDialingSequence::DeSerialize(std::istringstream &istr)
{
	//PTRACE2(eLevelInfoNormal,"CConfPartiesDialingSequence::DeSerialize",istr.str().c_str());

	DWORD sizeOfMap = 0;
	DWORD sizeOfList = 0;
	DWORD tempPartyId = 0;

	istr >> sizeOfMap;
	for (DWORD i = 0; i < sizeOfMap; i++)
	{
		istr >> tempPartyId;
		istr >> sizeOfList;
		PARTY_SEQUENCE_LIST* listTemp = new PARTY_SEQUENCE_LIST;

		for (DWORD j = 0; j < sizeOfList; j++)
		{
			istr.ignore(1);
			CRsrvParty* tmpRsrvParty = new CRsrvParty;

			tmpRsrvParty->DeSerialize(NATIVE, istr);
			CLargeString cstr;
			cstr << "deserializing party: " << j + 1 << "\n";
			DumpPartyDetailesToTrace(tmpRsrvParty, cstr);
			PTRACE(eLevelInfoNormal, cstr.GetString());
			listTemp->push_back(tmpRsrvParty);
		}
		m_pSequenceDialMap->insert(SEQUENCE_DIAL_MAP_PER_CONF::value_type(tempPartyId, listTemp));
	}
}

////////////////////////////////////////////////////////////////////////////
void CConfPartiesDialingSequence::DumpToTrace(CObjString& cstr)
{
	SEQUENCE_DIAL_MAP_PER_CONF::iterator it;
	int i, j;

	for (it = m_pSequenceDialMap->begin(), i = 0; it != m_pSequenceDialMap->end(); ++it, i++)
	{
		cstr << i << ")	   Party ID:" << it->first << "\t";
		PARTY_SEQUENCE_LIST* list = it->second;
		PARTY_SEQUENCE_LIST::iterator listIterator;
		for (listIterator = list->begin(), j = 0; listIterator != list->end(); ++listIterator, j++)
		{
			CLargeString cstr1;
			cstr1 << "[" << j << "]";
			CRsrvParty* pTmpParty = *listIterator;
			DumpPartyDetailesToTrace(pTmpParty, cstr1);
			cstr << cstr1 << " ; ";
			cstr1.Clear();
		}
		cstr << "\n";
	}
}

////////////////////////////////////////////////////////////////////////////
void CConfPartiesDialingSequence::DumpPartyDetailesToTrace(CRsrvParty* pRsrvParty, CLargeString& cstr)
{
	cstr << "PartyName:" << pRsrvParty->GetName() << ", PartyType:";

	char ipAdrStr[20];
	memset(ipAdrStr, 0, sizeof(ipAdrStr));

	switch (pRsrvParty->GetNetInterfaceType())
	{
		case H323_INTERFACE_TYPE:
		{
			ipToString(pRsrvParty->GetIpAddress(), ipAdrStr, 0);
			cstr << "H323" << ", Ip:" << ipAdrStr << ", Alias:" << pRsrvParty->GetH323PartyAlias();
			break;
		}
		case SIP_INTERFACE_TYPE:
		{
			ipToString(pRsrvParty->GetIpAddress(), ipAdrStr, 0);
			cstr << "SIP" << ", Ip:" << ipAdrStr << ", Alias:" << pRsrvParty->GetSipPartyAddress();
			break;
		}
		case ISDN_INTERFACE_TYPE:
		{
			if (pRsrvParty->GetVoice())
			{
				cstr << "PSTN";
			}
			else
			{
				cstr << "ISDN";
			}
			cstr << ", PhoneNumber:" << pRsrvParty->GetPhoneNumber();
			break;
		}
		default:
		{
			cstr << pRsrvParty->GetNetInterfaceType() << " - Failed, invalid interface type";
			break;
		}
	}
}

////////////////////////////////////////////////////////////////////////////
void CConfPartiesDialingSequence::AddPartyListToMap(PartyMonitorID partyId, PARTY_SEQUENCE_LIST* seqList)
{
	m_pSequenceDialMap->insert(SEQUENCE_DIAL_MAP_PER_CONF::value_type(partyId, seqList));
}

////////////////////////////////////////////////////////////////////////////
CRsrvParty* CConfPartiesDialingSequence::GetNextParty(PartyMonitorID partyId)
{
	CRsrvParty* res = NULL;
	SEQUENCE_DIAL_MAP_PER_CONF::iterator it = m_pSequenceDialMap->find(partyId);

	if (it != m_pSequenceDialMap->end())
	{
		PARTY_SEQUENCE_LIST* list = it->second;
		if (list && list->size() > 0)
		{
			res = list->front();
			list->pop_front();
		}
	}
	return res;
}

////////////////////////////////////////////////////////////////////////////
PARTY_SEQUENCE_LIST* CConfPartiesDialingSequence::GetListForParty(PartyMonitorID  partyId)
{
	SEQUENCE_DIAL_MAP_PER_CONF::iterator it = m_pSequenceDialMap->find(partyId);
	if (it != m_pSequenceDialMap->end())
	{
		PARTY_SEQUENCE_LIST* list = it->second;
		return list;
	}
	return NULL;
}

////////////////////////////////////////////////////////////////////////////
void CConfPartiesDialingSequence::RemoveMapEntry(PartyMonitorID partyId)
{
	SEQUENCE_DIAL_MAP_PER_CONF::iterator it = m_pSequenceDialMap->find(partyId);

	if (it != m_pSequenceDialMap->end())
	{
		PARTY_SEQUENCE_LIST* list = it->second;
		PARTY_SEQUENCE_LIST::iterator listIterator = list->begin();
		while (listIterator != list->end())
		{
			CRsrvParty* pRemovedParty = (*listIterator);
			list->erase(listIterator);
			POBJDELETE(pRemovedParty);
			listIterator =  list->begin();
		}

		PDELETE(list);
		m_pSequenceDialMap->erase(it);
	}
}

////////////////////////////////////////////////////////////////////////////
bool CConfPartiesDialingSequence::IsMemberInSequence(PartyMonitorID partyId)
{
	SEQUENCE_DIAL_MAP_PER_CONF::iterator it = m_pSequenceDialMap->find(partyId);
	return (it != m_pSequenceDialMap->end()) ? true : false;
}

////////////////////////////////////////////////////////////////////////////
void CConfPartiesDialingSequence::SetVoice(const BYTE btVoice, BOOL isPstnAllowed)
{
	SEQUENCE_DIAL_MAP_PER_CONF::iterator itEnd = m_pSequenceDialMap->end();
	for (SEQUENCE_DIAL_MAP_PER_CONF::iterator itMap = m_pSequenceDialMap->begin(); itMap != itEnd; ++itMap)
	{
		PARTY_SEQUENCE_LIST* pList = itMap->second;
		PARTY_SEQUENCE_LIST::iterator itListEnd = pList->end();
		for (PARTY_SEQUENCE_LIST::iterator itList = pList->begin(); itList != itListEnd; ++itList)
		{
            // BRIDGE-13471 - if PSTN is NOT Allowed set only SIP and H323 as voice
			if (FALSE == isPstnAllowed)
			{
				if ((*itList)->GetNetInterfaceType() != ISDN_INTERFACE_TYPE)
					(*itList)->SetVoice(btVoice);
				else
					PTRACE(eLevelInfoNormal, "dial out party will not set to Audio only since PSTN is disabled in GW Dial-out Protocols");	
			}
			else
			{
				(*itList)->SetVoice(btVoice);
			}
		}
	}
}
