//=================================================================================================
//
//Copyright (C) 2005 POLYCOM
//This file contains confidential information proprietary to ACCORD Networks Ltd. The use or 
//disclosure of any information contained in this file without the written consent of an officer of
//ACCORD Networks Ltd. is expressly forbidden.
//
//=================================================================================================

//=================================================================================================
//
//Module Name:  SIPREFER.CPP
//
//General Description:  
//
//    1.	control SIP conference package
//
//Generated By: Ori P.                            Date: 9.03.05
//
//Revisions and Updates: 
//
//Date         Updated By         Description
//========   ==============   =====================================================================
// 
//=================================================================================================


//===== Include Files =====
#include "SipRefer.h"
#include "ConfPartyDefines.h"
#include "StatusesGeneral.h"
#include "SystemFunctions.h"
#include "IpCommonDefinitions.h"
#include "IpCsOpcodes.h"
#include "ConfPartyManagerLocalApi.h"


#define TIMER_SUBSCRIBE_TOUT	100
#define TIMER_CONNECT_REFER		101
#define TIMER_NOTIFY_TOUT		102


#define	REFER_NOTIFY_TOUT		1*SECOND

// CSIPReferEventPackageManager states
const WORD   CONNECT        = 1;
const WORD	 TERMINATION	= 2;


// ************************************************************************************
//
//	CSIPREFERSubscriber
//
// ************************************************************************************

/////////////////////////////////////////////////////////////////////////////////////////
CSIPREFERSubscriber::CSIPREFERSubscriber()
{
	m_pReferTo = NULL;
	m_bReferWithBye = FALSE;
//	m_CallIndex = 0;
	m_ConnectRetry = TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
CSIPREFERSubscriber::CSIPREFERSubscriber(WORD boardId, const char* pFrom, const char* pFromTag, const char* pTo, const char* pToTag, const char* pCallId, DWORD CSeq, const char* pReferTo, BYTE bReferWithBye,
							   DWORD fromIp, WORD fromPort, WORD fromTransport, WORD expires, WORD srcUnitId, eRoleType role, DWORD callIndex,const char* pClickToConfIDStr/*const char* pMSConversationIDStr*/, DWORD cs_Id)
					:CSIPSubscriber(boardId, pFrom, pFromTag, pTo, pToTag, pCallId, fromIp, fromPort, fromTransport, expires, srcUnitId,callIndex, role,cs_Id)
{

	if(pReferTo)
	{
		m_pReferTo = new char[MaxAddressListSize];
		strncpy(m_pReferTo, pReferTo, MaxAddressListSize);
	}
	else
		m_pReferTo = NULL;
	
	/*if(pMSConversationIDStr)
	{
		m_pMSConversationIDStr = new char[H243_NAME_LEN];
		strncpy(m_pMSConversationIDStr, pMSConversationIDStr, H243_NAME_LEN);
	}
	else
		m_pMSConversationIDStr = NULL;
		*/
	 if(pClickToConfIDStr)
	{
		m_pClickToConfIDStr = new char[H243_NAME_LEN];
		strncpy(m_pClickToConfIDStr, pClickToConfIDStr, H243_NAME_LEN);
	}
	else
		m_pClickToConfIDStr = NULL;

	m_bReferWithBye = bReferWithBye;
	m_CSeq = CSeq;
//	m_CallIndex = callIndex;
	m_ConnectRetry = TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
CSIPREFERSubscriber::~CSIPREFERSubscriber()
{
	PDELETEA(m_pReferTo);
	PDELETEA(m_pClickToConfIDStr);
}

///////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
char* CSIPREFERSubscriber::GetReferTo()
{
	return m_pReferTo;
}

///////////////////////////////////////////////////////////////////
//char* CSIPREFERSubscriber::GetMSConversationID()
char* CSIPREFERSubscriber::GetClickToConfID()
{
	return m_pClickToConfIDStr;
}

///////////////////////////////////////////////////////////////////
BYTE CSIPREFERSubscriber::IsReferWithBye()
{
	return m_bReferWithBye;
}

///////////////////////////////////////////////////////////////////
DWORD CSIPREFERSubscriber::GetCSeq()
{
	return m_CSeq;
}

///////////////////////////////////////////////////////////////////
/*
DWORD CSIPREFERSubscriber::GetCallIndex()
{
	return m_CallIndex;
}
*/
///////////////////////////////////////////////////////////////////
BYTE CSIPREFERSubscriber::RetryConnect()
{
	BYTE result = FALSE;
	if(m_ConnectRetry)
	{
		result = TRUE;
		m_ConnectRetry = FALSE;
	}
	return result;
}

// ************************************************************************************
//
//	CSIPReferEventPackageManager
//
// ************************************************************************************

// start message map -------------------------------------------
PBEGIN_MESSAGE_MAP(CSIPReferEventPackageManager)

    // conf events
	ONEVENT(TIMER_SUBSCRIBE_TOUT	,CONNECT	,CSIPReferEventPackageManager::OnSubscribeTout)   
	ONEVENT(TIMER_CONNECT_REFER		,CONNECT	,CSIPReferEventPackageManager::OnConnectReferredPartyTout)   
	ONEVENT(TIMER_NOTIFY_TOUT		,CONNECT	,CSIPReferEventPackageManager::OnNotifyTimerTout)   
	
	
PEND_MESSAGE_MAP(CSIPReferEventPackageManager,CStateMachine);   
// end   message map -------------------------------------------

///////////////////////////////////////////////////////////////////
CSIPReferEventPackageManager::CSIPReferEventPackageManager(CSIPEventPackageDispatcher* pSIPDispatcher, COsQueue* pRcvMbx, CMplMcmsProtocol* pMplMcmsProtocol, 
												 CConfPartyManagerLocalApi* pConfPartyManagerApi, CConfApi* pConfApi)
						:CSIPEventPackageManager( pRcvMbx, pMplMcmsProtocol, pConfPartyManagerApi, pConfApi), m_countConnectRefer(0), m_pSIPDispatcher(pSIPDispatcher)
{
}

///////////////////////////////////////////////////////////////////
CSIPReferEventPackageManager::~CSIPReferEventPackageManager()
{
}

///////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////
void CSIPReferEventPackageManager::Refer(mcIndRefer* pReferInd, DWORD callIndex, WORD srcUnitId, eRoleType role, DWORD serviceId)
{
	PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::Refer");

	WORD	boardId = 1;
	enSipCodes	SipStatus=SipCodesBadRequest;
	BYTE		bValidReq=TRUE, acceptVerified=TRUE, bLooseProtocol=FALSE, bLooseMcuApi=FALSE, bReferWithBye=FALSE;
	char		*pFromStr=NULL, *pFromTagStr=NULL, *pToStr=NULL, *pToTagStr=NULL, *pCallIdStr=NULL, *pMSAssociatedStr=NULL, *pMSConversationIDStr=NULL, *pRefferedByStr=NULL;
	char		*pAcceptName=NULL;
	ALLOCBUFFER(pReferToStr, MaxAddressListSize);
	CCommConf*	pCommConf=NULL;
	CConfParty *pConfParty=NULL, *pReqParty=NULL, *pDestParty=NULL;
	CSIPREFERSubscriber* pSubscriber=NULL;
	
	CSipHeaderList *pTemp = new CSipHeaderList(pReferInd->sipHeaders);
	
	bValidReq = CheckRequestValidity(pReferInd, &SipStatus, &pReqParty, &pDestParty);
	
	ParseReferHeaders(pTemp, &pFromStr, &pFromTagStr, &pToStr, &pToTagStr, &pCallIdStr, &pRefferedByStr, &pMSAssociatedStr, &pMSConversationIDStr);
	
	if(bValidReq)
	{
		char *pConfName = new char [H243_NAME_LEN];
		
		if(strcmp(pToStr, ""))
		{
			char *temp = (char*)strstr(pToStr, "@");
			if(temp)
			{
				strncpy(pConfName, pToStr, temp - pToStr);
				pConfName[temp-pToStr] = '\0';
			}
		}
		//pCommConf = ::GetpConfDB()->GetCurrentConf(pConfName);
		pCommConf = ::GetpConfDB()->GetCurrentConfByNameOrByNumericId(pConfName);
		PDELETEA(pConfName);
		
		bReferWithBye = CheckIfReferWithBye(pTemp, NULL, pReferToStr);
		PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::Refer, referTo:", pReferToStr);

		if(!bReferWithBye)
		{
			if(IsValidPObjectPtr(pCommConf) && !IsValidPObjectPtr(pDestParty))
			{
				//if refer-to tel number
				
				char*	strAddressToDial= new char[MaxAddressListSize];
				BYTE	bIsTel			= 0; 
				int		interfaceType	= ParseAddress(pReferToStr,strAddressToDial,bIsTel);
				if (interfaceType != 0)
				{
					//*** Add referred party to conf ***
					CConfPartyManagerLocalApi* pDanApi = NULL;
					if(NULL == m_pConfPartyManagerApi)
					{
						const COsQueue * queue = CProcessBase::GetProcess()->GetOtherProcessQueue(eProcessConfParty,eManager);
						m_pConfPartyManagerApi = new CConfPartyManagerLocalApi;
						m_pConfPartyManagerApi->CreateOnlyApi(*queue);
						bLooseMcuApi = TRUE;
					}
				
//					WORD partyId = 0;
//					if(pReqParty)
//						partyId = (WORD)pReqParty->GetPartyId();
						
					/*if (interfaceType == SIP_INTERFACE_TYPE)
						m_pConfPartyManagerApi->CreateSipDialOutParty(pCommConf->GetConferenceId(), 0, strAddressToDial, boardId, pReferToStr, pMSAssociatedStr);
					else*/
					m_pConfPartyManagerApi->CreateDialOutParty(pCommConf->GetMonitorConfId(),0,interfaceType,strAddressToDial,bIsTel, pRefferedByStr, pReferToStr, pMSAssociatedStr);
				}
				else
				{
					SipStatus = SipCodesBadExtension;
					PTRACE2(eLevelError,"CSIPReferEventPackageManager::Refer: wrong address, check prefixes in system.cfg",pReferToStr);
				}
				PDELETEA(strAddressToDial); 
				
				if(bLooseMcuApi)
				{
					m_pConfPartyManagerApi->DestroyOnlyApi();
					POBJDELETE(m_pConfPartyManagerApi);
				}
			}
		}
		
		if(SipCodesBadExtension != SipStatus)
		{			
			//if party exists 
			pSubscriber = FindParty(pFromStr, pReferInd->remoteCseq, pCallIdStr);
			if(IsValidPObjectPtr(pSubscriber))
			{
				//unsubscribe
				/*if(0 == pReferInd->expires)
				{
					PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::Refer, unsubscribing party = ", pFromStr);
					m_pEventSubscribersList->remove(pSubscriber);
					SipStatus = SipCodesOk;
					POBJDELETE(pSubscriber);
				}
					//refresh expires Tout.
				else
				{
					char s[10];
					itoa(pSubscribeInd->expires, s, 10);
					PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::Refer, refreshing subscription, expires = ", s);
					pSubscriber->Refresh(pReferInd->remoteIp, pReferInd->remotePort, pReferInd->transportType, pReferInd->expires);
					SipStatus = SipCodesOk;
				}*/
			}
			//new subscriber
			else
			{	
				pSubscriber = new CSIPREFERSubscriber(boardId, pFromStr, pFromTagStr, pToStr, pToTagStr, pCallIdStr, pReferInd->remoteCseq, 
													pReferToStr, bReferWithBye, pReferInd->transportAddress.transAddr.addr.v4.ip, 
													pReferInd->transportAddress.transAddr.port, pReferInd->transportAddress.transAddr.transportType, 
													300, srcUnitId, role, /*0x00ff00ff*/callIndex, pMSConversationIDStr,serviceId);
				m_EventSubscribersList.push_back(pSubscriber);
				SipStatus = SipCodesAccepted; //SipCodesOk;
				PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::Refer, new subscriber party is added.");
			}
			//recalculate timer in case of: new subscribe, refresh, unsubscribe
			if(m_SubTimer)
				DeleteTimer(TIMER_SUBSCRIBE_TOUT);
			WORD duration = CalcTimer();
			if(duration > 0)
			{
				if(!m_runInTdd)
					StartTimer(TIMER_SUBSCRIBE_TOUT, SECOND * duration);
				m_SubTimer = TRUE;
			}
		}
	}
	else
		if(pFromStr)
			PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::Refer, Invalid request is rejected.");
		

	SendSipReferResponse(pReferInd, SipStatus, callIndex, srcUnitId, serviceId);
	if(/*SipCodesOk*/SipCodesAccepted == SipStatus)
	{
		//if(0==m_countConnectRefer && !m_runInTdd)
		if(!m_runInTdd)
			StartTimer(TIMER_CONNECT_REFER, 50);
		//m_countConnectRefer++;
	}
	
	POBJDELETE(pTemp);
	DEALLOCBUFFER(pReferToStr);
}

///////////////////////////////////////////////////////////////////
void CSIPReferEventPackageManager::ParseReferHeaders(CSipHeaderList *pTemp, char **pFromStr, char **pFromTagStr, char **pToStr, 
														char **pToTagStr, char **pCallIdStr, char **pRefferedByStr, 
														char **pMSAssociatedStr, char **pMSConversationIDStr)
{
	const CSipHeader* pFrom = pTemp->GetNextHeader(kFrom);
	if(pFrom)
		*pFromStr = (char *)pFrom->GetHeaderStr();
		
	const CSipHeader* pFromTag = pTemp->GetNextHeader(kFromTag);
	if(pFromTag)
		*pFromTagStr = (char *)pFromTag->GetHeaderStr();
	
	const CSipHeader* pTo = pTemp->GetNextHeader(kTo);
	if(pTo)
		*pToStr = (char *)pTo->GetHeaderStr();

	const CSipHeader* pToTag = pTemp->GetNextHeader(kToTag);
	if(pToTag)
		*pToTagStr = (char *)pToTag->GetHeaderStr();
	
	const CSipHeader* pCallId = pTemp->GetNextHeader(kCallId);
	if(pCallId)
		*pCallIdStr = (char *)pCallId->GetHeaderStr();

	char RefferedBy[] = "Referred-By";
	const CSipHeader* pRefferedBy = pTemp->GetNextPrivateOrProprietyHeader(kProprietyHeader, 11, RefferedBy);
	if(pRefferedBy)
	{
		*pRefferedByStr = (char *)pRefferedBy->GetHeaderStr();
		char* pTemp = (char*)strstr(*pRefferedByStr, "sip:");
		*pRefferedByStr =  pTemp;
		if( *pRefferedByStr )
		{
			pTemp = (char*)strstr(*pRefferedByStr, ">");
			if(pTemp)
				*pTemp = '\0';
		}
	}

	char MsAssociated[] = "ms-associated-sip-uri";
	const CSipHeader* pMSAssociatedHeader = pTemp->GetNextPrivateOrProprietyHeader(kProprietyHeader, 21, MsAssociated);
	if(pMSAssociatedHeader)
	{
		*pMSAssociatedStr = (char *)pMSAssociatedHeader->GetHeaderStr();
		*pMSAssociatedStr +=  23;	//Pass the header; hold only the value
	}

	char MsConversationId[] = "Ms-Conversation-ID:";
	const CSipHeader* pMsConversationIdHeader = pTemp->GetNextPrivateOrProprietyHeader(kProprietyHeader, 18, MsConversationId);
	if(pMsConversationIdHeader)
		*pMSConversationIDStr = (char *)pMsConversationIdHeader->GetHeaderStr();
}

///////////////////////////////////////////////////////////////////
int CSIPReferEventPackageManager::ParseAddress(const char* strAddress,/*out*/char* strParsedAddress,/*out*/BYTE& bIsTelephone) const
{
	int			interfaceType = SIP_INTERFACE_TYPE; //********NA;
	const char*	strUriEnd	= (char*)strstr(strAddress,";");
	const char* shtroodel = (char*)strstr(strAddress,"@");
	const char*	strUriStart = strAddress;

	if (strstr(strAddress, "tel:"))
	{
		strUriEnd		= shtroodel? shtroodel: strUriEnd;
		interfaceType	= ISDN_INTERFACE_TYPE;
		strUriStart		+=4;
		bIsTelephone	= YES;
	}
	else if(strstr(strAddress, "h323:"))
	{
		strUriEnd		= shtroodel? shtroodel: strUriEnd;
		strUriStart		+=5;
		interfaceType	= H323_INTERFACE_TYPE;
		bIsTelephone	= NO;
	}
	else 
	{
		if (strstr(strAddress, "sip:"))
			strUriStart+=4;
		
		if (strUriEnd && strstr(strUriEnd,";user=")) 
		{
			if (!strcmp(strUriEnd+6,"phone"))
			{
				int addrLen		= shtroodel - strUriStart;
/*				int digInPhone	= ::GetpSystemCfg()->GetSipNumOfDigitsInPhoneNumber();
				int digInPrefix = ::GetpSystemCfg()->GetSipNumOfDigitsInPrefix();

				if (digInPhone + digInPrefix == addrLen)
				{
					const char* isdnPrefix = ::GetpSystemCfg()->GetSipReferIsdnPrefix();
					const char* h323Prefix = ::GetpSystemCfg()->GetSipReferH323Prefix();
					const char* sipPrefix  = ::GetpSystemCfg()->GetSipReferPrefix();

					if (!strncmp(strUriStart,sipPrefix,digInPrefix))
					{
						strUriStart  += digInPrefix;
						interfaceType = SIP_INTERFACE_TYPE;
						bIsTelephone  = NO;
					}
					else
					{
						strUriEnd = shtroodel? shtroodel: strUriEnd;
						if (!strncmp(strUriStart,h323Prefix,digInPrefix))
						{
							strUriStart  += digInPrefix;
							interfaceType = H323_INTERFACE_TYPE;
							bIsTelephone  = NO;
						}
						else if (!strncmp(strUriStart,isdnPrefix,digInPrefix))
						{
							strUriStart  += digInPrefix;
							interfaceType = ISDN_INTERFACE_TYPE;
							bIsTelephone  = NO;
						}
					}
				}
				else if (addrLen <= digInPhone) // no prefix
				{
					strUriEnd = shtroodel? shtroodel: strUriEnd;
					interfaceType = ISDN_INTERFACE_TYPE;// default
					bIsTelephone  = YES;
				}
				else //wrong address len!
					DBGPASSERT(addrLen);*/
			}
			else if (!strcmp(strUriEnd+6,"sip"))
			{
				interfaceType = SIP_INTERFACE_TYPE;
				bIsTelephone  = NO;
			}
			else
			{
				//only if the address is sip we will leave the '@domain'
				strUriEnd = shtroodel? shtroodel: strUriEnd;

				if (!strcmp(strUriEnd+6,"h323"))
				{
					interfaceType = H323_INTERFACE_TYPE;
					bIsTelephone  = NO;
				}
				else if (!strcmp(strUriEnd+6,"isdn")) 
				{
					interfaceType = ISDN_INTERFACE_TYPE;
					bIsTelephone  = NO;
				}
				else
				{
					interfaceType = ISDN_INTERFACE_TYPE;// default
					bIsTelephone  = YES;
				}
			}
		}
		else // no user
		{
			interfaceType = SIP_INTERFACE_TYPE;
			bIsTelephone  = NO;
		}
	}

	if (interfaceType != NA)
	{
		int addrLen = strUriEnd? strUriEnd-strUriStart: MaxAddressListSize-1;
		strncpy(strParsedAddress,strUriStart,addrLen);
		strParsedAddress[addrLen] = 0;
	}
	return interfaceType;
}

///////////////////////////////////////////////////////////////////
void CSIPReferEventPackageManager::OnConnectReferredPartyTout(CSegment* pParam)
{	
	PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::OnConnectReferredPartyTout, conf=",m_pConfName);
	BYTE bLooseConfApi = FALSE;

	/*m_countConnectRefer--;
	if(0 != m_countConnectRefer && !m_runInTdd)
		StartTimer(TIMER_CONNECT_REFER, 50);*/
	
	std::vector< CSIPSubscriber * >::iterator itr =  m_EventSubscribersList.begin();
	while (itr != m_EventSubscribersList.end())
	{
		CSIPREFERSubscriber* pSubscriber = (CSIPREFERSubscriber*)(*itr);
		if(IsValidPObjectPtr(pSubscriber))
		{
			PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::OnConnectReferredPartyTout from:", pSubscriber->GetFrom());
			//verify conference exist
			//CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pConfName);
			CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConfByNameOrByNumericId(m_pConfName);
			if(IsValidPObjectPtr(pCommConf))
			{
				ALLOCBUFFER(referTo, MaxAddressListSize);
				CConfParty* pConfParty = FindReferedPartyInDB(referTo, pSubscriber);
				referTo[MaxAddressListSize - 1] = '\0';
				
				if(IsValidPObjectPtr(pConfParty))
				{
					if(STATUS_OK == pConfParty->AttachObserver(m_pRcvMbx, PARTYSTATE, SIP_REFER, (DWORD)pSubscriber))
					{
						pConfParty->SetReferredBy(pSubscriber->GetFrom());
						//check if self refer (OC flow)
						/****if(!strncmp(pSubscriber->GetFrom(), pSubscriber->GetReferTo(), IP_LIMIT_ADDRESS_CHAR_LEN))
							if(eAdministrator == pSubscriber->GetRole())	
								pConfParty->SetChair(TRUE);****/
						
						if(!m_pConfApi)
						{
							m_pConfApi = new CConfApi; 
							m_pConfApi->CreateOnlyApi(*pCommConf->GetRcvMbx());
							bLooseConfApi = TRUE;
						}
						if(pSubscriber->IsReferWithBye())
						{
							PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::OnConnectReferredPartyTout, disconnecting party:", pSubscriber->GetReferTo());
							m_pConfApi->DropParty(pConfParty->GetName(), 0, DISCONNECTED_BY_CHAIR);
						}
						else
						{
							PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::OnConnectReferredPartyTout, connecting party:", pSubscriber->GetReferTo());
							m_pConfApi->ReconnectParty(pConfParty->GetName(), 0);
						}
						if(bLooseConfApi)
						{
							m_pConfApi->DestroyOnlyApi();
							POBJDELETE(m_pConfApi);
						}
					}
				}
				else
				{
					PTRACE2(eLevelError, "CSIPReferEventPackageManager::OnConnectReferredPartyTout, referTo party no found : ", referTo);
					if(pSubscriber->RetryConnect())
					{
						PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::OnConnectReferredPartyTout, retrying timer is set.");
						StartTimer(TIMER_CONNECT_REFER, 50);
					}
					else
						ObserverUpdate(pSubscriber, PARTYSTATE, PARTY_DISCONNECTED);
				}
				
				DEALLOCBUFFER(referTo);
			}
			else
				PTRACE(eLevelError, "CSIPReferEventPackageManager::OnConnectReferredPartyTout, conf not found in db.");
		}

		itr++;
	}
}

///////////////////////////////////////////////////////////////////
CConfParty* CSIPReferEventPackageManager::FindReferedPartyInDB(char* referTo, CSIPREFERSubscriber* pSubscriber) const
{
	CConfParty* pConfParty = NULL;
	//CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pConfName);
	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConfByNameOrByNumericId(m_pConfName);
	if(pCommConf)
	{
		strncpy(referTo, pSubscriber->GetReferTo(), MaxAddressListSize);
		referTo[MaxAddressListSize - 1] = '\0';
		char* temp = (char*)strstr(referTo, "@");
		if(temp)
		{
			*temp = '\0';
			pConfParty = pCommConf->GetCurrentParty(referTo);
			//find party by full URI
			if(!IsValidPObjectPtr(pConfParty))
			{
				strncpy(referTo, pSubscriber->GetReferTo(), IP_LIMIT_ADDRESS_CHAR_LEN);
				referTo[MaxAddressListSize - 1] = '\0';
				pConfParty = pCommConf->GetFirstParty();
				while(IsValidPObjectPtr(pConfParty))
				{
					//if found
					if(!strncmp(pConfParty->GetSipPartyAddress(), referTo, IP_STRING_LEN))
						break;
					else
						pConfParty = pCommConf->GetNextParty();		
				}
			}
		}
		else
		{
			//find party by full data (in case no @ exists)
			pConfParty = pCommConf->GetCurrentParty(referTo);
			//find party by ip address
			if(!IsValidPObjectPtr(pConfParty))
			{
				pConfParty = pCommConf->GetFirstParty();
				while(IsValidPObjectPtr(pConfParty))
				{
					char Ip[16];
					Ip[0]='\0';
// IpV6					SystemDWORDToIpString(pConfParty->GetIpAddress(), Ip);
					if(!strncmp(Ip, referTo, IP_STRING_LEN))
						break;
					pConfParty = pCommConf->GetNextParty();		
				}
			}
		}
	}
	return pConfParty;
}
///////////////////////////////////////////////////////////////////
void CSIPReferEventPackageManager::OnNotifyTimerTout(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::OnNotifyTimerTout");
	//if there is a waiting Notify message, send it
	if(m_pNotifyMsg)
	{
		if (pParam && (pParam->GetWrtOffset() > 0))
		{
			WORD srcUnitId = 0;
			DWORD callIndex =0;
			DWORD cs_Id     =0;
			*pParam >> srcUnitId >> callIndex >> cs_Id;
			SendSipNotify(m_pNotifyMsg, srcUnitId, callIndex, cs_Id);
		}
		else
			SendSipNotify(m_pNotifyMsg);
		
		if(!m_runInTdd)
			StartTimer(TIMER_NOTIFY_TOUT, REFER_NOTIFY_TOUT);
		m_NotifyTimer = TRUE;
		PDELETE(m_pNotifyMsg);
	}
	//else, just mark that a new message may be sent.
	else
	{
		DeleteTimer(TIMER_NOTIFY_TOUT);
		m_NotifyTimer = FALSE;
	}
}

///////////////////////////////////////////////////////////////////
void CSIPReferEventPackageManager::ObserverUpdate(CSIPSubscriber* pSubscriber, WORD event, DWORD val)
{
	BYTE terminate = FALSE;
	ALLOCBUFFER(s, 100);
	snprintf(s, sizeof(s), "event=%i, val=%i", event, val);
	PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::ObserverUpdate, ", s);
	DEALLOCBUFFER(s);

	if(PARTYSTATE == event) 
	{
		switch(val)
		{
			case(PARTY_CONNECTING):
			{
				Notify(pSubscriber, "SIP/2.0 100 Trying", "active");
				break;
			}
			case(PARTY_CONNECTED):
			case(PARTY_CONNECTED_WITH_PROBLEM):
			case(PARTY_SECONDARY):
			case(PARTY_CONNECTED_PARTIALY):
			{
				Notify(pSubscriber, "SIP/2.0 200 OK", "terminated;reason=noresource");
				terminate = TRUE;
				break;
			}
			case(PARTY_DISCONNECTED):
			case(PARTY_DISCONNECTING):
			{
				Notify(pSubscriber, "SIP/2.0 503 Service Unavailable", "terminated;reason=noresource");
				terminate = TRUE;
				break;
			}
			default:
				PTRACE(eLevelError, "CSIPReferEventPackageManager::ObserverUpdate, unknown type");
				break;
		}
	}

	if(terminate)
	{
		//detach from observer pattern
		/*CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pConfName);
		if(IsValidPObjectPtr(pCommConf))
		{
			ALLOCBUFFER(referTo, MaxAddressListSize);
			strncpy(referTo, ((CSIPREFERSubscriber*)pSubscriber)->GetReferTo(), MaxAddressListSize);
			char* temp = (char*)strstr(referTo, "@");
			if(temp)
				*temp = '\0';	
			strcat(referTo, "_(referred)");
			CConfParty* pConfParty = pCommConf->GetCurrentParty(referTo);
			DEALLOCBUFFER(referTo);
			
			if(IsValidPObjectPtr(pConfParty))
				pConfParty->DetachObserver(m_pRcvMbx);*/
			
			PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::ObserverUpdate remove sub party=", pSubscriber->GetFrom());

			//CSIPREFERSubscriber* pSubscriber = (CSIPREFERSubscriber*)(*itr);
			CSIPREFERSubscriber* pTempSubscriber = NULL;
			std::vector< CSIPSubscriber * >::iterator itr =  m_EventSubscribersList.begin();
			while (itr != m_EventSubscribersList.end())
			{
				pTempSubscriber = (CSIPREFERSubscriber*)(*itr);
				if(!strncmp(pSubscriber->GetCallId(), pTempSubscriber->GetCallId(), MaxAddressListSize)
					&& pTempSubscriber->GetCSeq()==((CSIPREFERSubscriber*)pSubscriber)->GetCSeq())
				{
					m_EventSubscribersList.erase(itr);
					POBJDELETE(pTempSubscriber);
					break;
				}
				++itr;					
			}
			
			
	//	}
	}
}

///////////////////////////////////////////////////////////////////
BYTE CSIPReferEventPackageManager::CheckIfReferWithBye(CSipHeaderList * pHeadersList, char* pReferToStr, char* pFullReferToStr)
{
	BYTE result = FALSE;
	ALLOCBUFFER(pArgument, H243_NAME_LEN);
	char  *pReqStr = NULL, *temp=NULL;
	const CSipHeader* pReferTo = pHeadersList->GetNextHeader(kReferTo);
	
	if(pReferTo)
	{
		pReqStr = (char*)pReferTo->GetHeaderStr();
		if(pFullReferToStr)
		{
			strncpy(pFullReferToStr, pReqStr, MaxAddressListSize);
			pFullReferToStr[MaxAddressListSize - 1] = '\0';
		}
		
		temp = (char*)strstr(pReqStr, ";");
	}
	if(temp)
	{
		strncpy(pArgument, temp+1, H243_NAME_LEN);
		pArgument[H243_NAME_LEN - 1] = '\0';
		*temp = '\0';
		if(strstr(pArgument, "method=BYE"))
			result = TRUE;
	}
	if(pReferToStr && pReqStr)
		strncpy(pReferToStr, pReqStr, MaxAddressListSize);

	DEALLOCBUFFER(pArgument);
	return result;
}

///////////////////////////////////////////////////////////////////
BYTE CSIPReferEventPackageManager::CheckRequestValidity(mcIndRefer* pReferInd, enSipCodes *SipStatus, CConfParty **pReqParty, CConfParty **pDestParty)
{
	BYTE	bValidReq = TRUE, acceptVerified = TRUE, bReferWithBye=FALSE;
	const char *pFromStr="";
	const char* pToStr = NULL;
	char    emptyStr[2]="";
	char	*pAcceptName = NULL;
	ALLOCBUFFER(pReferToStr, MaxAddressListSize);
	*pReferToStr='\0';
	CSipHeaderList * pTemp = new CSipHeaderList(pReferInd->sipHeaders);
	
	//verify 'From' is not empty
	const CSipHeader* pFrom = pTemp->GetNextHeader(kFrom);
	if(pFrom)
		pFromStr = pFrom->GetHeaderStr();
	else
	{
		PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::CheckRequestValidity, From is empty.");
		bValidReq = FALSE;
	}
	
	bReferWithBye = CheckIfReferWithBye(pTemp, pReferToStr);
	
	//verify 'ReferTo' is not empty
	if(!strcmp(pReferToStr, ""))
	{
		PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::CheckRequestValidity, ReferTo is empty.");
		bValidReq = FALSE;
	}
	
	const CSipHeader* pTo = pTemp->GetNextHeader(kTo);

	if (pTo != NULL)
		pToStr = pTo->GetHeaderStr();
	else
		pToStr = emptyStr;

	char *pConfName = new char [H243_NAME_LEN];
	*pConfName = '\0';
	
	if(strcmp(pToStr, ""))
	{
		char *temp = (char*)strstr(pToStr, "@");
		if(temp)
		{
			strncpy(pConfName, pToStr, temp - pToStr);
			pConfName[temp-pToStr] = '\0';
		}
	} 
	//verify conference exists
	//CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(pConfName);
	CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConfByNameOrByNumericId(pConfName);
	if(!IsValidPObjectPtr(pCommConf))
	{
		PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::CheckRequestValidity, Target conf not found: ", pConfName);
		bValidReq = FALSE;
		*SipStatus = SipCodesNotFound;
	}
	else
	{
		//verify source party exists
		CConfParty* pConfParty = pCommConf->GetFirstParty();
		while(IsValidPObjectPtr(pConfParty))
		{
			//if found
			if(!strncmp(pConfParty->GetSipPartyAddress(), pFromStr, IP_STRING_LEN))
				break;
			else
				pConfParty = pCommConf->GetNextParty();		
		}
		if(!IsValidPObjectPtr(pConfParty))
		{
			CSIPSubscriber* pSubscriber = NULL;
			if(m_pSIPDispatcher)
				pSubscriber = m_pSIPDispatcher->FindPartyInSIPCX(pFromStr);
			if(pSubscriber)
				pConfParty = pCommConf->GetCurrentParty(pSubscriber->GetFrom());				
			else
			{
				PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::CheckRequestValidity, Source party not found: ", pFromStr);
				bValidReq = FALSE;
				*SipStatus = SipCodesNotFound;
			}
		}
		*pReqParty = pConfParty;

		//verify target party does not exist for REFER, or exists for REFER with BYE
		if(bValidReq)
		{
			CConfParty* pConfParty = pCommConf->GetFirstParty();
			while(IsValidPObjectPtr(pConfParty))
			{
				if(!strncmp(pConfParty->GetSipPartyAddress(), pReferToStr, IP_STRING_LEN))
					break;
				else
				{
					char Ip[16];
					Ip[0]='\0';
// IpV6					SystemDWORDToIpString(pConfParty->GetIpAddress(), Ip);
					if(!strncmp(Ip, pReferToStr, IP_STRING_LEN))
						break;
				}
				pConfParty = pCommConf->GetNextParty();		
			}
			
			if(!IsValidPObjectPtr(pConfParty))
			{
				if(bReferWithBye)
				{
					PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::CheckRequestValidity, BYE REFER party not found: ", pReferToStr);
					bValidReq = FALSE;
					*SipStatus = SipCodesNotFound;
				}
				else
					bValidReq = TRUE;
			}
			else
			{
				if(bReferWithBye)
					bValidReq = TRUE;
				else
				{
					DWORD partyState = pConfParty->GetPartyState();
					//if party exists in conf, verify it's a disconnected dial-out party
					if(DIAL_OUT == pConfParty->GetConnectionType() && (PARTY_STAND_BY == partyState || PARTY_IDLE == partyState || PARTY_DISCONNECTED == partyState))
						bValidReq = TRUE;
					else
					{
						PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::CheckRequestValidity, REFER party already in conf: ", pReferToStr);
						bValidReq = FALSE;
						*SipStatus = SipCodesBadRequest;
					}
				}
			}
			*pDestParty = pConfParty;
		}
	}
	
	PDELETEA(pConfName);
	DEALLOCBUFFER(pReferToStr);
	
	//verify 'Accept' is valid
	const CSipHeader* pAccept = pTemp->GetNextHeader(kAccept);
	while(pAccept)
	{
		pAcceptName = (char*)pAccept->GetHeaderStr();
		if(pAcceptName)
		{
			//verify allow is either empty or holds "message/sipfrag"
			if(strstr(pAcceptName, "message/sipfrag"))
			{
				//if(strcmp(pAcceptName, ""))
				acceptVerified = TRUE;
				break;
			}
			else
				acceptVerified = FALSE;
		}
		pAccept = pTemp->GetNextHeader(kAccept);
	}
	
	if(!acceptVerified)
	{
		*SipStatus = SipCodesNotAcceptable;
		bValidReq = FALSE;
		PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::CheckRequestValidity, Accept field is wrong: ");
	}
	
	//verify ip is not empty
	if(pReferInd->transportAddress.transAddr.addr.v4.ip == 0)
	{
		PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::CheckRequestValidity, IP = 0 ");
		bValidReq = FALSE;
	}
	
	//verify transpot type is valid
	if(eTransportTypeUdp	!= pReferInd->transportAddress.transAddr.transportType && eTransportTypeTcp != pReferInd->transportAddress.transAddr.transportType && eTransportTypeTls!= pReferInd->transportAddress.transAddr.transportType)
	{
		PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::CheckRequestValidity, transport type is invalid. ");
		bValidReq = FALSE;
	}
	
	POBJDELETE(pTemp);
	
	return bValidReq;
}

///////////////////////////////////////////////////////////////////
//Just do Notify
BYTE CSIPReferEventPackageManager::Notify(CSIPSubscriber* pSubscriber,char* content, char* state, BYTE isDistribute)
{
	PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::Notify, referTo=", ((CSIPREFERSubscriber*)pSubscriber)->GetReferTo());
	
	BYTE bLooseProtocol = FALSE, result = FALSE;

	CSipNotifyStruct SipNotify;
	SipNotify.SetHeaderField(kFrom, pSubscriber->GetTo());
	SipNotify.SetHeaderField(kFromTag, pSubscriber->GetToTag());
	SipNotify.SetHeaderField(kTo, pSubscriber->GetFrom());
	SipNotify.SetHeaderField(kToTag, pSubscriber->GetFromTag());
	SipNotify.SetHeaderField(kCallId, pSubscriber->GetCallId());
//	SipNotify.SetContentType("message/sipfrag;version=2.0");
	SipNotify.SetHeaderField(kContentType, "message/sipfrag;version=2.0");
	SipNotify.SetContent(content);
	CSmallString str;
	str << "refer";
	DWORD CSeq = ((CSIPREFERSubscriber*)pSubscriber)->GetCSeq();
	if(CSeq != 0)
		str << "; id=" << CSeq;
	SipNotify.SetHeaderField(kEvent, str.GetString());

	ALLOCBUFFER(SubState, H243_NAME_LEN);
	strncpy(SubState, state, H243_NAME_LEN);
	SubState[H243_NAME_LEN - 1] = '\0';
	if(strncmp(state, "terminated", 10))
	{
		int len = strlen(SubState);
		if(len < H243_NAME_LEN - 16)
		{
			CStructTm curTime;
			STATUS timeStatus = SystemGetTime(curTime);
			char temp[15];
			snprintf(temp, sizeof(temp), ";expires=%d", pSubscriber->GetExpireTime() - curTime);
			strncat(SubState, temp, 15);
			SubState[H243_NAME_LEN - 1] = '\0';
		}
	}
	//if terminating
	else
	{
		//detach from observer pattern
		//CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConf(m_pConfName);
		CCommConf* pCommConf = ::GetpConfDB()->GetCurrentConfByNameOrByNumericId(m_pConfName);
		if(IsValidPObjectPtr(pCommConf))
		{
			ALLOCBUFFER(referTo, MaxAddressListSize);
			strncpy(referTo, ((CSIPREFERSubscriber*)pSubscriber)->GetReferTo(), MaxAddressListSize);
			referTo[MaxAddressListSize - 1] = '\0';				
			char* temp = (char*)strstr(referTo, "@");
			if(temp)
				*temp = '\0';	
			CConfParty* pConfParty = pCommConf->GetCurrentParty(referTo);
			DEALLOCBUFFER(referTo);
			
			if(IsValidPObjectPtr(pConfParty))
				pConfParty->DetachObserver(m_pRcvMbx, PARTYSTATE, SIP_REFER, (DWORD)pSubscriber);
		}
	}
	SipNotify.SetHeaderField(kSubscrpState, SubState);
	DEALLOCBUFFER(SubState);

	SipNotify.SetIp(pSubscriber->GetIp());
	SipNotify.SetPort(pSubscriber->GetPort());
	SipNotify.SetTransportType(pSubscriber->GetTransport());
	SipNotify.SetCSeq(m_CSeq++);
	SipNotify.SetCallIndex(((CSIPREFERSubscriber*)pSubscriber)->GetCallIndex());

	m_pNotifyMsg = SipNotify.BuildNotifyReq();
	if( !m_pNotifyMsg )
	{
		DBGPASSERT(1);
		return FALSE;
	}
	COstrStream msg;
	SipNotify.Dump(msg);
	PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::Notify req:\n ", msg.str().c_str());

	//Notify may be sent only once a second (top frequency)
	if(!m_NotifyTimer)
	{
		SendSipNotify(m_pNotifyMsg, pSubscriber->GetSrcUnitId(),((CSIPREFERSubscriber*)pSubscriber)->GetCallIndex(),pSubscriber->GetCsId());
		if(!m_runInTdd)
		{
			CSegment *pNotifyParams = new CSegment;
			*pNotifyParams  << pSubscriber->GetSrcUnitId()
							<< ((CSIPREFERSubscriber*)pSubscriber)->GetCallIndex()
							<< ((CSIPREFERSubscriber*)pSubscriber)->GetBoardId();
			StartTimer(TIMER_NOTIFY_TOUT, REFER_NOTIFY_TOUT,pNotifyParams);
		}
		m_NotifyTimer = TRUE;
		PDELETEA(m_pNotifyMsg);
		result = TRUE;
	}
	else
		PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::Notify not sent due to 1 sec Timer.");
	
	return result;
}

///////////////////////////////////////////////////////////////////
CSIPREFERSubscriber* CSIPReferEventPackageManager::FindParty(const char* from, DWORD CSeq, char* callId)
{
	CSmallString str;
	str << from <<" CSeq=" << CSeq << "\n";
	PTRACE2(eLevelInfoNormal,"CSIPReferEventPackageManager::FindConfPkgParty named = ", str.GetString());
	CSIPREFERSubscriber* pSubscriber = NULL;
	if(from)
	{
		std::vector< CSIPSubscriber * >::iterator itr =  m_EventSubscribersList.begin();
		while (itr != m_EventSubscribersList.end())
		{
			pSubscriber = (CSIPREFERSubscriber*)(*itr);
			if(IsValidPObjectPtr(pSubscriber))
			{
				if(!strncmp(from, pSubscriber->GetFrom(), MaxAddressListSize)) {
					//only if CSeq is not 0, check it
					if(CSeq != 0)
					{
						if(CSeq == pSubscriber->GetCSeq()
							&& !strncmp(pSubscriber->GetCallId(), callId, MaxAddressListSize))
							break;
						else
							pSubscriber = NULL;
					}
					else
						break;
				}
			}
			pSubscriber = NULL;
			itr++;
		}
	}
	return pSubscriber;
}

///////////////////////////////////////////////////////////////////
BYTE CSIPReferEventPackageManager::FindParty(void* pSubscriber)
{
	BYTE result = FALSE;
	CSIPREFERSubscriber* pRunner = NULL;
		
	std::vector< CSIPSubscriber * >::iterator itr =  m_EventSubscribersList.begin();
	while (itr != m_EventSubscribersList.end())
	{
		pRunner = (CSIPREFERSubscriber*)(*itr);
		if(IsValidPObjectPtr(pRunner))
		{
			if(pRunner == pSubscriber)
				if(FindParty( ((CSIPREFERSubscriber*)pSubscriber)->GetFrom(), ((CSIPREFERSubscriber*)pSubscriber)->GetCSeq(), ((CSIPREFERSubscriber*)pSubscriber)->GetCallId() ))
				{
					result = TRUE;	
					break;
				}
		}
		++itr;
	}
	
	return result;
}

///////////////////////////////////////////////////////////////////
void CSIPReferEventPackageManager::Dump(COstrStream& msg) const
{
	CSIPSubscriber* pSubscriber = NULL;
	char* result = NULL;
	//OPENOSTRSTREAM(msg);
	
	if(msg)
	{
		msg << "CSIPReferEventPackageManager::Dump type = refer\n";
		msg << "-----------------------------------\n";
		
/*		std::vector< CSIPSubscriber * >::iterator itr =  m_EventSubscribersList.begin();
		while (itr != m_EventSubscribersList.end())
		{
			pSubscriber = (*itr);
			if(IsValidPObjectPtr(pSubscriber))
			{
				msg<< pSubscriber->ToString();
				msg<< '\n';
			}
			itr++;
		}*/
	}
}


///////////////////////////////////////////////////////////////////
void CSIPReferEventPackageManager::OnSubscribeTout(CSegment* pParam)
{
	PTRACE(eLevelInfoNormal, "CSIPReferEventPackageManager::OnSubscribeTout");
	CSIPSubscriber* pSubscriber = NULL;
	//calc current time
	CStructTm curTime;
	STATUS timeStatus = SystemGetTime(curTime);
	
	//find all subscribers with expired subscription
	std::vector< CSIPSubscriber * >::iterator itr =  m_EventSubscribersList.begin();
	while (itr != m_EventSubscribersList.end())
	{
		pSubscriber = (*itr);
		if(IsValidPObjectPtr(pSubscriber))
		{
			DWORD duration = pSubscriber->GetExpireTime() - curTime;
			if(duration < 5)
			{
				PTRACE2(eLevelInfoNormal, "CSIPReferEventPackageManager::OnSubscribeTout party = ",pSubscriber->GetFrom() );
				Notify(pSubscriber, "SIP/2.0 503 Service Unavailable", "terminated;reason=noresource");

				m_EventSubscribersList.erase(itr);
				POBJDELETE(pSubscriber);
				itr = m_EventSubscribersList.begin();
			}
			else
				++itr;
		}
		else
			++itr;
	}

	WORD duration = CalcTimer();
	if(duration > 0)
	{
		if(!m_runInTdd)
			StartTimer(TIMER_SUBSCRIBE_TOUT, SECOND * duration);
		m_SubTimer = TRUE;
	}
}

///////////////////////////////////////////////////////////////////
void CSIPReferEventPackageManager::SendSipReferResponse(mcIndRefer* pReferInd, enSipCodes sipCode, DWORD callIndex, WORD srcUnitId, DWORD serviceId)
{
	mcReqReferResp* pReferResp = new mcReqReferResp;
	pReferResp->pCallObj = pReferInd->pCallObj;
	pReferResp->status = sipCode;
	pReferResp->remoteCseq = pReferInd->remoteCseq;
	
	CSegment* pSeg = new CSegment;
	DWORD size = sizeof(mcReqReferResp);
	
	*pSeg << callIndex
		  << srcUnitId;
	*pSeg << size;	  
//	pSeg->Put((BYTE*)pReferResp, sizeof(mcReqReferResp));
	pSeg->Put((BYTE*)pReferResp, size);

	SendMsgToCS(serviceId, SIP_CS_SIG_REFER_RESP_REQ, pSeg);
	PDELETE(pReferResp);
	POBJDELETE(pSeg);
}

