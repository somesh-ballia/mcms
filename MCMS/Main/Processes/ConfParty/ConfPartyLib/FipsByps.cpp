
#include "FipsByps.h"
#include "Trace.h"
#include "ObjString.h"
#include "TraceHeader.h"
#include "ConfPartyGlobals.h"
//#include "SHA1.h"

extern "C" {
  
  BOOL Hashing_Fips186_1_x3_3(    UINT8 *pucMessage,
				  UINT8 *pucDigestedMessage,
				  UINT32 unLength);
}
//#include "obstring.h"
//#include<SHA1.h>
//#include<gextern.h>



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// implementation of class CProtectedArray
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// constructors
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CProtectedArray::CProtectedArray()
{
	for(WORD byte_index=0;byte_index<MAX_PROTECTED_DATA_ARRAY_LENGTH;byte_index++){
		m_protected_data_Array[byte_index]=0;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CProtectedArray::~CProtectedArray()
{
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CPObject pure virtual function
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const char* CProtectedArray::NameOf() const
{
	return "CProtectedArray";
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// public (const!) functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE CProtectedArray::GetByte(WORD index) const
{
	BYTE ret_val = 0;
	if(index<MAX_PROTECTED_DATA_ARRAY_LENGTH)
	{
		ret_val = m_protected_data_Array[index];
	}else{
		// trace on wrong index
		CSmallString sstr;
		sstr << "wrong index = " << index;
		PTRACE2(eLevelInfoNormal,"CProtectedArray::GetByte ",sstr.GetString());
	}
	return ret_val;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CProtectedArray::Dump(CObjString* ostr) const
{
	BYTE dump_to_str = 1;
	CObjString* dump_string = NULL;
	if(ostr==NULL)
	{
		dump_string = new CMedString();
		dump_to_str = 0;
	}else{
		dump_string = ostr;
	}

	for(WORD byte_index=0;byte_index<MAX_PROTECTED_DATA_ARRAY_LENGTH;byte_index++){
		*dump_string << m_protected_data_Array[byte_index];
	}

	if(!dump_to_str){
		PTRACE2(eLevelInfoNormal,"CProtectedArray::Dump = ", dump_string->GetString());
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// private functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST_RESULT CProtectedArray::SetByte(WORD index, BYTE value)
{
	TEST_RESULT ret_val = TEST_PASSED;
	ret_val = TestBeforeUpdate();
	if(ret_val==TEST_PASSED)
	{
		// we do not update data if test failed
		if(index<MAX_PROTECTED_DATA_ARRAY_LENGTH)
		{
			m_protected_data_Array[index] = value;
		}else{
			// trace on wrong index
			CSmallString sstr;
			sstr << "wrong index = " << index;
			PTRACE2(eLevelInfoNormal,"CProtectedArray::SetByte ",sstr.GetString());
		}
		ret_val = TestAfterUpdate();
	}
	if(ret_val != TEST_PASSED){
		Dump();
	}
	return ret_val;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// implementation of class CHashedArray
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHashedArray::CHashedArray()
{
	m_hashed_value = Hash();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHashedArray::~CHashedArray()
{
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CPObject pure virtual function
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const char* CHashedArray::NameOf() const
{
	return "CHashedArray";
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CProtectedArray pure virtual function
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST_RESULT CHashedArray::TestBeforeUpdate()
{
	TEST_RESULT ret_val = TEST_PASSED;
	CHashType updated_hash_value = Hash();
	if(m_hashed_value!=updated_hash_value){
		PTRACE(eLevelError,"CHashedArray::TestBeforeUpdate - FAILED");
		m_hashed_value.Dump(eLevelError);
		updated_hash_value.Dump(eLevelError);
		ret_val=TEST_FAILED;
	}
	return ret_val;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST_RESULT CHashedArray::TestAfterUpdate()
{
	return TEST_PASSED;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// API function
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST_RESULT CHashedArray::SetByte(WORD index, BYTE value)
{
	TEST_RESULT ret_val = TEST_PASSED;
	ret_val = CProtectedArray::SetByte(index,value);
	m_hashed_value = Hash();
	return ret_val;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Protected function
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHashType CHashedArray::Hash() const
{
	CHashType bit_mask;
	// create bit mask from protected data array
	for(WORD data_index=0;data_index<MAX_PROTECTED_DATA_ARRAY_LENGTH;data_index++)
	{
		if(GetByte(data_index)!=0){
			bit_mask.SetBit(data_index);
		}else{
			bit_mask.ResetBit(data_index);
		}
	}

	BYTE* arrayToHash = bit_mask.GetBytesArray();
	BYTE  hashResult[HASH_BSIZE];
	BOOL hash_action_status = ::Hashing_Fips186_1_x3_3(arrayToHash, hashResult, HASH_BSIZE);
	if(hash_action_status==FALSE)
	{
		DBGPASSERT(1);
		PTRACE(eLevelError,"CHashedArray::Hash: Hashing_Fips186_1_x3_3 failed");
	}

	CHashType hashed_bit_mask(hashResult);
	return hashed_bit_mask;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CHashedArray::Dump(DWORD level)
{
	CProtectedArray::Dump();
	m_hashed_value.Dump(level);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// implementation of class CHashType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHashType::CHashType()
{
	for(WORD bytes_units_index=0;bytes_units_index<HASH_BSIZE;bytes_units_index++){
		m_pHashDat[bytes_units_index]=0;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHashType::CHashType(BYTE* hashBytesArray)
{
	for(WORD bytes_units_index=0;bytes_units_index<HASH_BSIZE;bytes_units_index++){
		m_pHashDat[bytes_units_index]=hashBytesArray[bytes_units_index];
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHashType::~CHashType()
{
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CPObject pure virtual function
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const char* CHashType::NameOf() const
{
	return "CHashType";
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CHashType operator
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHashType& CHashType::operator=(const CHashType& other)
{
	for(WORD bytes_units_index=0;bytes_units_index<HASH_BSIZE;bytes_units_index++){
		m_pHashDat[bytes_units_index]=other.GetByte(bytes_units_index);
	}
	return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int operator==(const CHashType& hash1,const CHashType& hash2)
{
	int is_equal = 1;
	for(WORD bytes_units_index=0;bytes_units_index<HASH_BSIZE;bytes_units_index++){
		if(hash1.GetByte(bytes_units_index)!=hash2.GetByte(bytes_units_index)){
			is_equal=0;
			break;
		}
	}
	return is_equal;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int operator!=(const CHashType& hash1,const CHashType& hash2)
{
	return !(hash1==hash2);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CHashType API functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CHashType::SetBit(WORD index)
{
	if(index<MAX_PROTECTED_DATA_ARRAY_LENGTH)
	{
		WORD byte_index = index/8;
		WORD bit_ofset = index - byte_index*8;
		BYTE ofset_mask = (0x8 >> bit_ofset);
		m_pHashDat[byte_index] |= ofset_mask;
	}else{
		// trace on wrong index
		CSmallString sstr;
		sstr << "wrong index = " << index;
		PTRACE2(eLevelInfoNormal,"CHashType::SetBit ",sstr.GetString());
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CHashType::ResetBit(WORD index)
{
	if(index<MAX_PROTECTED_DATA_ARRAY_LENGTH)
	{
		WORD byte_index = index/8;
		WORD bit_ofset = index - byte_index*8;
		BYTE ofset_mask = ~(0x8 >> bit_ofset);
		m_pHashDat[byte_index] &= ofset_mask;
	}else{
		// trace on wrong index
		CSmallString sstr;
		sstr << "wrong index = " << index;
		PTRACE2(eLevelInfoNormal,"CHashType::ResetBit ",sstr.GetString());
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// API to compare
BYTE CHashType::GetByte(WORD index)const
{
	BYTE ret_val = 0;
	if(index<HASH_BSIZE)
	{
		ret_val = m_pHashDat[index];
	}else{
		// trace on wrong index
		CSmallString sstr;
		sstr << "wrong index = " << index;
		PTRACE2(eLevelInfoNormal,"CHashType::GetByte ",sstr.GetString());
	}
	return ret_val;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE* CHashType::GetBytesArray()
{
	return m_pHashDat;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CHashType::Dump(DWORD level)
{
	CMedString mstr;
	BYTE current_byte = 0;
	for(WORD byte_index = 0;byte_index<HASH_BSIZE;byte_index++)
	{
		BYTE ofset_mask = 0;
		current_byte = m_pHashDat[byte_index];
		for(WORD bit_index=0;bit_index<8;bit_index++)
		{
			ofset_mask = (0x8 >> bit_index);
			if((ofset_mask & current_byte)==0){
				mstr << '0';
			}else{
				mstr << '1';
			}
		}
	}
	PTRACE(level,mstr.GetString());
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

