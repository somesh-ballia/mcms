//=================================================================================================
//
//Copyright (C) 2000 ACCORD Networks Ltd.
//This file contains confidential information proprietary to ACCORD Networks Ltd. The use or 
//disclosure of any information contained in this file without the written consent of an officer of
//ACCORD Networks Ltd. is expressly forbidden.
//
//=================================================================================================

//=================================================================================================
//
//Module Name:  SipProxyConfCntl.h
//
//General Description:  
//
//    1.	control the conference registrations in the Proxy Server
//
//Generated By: Ori                            Date: 19.07.05
//
//Revisions and Updates: 
//
//Date         Updated By         Description
//========   ==============   =====================================================================
// 
//=================================================================================================

#ifndef __SIPPROXYCONFCNTL_H__
#define __SIPPROXYCONFCNTL_H__

//===== Include Files =====
#include "Trace.h"
#include "StateMachine.h"
#include "MplMcmsProtocol.h"
#include "DefinesIpService.h"
#include "SipSubscriberMngr.h"
#include "SipProxyMsSubscriber.h"
#include "SipProxyMsPresence.h"
#include  "IceCmReq.h"
#include "SIPProxyIpParameters.h"

//#define NUM_OF_IPS		  3
#define MAX_NUM_OF_PRESENCE_CONF_RMX2000	1000
#define MAX_NUM_OF_PRESENCE_CONF_RMX4000	1000

// SIP Proxy Manager Conf states
const WORD   CONF_IDLE          = 1;
const WORD   CONF_REGISTERING   = 2;
const WORD   CONF_REGISTERED    = 3;
const WORD   CONF_UNREGISTERING = 4;
const WORD	 CONF_IDLE_DNS_RESOLVING			= 5;
const WORD	 CONF_REGISTERING_DNS_RESOLVING		= 6;
const WORD	 CONF_REGISTERED_DNS_RESOLVING		= 7;
const WORD   CONF_UNREGISTERING_DNS_RESOLVING	= 8;
const WORD   CONF_ICE_DNS_RESOLVING             = 9;
const WORD   CONF_ICE_CONNECT                   = 10;

//One Conf Events
const WORD   SIP_START_REGISTER    = 1;
const WORD   AUTHENTICATION_REQ    = 2;
const WORD   REGISTERING_OK		   = 3;
const WORD   UNREGISTER			   = 4;
const WORD	 REGISTERING_FAILED	   = 5;
const WORD	 SUBSCRIBING_OK		   = 6;
const WORD	 SUBSCRIBING_FAILED    = 7;
const WORD   NOTIFY_IND			   = 8;
const WORD   END_ICE_INIT		   = 9;
const WORD	 SERVICE_IND_OK		   = 10;
const WORD	 SERVICE_IND_FAILED    = 11;
const WORD   ICE_RESOLVE_COMPLETE  = 12;

const WORD   DEFAULT_STUN_PORT     = 3478;


//Body-List presence states
typedef enum
{
	eOFFLINE = 0,
	eONLINE,
	eAWAY,
	eBUSY
}PRESENCE;

//Proxy Types
typedef enum
{
	eUNKNOWN = 0,
	eLCS,
	eOCS
}enProxyType;

typedef enum
{
	eUnknownServerVersion = 0,
	eW13,
	eLync
}enProxyVersionType;


//////////////////////////////////////////////////////////////
// CConfRegistrationList
class COneConfRegistration : public CPObject
{
CLASS_TYPE_1(COneConfRegistration, CPObject)
public:             
	COneConfRegistration();
	~COneConfRegistration();
	void SetServiceAddresses(ipAddressStruct ipAddrSt, WORD index);
	ipAddressStruct GetServiceAddress(WORD index);

	virtual const char*  NameOf() const;	
/*
	WORD	m_status;
	DWORD	m_confID;					// any value
	DWORD	m_serviceId;
	DWORD   m_serviceIp;				// legal IP address
	WORD	m_transportType;			//TCP UDP
	DWORD   m_serversConfig;			// auto / manual
	WORD	m_DNSStatus;
	DWORD	m_outboundProxyIP;			//
	WORD	m_outboundProxyPort;
	DWORD	m_proxyIP;					// legal IP address
	WORD	m_proxyPort;
	char*   m_poutboundProxyName;		// outboundProxy name
	char*   m_pProxyName;				// Proxy name
	char*	m_pHostName;				// MCU Host name, used as host part in URL regisration
	char*	m_pConfName;				// conf name
	DWORD   m_expires;					// time for reg expiration
	BYTE	m_move;						// 1 = moving registration from one card to another
	BYTE	m_remove;					// if while trying to register, we receive unregister request ->m_remove = 1 in order to execute unregister once the register request is answered.
	BYTE    m_bIsDiscovery;
*/
	WORD	m_status;
	DWORD	m_confID;					// any value
	DWORD	m_serviceId;
//	mcTransportAddress   m_serviceAddressIpV6;				// legal IP address
	//	DWORD	m_serviceIp;
	ipAddressStruct m_serviceAddrList[TOTAL_NUM_OF_IP_ADDRESSES];
	eIpType m_ipType;
//	mcTransportAddress m_serviceAddressIpV4;
	WORD	m_transportType;			//TCP UDP
	DWORD   m_serversConfig;			// auto / manual
	WORD	m_DNSStatus;
	mcTransportAddress	m_outboundProxyAddress;			//
//	DWORD	m_outboundProxyIp;
//	WORD	m_outboundProxyPort;
	mcTransportAddress	m_proxyAddress;					// legal IP address
//	DWORD	m_proxyIp;
//	WORD	m_proxyPort;
	char*   m_poutboundProxyName;		// outboundProxy name
	char*   m_pProxyName;				// Proxy name
	char*	m_pHostName;				// MCU Host name, used as host part in URL regisration
	char*	m_pConfName;				// conf name
	DWORD   m_expires;					// time for reg expiration
	BYTE	m_move;						// 1 = moving registration from one card to another
	BYTE	m_remove;					// if while trying to register, we receive unregister request ->m_remove = 1 in order to execute unregister once the register request is answered.
	BYTE    m_bIsDiscovery;
	BYTE	m_bIsOngoing;
	BYTE	m_bIsMR;
	BYTE	m_bIsEQ;
	BYTE	m_bIsFactory;
	BYTE	m_bIsGWProfile;
	BYTE 	m_bIsMSIceUser;
	BYTE 	m_bIsStandIceUser;
	BYTE	m_bIsFromOldService;		// TRUE when conf is unregisted with old parameters during changing in service parameters
	WORD 	m_sipServerType;
  char  m_dummy_name[H243_NAME_LEN];
  	WORD	m_lastRegStatus;  //eSipServerStatusType

};	// CConfRegistrationList

typedef struct
{
  DWORD connId;
  DWORD partyId;
}StPartiesDetailes;

//typedef std::vector<StPartiesDetailes*> PartiesDetailesVec;
typedef std::vector<std::pair<DWORD, DWORD> > PartiesDetailesVec;

//////////////////////////////////////////////////////////////
// COneConf
class COneConf : public CStateMachine
{
CLASS_TYPE_1(COneConf,CStateMachine)
// public functions
public:             
	COneConf();
	~COneConf();

    virtual void*	 GetMessageMap();
	virtual void  HandleEvent(CSegment *pMsg,DWORD msgLen,OPCODE opCode);
	void  HandleEventByIndex(OPCODE opcode, CSegment* pMsg);
	virtual int   Create( COneConfRegistration *data, unsigned int indInDB, COsQueue* pRcvMbx,
				 CMplMcmsProtocol* pMockMplProtocol = NULL);
	void  StartRegister(DWORD delay);
	void  Unregister();
	void  StopReg();
	void  ResetConfCntl();
	char* GetCallId() const;
	DWORD GetId();
	void  SetBusyServer(BYTE busyServer);
	BYTE  IsBusyServer();
	void  GetAddressFromList(mcTransportAddress* resolvedAddr,ipAddressStruct* pAddrList,eIpType ipType);
	virtual const char*  NameOf() const;
	
	// action functions
	void  OnStartRegisterIDLE(CSegment* pParam);
	void  OnUnRegisterIDLE(CSegment* pParam);
	void  OnAuthenticationRequest(CSegment* pParam);
	void  OnRegisteringTimer(CSegment* pParam);
	void  OnRegisteringOKRegistering(CSegment* pParam);
	void  OnRegisteringOKRegistered(CSegment* pParam);
	void  OnRefreshTimer(CSegment* pParam);
	void  OnRegisteringRefreshTimer(CSegment* pParam);
	void  OnUnRegisterRequestRegistering(CSegment* pParam);
	void  OnUnRegisterRequestRegistered(CSegment* pParam);
	void  OnUnRegisterRequestUnRegistering(CSegment* pParam);
	void  OnUnRegisterRequestIdleDNSResolving(CSegment* pParam);
	void  OnUnRegisterRequestRegisteringDNSResolving(CSegment* pParam);
	void  OnUnRegisterRequestRegisteredDNSResolving(CSegment* pParam);
	void  OnUnRegisterRequestUnRegisteringDNSResolving(CSegment* pParam);
	void  OnRegisteringOKUnRegistering(CSegment* pParam);
	void  OnUnRegisteringTimer(CSegment* pParam);
	void  OnRegisteringFailedRegistered(CSegment* pParam);
	void  OnRegisteringFailedRegistering(CSegment* pParam);
	void  OnRegisteringFailedUnRegistering(CSegment* pParam);
	virtual void  OnSubscribingOKRegistered(CSegment* pParam);
	virtual void  OnSubscribingFailedRegistered(CSegment* pParam);
	void  OnSubscribRefreshTimer(CSegment* pParam);
	virtual void  OnNotifyIndRegistered(CSegment* pParam);

	void  OnDNSResolveIndConfIDLEResolving(CSegment* pParam);
	void  OnDNSResolveIndConfREGISTERINGResolving(CSegment* pParam);
	void  OnDNSResolveIndConfREGISTEREDResolving(CSegment* pParam);
	void  OnDNSResolveIndConfUNREGISTERINGResolving(CSegment* pParam);

	void  OnDNSServiceIndConfIDLEResolving(CSegment* pParam);
	void  OnDNSServiceIndConfREGISTERINGResolving(CSegment* pParam);
	void  OnDNSServiceIndConfREGISTEREDResolving(CSegment* pParam);
	void  OnDNSServiceIndConfUNREGISTERINGResolving(CSegment* pParam);

	void  OnDNSResolvingTimer(CSegment* pParam);

//	BOOL IsIpEqualToZero(mcTransportAddress Address);
	void    SetCsIpArrayAccordingToIpTypeAndScopeId(COneConfRegistration* pData);
	virtual void SetProxyServerType(APIS8 HeaderField,char* Header);
	virtual void SetProxyServerVersionType(APIS8 HeaderField,char* Header);
	virtual void SetMsKeepAliveTout(APIS8 HeaderField,char* Header);

    virtual void   crlf_vGetKaParametersFromFormatedString(   char  * szMsKeepAlive_Data
                                                            , DWORD * pKa_Frequency
                                                            , DWORD * pnKa_PongTimeout
                                                            , DWORD * pnKa_Behavior
                                                            , DWORD * pnKa_Tipe);

	void UpdateRegisterState();
	void ChangePresence(BYTE presenceState);
	void OnStartPresenceOnlineRegistered(CSegment* pParam);
	void OnStartPresenceBusyRegistered(CSegment* pParam);
	void SetTransportErrorState();
	void AddPartyToRegisterWaitingPartiesVector(DWORD partyId, DWORD connId);
	void OnRegisterEmptyWaitingPartiesVector(DWORD status);
	void OnMsKeepAliveClientTimeOut(CSegment *pSeg);
	void OnMsKeepAliveToutErrInd(DWORD errCode);
	void SendCrlfMessageNow();
	void SendCrlfMessageOnTransportError();
	void SetGruuContact(APIS8 HeaderField, std::string Header);
	virtual enGeneralRegisterOpcode  GetRegisterSubOpcode(){ return RegisterConf; }


// protected functions
protected: 
	void  SendMsgToCS(OPCODE opcode, CSegment* pseg1);
	BYTE  RegisterRequest(DWORD expires);
	void  ServiceAutoAdd(int deltaNum);
	void  ServicePresence(PRESENCE newPresence);
	virtual void  Subscribe(char* pEvent, char* pAccept, DWORD expires);
	virtual void  CallSubscribe(BOOL IsFirstRegisteration);

	void  ClearResolvedIps();
	BYTE  CheckDHCPData(COneConfRegistration *pData);

	int	  GetRandomNumber();

	void  ResolveDomainReq(DWORD serviceId, char* pProxyName);
	void  ServiceReq(DWORD serviceId, char* m_pHostName, eIPProtocolType eIPProtocolType_SIP, WORD transportType);
	void  HandleBusyServer(BYTE bRegister);

    virtual void SetRegisterActiveAlarm(BYTE IsAdd);

    WORD GetTransportType();
    mcTransportAddress GetProxyAddress();
    void BuildcontactUriIp(char* LocalUri);

// public parameters
public:             
	
// protected parameters
protected: 
	COsQueue* m_pSipMngrRcvMbx;
	COneConfRegistration* m_data;		// pointer to the conf DB
	WORD	m_indInMngrDB;
	WORD	m_timerRegister;
	WORD	m_timerRefresh;
	WORD	m_timerUnRegister;
	WORD	m_timerSubscribeRefresh;
	BYTE	m_countFailedRegs;
	char*	m_callId;
	BYTE	m_DNSResolvedIp;
	enProxyType	m_proxyType;
	WORD	m_src_unit_id;
	BYTE	m_busyServer;
	CMplMcmsProtocol* m_pMockMplProtocol;	//for TDD only!!
	enProxyVersionType m_proxyVersionType;
	BYTE 	m_presenceState;
	BYTE 	m_presenceNeedToRepublish;
//	CSIPProxyLoadMngrConnector*	m_pLoadMngrConnector;*********
  PartiesDetailesVec m_PartiesWaiting;
  //---TCP Keep Alive ------------------------------------------//
  DWORD 	m_dwKeepAliveFrequencyConf_Sec  ;
  DWORD 	m_MsKeepAlivePongTimeOutConf    ;
  DWORD     m_dwKeppAliveBehaviorConf       ;
  DWORD     m_dwKeepAliveTypeConf           ;  


	BYTE 	m_bIsCrlfRegistration;
	char  m_GruuContact[MaxAddressListSize];


    PDECLAR_MESSAGE_MAP

};	// COneConf

//////////////////////////////////////////////////////////////
// CMsOneConf
class CMsOneConf : public COneConf
{
CLASS_TYPE_1(CMsOneConf,COneConf)
// public functions
public:
	CMsOneConf();
	~CMsOneConf();
	virtual const char*  NameOf() const;
	virtual void  SetProxyServerType(APIS8 HeaderField,char* Header);
	virtual void  SetProxyServerVersionType(APIS8 HeaderField,char* Header);
	void CallSubscribe(BOOL IsFirstRegisteration); // start presence flow
	void OnSubscribingOKRegistered(CSegment* pParam);
	void OnServiceIndOKRegistered(CSegment* pParam);
	void OnSubscribingFailedRegistered(CSegment* pParam);
	void OnServiceIndFailedRegistered(CSegment* pParam);
	void OnStartPresenceOnlineRegistered(CSegment* pParam);
	void OnStartPresenceBusyRegistered(CSegment* pParam);
// protected parameters
protected:


    CSipProxyMsPresence* m_pMsPresence;

	PDECLAR_MESSAGE_MAP

};// CMsOneConf


//////////////////////////////////////////////////////////////
// CMsIceUser
class CMsIceUser : public COneConf
{
CLASS_TYPE_1(CMsIceUser,COneConf)
// public functions
public:
	CMsIceUser();
	~CMsIceUser();
	int Create(COneConfRegistration *data, unsigned int indInDB, COsQueue* pRcvMbx, CMplMcmsProtocol* pMockMplProtocol = NULL);

    void CallSubscribe(BOOL IsFirstRegisteration);
    virtual const char*  NameOf() const;

     void SetProxyServerType(APIS8 HeaderField,char* Header);
     void SetProxyServerVersionType(APIS8 HeaderField,char* Header);
     void OnSubscribingOKRegistered(CSegment* pParam);
     void OnSubscribingFailedRegistered(CSegment* pParam);
     void OnNotifyIndRegistered(CSegment* pParam);
     void OnServiceOKRegistered(CSegment* pParam);
     void OnServiceFailedRegistered(CSegment* pParam);
     void OnCSEndIceInit(CSegment* pParam);
  //   void ResolveHostName(char* HostName);
     void OnSubscribRefreshTimer(CSegment* pParam);

     void SetRegisterActiveAlarm(BYTE IsAdd);
     void UpdateRegisterState();
 	virtual enGeneralRegisterOpcode  GetRegisterSubOpcode(){ return RegisterIce; }

// protected parameters
protected:
    CSipProxyMsSubscriber* m_pSubScriber;

	PDECLAR_MESSAGE_MAP

};// CMsIceUser



//////////////////////////////////////////////////////////////
// CStandIceUser
class CStandIceUser : public COneConf
{
CLASS_TYPE_1(CStandIceUser,COneConf)
// public functions
public:
	CStandIceUser();
	~CStandIceUser();
	int Create(COneConfRegistration *data, unsigned int indInDB, COsQueue* pRcvMbx, CMplMcmsProtocol* pMockMplProtocol = NULL,CSipProxyIpParams* pService = NULL);

	void UpdateCM();
	void FillICEparams(CSipProxyIpParams* pService);
	void needToResolveHostname(char *HostToResolve);
	void OnCSEndIceInit(CSegment* pParam);
	virtual const char*  NameOf() const;
	BOOL isHostNameAlreadyResolved(mcTransportAddress	*resolvedAddr);

	void OnConfIceDnsResolved(CSegment* pParam);
	void OnConfIceDnsResolveTimerExpired(CSegment* pParam);
	void SetRegisterActiveAlarm(BYTE IsAdd);
protected:

	DWORD m_serviceId;

	char m_stunPassServerHostName[H243_NAME_LEN];
	char 	m_stunPassServerUserName[H243_NAME_LEN];
	ICE_SERVER_PARAMS_S m_stunPassServerAddress;
	char 	m_stunPassServerPassword[H243_NAME_LEN];
	char	m_stunPassServerRealm[H243_NAME_LEN];

	char m_stunServerHostName[H243_NAME_LEN];
	ICE_SERVER_PARAMS_S m_stunServerUDPAddress;
	ICE_SERVER_PARAMS_S m_stunServerTCPAddress;
	char m_RelayServerHostName[H243_NAME_LEN];
	ICE_SERVER_PARAMS_S m_RelayServerUDPAddress;
	ICE_SERVER_PARAMS_S m_RelayServerTCPAddress;
	char m_ipAddrsStr[256];

	BOOL m_PassServerResolved;
	BOOL m_StunServerResolved;
	BOOL m_TurnServerResolved;
//	BOOL m_AllHostNamesEqual;
//	BOOL m_turnAndStunServerNamesEqaul;

	PDECLAR_MESSAGE_MAP

};// CStandIceUser
#endif	// __SIPPROXYCONFCNTL_H__ 

