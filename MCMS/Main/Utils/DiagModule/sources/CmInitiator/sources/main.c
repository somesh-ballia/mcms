 /*
*****************************************************************************
*
* Copyright (C) 2005 POLYCOM NETWORKS Ltd.
* This file contains confidential information proprietary to POLYCOM NETWORKSO
*  Ltd. The use or disclosure of any information contained
* in this file without the written consent of an officer of POLYCOM NETWORKS
* Ltd is expressly forbidden.
*
*****************************************************************************

*****************************************************************************

 Module Name: main.c

 General Description:  Module "" contains:

      1.

 Generated By:	Yigal Mizrahi       Date: 26.4.2005

*****************************************************************************/

/***** Include Files *****/



#include <string.h>


#include "LinuxSystemCallsApi.h"
#include "McmsApi.h"
#include "timers.h"
#include "MplMcmsStructs.h"

#include "SharedDefines.h"
#include "SocketApiWrapExt.h"
#include "SystemInfo.h"
#include "../../../version.h"
#include "../sources/Diagnostics/includes/Diagnostics.h"
#include "IpmiHandleThread.h"
#include "LanHandleThread.h"
#include "GetCpuMemUsage.h"
#include "Print.h"
#include "emaCtl.h"
#include "tools.h"


/***** Public Variables *****/

/***** Global Variables *****/
UINT32 switch_diag_mode = 0;

INT32 l_PrintQueue;

pthread_t WDThreadId;
pthread_t CmdCardThreadId;
pthread_t TimerManagerThreadId;
pthread_t TCPrcvThreadId;
pthread_t IpmiListenThreadId;
pthread_t EmaListenThreadId;
//pthread_t EmaSimulationListenThreadId;
pthread_t PrintThreadId = 0;
pthread_t CpuDiagListenThreadId;
pthread_t SensorReadThreadId;
pthread_t IpmiHandleThreadId;
pthread_t LanHandleThreadId;

/* [ 16/12/08 Pass_chassis_type Dotan.H ] */
/***** Defines *****/
#define NO_ARGUMENT_PASSED 		1
#define CHASSIS_TYPE_ARG_PLACE  1
#define USB_FLAG_ARG_PLACE  2

/***** Public Functions Declarations *****/

/***** Private Functions Declarations *****/
void SwitchMain(eChassisType chassisType);
void WDThread();

UINT32 GetWatchDogInterval();
extern char g_mngIPAddr[256];
//INT8 acIfNameVlan[15] ;
//INT8 acIfName[6];

IF_NAME_STRUCT tIfNameStruct;


UINT32 unEmaKeepAliveFail = 0;

/***** External Functions Declarations *****/
extern void InitSchedStruct();
extern pthread_t CreateThreadWrapper(void *pFuncAddr, const char *pFuncName, UINT32 ulPriority);
extern void API_setEnv(UINT8 *pucEnv, UINT8 *punMyEnv);
extern void EmaUserInitEncOperatorDBXml(void);
extern void UpdateHttpdConfig(BOOL isSecured,BOOL isPermanentOpen);
extern void InitSensorsCacheLock();
extern void EnterDiagnosticsMode();
extern void TestStart();
extern void TestEnd();
extern void RunSuite_TestLinuxSystemCalls();
extern UINT32 GetWatchDogInterval();
extern int readEmaWatchdogTimer();

extern void LSPhyTask();
extern void LSPollStatistics();
extern void PrintThread();
extern void DispatcherThread();
extern void NtpThread();
extern void OpenMcmsConnection();
extern void ParseMfaDbgCfg();
extern void OpenE2promFile();
extern void LanStatListenThread();
extern void IpmiListenThread();
extern void EmaListenThread();
extern void EmaSimulationListenThread();
extern void CpuDiagListenThread();
extern void ConnectToLoggerTask();
extern void TimerMngrThread();
//extern void updateEmaWatchdogTimer();
//extern int readEmaWatchdogTimer();
//extern void SetEmaWatchdogTimer(int var);
extern INT32 ConfigureNtpConfigurationFileToLocalServer();
extern void emaUserInitFile(void);
extern void CmdCardThread();
extern void TestUpdateCfsParams();
extern int RegisterExceptions();
extern void InitIpmcMutex();
extern void EthMonitoringThread();
extern UINT32 GetNetMaskByPlatform(UINT32 NetMask);
extern void * IpmiReadCache(void *pParam);
#ifdef x86_ARCH
extern void CancelAllThreads();
#endif

UINT32 pQMainPalBaseAddr = 0;
extern UINT32 unNtpServerOn;


UINT32 ulPlatformType;
eChassisType chassisType = eChassisType_Unknown;
int usb_flag = 0;

/***** Functions Code *****/
//int main(int agrc, char* agrv[])
INT32 main(INT32 agrc, UINT8 * agrv[])
{
	EmbSleep(5000);
	/* [ 16/12/08 Pass_chassis_type Dotan.H ] */
	// Store chassis type that was given as argument
	
	if (agrc > NO_ARGUMENT_PASSED)
	{
		// Chassis type is the first argument (after the name of program)
		chassisType = atoi(agrv[CHASSIS_TYPE_ARG_PLACE]);

		// If value not valid OR unknown chassis type, set default chassis type(RMX2000).
		if ((chassisType<=eChassisType_Unknown) || (chassisType >= eChassisType_Max))
		{
            		printf("\n\nERROR : BAD chassis type %d, will be default (NINJA)\n\n", chassisType);
			chassisType = GetProductType();
		}
	}

	if((chassisType<=eChassisType_Unknown) || (chassisType >= eChassisType_Max))
	{
		// If loader not sent and argument, set default chassis type (RMX2000)
        	printf("\n\nERROR : Loader did not pass chassisType , will be default (NINJA)\n\n");
		chassisType = eChassisType_Ninja;
	}

	if (agrc > USB_FLAG_ARG_PLACE)
	{
		// Chassis type is the first argument (after the name of program)
		if(0 == strcmp(agrv[USB_FLAG_ARG_PLACE], "usb")) usb_flag = 1;
	}

    g_isServiceRun = TRUE;
    SetZeroMessageParam();
    SwitchMain(chassisType);
#ifdef x86_ARCH
    atexit(RemoveAllMessageQueue);
    CancelAllThreads();

#else
    RemoveAllMessageQueue();
#endif
	return(1);
}


/*---------------------------------------EXT IP MEDIA CARD-----------*/

const char* START_SPAN_TAG  = "<IP_SPAN>";
const char* START_IP_TAG = "<IP>";
const char* END_IP_TAG = "</IP>";

char externalIps[MAX_IP_NUMBER][MAX_IP_ADDRESS_SIZE] = {EMPTY_IP, EMPTY_IP, EMPTY_IP, EMPTY_IP, EMPTY_IP, EMPTY_IP, EMPTY_IP, EMPTY_IP, EMPTY_IP};


/****************************************************************************
* Prototype:        SwitchMain
* Description:      Create all the Threads and server in the switch
* Return Value:
* Arguments:
* Global Variable Used:
* Global Variables Changed:
* Cautions:
*****************************************************************************/
void SwitchMain(eChassisType chassisType)
{
	INT32 rc = 0;
	e_TcpConn eId;
	INT8 aucInsmodRtcFileName[50];
	UINT32 ReturnValue = -1;
	char	*iperfArgvArr[] = {MY_APP_PATH"/iperf","-s",0};
	UINT32	childpid;
	char mngNetmask[256] = {0};
	char mngDefGateway[256] = {0};
	TMngrIpAddr mngrIpAddr;
	//SetWatchDogFunc(0xFF);	//disable watchdog
	//SetWatchDogFunc(0xBF);	//disable watchdog
	
	memset(&mngrIpAddr, 0, sizeof(TMngrIpAddr));
	memset(g_mngIPAddr, 0, sizeof(MAX_IPV6_ADDRESS_SIZE));
	GetMngIPAddr(&mngrIpAddr);
	SetNICIpAddress(&mngrIpAddr);
	GetCurrentIpAddress(&mngrIpAddr, g_mngIPAddr, MAX_IPV6_ADDRESS_SIZE);

	system("touch /tmp/DIAG_MODE.txt");
//	Create dropbear key
//	system("/usr/sbin/dropbearkey -t dss -f /etc/Secretkey");

	//read the dbgCfg.txt file if not ecsit create it
	ParseMfaDbgCfg();

	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"========================== Start SWITCH program ======================");

	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"chassisType = %d",chassisType);

	//printf("  ------------------      Yosi   pause the switch program ------------------");
	//EmbSleep(40000);
	//printf("  ------------------      Yosi   start the switch program ------------------");

	InitSchedStruct();

    WDThreadId = CreateThread(WDThread,85);
	
	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"WDThread: WDThreadId %d",WDThreadId);



	system("sysctl -w net.ipv4.ip_no_pmtu_disc=1");
	system("sysctl -w net.ipv4.tcp_keepalive_intvl=5");
	system("sysctl -w net.ipv4.tcp_keepalive_time=1");
	system("sysctl -w net.ipv4.tcp_keepalive_probes=1");

	for(eId = eMcmsCom ; eId < eMaxTcpConnections ; eId++)
	{
		t_TcpConnParams* ptTcpCon = &TcpConnection[eId];

		ptTcpCon->s			= 0xFFFF;
		ptTcpCon->us_Port 	= 0;
		ptTcpCon->e_Id 		= eId;

        ptTcpCon->IpV4Addr.auc_IpV4Address[0] = '\0';
        ptTcpCon->IpV4Addr.auc_NetMask[0] = '\0';
        ptTcpCon->IpV4Addr.auc_DefaultGetway[0] = '\0';

		ptTcpCon->ul_PrevConnState = NOT_CONNECTED;
		ptTcpCon->ul_ConnectionStatus = NOT_CONNECTED;

	}

	FD_ZERO(ptTcpActiveReadSockets);
  	FD_ZERO(ptTcpActiveSelectSockets);

	TimerManagerThreadId = CreateThread(TimerMngrThread,2);
	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"TimerMngrThread: TimerManagerThreadId %d",TimerManagerThreadId);

	//start the print task
	l_PrintQueue = CreateMessageQueue();
	if (l_PrintQueue == -1)
		MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"McmsComMain: create Print queue failed");
	else
	{
	    MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"McmsComMain: Print Queue id %d",l_PrintQueue);
	    PrintThreadId = CreateThread(PrintThread,2);
		MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"McmsComMain: PrintThreadId %d",PrintThreadId);
	}

	CmdCardThreadId = CreateThread(CmdCardThread,2);
	EmbSleep(1);


	MfaBoardPrint(	CM_INITIATOR_PRINT, PRINT_LEVEL_ERROR, PRINT_TO_TERMINAL,"(SwitchMain): SwitchBaseline: %s.",SwitchBaseline);

	system("echo 64 > /proc/sys/kernel/msgmni");

	// To create message queues with unique Ids, set enviroment variable for my application.
	chdir(MY_APP_PATH);
	system("mkdir DiagModule");
	API_setEnv("APPLICATION", "./DiagModule");

	//Init System Info DataBase

	ReturnValue = SystemInfoDatabaseInit("DiagModule", TRUE, chassisType);
	if(ReturnValue)
	{
   	   MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule)SystemInfoDataBaseInit - Init Failed");
	}
	else
	{
  	   MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule)SystemInfoDataBaseInit - Init Succeeded");
	}

	ReturnValue = SystemInfoDatabaseInitPlatformType("SystemInfoDatabaseInitPlatformType",TRUE , chassisType);
	if(ReturnValue)
	{
   	   MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule) SystemInfoDatabaseInitPlatformType - Init Failed");
	}
	else
	{
  	   MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule) SystemInfoDatabaseInitPlatformType - Init Succeeded");
	}

	//Get Platform type
	SystemInfoGetParam(ePLATFORM_TYPE_REQ, &ulPlatformType ,"DiagModule", TRUE);
	//change the eth according to hw ver

	EmaUserInitEncOperatorDBXml();

 	UpdateHttpdConfig(FALSE, TRUE);

	InitSensorsCacheLock();
	
	SensorReadThreadId  = CreateThread(IpmiReadCache,2);
	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule): IpmiReadCacheThread %d",SensorReadThreadId);
	
	IpmiListenThreadId  = CreateThread(IpmiListenThread,2);
	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule): IpmiListenThread %d",IpmiListenThreadId);

	IpmiListenThreadId  = CreateThread(LanStatListenThread,2);
	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule): LanStatListenThread %d",IpmiListenThreadId);
		
//former if 0 was here - PAVELK
	EmaListenThreadId  = CreateThread(EmaListenThread,2);
	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule): EmaListenThreadId %d",EmaListenThreadId);

	CpuDiagListenThreadId  = CreateThread(CpuDiagListenThread,2);
	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule): CpuDiagListenThreadId %d",CpuDiagListenThreadId);

	TCPrcvThreadId  = CreateThread(TCPrcvThread,80);
	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule): TCPrcvThreadId %d",TCPrcvThreadId);

	IpmiHandleThreadId = CreateThread(IpmiHandleThread,80);
	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule): IpmiHandleThreadId %d",IpmiHandleThreadId);

	LanHandleThreadId = CreateThread(LanHandleThread,80);
	MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(DiagModule): LanHandleThread %d",LanHandleThreadId);

	tCheckCPUReq.ulTicksCount = 5000;
	tCheckCPUReq.ulInterval = TIMER_TRUE;
	tCheckCPUReq.pvContext = NULL;
	tCheckCPUReq.callback = CheckCPUUsage;

      UINT32  ul_TimerHandle = TimerSetJob(&tCheckCPUReq);
	  
	printf("\n********************EnterDiagnosticsMode**************************\n");

	EnterDiagnosticsMode();
	while (1)
	{
	    EmbSleep(1000);
	}

	system("rm -f /tmp/DIAG_MODE.txt");
}

void TestMain()
{
	printf("TestMain");
	TestStart();
		RunSuite_TestLinuxSystemCalls();
	TestEnd();
	return;
}



//get the sleep time for the reset watchdog in miliseconds
UINT32 GetWatchDogInterval()
{
	UINT32 unReturnValue;

	unReturnValue = 30*100;

	return unReturnValue;//in miliseconds
}



void WDThread()
{
	UINT32 unResetWatchDogInterval = 0;
	t_TcpConnParams* ptTcpCon;

	EnrollInThreadList(eWDThread);

	unResetWatchDogInterval = GetWatchDogInterval();
    
	while (g_isServiceRun)
	{
//        printf("\n--- WD --> %s:%d: wd_timer %d, ema_ka %d\n", __FILE__, __LINE__, readEmaWatchdogTimer(), unEmaKeepAliveFail);
        
   	    if (readEmaWatchdogTimer() >= 6)   // when ema is connected it resets ema Watchdog timer
   	    {
   	    	ptTcpCon = &TcpConnection[eEmaApiServer];

			// Bracha: For apache module debugging, when connecting to external port, DO NOT close EMA socket.
   	    	if (ptTcpCon->ul_ConnectionStatus == CONNECTED)
   	    	{
   	    		ptTcpCon->ul_ConnectionStatus = NOT_CONNECTED;
				ptTcpCon->ul_PrevConnState	= CONNECTED;
				MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(WDThread): Close EMA Socket - No Keep Alive");
   	    	}

   	    	unEmaKeepAliveFail++;

  	    	if (unEmaKeepAliveFail == 5)
  	    	{
                printf("\n--- WD --> %s:%d: wd_timer %d, ema_ka %d -> restart httpd\n", __FILE__, __LINE__, readEmaWatchdogTimer(), unEmaKeepAliveFail);
        
				// Bracha: For apache module debugging, when connecting to external port, disable keepalive.
  	    		MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(WDThread): Reset EMA Module - No Keep Alive");
   	    		system(HTTPD_KILL_COMMAND);
   	    		EmbSleep(3000);
#if 0
				system("rm /var/lock/httpd.pid");
#else
				system("rm /tmp/mfa_cm_fs/httpd.pid");	
#endif
   	    		system(HTTPD_RUN_COMMAND);
   	    		unEmaKeepAliveFail = 0;
   	    		SetEmaWatchdogTimer(-1);
  	    	}
   	    }
        if (readEmaWatchdogTimer() != -1)  // start checking only when ema is connected
        {
        	updateEmaWatchdogTimer();
        }
        
	    EmbSleep(unResetWatchDogInterval);
        
	    MfaBoardPrint(CM_INITIATOR_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL,"(WDThread): EmaWatchdogTimer = %d unEmaKeepAliveFail = %d",readEmaWatchdogTimer(),unEmaKeepAliveFail);
	}
}

