 /*
*****************************************************************************
*
* Copyright (C) 2005 POLYCOM NETWORKS Ltd.
* This file contains confidential information proprietary to POLYCOM NETWORKSO
*  Ltd. The use or disclosure of any information contained
* in this file without the written consent of an officer of POLYCOM NETWORKS
* Ltd is expressly forbidden.
*
*****************************************************************************

*****************************************************************************

 Module Name: McmsApi.c

 General Description:  Module "" contains:

      1. 

 Generated By:	Yigal Mizrahi       Date: 10.5.2005

*****************************************************************************/

/***** Include Files *****/
#include <string.h>
#include "McmsApi.h"
#include "SystemInfo.h"
#include "Print.h"
 



/***** Public Variables *****/

/***** Global Variables *****/
static UINT32 unIndSequenceNum = 0;
/***** Public Functions Declarations *****/

/***** Private Functions Declarations *****/

/***** Functions Code *****/
/****************************************************************************
* Prototype:        AllocateApiMsg
* Description:      Alloc Pointer th mcms common header 
* Return Value:     return the pointer of the header.
* Arguments:        length - message size , opcode
* Global Variable Used: 
* Global Variables Changed: 
* Cautions: 
*****************************************************************************/
UINT32* AllocateMcmsApiMsg(UINT32 length, UINT32 opcode)
{
	UINT32					 	  *pGnrlHdr;
	UINT32						  unBoardId = 4;
	COMMON_HEADER_S              *ptCommon;
	MESSAGE_DESCRIPTION_HEADER_S *ptMsgDesc;
	PHYSICAL_INFO_HEADER_S       *ptPhysInfo;
	UINT32						  headersLen, tmp;

//UINT32	ulTime;

	MfaBoardPrint(SHARED_PRINT,PRINT_LEVEL_MAJOR,PRINT_TO_TERMINAL,"AllocateMcmsApiMsg");

    pGnrlHdr = (UINT32 *)malloc(length);
	if(pGnrlHdr)
	{
		memset(pGnrlHdr, 0, length);
		
		ptCommon   = &( ((TGeneralMcmsCommonHeader*)pGnrlHdr)->tCommonHeader);
		ptMsgDesc  = &( ((TGeneralMcmsCommonHeader*)pGnrlHdr)->tMessageDescription);	
		ptPhysInfo = &( ((TGeneralMcmsCommonHeader*)pGnrlHdr)->tPhysicalInfoHeader);

//		time( (time_t*)(&ulTime) );
		headersLen = sizeof( TGeneralMcmsCommonHeader );

		ptCommon->protocol_version 	= 1; //DC currently
		ptCommon->option 			= 0xFF; //DC currently
		ptCommon->src_id 			= eMpl;
		ptCommon->dest_id 			= eMcms;
		ptCommon->opcode	 		= SWAPL(opcode);
//		ptCommon->time_stamp		= ulTime;
//		ptCommon->sequence_num  	= unIndSequenceNum++;

		tmp = (length - headersLen);
		ptCommon->payload_len	 	= SWAPL(tmp);
		ptCommon->payload_offset  	= SWAPL(headersLen);
		ptCommon->next_header_type 	= SWAPL(eHeaderMsgDesc);
		
		tmp = sizeof(MESSAGE_DESCRIPTION_HEADER_S);
		ptCommon->next_header_offset 	= SWAPL(tmp);

		//ptMsgDesc is filled by mcms parser.
		ptMsgDesc->request_id 		= 0xFFFFFFFF;
		ptMsgDesc->entity_type 		= 0xFFFFFFFF;
		ptMsgDesc->time_stamp 		= 0xFFFFFFFF;
		ptMsgDesc->next_header_type = SWAPL(eHeaderPhysical);
		
		tmp = sizeof(PHYSICAL_INFO_HEADER_S);
		ptMsgDesc->next_header_size = SWAPL(tmp);
	
		ptPhysInfo->box_id 			= 0xFF; // currently DC
		//SystemInfoGetParam(eSWITCH_SLOT_ID_NUM, &(unBoardId) ,"LanStatHandleReq", TRUE);
		ptPhysInfo->board_id = unBoardId;
		ptPhysInfo->sub_board_id 	= 0x1;
		ptPhysInfo->unit_id			= 0xFF;//eMfaUnit_CM;
		ptPhysInfo->port_id 		= 0xFF; //not relevant for cm
		ptPhysInfo->resource_type 	= 0xFF;//ePhysical_res_cm;	 //tbd by shlomit
		ptPhysInfo->future_use1		= 0xFF;
		ptPhysInfo->future_use2		= 0xFF;
		ptPhysInfo->next_header_type  = SWAPL(eHeaderNone);
		ptPhysInfo->next_header_size  = 0;

	}	

	return (pGnrlHdr);
}

/****************************************************************************
* Prototype:        AllocatePortMcmsApiMsg
* Description:      allocate port mcms api message, and initialize headers 
* Return Value:     (msg addr) success/ (0) malloc failure
* Arguments:        
*****************************************************************************/
UINT32 *AllocatePortMcmsApiMsg(UINT32 length, UINT32 opcode)
{
	UINT32					 	 *pPortApiHdr;
	COMMON_HEADER_S              *ptCommon;
	MESSAGE_DESCRIPTION_HEADER_S *ptMsgDesc;
	PHYSICAL_INFO_HEADER_S       *ptPhysInfo;
	PORT_DESCRIPTION_HEADER_S	 *ptPortDesc;

	UINT32						  headersLen, tmp;					 
	 
	
	MfaBoardPrint(SHARED_PRINT,PRINT_LEVEL_MAJOR,PRINT_TO_TERMINAL,"AllocatePortMcmsApiMsg");
	 
	pPortApiHdr = AllocateMcmsApiMsg(length, opcode);

	if(pPortApiHdr)
	{
		ptCommon   = &( ((TPortMessagesHeader*)pPortApiHdr)->tGeneralMcmsCommonHeader.tCommonHeader);
		ptMsgDesc  = &( ((TPortMessagesHeader*)pPortApiHdr)->tGeneralMcmsCommonHeader.tMessageDescription);	
		ptPhysInfo = &( ((TPortMessagesHeader*)pPortApiHdr)->tGeneralMcmsCommonHeader.tPhysicalInfoHeader);
		ptPortDesc = &( ((TPortMessagesHeader*)pPortApiHdr)->tPortDescriptionHeader);

		ptCommon->dest_id 			= 0;

		headersLen = sizeof( TPortMessagesHeader );
		tmp = (length - headersLen);
		ptCommon->payload_len	 	= SWAPL(tmp);
		ptCommon->payload_offset  	= SWAPL(headersLen);

		ptPhysInfo->unit_id			= 0;
		ptPhysInfo->resource_type 	= 0;

		ptPhysInfo->next_header_type  = SWAPL(eHeaderPortDesc);
		
		tmp = sizeof(PORT_DESCRIPTION_HEADER_S);
		ptPhysInfo->next_header_size  = 0;

		ptPortDesc->party_id		= 0xFFFFFFFF;
		ptPortDesc->conf_id			= 0xFFFFFFFF;
		ptPortDesc->connection_id	= 0xFFFFFFFF;
		ptPortDesc->logical_resource_type_1	= 0xFF; 
		ptPortDesc->logical_resource_type_2	= 0xFF;
//		ptPortDesc->future_use1		= 0xFF;
//		ptPortDesc->future_use2		= 0xFF;
		ptPortDesc->next_header_type = SWAPL(eHeaderNone);
		ptPortDesc->next_header_size = 0;

	}

	return(pPortApiHdr);
}
