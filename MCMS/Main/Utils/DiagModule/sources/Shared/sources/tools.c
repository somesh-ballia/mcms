/*
*****************************************************************************
*
* Copyright (C) 2005 POLYCOM NETWORKS Ltd.
* This file contains confidential information proprietary to POLYCOM NETWORKSO
*  Ltd. The use or disclosure of any information contained
* in this file without the written consent of an officer of POLYCOM NETWORKS
* Ltd is expressly forbidden.
*
*****************************************************************************

*****************************************************************************

 Module Name: tools.c

 General Description:  

      1. 

 Generated By:	Yigal Mizrahi       Date: 08.112005

*****************************************************************************/

/***** Include Files *****/
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <unistd.h>
#include "tools.h"  
#include "Print.h"
#include "SocketApiTypes.h"
#include "DiagnosticsShared.h"
#include "EmaShared.h"  
#include "McuMngrStructs.h"  
#include "IpmiShared.h"
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <ifaddrs.h>

#include "timers.h"

#define OPCODE_2_STR(match, in_opcode) if((UINT32)match == in_opcode) { return #match; }

#define MAX_ARRAY_NUM		5
#define MAX_HW_VERSION_LENGTH	64

typedef struct
{
	UINT32	SlotId;
	UINT32	HWSlotID;
}HWCardsConvItem;

typedef struct
{
	UINT32	HWSlotID;
	UINT32	UnitIdx;
}HWUnitIdxItem;

/***** Public Variables *****/

/***** Global Variables *****/

int g_slotdspArray[MAX_DSP_CARD_SLOT_NUM][MAX_DSPUNIT_ON_CARD_NUM + 1];
char g_boardType[MAX_HW_VERSION_LENGTH];
char g_hwVersion[MAX_HW_VERSION_LENGTH];
BOOL g_isServiceRun;

HWCardsConvItem const g_HWCardsConvTable[MAX_DSP_CARD_SLOT_NUM] = { 
																		{DSP_CARD_SLOT_ID_0, 2},
																		{DSP_CARD_SLOT_ID_1, 0},
																		{DSP_CARD_SLOT_ID_2, 1}
							  										};
HWUnitIdxItem const g_HWUnitIdxBegin[MAX_DSP_CARD_SLOT_NUM] = { 
																	{0, 0},
																	{1, 6},
																	{2, 12}
																};

int g_RtmIsdnDsp = 0;
unsigned long g_DspLocationBitmap = 0;
/***** Public Functions Declarations *****/

/***** Private Functions Declarations *****/
void my_itoa(UINT8 num, UINT8* dest);
void ntpmy_itoa(INT8 num, INT8* dest);
UINT8* GetFilePlace(UINT8 *pSource);
/***** External Functions Declarations *****/






void ServiceStop()
{
	g_isServiceRun = FALSE;
}



/****************************************************************************
* Prototype:        GetIpAddr
* Description:      get the ipadd from uint32 to string
* Return Value:     SOCKET sClientSocket
* Arguments:        no.
* Global Variable Used: 
* Global Variables Changed: 
* Cautions: 
*****************************************************************************/
void GetIpAddr(UINT8* pucIpAddr , UINT32 unIpAddr)
{
	INT8 aucTempAddr[4] = {0,0,0,0} , aucIpAddr[16];
	INT8 ucTemp = 0;
	INT32 i;
	
	printf("\n  ****** unIpAddr = %x  ******  \n",unIpAddr);
	
	for (i = 3 ; i >= 0 ; i--)
	{
		ucTemp = unIpAddr>>(i*8);
		printf("\n  ****** 1 ucTemp = %x  ******  \n",ucTemp);
		
		ucTemp = ucTemp & 0xff;
		
		ntpmy_itoa(ucTemp,aucTempAddr);
		
		printf("\n  ****** aucTempAddr = %s   ******  \n",aucTempAddr);
		
		if (i == 3)
			strcpy(aucIpAddr,aucTempAddr);
		else
			strcat(aucIpAddr,aucTempAddr);
			
		if (i > 0)
			strcat(aucIpAddr,".");
			
		printf("\n  ****** aucIpAddr = %s  ******  \n",aucIpAddr);
	}
	
	memcpy(pucIpAddr,aucIpAddr,16);
	printf("\n  ******  aucIpAddr = %s , pucIpAddr = %s  ******  \n",aucIpAddr,pucIpAddr);
}

/****************************************************************************
* Prototype:        ntpmy_itoa
* Description:      itoa
* Return Value:     
* Arguments:        num to convert pointer to fill.
* Global Variable Used: 
* Global Variables Changed: 
* Cautions: 
*****************************************************************************/
void ntpmy_itoa(INT8 num, INT8* dest)
{
	INT32 i =0, j;
	UINT8 tmp_str[20];
	
	do
	{
		tmp_str[i++] = num%10 + '0';		
	}while( (num /= 10) > 0);
	
	tmp_str[i--] = '\0';

	for(j=0; i>= 0; j++, i--)
		dest[j] = tmp_str[i];

	dest[j] = '\0';	
}





/****************************************************************************
* Prototype:        my_itoa
* Description:      itoa
* Return Value:     
* Arguments:        num to convert pointer to fill.
* Global Variable Used: 
* Global Variables Changed: 
* Cautions: 
*****************************************************************************/
void my_itoa(UINT8 num, UINT8* dest)
{
	INT32 i =0, j;
	UINT8 tmp_str[20];
	
	if ( (num >= 10) && (num <= 15) )
	{
		switch (num)
		{
			case 10://A
			{
				*dest = 0x41;
				break;
			}
			case 11://B
			{
				*dest = 0x42;
				break;
			}
			case 12://C
			{
				*dest = 0x43;
				break;
			}
			case 13://D
			{
				*dest = 0x44;
				break;
			}
			case 14://E
			{
				*dest = 0x45;
				break;
			}
			case 15://F
			{
				*dest = 0x46;
				break;
			}
		}
		
	}
	else
	{
		do
		{
			tmp_str[i++] = num%10 + '0';		
		}while( (num /= 10) > 0);
		
		tmp_str[i--] = '\0';
	
		for(j=0; i>= 0; j++, i--)
			dest[j] = tmp_str[i];
	
		dest[j] = '\0';	
	}
}




UINT8* GetFilePlace(UINT8 *pSource)
{
	INT8 c , i=0;
	
	if(pSource == 0)
		return 0;
	
	c = *pSource;
	//look for beginning of file-name:		
	while( (c != '=') && (c != '\n') && (c != '\r') && (c != ';') && (c!='\0') )
			c = *(pSource++);

	//pSource++;		
	
	return (pSource);
}



UINT32 GetEndOfLineLen(UINT8 *pSource)
{
	INT8 c , i=0;
	
	if(pSource == 0)
		return 0;
	
	c = *pSource;
	//look for beginning of file-name:		
	while( (c != '\n') && (c != '\r') && (c != ';') && (c!='\0') )
	{
		i++;
		c = *(pSource++);
	}

	//pSource++;		
	
	return (i - 1);
}

const char* DiagSwitchEmaLoc2Str(eTraceDiagSwitchEmaComLocation loc)
{
#define LOC_2_STR(match, in_loc) if(match == in_loc) { return #match; }

//    if(eRecv == loc) { return "eRecv"; }
    
    LOC_2_STR(eRecv, loc);
    LOC_2_STR(eHandle, loc);
    LOC_2_STR(eSend, loc);

    return "None";
}
const char* DiagSwitchEmaOPcode2Str(UINT32 opcode)
{    
//#define OPCODE_2_STR(match, in_opcode) if((UINT32)match == in_opcode) { return #match; }
    
//    if(SOCKET_OPERATION_OK == opcode) { return "SOCKET_OPERATION_OK"; }
    
    OPCODE_2_STR(SOCKET_OPERATION_OK, opcode);
    OPCODE_2_STR(SOCKET_OPERATION_FAILED, opcode);
    OPCODE_2_STR(TPCKT_OPERATION_FAILED, opcode);
    OPCODE_2_STR(PRIVATE_OPCODE, opcode);
    OPCODE_2_STR(EMA_ENTER_DIAG_MODE_REQ, opcode);
    OPCODE_2_STR(EMA_GET_TEST_LIST_REQ, opcode);
    OPCODE_2_STR(EMA_START_TEST_REQ, opcode);
    OPCODE_2_STR(EMA_GET_TEST_STATUS_REQ, opcode);
    OPCODE_2_STR(EMA_STOP_TEST_REQ, opcode);
    OPCODE_2_STR(EMA_GET_UNITS_STATE_REQ, opcode);
    OPCODE_2_STR(EMA_GET_ERROR_LIST_REQ, opcode);
    
    return "None";
}
const char* DiagSwitchEmaSlot2Str(UINT32 ulSlotId)
{
#define SLOT_2_STR(match, in_slot) if(match == in_slot) { return #match; }

//    if(e_slotIdAll_4000 == ulSlotId) { return "e_slotIdAll_4000"; }

    enum ePlatformType platformType = eGideon5;//GetChasisPlatformTypeInDword(1);
    switch(platformType)
    {
        case eAmos:
            SLOT_2_STR(e_slotIdAll_4000, ulSlotId);
            SLOT_2_STR(e_slotIdMfa1_4000, ulSlotId);
            SLOT_2_STR(e_slotIdMfa2_4000, ulSlotId);
            SLOT_2_STR(e_slotIdMfa3_4000, ulSlotId);
            SLOT_2_STR(e_slotIdMfa4_4000, ulSlotId);
            SLOT_2_STR(e_slotIdShoval_4000, ulSlotId);
            SLOT_2_STR(e_slotIdCpu2_4000, ulSlotId);
            SLOT_2_STR(e_slotIdLogo_4000, ulSlotId);
            SLOT_2_STR(e_slotIdCpu1_4000, ulSlotId);
            SLOT_2_STR(e_slotIdPSupply1_4000, ulSlotId);
            SLOT_2_STR(e_slotIdPSupply2_4000, ulSlotId);
            SLOT_2_STR(e_slotIdPSupply3_4000, ulSlotId);
            SLOT_2_STR(e_slotIdFan_4000, ulSlotId);
            SLOT_2_STR(e_slotIdRtmIsdn1_4000, ulSlotId);
            SLOT_2_STR(e_slotIdRtmIsdn2_4000, ulSlotId);
            SLOT_2_STR(e_slotIdRtmIsdn3_4000, ulSlotId);
            SLOT_2_STR(e_slotIdRtmIsdn4_4000, ulSlotId);
            SLOT_2_STR(e_slotIdSwitch_4000, ulSlotId);
            SLOT_2_STR(e_slotIdPolystar_4000, ulSlotId);
            SLOT_2_STR(e_slotIdBackplane_4000, ulSlotId);
            SLOT_2_STR(e_slotIdPSupply_4000, ulSlotId);
            SLOT_2_STR(e_slotIdMax_4000, ulSlotId);
            break;

        case eYona:
            SLOT_2_STR(e_slotIdAll_1500, ulSlotId);
            SLOT_2_STR(e_slotIdMPMY_1500, ulSlotId);
            SLOT_2_STR(e_slotIdCpu1_1500, ulSlotId);
            SLOT_2_STR(e_slotIdPSupply_1500, ulSlotId);
            SLOT_2_STR(e_slotIdFan_1500, ulSlotId);
            SLOT_2_STR(e_slotIdRtmIsdn_1500, ulSlotId);
            SLOT_2_STR(e_slotIdSwitch_1500, ulSlotId);
            SLOT_2_STR(e_slotIdBackplane_1500, ulSlotId);
            break;

    	default:
    		// Note: some enumeration value are not handled in switch. Add default to suppress warning.
    		break;
    };
    
    return "None";
}

void TraceDiagSwitchEmaCom(eTraceDiagSwitchEmaComLocation place,
                           UINT32 ulMsgId,
                           UINT32 opcode,
                           UINT32 ulSlotId,
                           const char *message)
{
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "-+-+- %s (%d), MsgId %d, Opcode %s(%d), slot %s(%d) - %s",
             DiagSwitchEmaLoc2Str(place), place,
             ulMsgId,
             DiagSwitchEmaOPcode2Str(opcode), opcode,
             DiagSwitchEmaSlot2Str(ulSlotId), ulSlotId,
             message);

    switch(place)
    {
        case eRecv:
            printf("\n\n%s\n", buffer);
            break;

        case eHandle:
            printf("%s\n", buffer);
            break;

        case eSend:
            printf("%s\n\n", buffer);
            break;

        default:
            printf("%s\n", buffer);
            break;
    }
}

const char* TcpConnSwitchEmaOPcode2Str(e_TcpConn  eID)
{    
//#define OPCODE_2_STR(match, in_opcode) if(match == in_opcode) { return #match; }

    OPCODE_2_STR(eIpmiClient, eID);
    OPCODE_2_STR(eIpmiServer, eID);
    OPCODE_2_STR(eLanStatClient, eID);
    OPCODE_2_STR(eLanStatServer, eID);

    return "None";
}


/* IPMI */
const char* IpmiSwitchEmaOPcode2Str(UINT32 opcode)
{    
//#define OPCODE_2_STR(match, in_opcode) if((UINT32)match == in_opcode) { return #match; }
    
    OPCODE_2_STR(SOCKET_OPERATION_OK, opcode);
    OPCODE_2_STR(SOCKET_OPERATION_FAILED, opcode);
    OPCODE_2_STR(TPCKT_OPERATION_FAILED, opcode);
    OPCODE_2_STR(PRIVATE_OPCODE, opcode);
    OPCODE_2_STR(IPMI_ENTITY_LIST_REQ, opcode);
    OPCODE_2_STR(IPMI_FRU_REQ, opcode);
    OPCODE_2_STR(IPMI_SENSOR_LIST_REQ, opcode);
    OPCODE_2_STR(IPMI_SENSOR_READING_LIST_REQ, opcode);
    OPCODE_2_STR(IPMI_FAN_INFO_REQ, opcode);
    OPCODE_2_STR(IPMI_GET_FAN_LEVEL_REQ, opcode);
    OPCODE_2_STR(IPMI_SET_FAN_LEVEL_REQ, opcode);
    OPCODE_2_STR(IPMI_GET_LED_INFO_REQ, opcode);
    OPCODE_2_STR(IPMI_GET_LED_STATE_REQ, opcode);
    OPCODE_2_STR(IPMI_DO_RESET_REQ, opcode);
    OPCODE_2_STR(IPMI_GET_EVENT_LOG_REQ, opcode);

    return "None";
}

void TraceSwitchEmaCom(eTraceDiagSwitchEmaComLocation place,
				e_TcpConn  eID, 
                           UINT32 ulMsgId,
                           UINT32 opcode,
                           UINT32 ulSlotId,
                           const char *message)
{
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "-+-+- %s (%d), TcpConn:%s(%d), MsgId %d, Opcode %s(%d), slot %s(%d) - %s",
             DiagSwitchEmaLoc2Str(place), place,
             TcpConnSwitchEmaOPcode2Str(eID), eID,
             ulMsgId,
             IpmiSwitchEmaOPcode2Str(opcode), opcode,
             DiagSwitchEmaSlot2Str(ulSlotId), ulSlotId,
             message);

    switch(place)
    {
        case eRecv:
            printf("\n\n%s\n", buffer);
            break;

        case eHandle:
            printf("%s\n", buffer);
            break;

        case eSend:
            printf("%s\n\n", buffer);
            break;

        default:
            printf("%s\n", buffer);
            break;
    }
}


char *StringTrim(char * bstr, char * estr)
{
	char * retStr = NULL;
	if(NULL == bstr || NULL == estr) return NULL;

	// Trim leading space
	while(bstr < estr && isspace(*bstr)) bstr++;

	// Trim trailing space
	while(bstr < estr && isspace(*estr)) estr--;

	if((bstr > estr) || ((bstr == estr) && isspace(*bstr)))
	{
		retStr = (char *)malloc(1*sizeof(char));
		if(retStr != NULL) retStr[0] = '\0';
		return retStr;
	}

	retStr = (char *)malloc((estr - bstr + 2)*sizeof(char));
	if(retStr != NULL)
	{
		memcpy(retStr, bstr, estr - bstr + 1);
		retStr[estr - bstr + 1] = '\0';
	}
	return retStr;
}

int LineSplitTrim(char * line, char *** retbuf, const char * delim)
{
	char ** ptrbuf = NULL;
	char * ptrstr = line, * tmp = NULL;
	int ret = -1, count = 0, index = 0;
	if(NULL == line || NULL == retbuf || NULL == delim) goto done;

	while(NULL != (tmp = strpbrk(ptrstr, delim)))
	{
	      if(tmp == ptrstr)
	      {
	          ptrstr = tmp + 1;
	          continue;
		}
		count++;
		ptrstr = tmp + 1;
	}

	ptrbuf = (char **)malloc((count+1)*sizeof(char *));
	if(NULL == ptrbuf) goto done;
	
	ptrstr = line;
	while(NULL != (tmp = strpbrk(ptrstr, delim)))
	{
		if(tmp == ptrstr)
	      {
	          ptrstr = tmp + 1;
	          continue;
		}
		ptrbuf[index] = StringTrim(ptrstr, tmp -1);
		ptrstr = tmp + 1;
		index++;
	}

	ptrbuf[index] = StringTrim(ptrstr, ptrstr + strlen(ptrstr) - 1);
	*retbuf = ptrbuf;
	ret = index + 1;

done:
	return ret;
}

void LineSplitFree(char ** buf, int count)
{
	int i = 0;
	if(NULL == buf) return;
	
	for(; i < count; i++) 
		if(NULL != buf[i]) free(buf[i]);

	free(buf);
}

int IsDirFileExist(const char *dir)
{
    int ret = 0;
    struct stat st;
    if(stat(dir, &st) == 0)
    {
        ret = 1;
    }
    return ret;
}

BOOL SystemCommand(const char * system_command, char * output, int size)
{
    MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, "SystemCommand \n");
    BOOL ret = TRUE;

    memset(output, 0, size);
    char line[256];
    FILE *fpipe = NULL;
    if ( !(fpipe = (FILE*)popen(system_command,"r")) )
    {
        ret =  FALSE;
    }
    else
    {
        MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, "SystemCommand fopen OK\n");

        int i = 0;
        while ( fgets( line, sizeof line, fpipe))
        {
            MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, "SystemCommand fgets OK : %d\n", i);

            int localsize = size - strlen(output);
            strncat(output, line, localsize - 1);

            i++;
        }
        
        int exit_value = pclose(fpipe);
        ret = (-1 == exit_value
               ?
               FALSE : TRUE);
        output[size - 1] = '\0';
            
        MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, "SystemCommand pclose( exit_value ==  %d) : %s\n", exit_value, ret?"OK":"FAIL");
    }
    return ret;
}

UINT32 CovnSlotIDToHW(UINT32 slotId) //ulSlotId(DSP_CARD_SLOT_ID_0~DSP_CARD_SLOT_ID_2)
{
	UINT32 i = 0;
	for(; i < sizeof(g_HWCardsConvTable)/sizeof(g_HWCardsConvTable[0]); i++)
	{
		if(g_HWCardsConvTable[i].SlotId == slotId)	
			return g_HWCardsConvTable[i].HWSlotID;
	}

	return g_HWCardsConvTable[0].HWSlotID;
}

UINT32 CovnUnitIdToHW(UINT32 slotId, int unitid) //ulSlotId(DSP_CARD_SLOT_ID_0~DSP_CARD_SLOT_ID_2) uintId(1~6)   return unitId(0~17)
{
	UINT32 hwSlotId = 0, hwUnitIdxBegin = 0, i = 0;

	hwSlotId = CovnSlotIDToHW(slotId);
	for(; i < sizeof(g_HWUnitIdxBegin)/sizeof(g_HWUnitIdxBegin[0]); i++)
	{
		if(g_HWUnitIdxBegin[i].HWSlotID == hwSlotId)
		{
			hwUnitIdxBegin = g_HWUnitIdxBegin[i].UnitIdx;
			break;
		}
	}

	return hwUnitIdxBegin + unitid - 1;
}

int ExecNinjaDiagCmd(char *** szOutArray, int * pCount, const char * cmdPath, const char * command, const char * param1)
{
    char execCmd[1024] = {0};
    char * pTmp = NULL;
    char ** strArray = NULL;
    int currentCount = 0;
    int status;
	
    if(param1)
    {
        snprintf(execCmd, sizeof(execCmd), "%s %s %s", cmdPath, command, param1);
    }
    else
    {
        snprintf(execCmd, sizeof(execCmd), "%s %s", cmdPath, command);    
    }

    FILE * const fp = popen(execCmd, "r");
    int count = 0;
    if (fp)
    {
        char line[1024] = {0};
        int i=0;
        MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, "=== ExecNinjaDiagCmd Log Start === \n");
        MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, "%s \n", execCmd);
        while (NULL!=fgets(line, sizeof(line)-1, fp))
        {
            MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, ">> %s", line);
            pTmp = strstr(line, NINJA_CMD_PREFIX);
            if(pTmp != NULL)
            {
            		if(currentCount >= MAX_ARRAY_NUM) continue;
            		if(NULL == strArray)
			{
				strArray = (char **)malloc(MAX_ARRAY_NUM * sizeof(char *));
				if(NULL == strArray) continue;
			}
			int buffLen = strlen(pTmp + strlen(NINJA_CMD_PREFIX)) + 1;
			strArray[currentCount] = (char *) malloc(buffLen * sizeof(char));
			if(NULL != strArray[currentCount])
			{
				strncpy(strArray[currentCount], pTmp + strlen(NINJA_CMD_PREFIX), buffLen - 1);
				((char *)strArray[currentCount])[buffLen - 1] = '\0';
				if(((char *)strArray[currentCount])[buffLen - 2] == '\n') ((char *)strArray[currentCount])[buffLen - 2] = '\0';
				currentCount++;
			}
            } 
        }
        MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, "=== ExecNinjaDiagCmd Log End ===\n");
	  if(NULL != strArray)
	  {
	  	if(currentCount > 0)
		{
			//return strArray to caller.
			*pCount = currentCount;
			*szOutArray = strArray;
		}
		else
		{
			free(strArray);
		}
	  }

	  status = pclose(fp);
	  if(WIFEXITED(status))
	  {
	  	return WEXITSTATUS(status);
	  }
        return -2;
    }
    else
    {
        return -1;
    }	
}

int InitCardHWVersion()
{
	int ret;
	char ** strArray = NULL;
	int count = 0;
	char * phwVersion = NULL, *pBoardType=NULL;
	ret = ExecNinjaDiagCmd(&strArray, &count, PATHNAME_NinjaDiagCmdPath, GET_HARDWARE, NULL);
	if(ret == 0 && NULL != strArray && count >= 1 && NULL != strArray[0])
	{
		phwVersion = strstr(strArray[0], "Hardware Version:");
		pBoardType = strstr(strArray[0], "Board Type:");

		if(NULL != phwVersion)
		{
			char * newhwVersion = StringTrim(phwVersion + strlen("Hardware Version:"), strArray[0] + strlen(strArray[0]) - 1);
			if(NULL != newhwVersion)
			{
				strncpy(g_hwVersion, newhwVersion, MAX_HW_VERSION_LENGTH - 1);
				g_hwVersion[MAX_HW_VERSION_LENGTH - 1] = '\0';
				free(newhwVersion);
			}
		}

		if(NULL != phwVersion && NULL != pBoardType)
		{
			char * newBoadType = StringTrim(pBoardType + strlen("Board Type:"), phwVersion - 1);
			if(NULL != newBoadType)
			{
				strncpy(g_boardType, newBoadType, MAX_HW_VERSION_LENGTH - 1);
				g_boardType[MAX_HW_VERSION_LENGTH - 1] = '\0';
				free(newBoadType);
			}			
		}
	}
	
	if(strArray)
	{
		LineSplitFree(strArray, count);
	}
	return ret;
}


/*
     paser:
     0 | 0 | 1 | 2 | 3 | 4 | 5 
     1 | 0 | 1 | 2 | 3 | 4 | 5 
     2 | 0 | 1 | 2 | 3 | 4 | 5 
*/
int InitDspStatus()
{
	int ret, i, j;
	char ** strArray = NULL, ** subStrArray = NULL;
	int count = 0, subCount = 0;
	int srcCard = 0, srcDsp = 0, num;
	ret = ExecNinjaDiagCmd(&strArray, &count, PATHNAME_NinjaDiagCmdPath, GET_DSP_STATUS, NULL);
	if(ret == 0 && NULL != strArray && count >= 1)
	{
		for(i = 0 ; i < count; i++)
		{
			subStrArray = NULL;
			srcCard = 0;
			srcDsp = 0;
			subCount = LineSplitTrim(strArray[i], &subStrArray, "|");
			for(j = 0; j < subCount; j++)
			{
				if(NULL != subStrArray && NULL != subStrArray[j])
				{
					num = atoi(subStrArray[j]);
					if(0 == j)
					{
						srcCard = num;
						if(srcCard < MAX_DSP_CARD_SLOT_NUM) g_slotdspArray[srcCard][0] = 1;
					}
					else
					{
						srcDsp = num;
						if(srcCard < MAX_DSP_CARD_SLOT_NUM && srcDsp < MAX_DSPUNIT_ON_CARD_NUM) g_slotdspArray[srcCard][srcDsp+1] = 1;
					}
				}
			}
			if(subStrArray) LineSplitFree(subStrArray, subCount);
		}
	}

	if(strArray)
	{
		LineSplitFree(strArray, count);
	}
	return ret;	
}

BOOL isValidCard(UINT32 ulSlotId) //ulSlotId(DSP_CARD_SLOT_ID_0~DSP_CARD_SLOT_ID_2) 
{
	UINT32 hwSlotId = 0;
	if(ulSlotId >= DSP_CARD_SLOT_ID_0 && ulSlotId <= DSP_CARD_SLOT_ID_2)
	{
		hwSlotId = CovnSlotIDToHW(ulSlotId);
		if(1 == g_slotdspArray[hwSlotId][0]) return TRUE;
	}
	return FALSE;
}

BOOL isValidDsp(UINT32 ulSlotId, UINT32 unitId)  //ulSlotId(DSP_CARD_SLOT_ID_0~DSP_CARD_SLOT_ID_2) uintId(1~6)
{
	UINT32 hwSlotId = 0;
	if(ulSlotId >= DSP_CARD_SLOT_ID_0 && ulSlotId <= DSP_CARD_SLOT_ID_2)
	{
		hwSlotId = CovnSlotIDToHW(ulSlotId);		
		if((1 == g_slotdspArray[hwSlotId][0]) && (1 == g_slotdspArray[hwSlotId][unitId]))
			return TRUE;
	}

	return FALSE;
}

void LedDiagInProgress()
{
      system("/mcms/Bin/LightCli Diagnostic diagnostic_in_progress &> /dev/null");  
}

void LedDiagComplete()
{
      system("/mcms/Bin/LightCli Diagnostic diagnostic_completed &> /dev/null");      
}

#define BIT6(a, l) \
  ((ntohl(a->s6_addr32[(l) / 32]) >> (31 - ((l) & 31))) & 1)

int ipv6_prefix_length(struct in6_addr* a)
{
  int l, i;
  for (l = 0; l < 128; l++)
  {
    if (BIT6(a, l) == 0)
      break;
  }

  for (i = l + 1; i < 128; i++)
  {
    if (BIT6(a, i) == 1)
      return -1;
  }

  return l;
}

BOOL IsIPv6AddressGlobalScope(const char* pAddress)
{
  BOOL ret = FALSE;
  
  // set the begin pointer for scanning the string
  DWORD dBeginScan = (DWORD)pAddress;
  if ('[' == pAddress[0]) // address with brackets

    dBeginScan++;   // advance to after the opening bracket

  char* pBeginScan = (char*)dBeginScan;

  // ===== Unique Local Unicast format: 1111 110...
  // f    c/d
  if (!strncmp(pBeginScan, "fc", 2) ||
      !strncmp(pBeginScan, "fd", 2))
    ret = TRUE;

  // ===== Link local format: 1111 1110 1000 0000 0000...
  // f    e    8    0
  else if (!strncmp(pBeginScan, "fe80::", 6))
    ret = FALSE;

  // ===== Site local format: 1111 1110 11...
  // f    e    c/d/e/f
  else if (!strncmp(pBeginScan, "fec", 3) ||
           !strncmp(pBeginScan, "fed", 3) ||
           !strncmp(pBeginScan, "fee", 3) ||
           !strncmp(pBeginScan, "fef", 3))
    ret = FALSE;

  // ===== Multicast format: 1111 1111...
  // f    f
  else if (!strncmp(pBeginScan, "ff", 2))
    ret = FALSE;

  // ===== Loopback format: 0000...
  // 0
  else if (!strncmp(pBeginScan, "0", 1))
    ret = FALSE;

  // ===== Global format: 001...
  // 2/3
  // if ( !strncmp(pBeginScan, "2", 1) ||
  // !strncmp(pBeginScan, "3", 1) )
  else
    ret = TRUE;

  return TRUE;
}

// Description: Get ipV6 address (first Global address, if configured; otherwise - first Site address)
// Return code:
// 0                   - success
// non zero value      - error
BOOL RetrieveIpV6Address(char * ipv6GlobalAddr, unsigned int len)
{
  int status = 0;
  char dstBuf[IPV6_ADDRESS_LEN];
  char addrBuf_global[IPV6_ADDRESS_LEN];

  memset(dstBuf, 0, IPV6_ADDRESS_LEN);
  memset(ipv6GlobalAddr, 0, len);

  struct sockaddr_in*  sin;
  struct sockaddr_in6* sin6;

  struct ifaddrs  ifAddrs;
  struct ifaddrs* pIfAddrs = &ifAddrs;
  struct ifaddrs* pIfa = NULL;


  status = getifaddrs(&pIfAddrs);
  if (status == -1 )
    return FALSE;

  for (pIfa = pIfAddrs; pIfa; pIfa = pIfa->ifa_next)
  {

    sin = (struct sockaddr_in*) pIfa->ifa_addr;

    switch (sin->sin_family)
    {
      // ===== 2. IPV6
      case AF_INET6:
      {
        if (strstr(pIfa->ifa_name, "eth0"))
        {
          sin6 = (struct sockaddr_in6*) pIfa->ifa_addr;
          inet_ntop(AF_INET6, sin6->sin6_addr.s6_addr, dstBuf, IPV6_ADDRESS_LEN);

          char prefix[IPV6_ADDRESS_LEN];
          memset(prefix, '\0', IPV6_ADDRESS_LEN);
          struct sockaddr_in6* netmask =
            (struct sockaddr_in6*) pIfa->ifa_netmask;
          int len = ipv6_prefix_length(&netmask->sin6_addr);

          // ---------- 'Global' priority addresses ----------
          if (IsIPv6AddressGlobalScope(dstBuf))
          {
            strncpy(ipv6GlobalAddr, dstBuf, len - 1);
            goto done;
          }
        } // if eth0

        break;
      } // case AF_INET6

      default:
      {
        break;
      }
    } // end switch (sin->sin_family)
  } // loop over 'pIfa's


done:
  freeifaddrs(pIfAddrs);

  return TRUE;
}


unsigned long GetDspLocationBitmap()
{
    if (g_DspLocationBitmap == 0)
    {
        unsigned long dspLocationBitmap = 0;
        char ans[512] = {0};
        char * cmd = "/usr/rmx1000/bin/ninja_dsp_check";
        BOOL status = SystemCommand(cmd, ans, sizeof(ans));

        if (status == TRUE)
        {
            g_DspLocationBitmap = strtoul(ans, NULL, 0);

            MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, "GetDspLocationBitmap Current dsp location bitmap is : 0x%lX\n", dspLocationBitmap);
        }
        else
        {
            MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, "GetDspLocationBitmap run /usr/rmx1000/bin/ninja_dsp_check failed.\n");
        }
    }  

    return g_DspLocationBitmap;
}

void InitRtmIsdnDspStatus()
{
    unsigned long dspLocationBitmap = 0;
    BOOL isDspLocated = FALSE;
    
    dspLocationBitmap = GetDspLocationBitmap();

    isDspLocated = (dspLocationBitmap >> ISDN_DSP_LOCATION) % 2;

    if(isDspLocated) g_RtmIsdnDsp = 1;
    else g_RtmIsdnDsp = 0;

    MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, "InitRtmIsdnDspStatus g_RtmIsdnDsp=%d.\n", g_RtmIsdnDsp);
}

BOOL isValidRtmIsdnCard(UINT32 ulSlotId) //ulSlotId(ISDN_CARD_SLOT_ID) 
{
    if(ulSlotId == ISDN_CARD_SLOT_ID && g_RtmIsdnDsp) return TRUE;

    return FALSE;
}

BOOL isValidRtmIsdnDSP(UINT32 ulSlotId, UINT32 unitId) //ulSlotId(ISDN_CARD_SLOT_ID) 
{
    if(ulSlotId == ISDN_CARD_SLOT_ID && g_RtmIsdnDsp && unitId == 1) return TRUE;

    return FALSE;
}

/*
int system_closefd(const char * cmdstring)  
{  
    unsigned int i = 0;
    int status;
    struct rlimit rl;
    pid_t pid;
    struct sigaction ignore, saveintr, savequit;
    sigset_t chldmask, savemask;

    if(cmdstring == NULL) 
        return 1;

    ignore.sa_handler = SIG_IGN;
    sigemptyset(&ignore.sa_mask);
    ignore.sa_flags = 0;
    if(sigaction(SIGINT, &ignore, &saveintr) < 0)
        return -1;
    if(sigaction(SIGQUIT, &ignore, &savequit) < 0)
        return -1;

    sigemptyset(&chldmask);
    sigaddset(&chldmask, SIGCHLD);
    if(sigprocmask(SIG_BLOCK, &chldmask, &savemask) < 0)
        return -1;

    if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
    {
        rl.rlim_max = 2048;
    }

    if ((pid = fork()) < 0)  
    {  
        status = -1;
    }  
    else if (pid == 0)  
    {
        sigaction(SIGINT, &saveintr, NULL);
        sigaction(SIGQUIT, &savequit, NULL);
        sigprocmask(SIG_SETMASK, &savemask, NULL);
        
        if(rl.rlim_max == RLIM_INFINITY)
        {
            rl.rlim_max = 2048;
        }
        
        for (i = 0; i < rl.rlim_max; i++)  
        {  
            if (i != STDIN_FILENO && i != STDOUT_FILENO && i != STDERR_FILENO)  
                close(i);
        }
        execl("/bin/sh", "sh", "-c", cmdstring, (char *)0);  
        _exit(127);  
    }  
    else  
    {  
       while(waitpid(pid, &status, 0) < 0)
       {
            if(errno != EINTR)
            {
                status = -1;
                break;
            }
       }
    }

    if(sigaction(SIGINT, &saveintr, NULL) < 0)
        return -1;
    if(sigaction(SIGQUIT, &savequit, NULL) < 0)
       return -1;   
    if(sigprocmask(SIG_SETMASK, &savemask, NULL) < 0)
       return -1; 
     
    return status;
}  
*/

int SystemCall(const char * cmd)
{
    int ret = system(cmd);
    MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, "SystemCall %s return:%d \n", cmd, ret);
    return ret;
}

void StartRtmDiagServer()
{
    MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, ">> StartRtmDiagServer start video begin \n");
    SystemCall(CMD_START_VIDEO);
    EmbSleep(25*1000);
    MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, ">> StartRtmDiagServer start video sleep end \n");
    MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, ">> StartRtmDiagServer start RtmDiagTestCommand begin \n");
    SystemCall(CMD_START_RTMDIAGSERVER);
    EmbSleep(10*1000);
    MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, ">> StartRtmDiagServer start RtmDiagTestCommand sleep end \n");
}

void StopRtmDiagServer()
{
    MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, ">> StartRtmDiagServer stop video and RtmDiagTestCommand begin \n");
    SystemCall(CMD_STOP_VIDEO);
    SystemCall(CMD_STOP_RTMDIAGSERVER);
    EmbSleep(10*1000);
    MfaBoardPrint(DIAG_PRINT,PRINT_LEVEL_ERROR,PRINT_TO_TERMINAL, ">> StartRtmDiagServer stop video and RtmDiagTestCommand sleep end \n");
}
