#include "SourceFile.h"
#include "../../Libs/Common/ApiBaseObject.h"

#include <iostream>
#include <algorithm>

///////////////////////////////////////////////////////////////////////////
#define VERSION "3.0.25.0124"

///////////////////////////////////////////////////////////////////////////
const char* SourceFile::version_ = VERSION;

///////////////////////////////////////////////////////////////////////////
SourceFile::SourceFile(Context& context, const std::string& file_name)
	: std::ofstream((context.output_folder + file_name).c_str())
	, context_(context)
	, hasNamespace_(false)
{
	std::cout << "Creating " << file_name << '\n';
	context_.onCreateSourceFile(file_name);

	addFileHeader(context_.schema_name);

	if (*file_name.rbegin() == 'h')
		addHeaderGuardPrefix(file_name);
}

///////////////////////////////////////////////////////////////////////////
SourceFile::~SourceFile()
{
	addCloseNamespace();

	if (!name_def_.empty())
		addHeaderGuardPostfix();
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::addSystemInclude(const std::string& include)
{ *this << "#include <" << include << ">\n"; }

///////////////////////////////////////////////////////////////////////////
void SourceFile::addUserInclude(const std::string& include)
{ *this << "#include \"" << include << "\"\n"; }

///////////////////////////////////////////////////////////////////////////
void SourceFile::addUsingNamespace()
{
	if (!hasNamespace_ && !context_.api_ns.empty())
	{
		SourceFile::AddSeparator(*this);
		*this << "using namespace " << context_.api_ns << ";\n";
	}
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::addOpenNamespace()
{
	if (!hasNamespace_ && !context_.api_ns.empty())
	{
		hasNamespace_ = true;

		SourceFile::AddSeparator(*this);
		*this <<
				"namespace " << context_.api_ns << "\n"
				"{\n";
	}
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::addCloseNamespace()
{
	if (hasNamespace_ && !context_.api_ns.empty())
	{
		hasNamespace_ = false;

		SourceFile::AddSeparator(*this);
		*this << "} // namespace " << context_.api_ns << "\n";
	}
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::addFileHeader(const std::string& schema_name)
{
	*this <<
		"///////////////////////////////////////////////////////////////////////////\n"
		"// Please NEITHER edit this file directly NOR add it to version control:\n"
		"// It was automatically generated by Xml2Source (version " VERSION ")\n"
		"// for ApiObject Framework version " API_OBJECT_FRAMEWORK_VERSION "\n"
		"//  from '" << schema_name << "'\n"
		"///////////////////////////////////////////////////////////////////////////\n";
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::addHeaderGuardPrefix(const std::string& name)
{
	name_def_ = name;
	splitCamelCase(name_def_);

	std::replace(name_def_.begin(), name_def_.end(), ' ', '_');
	std::transform(name_def_.begin(), name_def_.end(), name_def_.begin(), (int(*)(int)) toupper);

	name_def_ += "__";

	*this <<
		"#ifndef " << name_def_ << "\n"
		"#define " << name_def_ << "\n";

	SourceFile::AddSeparator(*this);
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::addHeaderGuardPostfix()
{
	SourceFile::AddSeparator(*this);
	*this << "#endif // " << name_def_ << "\n";

	name_def_.clear();
}

///////////////////////////////////////////////////////////////////////////
bool SourceFile::isValidName(const std::string& name)
{
	if (name.empty())
		return false;

	std::string::const_iterator it = name.begin();

	for ( ; it != name.end() && isspace(*it); ++it);

	if (it == name.end())
		return false;

	if (!isalpha(*it) && *it != '_')
		return false;

	for (; it != name.end(); ++it)
	{
		if (!isspace(*it) && !isalnum(*it) && *it != '_' && *it != '-')
			return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////
bool SourceFile::isValidTag(const std::string& tag)
{
	if (tag.empty())
		return false;

	std::string::const_iterator it = tag.begin();

	if (!isalpha(*it) && *it != '_')
		return false;

	for (; it != tag.end(); ++it)
	{
		if (!isalnum(*it) && *it != '_' && *it != '-' && *it != '.')
			return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::tagToName(const std::string& tag, std::string& name, bool toClassName/* = false*/)
{
	name = tag;

	std::replace(name.begin(), name.end(), '.', ' ');
	std::replace(name.begin(), name.end(), '-', ' ');
	std::replace(name.begin(), name.end(), '_', ' ');

	std::istringstream is(name);
	name.clear();

	while (!is.eof())
	{
		std::string word;
		is >> word;

		if (!word.empty() && (toClassName || !name.empty()))
			*word.begin() = toupper(*word.begin());

		name += word;
	}
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::nameToTag(const std::string& name, std::string& tag)
{
	tag = name;
	splitCamelCase(tag);
	std::replace(tag.begin(), tag.end(), ' ', '-');
	std::transform(tag.begin(), tag.end(), tag.begin(), (int(*)(int))tolower);
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::nameToDefine(const std::string& name, std::string& define)
{
	define = name;
	splitCamelCase(define);
	std::replace(define.begin(), define.end(), ' ', '_');
	std::transform(define.begin(), define.end(), define.begin(), (int(*)(int))toupper);
}

///////////////////////////////////////////////////////////////////////////
const std::string SourceFile::toName(const std::string& tag, bool toClassName/* = false*/)
{
	std::string out;
	SourceFile::tagToName(tag, out, toClassName);
	return out;
}

///////////////////////////////////////////////////////////////////////////
const std::string SourceFile::toTag(const std::string& name)
{
	std::string out;
	SourceFile::nameToTag(name, out);
	return out;
}

///////////////////////////////////////////////////////////////////////////
const std::string SourceFile::toDefine(const std::string& name)
{
	std::string out;
	SourceFile::nameToDefine(name, out);
	return out;
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::unescape(std::string& s)
{
	std::string res;
	res.reserve(s.size());

	for (std::string::const_iterator it = s.begin(); it != s.end(); ++it)
	{
		char c = *it;

		if (c == '\\' && it != s.end())
		{
			++it;

			switch (*it)
			{
			case '\\':
				c = '\\';
				break;

			case 'n':
				c = '\n';
				break;

			case 't':
				c = '	';
				break;

			default:
				res += '\\';
				c = *it;
				break;
			}
		}

		res += c;
	}

	std::swap(s, res);
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::splitCamelCase(std::string& s)
{
	if (s.size() <= 1)
		return;

	std::string res;
	res.reserve(s.size() * 3 / 2);

	std::string::const_iterator it = s.begin();
	std::string::value_type c = *it;

	// non-Alpha:  0
	// lower case: 1
	// Upper case: 2
	// digit:      4
	int previous = !!isalpha(c) + !!isupper(c) + 4 * !!isdigit(c);

	for ( ; ; )
	{
		if (isalnum(c))
			res += c;

		++it;

		if (it == s.end())
			break;

		c = *it;
		int current = !!isalpha(c) + !!isupper(c) + 4 * !!isdigit(c);

		if (current != previous)
		{
			// every transition except of from Upper to lower case letter splits the sequence
			if (current != 1 && previous != 2)
				res += ' ';

			previous = current;
		}
	}

	std::swap(res, s);
}

///////////////////////////////////////////////////////////////////////////
void SourceFile::AddSeparator(std::ostream& os)
{
	os <<
		"\n"
		"///////////////////////////////////////////////////////////////////////////\n";
}

///////////////////////////////////////////////////////////////////////////
void FilePath::fix(std::string& path)
{
	std::string::const_reverse_iterator it = path.rbegin();

	if (it != path.rend() && *it != '/' && *it != '\\')
		path += '/';
}

///////////////////////////////////////////////////////////////////////////
bool FilePath::isRelative(const std::string& path)
{
	std::string::const_iterator it = path.begin();

	return (it != path.end() && *it != '/' && *it != '\\');
}

///////////////////////////////////////////////////////////////////////////
const std::string FilePath::pathOf(const std::string& file_name)
{
	std::string::size_type n = file_name.find_last_of("/\\");

	return (n != std::string::npos) ? file_name.substr(0, n + 1) : "./";
}

///////////////////////////////////////////////////////////////////////////
const std::string FilePath::nameOf(const std::string& file_name)
{
	std::string::size_type n = file_name.find_last_of("/\\");

	return (n != std::string::npos) ? file_name.substr(n + 1) : "";
}

///////////////////////////////////////////////////////////////////////////
